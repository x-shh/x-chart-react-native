<!DOCTYPE html>
<!--[if IE 8 ]><html class="ie8" lang="en-gb"> <![endif]-->
<!--[if IE 9 ]><html class="ie9" lang="en-gb"><![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<html lang="en-gb">
<!--<![endif]-->
<!--[if lt IE 9]>
<script src="http://html5shim.googlecode.com/svn/trunk/html5.Â®js"></script>
<![endif]-->

<head>

    <style>
        .error_input {
            border: 1px solid red;
        }
        .description{
        }
        .level2 {
            font-size: 12px;
        }
        .item{
        }

    </style>

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, minimum-scale=1, maximum-scale=1">

    <!-- Bootstrap & Addons-->
    <link href="../libs/bootstrap/css/bootstrap.css" rel="stylesheet" type="text/css">


    <link rel="stylesheet" href="../libs/jquery/jquery-ui.css">



    <title>Chart</title>

</head>
<body>
<div style="display: none" id="symbol_search_container">
    <input type="text" id="txtBaseSymbol" placeholder="Enter Symbol" class="text_area">
    <input type="hidden" id="txtBaseSymbolDesc"/>
    <input type="hidden" id="txtBaseSymbolDp"/>
    <input type="hidden" id="txtBaseSymbolType"/>

    <input type="button" value="Reload Chart" id="reloadChart" class="def_button"/>


</div>

<!--<input type="button" id="performanceCheck" value="performance">-->

<!--Chart Container-->
<div id="mainchart" style="height:650px;width:100%"></div>
<!--<div id="depth" style="height:100px;"></div>-->
<!--<div id="depth-navigator" class="inf-chart" style="height:50px;"></div>-->



<!--Common Libs-->
<!--[if lt IE 9]>
<script src="../libs/bootstrap/js/respond.src.js" type="text/javascript"></script>
<script src="../libs/jquery/jquery-1.9.1.js" type="text/javascript"></script>
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<script src="../libs/jquery/jquery.js" type="text/javascript"></script>
<!--<![endif]-->
<script src="../libs/json/jquery.json-2.4.min.js"></script>
<script src="../libs/jquery/jquery.localize.min.js"></script>
<script src="../libs/bootstrap/js/bootstrap.js"></script>

<!--HighChart-->
<script src="../libs/highcharts/highstock.src.js" type="text/javascript"></script>
<script src="../libs/highcharts/highcharts-more.js" type="text/javascript"></script>

<!--Chart-->
<!--<script src="../theme/dark-unica.js" type="text/javascript"></script> &lt;!&ndash;TODO :: load according to the user theme &ndash;&gt;-->


<script src="../libs/jquery/jquery-ui.min.js" type="text/javascript"></script>
<script src="../js/chart.util.js"></script>

<script>
    $(document).ready(function(){
        var onSuccess = function(responseData){
            var dataObj = convertData(responseData.columns, responseData.values, undefined,
                    responseData.symbol, "T");

            var config = {
                /* TODO :: uncomment once extend method is implemented
                 infmerge:{
                 avoidReplace : [
                 "xAxis",
                 "yAxis",
                 "series",
                 "scrollbar"
                 ]
                 },*/
                credits: {
                    enabled: false
                },
                watermark: {
                    type: "text",
                            text: "",
                            opacity: 0.5,
                            enabled: false
                },
                "scrollbar": {
                "enabled": true,
                        height: 0,
                        liveRedraw: true
            },
                legend: {
                    enabled: true,
                            layout: 'horizontal',
                            align: 'left',
                            verticalAlign: 'top',
                            borderWidth: 0,
                            itemDistance: 5,
                            symbolPadding: 0,
                            symbolWidth: 0.001,
                            symbolHeight: 0.001,
                            symbolRadius: 0,
                            navigation: {
                        enabled: false
                    },
                    /*labelFormatter: function () {
                       // return infChart.manager.getLegend(this, false);
                    },*/
                    useHTML: true
                },
                "tooltip": {
                followTouchMove: false,
                        animation: false,
                        enabled: true,
                        shared: true,
                        useHTML: true,
                        shadow: false,
                    borderWidth: 0,
                        positioner: function (labelWidth, labelHeight, point) {
                            var chart = this.chart,
                                    tooltipX,
                                    tooltipY;

                            if (point.plotX > chart.plotWidth - labelWidth) {
                                tooltipX = chart.plotLeft;
                            } else {
                                tooltipX = chart.plotLeft + chart.plotWidth - labelWidth;
                            }

                            tooltipY = chart.plotTop + chart.plotHeight - labelHeight;

                            return {
                                x: tooltipX,
                                y: tooltipY
                            };
                }/*,
                formatter: function (tooltip) {
                    return infChart.manager.tooltipFormatter(this, tooltip);
                }*/
            },
                "title": {
                "text": ""
            },
                "chart": {
                    "renderTo" : "mainchart",
                "alignTicks": false,
                        "plotBorderWidth": 0,
                        "borderWidth": 0,
                        "marginLeft": 3,
                        "marginRight": 40,
                        "marginTop": 0,
                        "marginBottom": 15,
                        "spacingBottom": 0,
                        "animation": false,
                        "lineWidth": 1.6,
                        "type": "candlestick",
                        "spacingTop": 25,
                        "zoomType" : undefined,
                        events: {
                    /* TODO :: uncomment once extend method is implemented
                     infmerge:{
                     avoidReplace : [
                     "click",
                     "redraw"
                     ]
                     },*/
                    /*click: function (e) {
                        infChart.manager.chartClick(this, e);
                    },
                    redraw: function () {
                        var chart = this;

                        var chartId = this.renderTo.id;
                        setTimeout(function () {
                            infChart.manager.afterRedraw(chartId);
                        }, 1);
                    }*/
                }
            },
                "annotationsOptions": {
                "enabledButtons": false
            },
                annotations: [],
                        "plotOptions": {
                "series": {
                    "allowPointSelect": false,
                            "lineWidth": 1,
                         "shadow": false,
                            "stickyTracking": true,
                            "enableMouseTracking": true,
                            "animation": false,
                            findNearestPointBy: 'x',
                            "yAxis": "#0",
                            "zIndex": 20,
                            "cropThreshold": 0,
                            "marker": {
                        "enabled": false
                    },
                    "dataGrouping": {
                        "enabled": true,
                                "smoothed": false,
                                groupPixelWidth: 5,
                                units: [[
                            'millisecond', // unit name
                            [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
                        ], [
                            'second',
                            [1, 2, 5, 10, 15, 30]
                        ], [
                            'minute',
                            [1, 2, 5, 10, 15, 30]
                        ], [
                            'hour',
                            [1, 2, 3, 4, 6, 8, 12]
                        ], [
                            'day',
                            [1, 2, 3, 4]
                        ], [
                            'week',
                            [1, 2]
                        ], [
                            'month',
                            [1, 3, 6]
                        ], [
                            'year',
                            null
                        ]]
                    },
                    events: {

                        /* TODO :: uncomment once extend method is implemented
                         infmerge:{
                         avoidReplace : [
                         "click",
                         "mouseOut",
                         "legendItemClick"
                         ]
                         },*/
                        /*click: function (e) {
                            infChart.manager.chartClick(this.chart, e);
                        },
                        mouseOut: function (event) {
                            infChart.manager.chartMouseOutEvent(this.chart, "series");
                        }, legendItemClick: function () {

                            return false;
                            /!* <== returning false will cancel the default action*!/
                        }*/
                    }

                },
                "yAxis": {
                    "startOnTick": false,
                            "endOnTick": false,
                            "maxPadding": 0.05,
                            "minPadding": 0.05,
                            showLastLabel: true,
                            "title": {
                        "text": ""
                    },
                    "opposite": true,
                            "labels": {
                        "align": "right",
                                "x": 34,
                                "y": 5,
                            /* TODO :: uncomment once extend method is implemented
                             infmerge:{
                             avoidReplace : [
                             "formatter"
                             ]
                             },*/
                                style: {textOverflow: 'unset'},
                        /*formatter: function () {

                            return infChart.manager.yAxisLabelFormatter(this, true);
                        }*/
                    }
                },

                column: {
                    borderWidth: 0,
                            threshold: null,
                            dataGrouping: {
                        approximation: "close"
                    }
                },
                volume: {
                    lineWidth: 0,
                            threshold: null
                },
                arearange: {
                    dataGrouping: {
                        approximation: function (low, high) {

                            var NUMBER = 'number';

                            var sum = function (arr) {
                                var len = arr.length,
                                        ret;

                                /* 1. it consists of nulls exclusively*/
                                if (!len && arr.hasNulls) {
                                    ret = null;
                                    /* 2. it has a length and real values*/
                                } else if (len) {
                                    ret = 0;
                                    while (len--) {
                                        ret += arr[len];
                                    }
                                }
                                /*3. it has zero length, so just return undefined
                                 => doNothing()*/

                                return ret;
                            };

                            var len = low.length;
                            low = sum(low);

                            /*If we have a number, return it divided by the length. If not, return
                             null or undefined based on what the sum method finds.*/
                            if (typeof low === NUMBER && len) {
                                low = low / len;
                            }
                            len = high.length;
                            high = sum(high);

                            /*If we have a number, return it divided by the length. If not, return
                             null or undefined based on what the sum method finds.*/
                            if (typeof high === NUMBER && len) {
                                high = high / len;
                            }


                            if (typeof low === NUMBER || typeof high === NUMBER) {
                                return [low, high];
                            }
                            /* else, return is undefined*/
                        }
                    }
                },
                line: {findNearestPointBy: 'x', "dataGrouping": {}},
                spline: {},
                area: {
                    "dataGrouping": {},
                    threshold: null
                },
                candlestick: {
                    "dataGrouping": {},
                    shadow : {
                        offsetX: 1,
                                offsetY: 5,
                                width: 4,
                                opacity: 0.3,
                                color: '#000000'
                    }

                },
                ohlc: {

                    "dataGrouping": {},
                    shadow : {
                        offsetX: 1,
                                offsetY: 5,
                                width: 4,
                                opacity: 0.9,
                                color: '#000000'
                    }
                },
                hlc: {
                    "dataGrouping": {},
                    shadow : {
                        offsetX: 1,
                                offsetY: 5,
                                width: 4,
                                opacity: 0.3,
                                color: '#000000'
                    }
                },
                heikinashi: {
                    "dataGrouping": {},
                    shadow : {
                        offsetX: 1,
                                offsetY: 5,
                                width: 4,
                                opacity: 0.3,
                                color: '#000000'
                    }
                },
                engulfingCandles: {
                    "dataGrouping": {},
                    shadow : {
                        offsetX: 1,
                        offsetY: 5,
                        width: 4,
                        opacity: 0.3,
                        color: '#000000'
                    }
                },
                point: {
                    "dataGrouping": {},
                    shadow : {
                        offsetX: 1,
                                offsetY: 5,
                                width: 4,
                                opacity: 0.3,
                                color: '#000000'
                    }
                },
                equivolume: {
                    "dataGrouping": {},
                    shadow : {
                        offsetX: 1,
                                offsetY: 5,
                                width: 4,
                                opacity: 0.3,
                                color: '#000000'
                    }
                },
                step: {
                    "dataGrouping": {}
                },
                flags: {
                    allowPointSelect: false,
                            "stickyTracking": false,
                            states: {
                        hover: {
                            enabled: false,
                                    halo: false
                        }
                    },
                    "dataGrouping": {}
                },
                infUDSignal: {
                    allowPointSelect: false,
                            "stickyTracking": false,
                            states: {
                        hover: {
                            enabled: false,
                                    halo: false
                        }
                    },
                    "dataGrouping": {}
                },
                infsignal: {
                    findNearestPointBy: 'x',
                            allowPointSelect: false,
                            "stickyTracking": false,
                            states: {
                        hover: {
                            enabled: false,
                                    halo: false
                        }
                    }
                },
                plotrange: {

                    threshold: null,
                            findNearestPointBy: 'x',
                            allowPointSelect: false,
                            "stickyTracking": false
                }
            },
                "navigator": {
                adaptToUpdatedData: false,
                    /* "series": {
                     "animation": false
                     },*/
                        "margin": 10,
                        "height": 70,
                        "enabled": true,
                        "visible": true,
                        "maskInside": false,
                        "infMaxHeight": 100,
                        "infMinHeight": 15,
                        zoomType : 'none'
            },
                "rangeSelector": {
                "enabled": false
            },
                "xAxis": {
                id: "#X1",
                        type: "datetime",
                        dateTimeLabelFormats: {
                    "millisecond": "%H:%M:%S.%L",
                            "second": "%H:%M:%S",
                            "minute": "%H:%M",
                            "hour": "%H:%M",
                            "day": "%e.%b'%y",
                            "week": "%e.%b'%y",
                            "month": "%b'%y",
                            "year": "%Y"
                },
                crosshair: {
                    snap: false,
                            label: {
                        enabled: true,
                                /*formatter: function (value) {
                            var chartObj = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(this.chart.renderTo.id));
                            var time = chartObj && chartObj.ttgrpVolIdx != undefined && chartObj.ttTime ? chartObj.ttTime : value;
                            return chartObj.getXAxisCrosshairLabel(time, this);
                        }*/
                    }

                },
                labels: {
                    showFirstLabel: true,
                            showLastLabel: false,
                            staggerLines: 1,
                            style: {textOverflow: 'unset'},
                    /*formatter: function () {
                        return infChart.manager.xAxisLabelFormatter(this);
                    }*/
                },
                events: {
                    /*setExtremes: function (e) {
                        var chartObj = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(this.chart.renderTo.id));
                        if (chartObj.mouseWheelController) {
                            chartObj.mouseWheelController.setExtremes.call(chartObj.mouseWheelController, e, this);
                        }
                    },
                    afterSetExtremes: function (e) {
                        var chartObj = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(this.chart.renderTo.id));
                        var chart = chartObj.chart;
                        chartObj.afterSetExtremes();
                        var series = this.chart.series[0];

                        if (chart && chart.annotations && typeof chartDrawings !== "undefined") {
                            chartDrawings.scaleDrawings(chartObj.id);
                        }
                    }*/
                },
                /*tickPositioner: function (min, max) {
                    return infChart.manager.xAxisTickPositioner(this, min, max);
                }*/
            },
                "yAxis": [
                {
                    "id": "#0",
                    gridLineWidth: 0,
                    infBaseYAxis: true,
                    labels: {enabled: false},
                    events: {
                        /*afterSetExtremes: function (e) {
                            var chartObj = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(this.chart.renderTo.id));
                            var chart = chartObj.chart;

                            if (chart && chart.annotations && typeof chartDrawings !== "undefined") {
                                chartDrawings.scaleDrawings(chartObj.id);
                                // $.each(chart.annotations.allItems, function (i, annotation) {
                                //     if(typeof annotation.options.afterSetExtremesFn === 'function'){
                                //         var drawing = chartDrawings.getDrawingObject(annotation.options.id);
                                //         annotation.options.afterSetExtremesFn.call(drawing);
                                //     }
                                // });
                            }
                            if (chartObj.hasLastLine || chartObj.hasPreviousCloseLine) {
                                chartObj.adjustPriceLineLabels();
                            }
                            chartObj.updateMinMax();
                        }*/
                    },
                    crosshair: {
                        snap: false,
                        label: {
                            enabled: true,
                            /*formatter: function (value) {
                                return infChart.manager.getYLabel(this.chart, value, false);
                            }*/
                        }
                    }

                },
                {
                    "linkedTo": 0,
                    gridLineWidth: 1,
                    "id": "#1",
                    visible: true,

                    labels: {enabled: false},
                    /*tickPositioner: function (min, max) {
                        return infChart.manager.yAxisTickPositioner(this, min, max);
                    }*/
                }
            ],
                    "series": [
                {
                    data: dataObj.data,
                    "id": "c0",
                    "type": 'candlestick',
                    "name": "Primary",
                    infType: "base",
                    showInNavigator: true/*,
                 navigatorOptions : {data :[]}*/
                }/*,
                {
                    data: [],
                    "id": infChart.constants.dummySeries.missingId,
                    "type": 'line',
                    "name": "Empty",
                    infType: "dummy",
                    showInNavigator: false,
                    showInLegend : true/!*,
                 navigatorOptions : {data :[]}*!/
                },
                {
                    data: [],
                    "id": infChart.constants.dummySeries.forwardId,
                    "type": 'line',
                    "name": infChart.constants.dummySeries.forwardId,
                    infType: "dummy",
                    showInNavigator: false,
                    showInLegend : true/!*,
                 navigatorOptions : {data :[]}*!/
                },
                {
                    data: [],
                    "id": infChart.constants.dummySeries.backwardId,
                    "type": 'line',
                    "name": infChart.constants.dummySeries.backwardId,
                    infType: "dummy",
                    showInNavigator: false,
                    showInLegend : true/!*,
                 navigatorOptions : {data :[]}*!/
                }*/
            ],
                    noData : {color: '#4572A7', fontWeight: 'bold', fontSize: '11px'}
            };

            var chart = new Highcharts.StockChart(config);
        };
        infUtil.sendAjax('../data/ticks_data_BTC_USD.BITFINEX', 'json', onSuccess, function(){

        }, this);

        var getIntervalDate = function (time, interval) {

            if (time && !isNaN(new Date(time))) {
                switch (interval) {
                    case 'Y':
                        time = infUtil.getLastDayOfYear(time);
                        break;
                    case 'M':
                        time = infUtil.getLastDayOfMonth(time);
                        break;
                    case 'W' :
                        time = infUtil.getLastDayOfWeek(time);
                        break;
                    default :
                        break;
                }
                return time;
            }
        };

        var getChartTime = function (tickTime, timeZoneOffset) {
            if (timeZoneOffset) {
                if (!isNaN(tickTime)) {
                    return +(tickTime) + +(timeZoneOffset) * 60 * 60000;
                }
            } else {
                return +(tickTime);
            }
        };

        var convertData = function (columns, input, type, symbol, interval) {
            var self = this,
                    result = [],
                    resultMap = {},
                    mapCurrentTimes = {},
                    timeZoneOffset = this.timeZoneOffset;

            if (!input) {
                return result;
            }

            var openIndex = $.inArray('open', columns), closeIndex = $.inArray('close', columns),
                    highIndex = $.inArray('high', columns), lowIndex = $.inArray('low', columns), volumeIndex = $.inArray('volume', columns),
                    bidIndex = $.inArray('bid', columns), askIndex = $.inArray('ask', columns),
                    manager = this;

            $.each(input, function (key, val) {
                try {
                    var dataRow;
                    key = getChartTime(key, timeZoneOffset);

                    var intervalDate = getIntervalDate(+key, interval);

                    if (val[openIndex] != null && val[highIndex] != null && val[lowIndex] != null && val[closeIndex] != null && val[volumeIndex] != null) {
                        var bid = (val[bidIndex] != null) ? val[bidIndex].valueOf() : 0;
                        var ask = (val[askIndex] != null) ? val[askIndex].valueOf() : 0;
                        dataRow = [intervalDate, val[openIndex].valueOf(), val[highIndex].valueOf(), val[lowIndex].valueOf(), val[closeIndex].valueOf(), val[volumeIndex].valueOf(),
                            bid, ask];
                    }
                    if (dataRow && intervalDate) {
                        if (resultMap[intervalDate.toString()]) {
                            var row = resultMap[intervalDate.toString()];
                            var currentTimeObj = mapCurrentTimes[intervalDate.toString()];

                            if (currentTimeObj.open > (+key)) {
                                row[1] = dataRow[1];
                                currentTimeObj.open = +key;
                            }
                            row[2] = row[2] < dataRow[2] ? dataRow[2] : row[2];
                            row[3] = row[3] > dataRow[3] ? dataRow[3] : row[3];
                            if (currentTimeObj.close < (+key)) {
                                row[4] = dataRow[4];
                                currentTimeObj.close = +key;
                            }
                            row[5] += dataRow[5];
                        }
                        else {

                            result.push(dataRow);
                            resultMap[intervalDate.toString()] = dataRow;
                            mapCurrentTimes[intervalDate.toString()] = {open: +key, close: +key};
                        }
                    }
                }
                catch (e) {
                    infUtil.console.error(e);
                }
            });

            function compare(a, b) {
                if (a[0] < b[0])
                    return -1;
                if (a[0] > b[0])
                    return 1;
                return 0;
            }

            result.sort(compare);

            return {data: result, dataMap: resultMap};
        };

    });
</script>

<!--KeyCloak related js-->
<!--<script src="https://security-xinfinit.rhcloud.com/auth/js/keycloak.js"></script>-->
<!--<script src="../js/keycloakAdaptor.js"></script>-->



</body>
</html>