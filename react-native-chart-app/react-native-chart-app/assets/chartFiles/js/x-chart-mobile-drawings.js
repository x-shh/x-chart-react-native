var infChart = window.infChart || {};

/**
 * Drawing Constructor
 * @param drawingId generated unique id for chart drawing
 * @param chartObj high chart object
 * @param shapeId type of the drawing
 * @param drawingSettingsContainer drawing settings popup container
 * @constructor
 */
infChart.Drawing = function (drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer, isContinuousDrawing) {
    this.drawingId = drawingId;
    this.shape = shapeId;
    this.chart = chartObj;
    this.container = chartObj.container;
    this.annotations = chartObj.annotations.allItems;
    this.annotation = undefined;
    this.drawingSettingsContainer = drawingSettingsContainer;
    this.quickDrawingSettingsContainer = quickDrawingSettingsContainer;
    this.fontSize = 12; // Only used in label tool
    this.dragSupporters = [];
    this.fibonacciDrawings = {}; // only used in Fibonacci drawing types
    this.additionalDrawings = {};
    this.isContinuousDrawing = isContinuousDrawing ? isContinuousDrawing : false;

    this.stockChartId = infChart.manager.getContainerIdFromChart(this.chart.renderTo.id);
    this.stockChart = infChart.manager.getChart(this.stockChartId);

    // this.stepFunction = function() {
    //     var ann = this.annotation;
    //     if(ann && ann.options && ann.options.snapToCandle) {
    //         var chart = ann.chart;
    //         var e = arguments[0];
    //         var x = e.chartX
    //         var xAxis = chart.xAxis[ann.options.xAxis],
    //             nearestXValue = infChart.math.findNearestXDataPoint(chart, ann.options.xValue, undefined, ann.options.useAllXDataToFindNearestPoint),
    //             nearestXValueEnd = infChart.math.findNearestXDataPoint(chart, xAxis.toValue(x), undefined, ann.options.useAllXDataToFindNearestPoint);

    //         ann.update({
    //             xValue: nearestXValue,
    //             nearestXValueEnd: nearestXValueEnd
    //         });

    //         e.chartX = xAxis.toPixels(nearestXValueEnd);
    //     }

    //     if(infChart.drawingUtils[shapeId].step) {
    //         return infChart.drawingUtils[shapeId].step.apply(this, arguments);
    //     }
    // };
    // this.stopFunction = function () {
    //     // callthing this through wrapper since this need to be catched from cammands wrapper
    //     return this.wrapFunctionHelper.call(this, "stopFunction", infChart.drawingUtils[shapeId].stop, arguments);
    // };
    //this.scalableFunction = infChart.drawingUtils[shapeId].scale;
    //this.selectAndBindResizeFunction = infChart.drawingUtils[shapeId].selectAndBindResize;
    // this.deselectFunction = infChart.drawingUtils[shapeId].deselect || function () {
    //     infChart.drawingUtils.common.onDeselect.call(this);
    // // };
    // this.selectFunction = infChart.drawingUtils[shapeId].select || function () {
    // };
    //this.additionalDrawingFunction = infChart.drawingUtils[shapeId].additionalDrawings;
    // this.translateFunction = function() {
    //     var ann = this.annotation;
    //     if(ann && ann.options && ann.options.snapToCandle) {
    //         var chart = ann.chart;
    //         var xAxis = chart.xAxis[ann.options.xAxis],
    //             nearestXValue = infChart.math.findNearestXDataPoint(chart, ann.options.xValue, undefined, ann.options.useAllXDataToFindNearestPoint),
    //             nearestXValueEnd = infChart.math.findNearestXDataPoint(chart, ann.options.xValueEnd, undefined, ann.options.useAllXDataToFindNearestPoint);

    //         var line = ann.shape.d.split(' '),
    //             newX = xAxis.toPixels(nearestXValue) - xAxis.toPixels(ann.options.xValue),
    //             newLine = ["M", 0, 0, 'L', xAxis.toPixels(nearestXValueEnd) - xAxis.toPixels(nearestXValue), line[5]];

    //         ann.update({
    //             xValue: nearestXValue,
    //             xValueEnd: nearestXValueEnd,
    //             shape: {
    //                 params: {
    //                     d: newLine
    //                 }
    //             }
    //         });
    //     }

    //     if(infChart.drawingUtils[shapeId].translate) {
    //         return infChart.drawingUtils[shapeId].translate.apply(this, arguments);
    //     }
    // }
    // this.translateEndFunction = infChart.drawingUtils[shapeId].translateEnd && function () {
    //     // callthing this through wrapper since this need to be catched from cammands wrapper
    //     return this.wrapFunctionHelper.call(this, "translateEndFunction", infChart.drawingUtils[shapeId].translateEnd, arguments);
    // };
    // this.destroyFunction = infChart.drawingUtils[shapeId].destroy;
    // this.beforeDestroyFunction = infChart.drawingUtils[shapeId].beforeDestroy;
    this.onPropertyChange = infChart.drawingUtils.common.onPropertyChange;
    //this.afterRedrawXAxisWithoutSetExtremesFunction = infChart.drawingUtils[shapeId].afterRedrawXAxisWithoutSetExtremes;

    // this.getConfigFunction = infChart.drawingUtils[shapeId].getConfig;//used in saving drawings
    // this.getConfigToCopyFunction = infChart.drawingUtils[shapeId].getConfigToCopy;//used in copy/paste
    // this.getPropertiesFunction = infChart.drawingUtils[shapeId].getOptions;//get specific options
    // this.getSettingsHTMLFunction = infChart.drawingUtils[shapeId].getSettingsPopup;//returns the html of the settings of the drawing
    // this.bindSettingsEventsFunction = infChart.drawingUtils[shapeId].bindSettingsEvents;
    // this.updateSettingsFunction = infChart.drawingUtils[shapeId].updateSettings;//update settings according to loaded properties
    // this.getPlotXFunction = infChart.drawingUtils[shapeId].getPlotX;//update settings according to loaded properties
    // this.getPlotHeightFunction = infChart.drawingUtils[shapeId].getPlotHeight;//returns the height of the drawing
    // this.updateOptionsFunction = infChart.drawingUtils[shapeId].updateOptions;//used in trading break even drawing
    // this.setPropertiesFunction = infChart.drawingUtils[shapeId].setOptions;//returns the height of the drawing
    // this.afterDragFunction = infChart.drawingUtils[shapeId].afterDrag;//returns the height of the drawing
    // //this.openDrawingSettingsFunction = infChart.drawingUtils[shapeId].openDrawingSettings;//open settings container
    // this.onClickFunction = infChart.drawingUtils[shapeId].onClick || function () {
    // };//set onclick event for the shape
    // this.getAxisOffset = infChart.drawingUtils[shapeId].getAxisOffset || function () {
    //     return 0;
    // };//returns the space required from the given axis
    // this.getContextMenuOptions = infChart.drawingUtils[shapeId].getContextMenuOptions || infChart.drawingUtils.common.getContextMenuOptions;
    //this.getNextPointOptions = infChart.drawingUtils[shapeId].getNextPointOptions;
    //this.hasMoreIntermediateSteps = infChart.drawingUtils[shapeId].hasMoreIntermediateSteps;
    //this.getClickValuesFunction = infChart.drawingUtils[shapeId].getClickValues;

    this.yValue = undefined;
    this.yValueEnd = undefined;
    this.trendYValue = undefined; // used in trend channel and andrew's pitchfork,
    this.intermediatePoints = [];
    this.isQuickSetting = true;

    /*this.isPercent =  this.stockChart.isPercent;
     this.isLog = this.stockChart.isLog;
     this.isCompare = this.stockChart.isCompare;*/
};

infChart.Drawing.prototype.translateFunction = function () {
    var ann = this.annotation;
    if (ann && ann.options && ann.options.snapToCandle) {
        var chart = ann.chart;
        var xAxis = chart.xAxis[ann.options.xAxis],
            nearestXValueData = infChart.math.findNearestDataPoint(chart, ann.options.xValue, undefined, ann.options.useAllXDataToFindNearestPoint, ann.options.useFutureDate),
            nearestXValueEndData = infChart.math.findNearestDataPoint(chart, ann.options.xValueEnd, undefined, ann.options.useAllXDataToFindNearestPoint, ann.options.useFutureDate);

        var line = ann.shape.d.split(' '),
            newX = xAxis.toPixels(nearestXValueData.xData) - xAxis.toPixels(ann.options.xValue),
            newLine = ["M", 0, 0, 'L', xAxis.toPixels(nearestXValueEndData.xData) - xAxis.toPixels(nearestXValueData.xData), line[5]];

        ann.update({
            xValue: nearestXValueData.xData,
            xValueDataIndex: nearestXValueData.dataIndex,
            xValueEnd: nearestXValueEndData.xData,
            xValueEndDataIndex: nearestXValueEndData.dataIndex,
            shape: {
                params: {
                    d: newLine
                }
            }
        });
    }

    if (this.translate) {
        return this.translate.apply(this, arguments);
    }
};

infChart.Drawing.prototype.stepFunction = function (e, isStartPoint) {
    var ann = this.annotation;
    if (ann && ann.options && ann.options.snapToCandle) {
        var chart = ann.chart;
        var x = e.chartX
        var xAxis = chart.xAxis[ann.options.xAxis],
            nearestXValueData = infChart.math.findNearestDataPoint(chart, ann.options.xValue, undefined, ann.options.useAllXDataToFindNearestPoint, ann.options.useFutureDate),
            nearestXValueEndData = infChart.math.findNearestDataPoint(chart, xAxis.toValue(x), undefined, ann.options.useAllXDataToFindNearestPoint, ann.options.useFutureDate);

        var options = {
            xValue: nearestXValueData.xData,
            xValueDataIndex: nearestXValueData.dataIndex
        };

        if(!isStartPoint) {
            options.nearestXValueEnd = nearestXValueEndData.xData;
            options.xValueEndDataIndex = nearestXValueEndData.dataIndex;
        }

        ann.update(options);

        e.chartX = xAxis.toPixels(nearestXValueEndData.xData);
    }

    if (this.step) {
        return this.step.apply(this, arguments);
    }
};

/**
 * This helps to wrap the above function since those are not defined as prototype functions
 * @param functionName
 * @param func
 * @param arguments
 * @returns {*}
 */
infChart.Drawing.prototype.wrapFunctionHelper = function (functionName, func, arguments) {
    if (func) {
        return func.apply(this, arguments);
    }
};

/**
 * This helps to open the setting panel when double click on the drawing.
 * @param {object} e
 */
infChart.Drawing.prototype.onDoubleClick = function (e) {
    this.openSettingPanel();
    e.stopPropagation();
};

infChart.Drawing.prototype.openSettingPanel = function () {
    var drawingObj = this;
    if (drawingObj.isQuickSetting) {
        infChart.drawingUtils.common.toggleSettings.call(drawingObj);
    } else if (drawingObj.shape === "highLowLabels" ) {
        infChart.drawingsManager.openSettings(drawingObj, false);
    }
};


infChart.Drawing.prototype.getTitle = function () {
    return infChart.manager.getLabel('label.' + this.shape);
};

infChart.Drawing.prototype.selectPointEvents = function (dragItem, stepFunction, stopFunction, isStartPoint, itemProperties) {
    var self = this;
    var ann = self.annotation, chart = ann.chart;
    var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart);
    var chartInstance = infChart.manager.getChart(stockChartId);

    function drag(e) {
        if (e.button !== 2 && !(e.ctrlKey && e.button === 0)) { // ignore right click - cannot use an event since mousedown event is fired first , ignore ctrl + click
            var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart);
            if (!infChart.drawingsManager.isMultipleDrawingsEnabled(chartId) && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
                e.preventDefault();
                e.stopPropagation();
                e = chart.pointer.normalize(e);
                ann.events.deselect.call(ann, e);
                if(self.showSelectionMarkers){
                    self.showSelectionMarkers(itemProperties);
                }
                chart.annotationChangeInProgress = true;
                infChart.drawingsManager.onAnnotationStore(ann);

                if (!ann.options.isLocked && !chartInstance.isGloballyLocked){

                infChart.util.bindEvent(chart.container, 'mousemove', step);
                infChart.util.bindEvent(chart.container, 'mouseup', drop);
                infChart.util.bindEvent(chart.container, 'mouseleave', drop);
                };
            }
        }
    }

    function step(e) {
        e = chart.pointer.normalize(e);
        if(ann.options){
            ann.options.mouseDownOnAnn = false;
            if(self.toggleFibLevelEraseIcon){
                self.toggleFibLevelEraseIcon(true);
            }
            if (stepFunction) {
                stepFunction.call(self, e, isStartPoint, itemProperties);
            }
        }
    }

    function drop(e) {
        e = self.chart.pointer.normalize(e);
        if (self.annotation && self.stop) {
            stopFunction.call(self, e, isStartPoint, itemProperties);
        }
        //$(document).unbind('.dragItem');
        // self.openDrawingSettings.call(self);
        self.selectAndBindResize();
        chart.selectedAnnotation = ann;
        chart.annotationChangeInProgress = false;
        infChart.drawingsManager.onAnnotationRelease(ann);
        if(self.toggleFibLevelEraseIcon){
            self.toggleFibLevelEraseIcon(false);
        }
        infChart.util.unbindEvent(chart.container, 'mousemove', step);
        infChart.util.unbindEvent(chart.container, 'mouseup', drop);
        infChart.util.unbindEvent(chart.container, 'mouseleave', drop);
    }

    //dragItem.on('mousedown', drag);
    infChart.util.bindEvent(dragItem.element, 'mousedown', drag);
    // infChart.util.bindDragEvents(chart, dragItem, step, drop, drag);
};

/**
 * Destroy the drawing object
 * @param {boolean} isPropertyChange isPropertyChange used in wrappers
 * @param {object} properties deleted drawing obj properties used in wrappers
 * @returns {boolean}
 */
infChart.Drawing.prototype.destroy = function (isPropertyChange, properties) {
    var annotation = this.annotation,
        options = annotation.options;

    if (this.settingsPopup) {
        this.settingsPopup.remove();
        this.settingsPopup = null;
    }

    if (options.removeMouseMove) {
        options.removeMouseMove.forEach(function (removeFn) {
            removeFn();
        });
        options.removeMouseMove = undefined;
    }

    if (options.removeMouseUp) {
        options.removeMouseUp.forEach(function (removeFn) {
            removeFn();
        });
        options.removeMouseUp = undefined;
    }
    // need to do this before destroying annotation since properties are used inside destroy functions
    if (this.beforeDestroy) {
        this.beforeDestroy();
    }

    annotation.events.destroyAnnotation(annotation);
    if (this.destroyDrawing) {
        this.destroyDrawing();
    }

    // should redraw from the callee function id this is true
    return this.chartRedrawRequired && isPropertyChange;
};

infChart.Drawing.prototype.getOptions = function(properties,options){

    if (properties.isLocked !== "undefined") {
        options.isLocked = properties.isLocked;
    } else {
        options.isLocked = false;
    }

    return options;
};

/**
 * load setting window or popup based on option
 * @param {boolean} hide - hide setting popup
 * @param {object} options - settings option from config
 */
infChart.Drawing.prototype.loadSettingWindow = function (hide, options) {
    var self = this, content;
    function onClose() {
        infChart.drawingUtils.common.removeDrawing.call(self);
    }
    function ontoggleSettings() {
        infChart.drawingUtils.common.toggleSettings.call(self);
    }
    infChart.drawingsManager.setActiveDrawing(self.annotation);
    if (!self.settingsPopup) {
        var content = self.getSettingsPopup();
        if (content) {
            var html;
            if (options && options.isDisableDrawingSettingsPanel) {
                html = infChart.structureManager.settings.getPopupHTML(self.getTitle(), content);
                self.settingsPopup = $(html).appendTo(self.drawingSettingsContainer);
                var container = $('#' + infChart.manager.getContainerIdFromChart(self.stockChartId))[0];
                infChart.structureManager.settings.bindPopup(container, self.settingsPopup, ontoggleSettings);
            } else {
                html = infChart.structureManager.settings.getPanelHTML(self.stockChartId + "-drawing-panel", self.drawingId, self.getTitle(), content);
                self.settingsPopup = $(html).appendTo(self.drawingSettingsContainer);
                infChart.structureManager.settings.bindPanel(self.settingsPopup, onClose);
            }
            self.isQuickSetting = false;
            self.bindSettingsEvents();
        }
    }
    self.settingsPopup.data("infLoadSettings", true);
    self.updateSettings(self.getConfig());
    self.settingsPopup.data("infLoadSettings", false);
    if (!hide) {
        var popupPosition = options ? options.popupPosition : undefined;
        infChart.drawingsManager.setActiveDrawingSettings(self, popupPosition);

        if(self.focusAndSelectInput){
            self.focusAndSelectInput();
        }
    }
};

infChart.Drawing.prototype.loadQuickSettingPopup = function (isLocked) {
    var self = this;
    function onDelete() {
        infChart.drawingUtils.common.removeDrawing.call(self);
    }
    function ontoggleSettings() {
        infChart.drawingUtils.common.toggleSettings.call(self);
    }
    function toggleLock(element, isPropertyChange) {
        infChart.Drawing.prototype.toggleLock.call(self, element, isPropertyChange);
    }
    if (!self.settingsPopup) {
        var content = self.getQuickSettingsPopup();
        var html;
        if (content) {
            html = infChart.structureManager.drawingTools.getQuickSettingsPopupHTML(content,isLocked );
        } else {
            html = infChart.structureManager.drawingTools.getQuickSettingsPopupHTML("", isLocked);
        }
        this.settingsPopup = $(html).appendTo(self.quickDrawingSettingsContainer);
        infChart.toolbar.initializeTooltips($(this.settingsPopup));
        infChart.structureManager.drawingTools.bindQuickSettingsPopup(self.stockChartId, self.settingsPopup, onDelete, ontoggleSettings, toggleLock );
        self.bindSettingsEvents();
        self.isQuickSetting = true;
        self.settingsPopup.data("infLoadSettings", true);
        self.updateSettings(self.getConfig());
        self.settingsPopup.data("infLoadSettings", false);
    }
};

infChart.Drawing.prototype.updateSavedDrawingProperties = function (resetToDefault) {
    infChart.drawingsManager.updateSavedDrawingProperties(this.stockChartId, this.shape, this.drawingId, resetToDefault);
};

infChart.Drawing.prototype.resetToUserDefaultDrawingProperties = function () {
    infChart.drawingsManager.resetToUserDefaultDrawingProperties(this.stockChartId, this.shape, this.drawingId);
};

infChart.Drawing.prototype.reloadSettings = function () {
    infChart.drawingsManager.reloadSettings(this.stockChartId, this.drawingId);
};

infChart.Drawing.prototype.isSettingsPropertyChange = function () {
    return this.settingsPopup && !this.settingsPopup.data("infLoadSettings") && !this.settingsPopup.data("infUndoRedo");
};
/**
 * Open drawing settings or load settings and hide according to the request
 * @param {boolean|undefined} hide to hide panel
 * @param {object} options - settings option from config
 */
infChart.Drawing.prototype.openDrawingSettings = function (hide, options) {
    switch (this.annotation.options.drawingType) {
        case infChart.constants.drawingTypes.trading:
        case infChart.constants.drawingTypes.alert:
        case infChart.constants.drawingTypes.indicator:
            // this.loadSettingWindow(true);
            break;
        default:
            this.loadSettingWindow(!!hide, options);
            break;
    }
};

infChart.Drawing.prototype.showQuickDrawingSettings = function () {
    var self = this;
    infChart.structureManager.settings.hideAllSettingsPopups(true);
    if(!self.disableQuickSettingPanel){
        if (self.isQuickSetting) {
            if (!self.settingsPopup) {
                self.loadQuickSettingPopup(self.annotation.options.isLocked);
            } else {
                $(self.settingsPopup).show();
            }
        } else {
            infChart.drawingUtils.common.toggleSettings.call(self);
        }
    }
};

infChart.Drawing.prototype.isVisibleLastLevel = function () {
    var self = this;
    var count = 0;
    $.each(self.additionalDrawings.lines, function (key, value) {
        if (value.visibility !== 'hidden') {
            count = count + 1;
        }
    });

    return count === 1;
};



/**
 * drawing object yValue/yValueEnd/trendYValue are always the base y value
 * this will update the yValue/yValueEnd/trendYValue in annotation options according to the chart mode. eg : compare/log/percentage
 */
infChart.Drawing.prototype.scaleDrawing = function (isCalculateNewValueForScale) {
    var self = this,
        ann = self.annotation,
        yValues = {},
        stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart),
        chartInstance = infChart.manager.getChart(stockChartId);
    // TODO :: check why this method executes when changing pages in infinit app (Having trading tools in the chart with modified y min /max)
    if (ann && ann.chart) {

        if((chartInstance.isCompare || isCalculateNewValueForScale) && !(infChart.drawingsManager.getIsActiveDrawingInprogress())) {
            switch (self.shape) {
                case 'tradingLine':
                case 'holdingLine':
                case 'limitOrder':
                case 'upperLimit':
                case 'lowerLimit':
                case 'timestampMarker':
                    break;
                case 'trendChannel':
                case 'andrewsPitchfork':
                case 'fib3PointPriceProjectionHLH':
                case 'fib3PointPriceProjectionLHL':
                case 'fib3PointTimeProjection':
                case 'fib3PointPriceProjectionGeneric':
                    yValues["yValueEnd"] = infChart.drawingUtils.common.getYValue.call(self, self.yValueEnd);
                    yValues["trendYValue"] = infChart.drawingUtils.common.getYValue.call(self, self.trendYValue);
                    break;
                default:
                    yValues["yValueEnd"] = infChart.drawingUtils.common.getYValue.call(self, self.yValueEnd);
                    break;
            }
            if (self.intermediatePoints) {
                var intermediatePoints = [];
                infChart.util.forEach(self.intermediatePoints, function (index, value) {
                    intermediatePoints.push({
                        xValue: value.xValue,
                        yValue: infChart.drawingUtils.common.getYValue.call(self, value.yValue)
                    });
                });
                yValues["intermediatePoints"] = intermediatePoints;
            }

            if (self.nearestIntermediatePoints) {
                var nearestIntermediatePoints = [];
                infChart.util.forEach(self.nearestIntermediatePoints, function (index, value) {
                    nearestIntermediatePoints.push({
                        xValue: value.xValue,
                        yValue: infChart.drawingUtils.common.getYValue.call(self, value.yValue),
                        topOfThePoint: value.topOfThePoint
                    });
                });
                yValues["nearestIntermediatePoints"] = nearestIntermediatePoints;
            }

            yValues["yValue"] = infChart.drawingUtils.common.getYValue.call(self, self.yValue);
            if (self.nearestYValue) {
                yValues["nearestYValue"] = infChart.drawingUtils.common.getYValue.call(self, self.nearestYValue);
            }
            if (self.nearestYValueEnd) {
                yValues["nearestYValueEnd"] = infChart.drawingUtils.common.getYValue.call(self, self.nearestYValueEnd);
            }
            if (self.nearestTrendYValue) {
                yValues["nearestTrendYValue"] = infChart.drawingUtils.common.getYValue.call(self, self.nearestTrendYValue);
            }

            ann.update(yValues);
        }
        if(chartInstance.isCompare){
            self.scale(true);
        } else {
            if(ann && ann.chart && ann.chart.annotationChangeInProgress){
                self.scale(true);
            } else {
                self.scale(isCalculateNewValueForScale);
            }
        }
        // ann.events.deselect.call(ann);
        //ann.chart.seriesGroup.toFront();

        //If the annotation is already selected the selection markers should update
        if (ann.selectionMarker && ann.selectionMarker.length && self.stop && self.selectAndBindResize) {
            self.selectAndBindResize();
            ann.chart.selectedAnnotation = ann;
        }

        //When reload the drawings from properties those drawing needs to be deselected 
        if(isCalculateNewValueForScale){
            if(self.annotation.selectionMarker){
                for (var i = 0; i < self.annotation.selectionMarker.length; i++) {
                    self.annotation.selectionMarker[i].destroy();
                }
            }
            self.annotation.selectionMarker = false;
            self.deselect(true);
            self.annotation.chart.selectedAnnotation = null;
        }

        var chart = ann.chart,
            yAxes = chart.yAxis,
            yLen = yAxes.length,
            groups = chart.annotations.groups,
            parentNode = ann.chart.seriesGroup.element.parentNode,
            i = 0;

        /*for (; i < yLen; i++) {
         parentNode.insertBefore(groups[i + "-behind-series"].element, ann.chart.seriesGroup.element);
         }*/
    }
};

/**
 * Event handler for afterRedrawXAxisWithoutSetExtremes
 */
// infChart.Drawing.prototype.afterRedrawXAxisWithoutSetExtremes = function () {
//     var ann = this.annotation;
//     if (ann && ann.chart && this.afterRedrawXAxisWithoutSetExtremes) {
//         this.afterRedrawXAxisWithoutSetExtremes();
//     }
// };

/**
 *  update drawing object from given properties
 * @param {object} properties new properties
 * @param {boolean|undefined} redraw indicate redraw
 */
infChart.Drawing.prototype.update = function (properties, redraw) {
    if (typeof redraw === "undefined") {
        redraw = true;
    }
    var ann = this.annotation;
    if (ann) {
        var options = this.annotation.options;

        if(this.beforeUpdateOptions) {
            this.beforeUpdateOptions(properties);
        }

        properties.yValue && (this.yValue = properties.yValue);
        properties.yValueEnd && (this.yValueEnd = properties.yValueEnd);
        properties.trendYValue && (this.trendYValue = properties.trendYValue);
        properties.xValue && (options.xValue = properties.xValue);
        properties.xValueEnd && (options.xValueEnd = properties.xValueEnd);
        properties.trendXValue && (options.trendXValue = properties.trendXValue);

        if(properties.jointLineValue){
            options.jointLineValue = properties.jointLineValue;
        }

        if (properties.intermediatePoints) {
            this.intermediatePoints = properties.intermediatePoints;
        }

        if (this.updateOptions) {
            this.updateOptions(properties);
        }
        if (redraw) {
            this.scaleDrawing(true);
        }
    }
};

infChart.Drawing.prototype.toggleLock = function (element, isPropertyChange) {

    var self = this;
    var ann = self.annotation;

    if (typeof isPropertyChange == 'undefined') {
        isPropertyChange = true;
    }

    if (ann.options.isLocked){
        $($(element).parent()[0]).attr({'adv-chart-tooltip' : infChart.manager.getLabel('label.lock')});
    } else {
        $($(element).parent()[0]).attr({'adv-chart-tooltip' : infChart.manager.getLabel('label.unlock')});
    };



    if (ann.options){
        ann.options.isLocked = !ann.options.isLocked ;

        if (ann.options.isLocked){
            $($(element).children()[0]).attr({class: 'icom icom-lock' })
        } else {
            $($(element).children()[0]).attr({class: 'icom icom-unlock' })
        };
    };

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.Drawing.prototype.saveDrawingTemplate = function (templateName) {
    infChart.drawingsManager.saveDrawingTemplate(this.stockChartId,  this.drawingId, this.shape, templateName);
};

infChart.Drawing.prototype.applyDrawingTemplate = function (templateName) {
    infChart.drawingsManager.applyDrawingTemplate(this.stockChartId, this.drawingId, this.shape, templateName);
};

infChart.Drawing.prototype.deleteDrawingTemplate = function (templateName) {
    infChart.drawingsManager.deleteDrawingTemplate(this.stockChartId, this.drawingId, this.shape, templateName);
};

infChart.Drawing.prototype.getDrawingTemplates = function () {
    return infChart.drawingsManager.getDrawingTemplates(this.stockChartId, this.shape);
};

infChart.Drawing.prototype.getUserDefaultSettings = function () {
    return infChart.drawingsManager.getUserDefaultDrawingProperties(this.stockChartId, this.shape);
};

var infChart = window.infChart || {};

infChart.mobileDrawing = function () {
    infChart.Drawing.apply(this, arguments);
};

infChart.mobileDrawing.prototype = Object.create(infChart.Drawing.prototype);

infChart.mobileDrawing.prototype.selectPointEvents = function (dragItem, stepFunction, stopFunction, isStartPoint, itemProperties) {
    var self = this;
    var ann = self.annotation, chart = ann.chart;
    var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart);
    var chartInstance = infChart.manager.getChart(stockChartId);

    function drag(e) {
        if (e.button !== 2 && !(e.ctrlKey && e.button === 0)) { // ignore right click - cannot use an event since mousedown event is fired first , ignore ctrl + click
            var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart);
            if (!infChart.drawingsManager.isMultipleDrawingsEnabled(chartId) && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
                //e.preventDefault();
                e.stopPropagation();
                e = chart.pointer.normalize(e);
                //ann.events.deselect.call(ann, e);
                if(self.showSelectionMarkers){
                    self.showSelectionMarkers(itemProperties);
                }
                chart.annotationChangeInProgress = true;
                infChart.drawingsManager.onAnnotationStore(ann);

                if (!ann.options.isLocked && !chartInstance.isGloballyLocked){
                    infChart.util.bindEvent(dragItem.element, 'mousemove', step);
                    infChart.util.bindEvent(dragItem.element, 'mouseup', drop);
                };
            }
        }
    }

    function step(e) {
        e = chart.pointer.normalize(e);
        if(ann.options){
            ann.options.mouseDownOnAnn = false;
            if(self.toggleFibLevelEraseIcon){
                self.toggleFibLevelEraseIcon(true);
            }
            if (stepFunction) {
                stepFunction.call(self, e, isStartPoint, itemProperties);
            }
        }
    }

    function drop(e) {
        e = self.chart.pointer.normalize(e);
        infChart.util.unbindEvent(dragItem.element, 'mousemove', step);
        infChart.util.unbindEvent(dragItem.element, 'mouseup', drop);
        if (self.annotation && self.stop) {
            stopFunction.call(self, e, isStartPoint, itemProperties);
        }
        //$(document).unbind('.dragItem');
        // self.openDrawingSettings.call(self);
        self.selectAndBindResize();
        chart.selectedAnnotation = ann;
        chart.annotationChangeInProgress = false;
        infChart.drawingsManager.onAnnotationRelease(ann);
        if(self.toggleFibLevelEraseIcon){
            self.toggleFibLevelEraseIcon(false);
        }
    }

    infChart.util.bindEvent(dragItem.element, 'mousedown', drag);
};
window.infChart = window.infChart || {};

infChart.drawingObject = function () {
    infChart.mobileDrawing.apply(this, arguments);
};

infChart.drawingObject.prototype = Object.create(infChart.mobileDrawing.prototype);

//used in adding additional drawings for a drawing
infChart.drawingObject.prototype.additionalDrawingsFunction = function () {};

infChart.drawingObject.prototype.afterRedrawXAxisWithoutSetExtremes = function () {};

//used in destroy additional drawings attached with drawing
infChart.drawingObject.prototype.beforeDestroy = function () {};

infChart.drawingObject.prototype.bindSettingsEvents = function () {};

infChart.drawingObject.prototype.deselect = function(){
    this.annotation && this.annotation.group.removeClass('active-drawing');
};

//used in destroy drawings
infChart.drawingObject.prototype.destroyDrawing = function () {};

//used in saving drawings
infChart.drawingObject.prototype.getConfig = function () {};

//used in copy/paste
infChart.drawingObject.prototype.getConfigToCopy = function () {
    var annotation = this.annotation;
    var chart = annotation.chart;
    var options = annotation.options;
    var xAxis = chart.xAxis[options.xAxis];
    var yAxis = chart.yAxis[options.yAxis];
    var shapeTheme = infChart.drawingUtils.common.theme[this.shape];
    var copyDistance = shapeTheme && shapeTheme.copyDistance;
    var defaultCopyDistance = infChart.drawingUtils.common.theme.defaultCopyDistance;
    var candleDistance = this.getCandleDistance();
    var copyDistanceX = candleDistance ? candleDistance : (copyDistance && (copyDistance.x || copyDistance.x == 0)) ? copyDistance.x : defaultCopyDistance;
    var copyDistanceY = (copyDistance && (copyDistance.y || copyDistance.y == 0)) ? copyDistance.y : defaultCopyDistance;

    var properties = this.getConfig();
    properties.xValue = xAxis.toValue(xAxis.toPixels(properties.xValue) + copyDistanceX);
    properties.xValueEnd = xAxis.toValue(xAxis.toPixels(properties.xValueEnd) + copyDistanceX);
    properties.trendXValue = xAxis.toValue(xAxis.toPixels(properties.trendXValue) + copyDistanceX);
    properties.yValue = yAxis.toValue(yAxis.toPixels(properties.yValue) + copyDistanceY);
    properties.yValueEnd = yAxis.toValue(yAxis.toPixels(properties.yValueEnd) + copyDistanceY);
    properties.trendYValue = yAxis.toValue(yAxis.toPixels(properties.trendYValue) + copyDistanceY);

    if (properties.intermediatePoints) {
        infChart.util.forEach(properties.intermediatePoints, function (index, value) {
            value.xValue = xAxis.toValue(xAxis.toPixels(value.xValue) + copyDistanceX);
            value.yValue = yAxis.toValue(yAxis.toPixels(value.yValue) + copyDistanceY);
        });
    }

    return properties;
};

infChart.drawingObject.prototype.getCandleDistance = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis];

    var candleDistance;
    if (chart.hoverSeries) {
        var firstPoint = chart.hoverSeries.processedXData[0];
        var secondPoint = chart.hoverSeries.processedXData[1];
        candleDistance = xAxis.toPixels(secondPoint) - xAxis.toPixels(firstPoint);
    }
    return candleDistance;
}

//get specific options
infChart.drawingObject.prototype.getOptions = function () {};

//returns the html of the settings of the drawing
infChart.drawingObject.prototype.getSettingsPopup = function () {};

infChart.drawingObject.prototype.getQuickSettingsPopup = function () {}

infChart.drawingObject.prototype.onClick = function () {};

//used in scale the drawing
infChart.drawingObject.prototype.scale = function () {};

//used in selection of each drawing
infChart.drawingObject.prototype.select = function () {};

infChart.drawingObject.prototype.selectAndBindResize = function () {};

//returns the height of the drawing
infChart.drawingObject.prototype.setOptions = function () {};

infChart.drawingObject.prototype.step = function () {};

infChart.drawingObject.prototype.stop = function () {};

infChart.drawingObject.prototype.translate = function () {};

infChart.drawingObject.prototype.translateEnd = function () {};

//used in trading break even drawing
infChart.drawingObject.prototype.updateOptions = function () {};

//update settings according to loaded properties
infChart.drawingObject.prototype.updateSettings = function () {};

//check whether the property is required when saving and resetting the drawing
infChart.drawingObject.prototype.isRequiredProperty = function () {};
var infChart = window.infChart || {};
/**
 * Created by nimila on 9/15/15.
 * Chart drawing features
 */
infChart.drawingsManager = (function ($, infChart) {
    var chartDrawingObjects = {},
        listeners = {},
        drawingToolBarProperties = {},
        scaleDrawingPausedCharts = [],
        scaleDrawingCalledWhenPaused = [],
        activeDrawing = null,
        activeDrawingSettings = null,
        isActiveDeleteTool = {},
        isActiveEraseMode = {},
        isActiveDrawing = false,
        isActiveDrawingInprogress = false,
        activeAnnotationInprogress = null,
        drawingConfigs = {},
        copiedDrawingObjProperties = {},
        _onKeyDownFunctions = {},
        _chartAreaKeyDownFunctions = {},
        _multipleDrawingsEnabledProperties = {},
        _savedDrawingOptionsMap = {},
        _providerInstances = {},
        _chartDrawingProviderTypes = {},
        _drawingTemplates = {},
        _drawingToolbarConfigs = [],
        _isDisableDrawingSettingsPanel = false;

    const ESC_KEY = 27;

    /**
     * Bind events for chart drawing
     * Drag, Step and Drop
     */
    var events = (function () {
        var chart, container, annotations, annotation, shapeId, drawingSettingsContainer, drawingObj, subTypeId,
            quickDrawingSettingsContainer, isPropertyChange;

        /**
         * step function called on mouse move
         * @param e
         */
        function step(e) {
            if (chart) {
                e = chart.pointer.normalize(e);
            }

            if (drawingObj.stepFunction) {
                drawingObj.stepFunction(e, false, drawingObj.getNextPointOptions && drawingObj.getNextPointOptions());
            }
            if(_isIntermediatePointDrawing(shapeId)){
                drawingObj.newPointAdded = true;
            }
        }

        /**
         * add annotation, bind events for step & stop function
         * @param e
         */
        function start(e) {
            if (chart) {
                e = chart.pointer.normalize(e);
            }
            _changeGlobalLockStatus(chart);
            var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart);
            var chartInstance = infChart.manager.getChart(stockChartId);
            chart.annotationChangeInProgress = true;
            chartInstance.throughTheDrawingClick = true;
            isActiveDrawingInprogress = true;
            var bbox = chart.container.getBoundingClientRect(),
                clickX = e.chartX,
                clickY = e.chartY;

            if (!chart.isInsidePlot(clickX - chart.plotLeft, clickY - chart.plotTop)) {
                return;
            }

            var clickValues = _getClickValues(shapeId, chart, clickX, clickY);
            clickValues.subType = subTypeId;
            clickValues.completedSteps = 1;
            clickValues.shape = shapeId;
            var drawingObject = _createDrawing(chart, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
            drawingObj = _addAnnotation(drawingObject, chart, shapeId, clickValues, false);

            var hasIntermediateStep = drawingObj.hasMoreIntermediateSteps && drawingObj.hasMoreIntermediateSteps();

            chart.activeAnnotation = drawingObj.annotation;

            chart.activeAnnotation.startXDiff = e.chartX - drawingObj.annotation.group.translateX;
            chart.activeAnnotation.startYDiff = e.chartY - drawingObj.annotation.group.translateY;
            chart.activeAnnotation.transX = 0;
            chart.activeAnnotation.transY = 0;

            Highcharts.removeEvent(container, 'touchstart', start);
            document.addEventListener('keydown', keyDownEnd);

            switch (shapeId) {
                case 'label':
                case 'horizontalLine':
                case 'shortLine':
                case 'longLine':
                case 'horizontalRay':
                case 'verticalLine':
                case 'tradingLine':
                case 'limitOrder':
                case 'highLowLabels':
                case 'longPositions':
                case 'shortPositions':
                case 'upArrow':
                case 'downArrow':
                    end(e);
                    break;
                case 'andrewsPitchfork':
                case 'fib3PointPriceProjectionHLH':
                case 'fib3PointPriceProjectionLHL':
                case 'fib3PointPriceProjectionGeneric':
                case 'fib3PointTimeProjection':
                    infChart.util.bindEvent(container, 'mousemove', step);
                    infChart.util.bindEvent(container, 'mousedown', intermediate);
                    break;
                case 'brush':
                    infChart.util.bindEvent(container, 'mousemove', step);
                    infChart.util.bindEvent(container, 'mouseup', end);
                    break;
                case 'polyline':
                    infChart.util.bindEvent(container, 'mousemove', step);
                    infChart.util.bindEvent(container, 'mousedown', specificIntermediate);
                    break;
                default:
                    if (hasIntermediateStep) {
                        infChart.util.bindEvent(container, 'mousemove', step);
                        infChart.util.bindEvent(container, 'mousedown', intermediate);
                    } else {
                        Highcharts.addEvent(container, 'touchmove', step);
                        Highcharts.addEvent(container, 'touchstart', end);
                    }
                    break;
            }

            infChart.util.setCursor(container, 'block');
        }

        function ignoreUnfinishedDrawing(e){
            (drawingObj.isContinuousDrawing) ? end(e, true) : end(e, true, true);
        }

        /**
         * used only in andrews' pitchfork
         * to be written generally
         * @param e
         */
        function intermediate(e) {
            if (e.which == 3) {
                end(undefined, true);
            } else {
                if (e.detail === 2 || !drawingObj.newPointAdded) {
                    e.preventDefault();
                    return;
                }
                if (chart) {
                    e = chart.pointer.normalize(e);
                }

                var bbox = chart.container.getBoundingClientRect(),
                    clickX = e.chartX,
                    clickY = e.chartY;

                if (!chart.isInsidePlot(clickX - chart.plotLeft, clickY - chart.plotTop)) {
                    return;
                }

                //destroy pitchfork
                var basePointX = drawingObj.annotation.options.trendXValue !== Number.MIN_SAFE_INTEGER ? drawingObj.annotation.options.trendXValue : drawingObj.annotation.options.xValue;
                var basePointY = drawingObj.annotation.options.trendYValue !== Number.MIN_SAFE_INTEGER ? drawingObj.annotation.options.trendYValue : drawingObj.annotation.options.yValue;
                var id = drawingObj.drawingId;
                var intermediatePoints = drawingObj.annotation.options.intermediatePoints;
                var completedSteps = drawingObj.annotation.options.completedSteps;

                var clickValues = drawingObj.getClickValues ? drawingObj.getClickValues(clickX, clickY) : _getClickValues(shapeId, chart, clickX, clickY);

                _removeDrawingInner(_getChartIdFromHighchartInstance(chart), id);

                clickValues.trendXValue = basePointX;
                clickValues.trendYValue = basePointY;
                clickValues.completedSteps = completedSteps + 1;
                clickValues.subType = subTypeId;

                var drawingObject = _createDrawing(chart, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                drawingObj = _addAnnotation(drawingObject, chart, shapeId, clickValues, false);
                if (typeof drawingObj.scale === "function" && drawingObj.annotation && drawingObj.annotation.options && !drawingObj.annotation.options.disableIntermediateScale) {
                    drawingObj.scaleDrawing();
                }
                chart.annotationChangeInProgress = true;

                var hasIntermediateStep = drawingObj.hasMoreIntermediateSteps && drawingObj.hasMoreIntermediateSteps();
                if (!hasIntermediateStep) {
                    Highcharts.removeEvent(container, 'mousedown', intermediate);
                    Highcharts.addEvent(container, 'mousemove', step);
                    Highcharts.addEvent(container, 'mousedown', end);
                } else {
                    chart.annotations.allowZoom = false;
                }
                if(_isIntermediatePointDrawing(shapeId)){
                    drawingObj.newPointAdded = false;
                }
                infChart.util.setCursor(container, 'block');
            }
        }


        /**
         * used only in andrews' pitchfork
         * to be written generally
         * @param e
         */
        function specificIntermediate(e) {
            if (e.which == 3) {
                end(undefined, true);
            } else {
                if (e.detail == 2) {
                    if (drawingObj.annotation.options.intermediatePoints.length > 0) {
                        drawingObj.annotation.options.completedSteps = drawingObj.annotation.options.completedSteps - 1;
                        end(e);
                    }
                } else {
                    var name = e.target.getAttribute('name');
                    var drawingId = e.target.getAttribute('drawingId');
                    if (name == '0' && drawingId == drawingObj.drawingId) {
                        drawingObj.drawingIsFullFilled = true;
                        drawingObj.annotation.options.drawingIsFullFilled = true;
                        end(e);
                    } else {
                        if (chart) {
                            e = chart.pointer.normalize(e);
                        }

                        var clickX = e.chartX,
                            clickY = e.chartY;

                        if (!chart.isInsidePlot(clickX - chart.plotLeft, clickY - chart.plotTop)) {
                            return;
                        }

                        var id = drawingObj.drawingId;
                        var intermediatePoints = drawingObj.annotation.options.intermediatePoints;
                        var completedSteps = drawingObj.annotation.options.completedSteps;

                        var clickValues = drawingObj.getClickValues ? drawingObj.getClickValues(clickX, clickY) : _getClickValues(shapeId, chart, clickX, clickY);

                        _removeDrawingInner(_getChartIdFromHighchartInstance(chart), id);

                        clickValues.completedSteps = completedSteps + 1;
                        clickValues.subType = subTypeId;

                        var drawingObject = _createDrawing(chart, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                        drawingObj = _addAnnotation(drawingObject, chart, shapeId, clickValues, false);
                        if (typeof drawingObj.scale === "function" && drawingObj.annotation && drawingObj.annotation.options && !drawingObj.annotation.options.disableIntermediateScale) {
                            drawingObj.scaleDrawing();
                        }

                        chart.annotationChangeInProgress = true;
                        chart.annotations.allowZoom = false;

                        infChart.util.setCursor(container, 'block');
                    }
                    if(shapeId == 'polyline'){
                        drawingObj.newPointAdded = false;
                    }
                }
            }
        }

        function keyDownEnd(e) {
            if (e) {
                if (e.keyCode == 27) {
                    end(e, true);
                }
            }
        }

        /**
         * call stop function
         * @param e
         */
        function end(e, abortDrawing, unfinishedDrawing) {
            var isRightClick = (e && e.which === 3);
            var isDoubleClick = (e && e.detail === 2);
            var isPolyline = (shapeId === "polyline" || drawingObj.shape === "polyline");
            var isHighLowLabel = (shapeId === "highLowLabels" || drawingObj.shape === "highLowLabels");
            var isBrush = (shapeId === "brush" || drawingObj.shape === "brush");
            var stopFunctionOutput;
            var chartId = _getChartIdFromHighchartInstance(chart);

            if(isRightClick){
                abortDrawing = true;
            }

            if (isDoubleClick && !isPolyline && !isHighLowLabel || (!drawingObj.newPointAdded && _isIntermediatePointDrawing(shapeId, true))) {
                if (!_isSingleClickDrawing(shapeId)) {
                    return;
                }
            }
            if(isPolyline && abortDrawing && !drawingObj.newPointAdded){
                abortDrawing = false;
            }

            if (chart && e) {
                e = chart.pointer.normalize(e);
            }
            chart.annotationChangeInProgress = false;
            chart.activeAnnotation = null;

            if (isPolyline) {
                drawingObj.finishedInitialDrawing = true;
                drawingObj.annotation.options.finalCompletedSteps = (drawingObj.annotation.options.completedSteps - (abortDrawing ? 1 : 0));
            }

            if ((drawingObj && !drawingObj.settingsPopup && !abortDrawing) || isPolyline) {
                _loadQuickSettings(drawingObj);
            }

            if (drawingObj && !(abortDrawing && !drawingObj.isContinuousDrawing) && drawingObj.annotation && drawingObj.stop) {
                stopFunctionOutput = drawingObj.wrapFunctionHelper.call(drawingObj, "stopFunction", drawingObj.stop, [e, undefined, true, abortDrawing]);
            }

            if ((abortDrawing && !drawingObj.isContinuousDrawing) || (stopFunctionOutput && stopFunctionOutput.stopPropagation)) { // if a drawing is not required to propagate it will be destroyed here
                _removeDrawingInner(chartId, drawingObj.drawingId);
                drawingObj = null;
                Highcharts.removeEvent(container, 'mousedown', intermediate);
            }

            Highcharts.removeEvent(container, 'touchmove', step);
            document.removeEventListener('keydown', keyDownEnd, false);

            if (isBrush) {
                infChart.util.unbindEvent(container, 'mouseup', end);

                if (!abortDrawing && !_isMultipleDrawingsEnabled(chartId)) {
                    _toggleMultipleDrawings(chartId);
                    _addActiveClassToMultipleDrawingBtn(chartId);
                }
            } else if (isPolyline) {
                infChart.util.unbindEvent(container, 'mousedown', specificIntermediate);
            } else {
                infChart.util.unbindEvent(container, 'mousedown', end);
                Highcharts.removeEvent(container, 'touchstart', end);
            }

            if (_isMultipleDrawingsEnabled(chartId) && subTypeId === infChart.constants.drawingTypes.shape || unfinishedDrawing) {
                Highcharts.addEvent(container, 'mousedown', start);
                infChart.util.setCursor(container, 'block');
            } else {
                _disableDrawing(chartId);
            }

            if (!abortDrawing && !isPolyline) {
                Highcharts.addEvent(container, 'mouseup', select);
            }

            if (drawingObj && isPropertyChange) {
                drawingObj.onPropertyChange("drawings");
            }
            isActiveDrawingInprogress = false;
            if (drawingObj && drawingObj.chartRedrawRequired) {
                infChart.manager.getChart(drawingObj.stockChartId).redrawChart();
            }

            if (isBrush || isHighLowLabel) {
                select();
            }
        }

        function select() {

            if (drawingObj && drawingObj.annotation) {
                if (drawingObj.stop) {
                    if (drawingObj.selectAndBindResize) {
                        drawingObj.selectAndBindResize();
                        if (!drawingObj.settingsPopup) {
                            drawingObj.showQuickDrawingSettings.call(drawingObj);
                        }
                    }
                    if (drawingObj && drawingObj.annotation.options.drawingType === infChart.constants.drawingTypes.shape) {
                        _bindKeyDown(drawingObj.annotation);
                    }
                }

                chart.selectedAnnotation = drawingObj.annotation;
            }

            annotation = null;
            drawingObj = null;

            //infChart.util.unbindEvent(container, 'mouseup', select);
            Highcharts.removeEvent(container, 'mouseup', select);
        }

        return {
            bindEvents: function (chartObj, shape, drawSetCon, quickDrawSetCon, subType, isPropChange) {
                events.unbindEvents(chartObj);
                chart = chartObj;

                if(chart.annotationChangeInProgress) {
                    end(undefined, true);
                    isActiveDrawingInprogress = true;
                }

                container = chartObj.container;
                annotations = chartObj.annotations.allItems;
                shapeId = shape;
                subTypeId = subType;
                drawingSettingsContainer = drawSetCon;
                quickDrawingSettingsContainer = quickDrawSetCon;
                chart.annotations.allowZoom = false;
                chart.annotations.tradingMode = (shape === 'tradingLine' || subType === 'shape');
                isPropertyChange = isPropChange;

                Highcharts.addEvent(container, 'touchstart', start);
                infChart.util.setCursor(container, 'block');
            },
            unbindEvents: function (chartObj) {
                container = chartObj.container;
                Highcharts.removeEvent(container, 'mousedown', start);
                infChart.util.setCursor(container, 'default');

                if (chartObj.annotations) {
                    chartObj.annotations.allowZoom = true;
                    chartObj.annotations.tradingMode = false;
                }
            },
            annotationEnd: function(chartObj){
                var chart = chartObj;
                if(chart.annotationChangeInProgress) {
                    end(undefined, true);
                }
            }
        }
    })();

    var _isSingleClickDrawing = function (shapeId){
        var isSingleClickDrawing = false;
        switch(shapeId){
            case 'label':
            case 'horizontalLine':
            case 'shortLine':
            case 'longLine':
            case 'horizontalRay':
            case 'verticalLine':
            case 'highLowLabels':
            case 'longPositions':
            case 'shortPositions':
                isSingleClickDrawing = true;
                break;
            default:
                isSingleClickDrawing = false;
                break;
        }
        return isSingleClickDrawing;
    }

    var _isIntermediatePointDrawing = function (shapeId, isEnd){
        var isIntermediatePointDrawing = false;
        switch(shapeId){
            case 'harmonicPattern':
            case 'abcdPattern':
            case 'elliotTriangleWave':
            case 'elliotImpulseWave':
            case 'elliotCorrectiveWave':
            case 'elliotCorrectiveDoubleWave':
            case 'correctiveTripleWave':
            case 'fib3PointPriceProjectionHLH':
            case 'fib3PointPriceProjectionLHL':
            case 'fib3PointTimeProjection':
            case 'fib3PointPriceProjectionGeneric':
            case 'andrewsPitchfork':
                isIntermediatePointDrawing = true;
                break;
            case 'polyline':
                isIntermediatePointDrawing = !isEnd;
                break;
            default:
                break;
        }
        return isIntermediatePointDrawing;
    }

    var _getClickValues = function (shapeId, chart, clickX, clickY) {
        var coordinates = {xValue: 0, yValue: 0},
            xAxis = chart.xAxis[0],
            yAxis = chart.yAxis[0];

        switch (shapeId) {
            case "horizontalLine":
            case "tradingLine":
            case "holdingLine":
                coordinates.xValue = xAxis.toValue(chart.plotLeft);
                coordinates.yValue = yAxis.toValue(chart.plotTop + clickY);
                break;
            case 'verticalLine':
                coordinates.xValue = xAxis.toValue(chart.plotLeft + clickX);
                coordinates.yValue = yAxis.toValue(chart.plotTop);
                break;
            default:
                coordinates.xValue = xAxis.toValue(clickX);
                coordinates.yValue = yAxis.toValue(clickY);
                break;
        }

        return coordinates;
    };

    /**
     * @param {string} drawingId
     * @param {object} chartObj
     * @param {string} shapeId
     * @param {object} drawingSettingsContainer - chart container
     * @returns drawing object
     */
    var _createDrawing = function (chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer, drawingId) {
        var drawing;

        if (!drawingId) {
            drawingId = infChart.util.generateUUID();
        }

        switch (shapeId) {
            case 'line':
                drawing = new infChart.mobilelineDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'lineArrow':
                drawing = new infChart.lineArrowDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'ray':
                drawing = new infChart.rayDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'extendedLine':
                drawing = new infChart.extendedLineDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'horizontalLine':
                drawing = new infChart.horizontalLineDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'shortLine':
                drawing = new infChart.shortLineDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'longLine':
                drawing = new infChart.longLineDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'verticalLine':
                drawing = new infChart.verticalLineDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'trendChannel':
                drawing = new infChart.trendChannelDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'horizontalRay':
                drawing = new infChart.horizontalRayDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'rectangle':
                drawing = new infChart.rectangleDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'ellipse':
                drawing = new infChart.ellipseDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'brush':
                drawing = new infChart.brushDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'upArrow':
                drawing = new infChart.arrowDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'downArrow':
                drawing = new infChart.arrowDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'regressionLine':
                drawing = new infChart.regressionLineDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'regressionChannel':
                drawing = new infChart.regressionChannelDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'andrewsPitchfork':
                drawing = new infChart.andrewsPitchforkDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'label':
                drawing = new infChart.labelDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'fibFans':
                drawing = new infChart.fibFansDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'fibRetracements':
                drawing = new infChart.fibRetracementsDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'fibVerRetracements':
                drawing = new infChart.fibVerRetracementsDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'fibArcs':
                drawing = new infChart.fibArcsDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'fib3PointPriceProjectionHLH':
            case 'fib3PointPriceProjectionLHL':
                drawing = new infChart.fib3PointPriceProjectionDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'fib3PointPriceProjectionGeneric':
                drawing = new infChart.fib3PointPriceProjectionGenericDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'fib3PointTimeProjection':
                drawing = new infChart.fib3PointTimeProjection(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'fib2PointTimeProjection':
                drawing = new infChart.fib2PointTimeProjection(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'harmonicPattern':
                drawing = new infChart.harmonicPatternDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'abcdPattern':
                drawing = new infChart.abcdPatternDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'elliotTriangleWave':
                drawing = new infChart.elliotTriangleWaveDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'elliotImpulseWave':
                drawing = new infChart.elliotImpluseWaveDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'elliotCorrectiveWave':
                drawing = new infChart.elliotCorrectiveWaveDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'elliotCorrectiveDoubleWave':
                drawing = new infChart.elliotCorrectiveDoubleWaveDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'correctiveTripleWave':
                drawing = new infChart.elliotCorrectiveTripleWaveDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'highLowLabels':
                drawing = new infChart.highLowLabels(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'longPositions':
            case 'shortPositions':
                drawing = new infChart.positionsDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
            case 'timestampMarker':
                drawing = new infChart.timestampMarkerDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer);
                break;
            case 'polyline':
                drawing = new infChart.polylineDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer, true);
                break;
            case 'volumeProfile':
                drawing = new infChart.volumeProfileDrawing(drawingId, chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer);
                break;
        }
        return drawing;
    };

    /**
     *
     * @param {object} drawingObj of drawing
     * @param {object} chart
     * @param {sting} shape of the drawing object
     * @param {object} properties
     * @param {object} drawFromProperties
     * @returns drawingObj
     */
    var _addAnnotation = function (drawingObj, chart, shapeId, properties, drawFromProperties) {
        _setDrawingObject(drawingObj);

        var options = _getDrawingOptions(drawingObj.drawingId, shapeId, properties, chart, drawFromProperties);

        drawingObj.yValue = options.yValue;
        drawingObj.yValueEnd = options.yValueEnd;
        drawingObj.trendYValue = options.trendYValue;
        drawingObj.intermediatePoints = options.intermediatePoints;

        if (drawingObj.setNearestYValues) {
            drawingObj.setNearestYValues(options, chart);
        }
        drawingObj.nearestIntermediatePoints = options.nearestIntermediatePoints;
        drawingObj.subType = options.subType;

        chart.addAnnotation(options, true);

        var annotations = chart.annotations.allItems;
        var idx = 0;
        drawingObj.annotation = annotations[annotations.length - 1];

        if (annotations.length > 1) {
            var lastAnn = annotations[annotations.length - 2],
                stockChartId = _getChartIdFromHighchartInstance(lastAnn.chart);
            var lastDrwing = _getDrawingObject(stockChartId, lastAnn.options.id);
            idx = lastDrwing.idx + 1;
        }
        drawingObj.idx = idx;
        if (drawingObj.additionalDrawingsFunction) {
            drawingObj.additionalDrawingsFunction();
        }

        if (_validateExtremes(options)) {
            var yAxis = chart.yAxis[options.yAxis], extremes = options.getExtremesFn.call(drawingObj);
            if (extremes && ((yAxis.userMin || yAxis.dataMin) > extremes.min || (yAxis.userMax || yAxis.dataMax) < extremes.max)) {
                _setExtremes(drawingObj.stockChartId, true);
            }
        }

        return drawingObj;
    };

    var _getChartIdFromHighchartInstance = function (highchartInstance) {
        return infChart.manager.getContainerIdFromChart(highchartInstance.renderTo.id);
    };

    /**
     * get drawing options
     * @param {string} drawingId - drawing id
     * @param {string} shapeId - shape id
     * @param {object} properties - properties
     * @param  {object} chart - chart object
     * @param  {boolean} drawFromProperties - true, if drawing is existing one
     * @returns {object} - options
     * @private
     */
    var _getDrawingOptions = function (drawingId, shapeId, properties, chart, drawFromProperties) {
        var chartId = _getChartIdFromHighchartInstance(chart);
        var drawingObj = _getDrawingObject(chartId, drawingId);
        var defaultOptions = infChart.drawingUtils.common.getDefaultOptions();
        var specificOptions = drawingObj.getOptions(
            drawFromProperties ? properties : $.extend(true, {}, _getDefaultDrawingProperties(chartId, shapeId), properties),
            chart
        );
        var stockChart = infChart.manager.getChart(chartId);
        if (stockChart.settings.config.disableDrawingMove) {
            specificOptions.allowDragX = false;
            specificOptions.allowDragY = false;
            specificOptions.allowDragByHandle = false;
        }
        var options = $.extend(true, {}, defaultOptions, specificOptions);
        return $.extend(true, {
            id: drawingId,
            events: _getDrawingEvents(drawingId, chartId, options.drawingType)
        }, options);
    };

    var _addEventListeners = function (chartId) {
        listeners[chartId] = [];

        var chartInstance = infChart.manager.getChart(chartId);

        listeners[chartId].push({
            method: 'setSymbol',
            id: chartInstance.registerForEvents('setSymbol', function (newSymbol, previousSymbol, config) {
                if (config.setProperties) {
                    _removeAllDrawings(chartId);
                }
            })
        });

        listeners[chartId].push({
            method: 'onReadHistoryDataLoad',
            id: chartInstance.registerForEvents('onReadHistoryDataLoad', function (data, config) {
                _onNewProperties(chartId, config.drawings, true, data);
            })
        });

        listeners[chartId].push({
            method: 'afterSetExtremes',
            id: chartInstance.registerForEvents('afterSetExtremes', function () {
                if (!chartInstance.chart.isChartDragging) {
                    _scaleDrawings(chartId);
                }
            })
        });

        listeners[chartId].push({
            method: 'onSeriesTypeChange',
            id: chartInstance.registerForEvents('onSeriesTypeChange', function () {
                _scaleDrawingOnChartTypeChange(chartId);
            })
        });

        listeners[chartId].push({
            method: 'afterYSetExtremes',
            id: chartInstance.registerForEvents('afterYSetExtremes', function () {
                if (!chartInstance.chart.isChartDragging && !infChart.util.isEmpty(chartDrawingObjects[chartId])) {
                    _scaleDrawings(chartId);
                    if (_setExtremesRequired(chartId)) {
                        _setExtremes(chartId, false);
                    }
                }
            })
        });

        listeners[chartId].push({
            method: 'setExtremesByDragging',
            id: chartInstance.registerForEvents('setExtremesByDragging', function (isXZoom) {
                if (isXZoom) {
                    _scaleDrawings(chartId);
                } else if (!infChart.util.isEmpty(chartDrawingObjects[chartId])) {
                    _scaleDrawings(chartId);
                    if (_setExtremesRequired(chartId)) {
                        _setExtremes(chartId, false);
                    }
                }
            })
        });

        listeners[chartId].push({
            method: 'resize',
            id: chartInstance.registerForEvents('resize', function () {
                _scaleDrawings(chartId);
                infChart.structureManager.toolbar.positionFavoriteMenu(chartId);
            })
        });

        listeners[chartId].push({
            method: 'destroy',
            id: chartInstance.registerForEvents('destroy', function () {
                _removeAllDrawings(chartId);
            })
        });

        listeners[chartId].push({
            method: 'onBaseAxisResize',
            id: chartInstance.registerForEvents('onBaseAxisResize', function () {
                _scaleDrawings(chartId);
            })
        });

        // listeners[chartId].push({
        //     method: 'beforeScalingAxis',
        //     id: chartInstance.registerForEvents('beforeScalingAxis', function () {
        //         _pauseScaleDrawings(chartId);
        //     })
        // });
        //
        // listeners[chartId].push({
        //     method: 'afterScalingAxis',
        //     id: chartInstance.registerForEvents('afterScalingAxis', function () {
        //         _unPauseScaleDrawings(chartId);
        //     })
        // });

        // used in horzontal line since plot area changes according to the label
        listeners[chartId].push({
            method: 'modeChange',
            id: chartInstance.registerForEvents('modeChange', function () {
                _scaleDrawings(chartId, true);
            })
        });

        listeners[chartId].push({
            method: 'afterRedrawXAxisWithoutSetExtremes',
            id: chartInstance.registerForEvents('afterRedrawXAxisWithoutSetExtremes', function () {
                _afterRedrawXAxisWithoutSetExtremes(chartId);
            })
        });

        listeners[chartId].push({
            method: 'onReadHistoryDataLoad',
            id: chartInstance.registerForEvents('onReadHistoryDataLoad', function () {
                _scaleDrawings(chartId, true);
            })
        });

        listeners[chartId].push({
            method: 'onCompareSymbolLoad',
            id: chartInstance.registerForEvents('onCompareSymbolLoad', function () {
                _scaleDrawings(chartId, true);
            })
        });

        listeners[chartId].push({
            method: 'onRemoveCompareSymbol',
            id: chartInstance.registerForEvents('onRemoveCompareSymbol', function () {
                _scaleDrawings(chartId, true);
            })
        });
    };

    var _removeEventListeners = function (chartId) {
        var chartInstance = infChart.manager.getChart(chartId);

        listeners[chartId].forEach(function (val) {
            chartInstance.removeRegisteredEvent(val.method, val.id);
        });

        delete listeners[chartId];
    };

    /**
     * get settings container
     * @param {string} chartId - chart ic
     * @returns {object} - settings container
     */
    var _getSettingsContainer = function (chartId) {
        return $(_getDrawingSettingsContainer($(infChart.manager.getChart(chartId).getContainer())));
    };

    var _getQuickSettingsContainer = function (chartId) {
        return $(_getQuickDrawingSettingContainer($(infChart.manager.getChart(chartId).getContainer())));
    };

    var _onNewProperties = function (chartId, drawingProperties, keepPrevious, data) {
        if (!keepPrevious) {
            _removeAllDrawings(chartId);
        }
        if (drawingProperties && drawingProperties.length > 0 && data.length !== 0) {
            var chartInstance = infChart.manager.getChart(chartId),
                settingsContainer = _getSettingsContainer(chartId),
                quickSettingsContainer = _getQuickSettingsContainer(chartId);

            var chartRedrawRequired = false;
            infChart.util.forEach(drawingProperties, function (i, drawing) {
                var drawingObj = _createDrawing(chartInstance.chart, drawing.shape, settingsContainer, quickSettingsContainer, drawing.drawingId);
                drawingObj = _drawDrawingFromProperties(drawingObj, chartInstance.chart, settingsContainer, drawing);
                // _loadSettings(drawingObj);
                // _loadQuickSettings(drawingObj);
                if (drawingObj.chartRedrawRequired) {
                    chartRedrawRequired = true
                }
            });

            if (chartRedrawRequired) {
                chartInstance.chart.redraw();
            }
        }
    };

    /**
     * initialise drawing manager
     * @param {string} chartId - chart id
     * @param {object} dataProviderObj - chart data provider obj
     * @param {boolean} isDisableDrawingSettingsPanel - is disable drawing setting panel
     */
    var _onInitialize = function (chartId, dataProviderObj, isDisableDrawingSettingsPanel) {
        infChart.drawingUtils.common.setTheme();
        _isDisableDrawingSettingsPanel = isDisableDrawingSettingsPanel;
        if (chartId) {
            isActiveDeleteTool[chartId] = false;
        }
        if (chartId) {
            isActiveEraseMode[chartId] = false;
        }

        if (!chartDrawingObjects[chartId]) {
            chartDrawingObjects[chartId] = {};
            _setDataProvider(chartId, dataProviderObj);
            _addEventListeners(chartId);
        } else {
            infChart.util.console.error('drawings manager already initialized for chart => ' + chartId);
        }
    };

    var _onDestroy = function (chartId) {
        _getSettingsContainer(chartId).html('');
        _removeAllDrawings(chartId);
        _removeEventListeners(chartId);
        _removeChartAreaKeyDownListener(chartId, ESC_KEY);
        _multipleDrawingsEnabledProperties[chartId] = false;
        delete chartDrawingObjects[chartId];
    };

    var _scaleDrawingsInner = function (chartId, isCalculateNewValueForScale) {
        var drawings = chartDrawingObjects[chartId],
            selectedDrawing;
        if (drawings) {
            $.each(drawings, function (key, drawing) {
                if (drawing.annotation.chart) {
                    drawing.scaleDrawing(isCalculateNewValueForScale);
                    if (drawing.annotation.chart.selectedAnnotation && drawing.annotation.chart.selectedAnnotation === drawing.annotation) {
                        selectedDrawing = drawing;
                    }
                }
            });

            // to bring the axis label of the selected label to front
            if (selectedDrawing) {
                selectedDrawing.select();
            }
        }
    };


    var _deselectDrawingTools = function (chartId, currentDrawingId) {
        var drawings = chartDrawingObjects[chartId];
        if (drawings) {
            $.each(drawings, function (drawingId, drawing) {
                if (drawing.deselectAllDrawingsInAdditionalDrawingSelect) {
                    if (currentDrawingId != drawingId) {
                        drawing.deselect.call(drawing);
                    }
                }
            });
        }
    };

    var _removeDrawingInner = function (chartId, drawingId, isPropertyChange) {
        var drawingObj = _getDrawingObject(chartId, drawingId);
        var ann = drawingObj.annotation, chart = ann.chart, annOptions = ann.options;
        var chartRedrawRequired = false;
        if (drawingObj) {
            var drawingType = annOptions.drawingType;
            if (drawingType === infChart.constants.drawingTypes.shape) {
                if (chart.activeAnnotation === ann) {
                    chart.activeAnnotation = null;
                    chart.annotationChangeInProgress = false;
                    chart.annotations.allowZoom = true;
                    _setActiveAnnotationInprogress(null);
                }
                if (chart.selectedAnnotation === ann) {
                    drawingObj.annotation.events.deselect.call(drawingObj.annotation);
                }
                var drawingProperties = _getDrawingProperties(ann);
                _deleteDrawingObject(chartId, drawingId);
                if (isPropertyChange) {
                    drawingObj.onPropertyChange("drawings");
                }
                chartRedrawRequired = drawingObj.destroy(isPropertyChange, drawingProperties);
            }
        }
        return chartRedrawRequired;
    };

    /**
     * switch right settings panel to symbol when no drawing tools
     * @param {string} chartId
     */
    var _switchSettingsTab = function (chartId) {
        var stockChart = infChart.manager.getChart(chartId);
        if (stockChart.isRightPanelOpen()) {//todo : need to check if drawings tab is open
            var drawings = chartDrawingObjects[chartId];
            var hasShapeDrawings = false;

            $.each(drawings, function (drawingId, drawingObj) {
                if (!hasShapeDrawings && drawingObj.annotation.options.drawingType === infChart.constants.drawingTypes.shape) {
                    hasShapeDrawings = true;
                }
            });

            if (!hasShapeDrawings) {
                stockChart.showRightPanelWithTab((chartId + "_" + "symbolSettingsPanelView"));
            }
        }
    };

    /**
     * check whether extremes have to be validated
     * @param chartId
     * @returns {boolean}
     * @private
     */
    var _setExtremesRequired = function (chartId) {
        var required = false,
            stockChart = infChart.manager.getChart(chartId),
            chart = stockChart.chart,
            annotations = chart.annotations;

        if (annotations && annotations.allItems.length > 0) {
            for (var i = 0; i < annotations.allItems.length; i++) {
                var annotation = annotations.allItems[i];
                if (_validateExtremes(annotation.options) && annotation.visible !== false) {
                    required = true;
                    break;
                }
            }
        }
        return required;
    };

    var _validateExtremes = function (options) {
        return typeof options.getExtremesFn === 'function' && options.adjustYAxisToViewAnnotation;
    };

    var _setExtremes = function (chartId, resetExtremes) {
        var stockChart = infChart.manager.getChart(chartId),
            chart = stockChart.chart,
            yAxis = chart.yAxis[0];
        if (yAxis.dataMin && yAxis.dataMax) {
            var min = undefined, max = undefined, setExtremes = false;
            var extremes = _getExtremesForDrawings(chartId, stockChart.isUserDefinedYAxisExtremes());
            if (!stockChart.isUserDefinedYAxisExtremes()) {
                if (extremes && extremes.min !== null && extremes.max !== null && (yAxis.dataMin > extremes.min || yAxis.dataMax < extremes.max)) {
                    if (yAxis.dataMin > extremes.min) {
                        if (yAxis.dataMax < extremes.max) {
                            if (yAxis.userMin || yAxis.userMax) {
                                if (yAxis.userMin) {
                                    if (yAxis.userMin > extremes.min) {
                                        setExtremes = true;
                                        if (yAxis.userMax) {
                                            if (yAxis.userMax < extremes.max) {
                                                min = extremes.minPaddingUtilized ? extremes.min : extremes.min - ((extremes.max - extremes.min) * yAxis.options.minPadding);
                                                max = extremes.max + ((extremes.max - extremes.min) * yAxis.options.maxPadding);
                                            } else {
                                                min = extremes.minPaddingUtilized ? extremes.min : extremes.min - ((yAxis.userMax - extremes.min) * yAxis.options.minPadding);
                                                max = yAxis.userMax;
                                            }
                                        } else {
                                            min = extremes.minPaddingUtilized ? extremes.min : extremes.min - ((extremes.max - extremes.min) * yAxis.options.minPadding);
                                            max = extremes.max + ((extremes.max - extremes.min) * yAxis.options.maxPadding);
                                        }
                                    } else {
                                        if (yAxis.userMax) {
                                            if (yAxis.userMax < extremes.max) {
                                                setExtremes = true;
                                                max = extremes.max + ((extremes.max - yAxis.userMin) * yAxis.options.maxPadding);
                                                min = yAxis.userMin;
                                            }
                                        } else {
                                            setExtremes = true;
                                            max = extremes.max + ((extremes.max - yAxis.userMin) * yAxis.options.maxPadding);
                                            min = yAxis.userMin;
                                        }
                                    }
                                } else {
                                    setExtremes = true;
                                    if (yAxis.userMax < extremes.max) {
                                        min = extremes.minPaddingUtilized ? extremes.min : extremes.min - ((extremes.max - extremes.min) * yAxis.options.minPadding);
                                        max = extremes.max + ((extremes.max - extremes.min) * yAxis.options.maxPadding);
                                    } else {
                                        min = extremes.minPaddingUtilized ? extremes.min : extremes.min - ((yAxis.userMax - extremes.min) * yAxis.options.minPadding);
                                        max = yAxis.userMax;
                                    }
                                }
                            } else {
                                setExtremes = true;
                                min = extremes.minPaddingUtilized ? extremes.min : extremes.min - ((extremes.max - extremes.min) * yAxis.options.minPadding);
                                max = extremes.max + ((extremes.max - extremes.min) * yAxis.options.maxPadding);
                            }
                        } else {
                            if (yAxis.userMin) {
                                if (yAxis.userMin > extremes.min) {
                                    setExtremes = true;
                                    min = extremes.minPaddingUtilized ? extremes.min : extremes.min - (((yAxis.userMax || yAxis.dataMax) - extremes.min) * yAxis.options.minPadding);
                                    max = yAxis.userMax || yAxis.dataMax;
                                }
                            } else {
                                setExtremes = true;
                                min = extremes.minPaddingUtilized ? extremes.min : extremes.min - (((yAxis.userMax || yAxis.dataMax) - extremes.min) * yAxis.options.minPadding);
                                max = yAxis.userMax || yAxis.dataMax;
                            }
                        }
                    } else {
                        if (yAxis.userMax) {
                            if (yAxis.userMax < extremes.max || (chart.activeAnnotation && !chart.activeAnnotation.options.mouseDownOnAnn)) {
                                setExtremes = true;
                                max = extremes.max + ((extremes.max - (yAxis.userMin || yAxis.dataMin)) * yAxis.options.maxPadding);
                                min = yAxis.userMin || yAxis.dataMin;
                            }
                        } else {
                            setExtremes = true;
                            max = extremes.max + ((extremes.max - (yAxis.userMin || yAxis.dataMin)) * yAxis.options.maxPadding);
                            min = yAxis.userMin || yAxis.dataMin;
                        }
                    }

                    if (setExtremes) {
                        // console.error('chart :: setting y axis extremes => min=' + min + ', max=' + max);
                        yAxis.setExtremes(min, max, true, false);
                    }
                } else {
                    if (resetExtremes && (yAxis.userMin || yAxis.userMax)) {
                        // console.error('chart :: resetting setting y axis extremes => min=' + yAxis.userMin + ', max=' + yAxis.userMax);
                        yAxis.setExtremes(null, null, true, false);
                    }
                }
            } else {
                if (extremes && extremes.min !== null && extremes.max !== null && (yAxis.userMin > extremes.min || yAxis.userMax < extremes.max)) {
                    if (yAxis.userMin > extremes.min) {
                        if (yAxis.userMax < extremes.max) {
                            min = extremes.minPaddingUtilized ? extremes.min : extremes.min - ((extremes.max - extremes.min) * yAxis.options.minPadding);
                            max = extremes.max + ((extremes.max - extremes.min) * yAxis.options.maxPadding);
                        } else {
                            max = yAxis.userMax;
                            min = extremes.minPaddingUtilized ? extremes.min : extremes.min - ((yAxis.userMax - extremes.min) * yAxis.options.maxPadding);
                        }
                    } else {
                        min = yAxis.userMin;
                        max = extremes.max + ((extremes.max - yAxis.userMin) * yAxis.options.maxPadding);
                    }
                    yAxis.setExtremes(min, max, true, false);
                }
            }
        }
    };

    /**
     * called when remove drawing from the chart
     * set extremes null when chart is not zoom
     * @param {string} chartId
     * @param {string} annotationId
     * @private
     */
    var _setExtremesOnRemove = function (chartId, annotationId) {
        var stockChart = infChart.manager.getChart(chartId),
            chart = stockChart.chart,
            yAxis = chart.yAxis[0];

        if (stockChart.isUserDefinedYAxisExtremes()) {
            _setExtremes(chartId, (annotationId === chart.infMinAnnotation || annotationId === chart.infMaxAnnotation));
        } else {
            yAxis.setExtremes(null, null, true, false);
        }
    };

    var _setDrawingObject = function (drawingObj) {
        var stockChartId = drawingObj.stockChartId,
            drawingId = drawingObj.drawingId;

        chartDrawingObjects[stockChartId][drawingId] = drawingObj;
    };

    var _deleteDrawingObject = function (chartId, drawingId) {
        if (chartDrawingObjects[chartId] && chartDrawingObjects[chartId][drawingId]) {
            delete chartDrawingObjects[chartId][drawingId];
        }
    };

    /**
     * Paste copied item
     * IMPORTANT Note :: made this method public to wrap up drom commands.wrappers
     * @param annotation
     */
    var pasteNewItem = function (annotation) {
        var chartId = _getChartIdFromHighchartInstance(annotation.chart);
        var chartInstance = infChart.manager.getChart(chartId);
        var settingsContainer = _getSettingsContainer(chartId);
        var quickSettingsContainer = _getQuickSettingsContainer(chartId);

        var drawingObj = _createDrawing(chartInstance.chart, copiedDrawingObjProperties[chartId].shape, settingsContainer, quickSettingsContainer, copiedDrawingObjProperties[chartId].drawingId);
        drawingObj = _drawDrawingFromProperties(drawingObj, chartInstance.chart, settingsContainer, copiedDrawingObjProperties[chartId]);
        var newAnn = drawingObj.annotation;

        // select the annotation if not selected
        if (!newAnn.selectionMarker) {
            var drawings = chartDrawingObjects[chartId],
                prevDrawing = drawings && drawings[annotation.options.id];
            if (!annotation.selectionMarker) {
                //prevDrawing.deselectFunction.call(prevDrawing);
                if (prevDrawing.deselect) {
                    prevDrawing.deselect(true);
                } else {
                    infChart.drawingUtils.common.onDeselect.call(this);
                }
            } else {
                annotation.events.deselect.call(annotation, undefined, true);
            }
            drawingObj.selectAndBindResize();
            annotation.chart.selectedAnnotation = newAnn;
        }
        if (drawingObj && newAnn.options.drawingType === infChart.constants.drawingTypes.shape) {
            _bindKeyDown(newAnn);
            copiedDrawingObjProperties[chartId] = _getDrawingPropertiesToCopy(newAnn);
        }
        return drawingObj;
    };

    /**
     * Handles the copy/paste of given annotation
     * @param {Event} event keypress event
     * @param {object} annotation highchart annotation
     * @private
     */
    var _handleCopyPaste = function (event, annotation) {
        var key = event.which || event.keyCode,
            ctrl = event.ctrlKey || event.metaKey || ((key === 17) ? true : false),
            chartId = _getChartIdFromHighchartInstance(annotation.chart),
            targetEl = event.target;

        if (($(targetEl).is('body') || (targetEl.hasAttribute("x-enable-drawing-copy") && (!targetEl.xIsTextField() || targetEl.xGetSelectedText() === undefined)))
            && annotation && annotation.options) {
            if (ctrl) {
                switch (key) {
                    case 86:
                        console.debug("Chart Drawing:: Ctrl + V Pressed !");
                        if (copiedDrawingObjProperties[chartId]) {
                            infChart.drawingsManager.pasteNewItem(annotation);
                            event.preventDefault();
                            event.stopPropagation();
                        }
                        break;
                    case 67:
                        console.debug("Chart Drawing:: Ctrl + C Pressed !");
                        copiedDrawingObjProperties = {}; // to invalidate other copied items in the other charts
                        copiedDrawingObjProperties[chartId] = _getDrawingPropertiesToCopy(annotation);
                        break;
                    default:
                        break;
                }
            }
        } else if (key == 67 && ctrl) {
            // to avoid multiple copies of the previous item
            copiedDrawingObjProperties = {};
        }
    };

    /**
     * Bind key down after selecting the given annotation
     * @param {object} annotation highcharts annotation
     * @private
     */
    var _bindKeyDown = function (annotation) {
        var chartId = _getChartIdFromHighchartInstance(annotation.chart);

        function onKeyDown(event) {
            if (annotation && (!annotation.chart || !annotation.chart.infMouseIn && !$("#" + chartId).xIsInside(event.target, ".inf-chart"))) {
                return;
            }

            var key = event.which || event.keyCode;

            if (!$(event.target).is('input') && !$(event.target).is('textarea') && annotation && annotation.options && annotation.chart && annotation.chart.selectedAnnotation) {
                switch (key) {
                    case 8://event.key === "Backspace"
                    case 46://event.key === "Delete"
                        if (!infChart.drawingsManager.getIsActiveDrawingInprogress()) {
                            _removeDrawing(chartId, annotation.options.id, undefined, true);
                            _unbindKeyDown(chartId);
                        }
                        break;
                    default:
                        break;
                }
            }
            if (annotation.options && !annotation.options.disableCopyPaste && annotation.chart) {
                _handleCopyPaste(event, annotation);
            }
        }

        _unbindKeyDown(chartId);
        $(document).on('keydown', onKeyDown);
        _onKeyDownFunctions[chartId] = onKeyDown;
    };

    /**
     * unbind specific key down for drawing tools
     * @param {string} chartId chart id of the event
     * @private
     */
    var _unbindKeyDown = function (chartId) {
        var stockChart = infChart.manager.getChart(chartId);
        if (_onKeyDownFunctions[chartId]) {
            $(document).off('keydown', _onKeyDownFunctions[chartId]);
            delete _onKeyDownFunctions[chartId];
        }
    };

    var _disableDrawing = function (chartId) {
        $(infChart.manager.getChart(chartId).getContainer()).find("a[inf-ctrl-role=disDrawing]").trigger('click');
    };

    var _addActiveClassToMultipleDrawingBtn = function (chartId) {
        $(infChart.manager.getChart(chartId).getContainer()).find("a[inf-ctrl-role=multipleDrawing]").addClass('active');
    };

    /**
     * get min max for all annotations
     * sets min/max annotations to yAxis also
     * @param {string} chartId
     * @param {boolean} isYAxisAdjusted
     */
    var _getExtremesForDrawings = function (chartId, isYAxisAdjusted) {
        var stockChart = infChart.manager.getChart(chartId),
            chart = stockChart.chart,
            annotations = chart.annotations,
            yAxis,
            min = null,
            max = null,
            minAnnotationId = null,
            maxAnnotationId = null,
            minPaddingUtilized,
            maxPaddingUtilized,
            dataMax,
            dataMin;

        if (annotations && annotations.allItems.length > 0) {
            chart.infGetDrawingExtremesInProgress = true;
            for (var i = 0; i < annotations.allItems.length; i++) {
                var annotation = annotations.allItems[i];
                if (!yAxis) {
                    yAxis = chart.yAxis[annotation.options.yAxis];
                }
                if (_validateExtremes(annotation.options) && annotation.visible !== false) {
                    var useDrawing = isYAxisAdjusted ? annotation.options.viewAnnotionWhenAdjustedYAxis : annotation.options.adjustYAxisToViewAnnotation;
                    if (useDrawing) {
                        var drawing = _getDrawingObject(chartId, annotation.options.id),
                            userExtremes = annotation.options.getExtremesFn.call(drawing);
                        var annotationId = annotation.options.id;
                        if (userExtremes) {
                            if (min === null || userExtremes.min < min) {
                                min = userExtremes.min;
                                if (yAxis.dataMin > min) {
                                    minAnnotationId = annotationId;
                                    minPaddingUtilized = userExtremes.minPaddingUtilized;
                                    ///yAxis.tempMinAnnotationId =
                                }
                                dataMin = userExtremes.dataMin;
                            }

                            if (max === null || userExtremes.max > max) {
                                max = userExtremes.max;
                                if (yAxis.dataMax < max) {
                                    maxAnnotationId = annotationId;
                                    maxPaddingUtilized = userExtremes.maxPaddingUtilized;
                                }
                                dataMax = userExtremes.dataMax;
                            }
                        }
                    }
                }
            }
        }

        if (yAxis) {

            if (yAxis.infMinAnnotation != minAnnotationId) {
                yAxis.prevMinAnnotation = yAxis.infMinAnnotation;
            }

            if (yAxis.infMaxAnnotation != maxAnnotationId) {
                yAxis.prevMaxAnnotation = yAxis.infMaxAnnotation;
            }

            yAxis.infMinAnnotation = minAnnotationId;
            yAxis.infMaxAnnotation = maxAnnotationId;

        }
        chart.infGetDrawingExtremesInProgress = false;

        return {
            min: min,
            max: max,
            dataMax: dataMax,
            dataMin: dataMin,
            minPaddingUtilized: minPaddingUtilized,
            maxPaddingUtilized: maxPaddingUtilized

        };

    };

    /**
     * called when user releases the drawing and when show order on chart
     * set y axis extremes in above scenarios
     * we have to set the y axis extremes in following scenarios
     * 1. drawing is inside the data/user range and it is moved outside the data/user range
     * 2. drawing is min/max annotation(outside the data range) and it is moved even further
     * 3. drawing is min/max annotation(outside the data range) and it is moved closer(but still outside the data range)
     * @param {string} chartId
     * @param {object} annotation
     * @private
     */
    var _setYExtremesOnAnnotationUpdate = function (chartId, annotation) {
        if (_validateExtremes(annotation.options)) {
            var stockChart = infChart.manager.getChart(chartId);
            var chart = stockChart.chart, yAxis = chart.yAxis[annotation.options.yAxis], min = null, max = null;
            var drawing = _getDrawingObject(chartId, annotation.options.id);
            var userExtremes = annotation.options.getExtremesFn.call(drawing);
            var yValue = annotation.options.yValue;
            var annotationId = annotation.options.id,
                maxCalData,
                minCalData;

            if (userExtremes && !stockChart.isUserDefinedYAxisExtremes()) {
                var drawingExtremes = yAxis.infMinAnnotation || yAxis.infMaxAnnotation ? _getExtremesForDrawings(chartId, false) : undefined;

                if (annotationId === yAxis.infMinAnnotation) {
                    if (userExtremes.min < yAxis.userMin || userExtremes.min < yAxis.dataMin) {//set new min using annotations extremes
                        maxCalData = yAxis.infMaxAnnotation ? (drawingExtremes && (drawingExtremes.dataMax || drawingExtremes.max)) || yAxis.userMax : yAxis.dataMax; // need to calculated data max from yAxis.userMax if it is uesd
                        minCalData = userExtremes.minPaddingUtilized ? userExtremes.dataMin || (userExtremes.min + maxCalData * yAxis.options.minPadding) / (1 - yAxis.options.minPadding) : userExtremes.min;
                        min = userExtremes.minPaddingUtilized ? userExtremes.min : userExtremes.min - ((maxCalData - userExtremes.min) * yAxis.options.minPadding);
                        if (yAxis.infMaxAnnotation) {
                            if (yAxis.infMaxAnnotation == annotationId) {
                                max = userExtremes.maxPaddingUtilized ? userExtremes.max : userExtremes.max + ((userExtremes.max - minCalData) * yAxis.options.maxPadding);
                            } else if (drawingExtremes || yAxis.userMax) {
                                max = (drawingExtremes && drawingExtremes.max) || yAxis.userMax;
                            } else {
                                max = null;
                            }
                            yAxis.setExtremes(min, max, true, false);
                        } else {
                            yAxis.setExtremes(min, null, true, false);
                        }
                    } else {
                        //reset min
                        if (yAxis.infMaxAnnotation && yAxis.userMax) {
                            max = (drawingExtremes && drawingExtremes.max) || yAxis.userMax;
                            yAxis.setExtremes(null, max, true, false);
                        } else {
                            yAxis.setExtremes(null, null, true, false);
                        }
                    }
                } else if (annotationId === yAxis.infMaxAnnotation) {
                    maxCalData = /*userExtremes.maxPaddingUtilized ? null :*/ userExtremes.dataMax || userExtremes.max; // IMPORTANT : do not use this to calculate datamax when userExtremes.maxPaddingUtilized = true
                    minCalData = yAxis.infMinAnnotation ? (drawingExtremes && drawingExtremes.min && drawingExtremes.minPaddingUtilized) || (!drawingExtremes && yAxis.userMin) ?
                        (drawingExtremes && drawingExtremes.dataMin) || (maxCalData + ((drawingExtremes && drawingExtremes.min) || yAxis.userMin) * yAxis.options.minPadding) / (1 + yAxis.options.minPadding) :
                        drawingExtremes && (drawingExtremes.dataMin || drawingExtremes.min) || yAxis.dataMin : yAxis.dataMin;
                    min = yAxis.infMinAnnotation ? (drawingExtremes && drawingExtremes.min) || (yAxis.userMin || yAxis.dataMin) : yAxis.dataMin;

                    if (userExtremes.max > yAxis.userMax || userExtremes.max > yAxis.dataMax) {//set new max

                        max = userExtremes.maxPaddingUtilized ? userExtremes.max : userExtremes.max + ((userExtremes.max - minCalData) * yAxis.options.maxPadding);
                        if (yAxis.infMinAnnotation) {
                            yAxis.setExtremes(min, max, true, false);
                        } else {
                            yAxis.setExtremes(null, max, true, false);
                        }
                    } else {
                        //reset max
                        if (yAxis.infMinAnnotation) {
                            yAxis.setExtremes(min, null, true, false);
                        } else {
                            yAxis.setExtremes(null, null, true, false);
                        }
                    }
                } else {
                    // annotation doesn't expand the extremes
                    var reset = false;
                    if (userExtremes.max > yAxis.dataMax || userExtremes.min < yAxis.dataMin) {
                        //annotation is beyond the data extremes of the chart
                        if (userExtremes.max > yAxis.dataMax) {
                            if (!yAxis.userMax || userExtremes.max > yAxis.userMax) { // current userMax is not set or current y axis max is lower than the annotation max
                                if (yAxis.infMinAnnotation && (drawingExtremes.min || yAxis.userMin)) {
                                    // there is a min annotation and use that for the max calculation and actual min
                                    max = userExtremes.max + ((userExtremes.max - ((drawingExtremes && drawingExtremes.min) || yAxis.userMin || yAxis.dataMin)) * yAxis.options.maxPadding);
                                    yAxis.setExtremes((drawingExtremes.min || yAxis.userMin), max, true, false);
                                } else {
                                    // no min annotation and data min is used for the calculation and min is rest
                                    max = userExtremes.max + ((userExtremes.max - (yAxis.userMin || yAxis.dataMin)) * yAxis.options.maxPadding);
                                    yAxis.setExtremes(null, max, true, false);
                                }
                            } else if (!yAxis.infMaxAnnotation) {
                                // if there is no max annotation this annotation should be the max since its extremes are greater than the data max of the chart
                                var minForCal = yAxis.infMinAnnotation && (drawingExtremes.min || yAxis.userMin) ? drawingExtremes.min || yAxis.userMin : userExtremes.min < yAxis.dataMin ? userExtremes.min : null;
                                min = minForCal ? minForCal == userExtremes.min && userExtremes.minPaddingUtilized ? userExtremes.min
                                    : minForCal - ((userExtremes.max - minForCal) * yAxis.options.minPadding) : null;
                                max = userExtremes.max + ((userExtremes.max - (min || yAxis.dataMin)) * yAxis.options.maxPadding);
                                yAxis.setExtremes(min, max, true, false);

                            } else if (annotation.infExpanded) {
                                // when annotation is released after expanded moving towards the data range, it needs to be reset
                                reset = true;
                            } else if (yAxis.prevMaxAnnotation === annotationId || yAxis.prevMinAnnotation === annotationId) {
                                // when annotation is released which earlier was the max annotation
                                reset = true;
                            }
                        } else {
                            if (!yAxis.userMin || userExtremes.min < yAxis.userMin) {
                                //annotation is beyond the data extremes of the chart or userMax is not set
                                if (annotation.infExpanded) {
                                    // when annotation is released after expanded moving towards the data range, it needs to be reset
                                    reset = true;
                                } else if (yAxis.infMaxAnnotation && yAxis.userMax) {
                                    // since there is a max annotation using that for calculation of the min
                                    min = userExtremes.min - ((((drawingExtremes && drawingExtremes.max) || yAxis.userMax || yAxis.dataMax) - userExtremes.min) * yAxis.options.minPadding);
                                    yAxis.setExtremes(min, yAxis.userMax, true, false);
                                } else {
                                    // calculate min using dataMax or usermax since there is no max annotation
                                    min = userExtremes.min - (((yAxis.userMax || yAxis.dataMax) - userExtremes.min) * yAxis.options.minPadding);
                                    yAxis.setExtremes(min, null, true, false);
                                }
                            } else if ((annotation.infExpanded && drawingExtremes && (yAxis.userMin < drawingExtremes.min || yAxis.userMax > drawingExtremes.max)) ||
                                (yAxis.prevMaxAnnotation === annotationId || yAxis.prevMinAnnotation === annotationId)) {
                                // when annotation is released after expanded moving towards the data range, it needs to be reset or
                                // when annotation is released which earlier was the max annotation
                                reset = true;
                            }
                        }
                    } else if ((annotation.infExpanded && drawingExtremes && (yAxis.userMin < drawingExtremes.min || yAxis.userMax > drawingExtremes.max)) ||
                        (yAxis.prevMaxAnnotation === annotationId || yAxis.prevMinAnnotation === annotationId)) {
                        reset = true;
                    }

                    if (drawingExtremes && reset) {
                        // when there are other annotations which occupy the min and max extremes but current extremes are changed when moving the released annotation earlier
                        _resetYExtremes(chartId, drawingExtremes);
                        // annotation.infExpanded = false;  // Note :: this is done in the annotation js. If it needs to be done just after resetting extremes it should go here.

                    } else if (reset) {
                        yAxis.setExtremes(null, null, true, false);
                        //annotation.infExpanded = false; // Note :: this is done in the annotation js. If it needs to be done just after resetting extremes it should go here.

                    }
                }

                if (!yAxis.infMinAnnotation) {
                    yAxis.prevMinAnnotation = null;
                }

                if (!yAxis.infMaxAnnotation) {
                    yAxis.prevMaxAnnotation = null;
                }
            }
        }
    };

    /**
     * Reset y Extremes to min/max drawings or data range
     * @param drawingExtremes
     * @param chartId
     * @private
     */
    var _resetYExtremes = function (chartId, drawingExtremes) {

        var stockChart = infChart.manager.getChart(chartId),
            yAxis = stockChart && stockChart.getMainYAxis();

        if (stockChart && !stockChart.isUserDefinedYAxisExtremes()) {

            drawingExtremes = drawingExtremes || _getExtremesForDrawings(chartId, false);
            // when there are other annotations which occupy the min and max extremes but current extremes are changed when moving the released annotation earlier
            var maxCalData = yAxis.infMaxAnnotation ? (drawingExtremes && (drawingExtremes.dataMax || drawingExtremes.max)) || yAxis.userMax : yAxis.dataMax, // need to calculated data max from yAxis.userMax if it is uesd
                minCalData;

            if (yAxis.infMinAnnotation) {

                if (drawingExtremes && drawingExtremes.dataMin) {
                    // dataMin is calculated from the minimum drawing tool
                    minCalData = drawingExtremes && drawingExtremes.dataMin;

                } else if ((drawingExtremes && drawingExtremes.min && drawingExtremes.minPaddingUtilized) ||
                    (!drawingExtremes && yAxis.userMin)) {
                    // dataMin is not calculated from the minimum drawing tool, but padding space is utilized or drawingExtremes are not specified.
                    // So calculate it using dataMax and padding.
                    minCalData = (maxCalData + ((drawingExtremes && drawingExtremes.min) || yAxis.userMin) * yAxis.options.minPadding) / (1 + yAxis.options.minPadding);
                } else {
                    // dataMin is not calculated from the minimum drawing tool, but padding space is not utilized (So min is calculated including the padding)
                    // or drawingExtremes are not specified
                    minCalData = drawingExtremes && drawingExtremes.min || yAxis.dataMin;
                }
            } else {
                // It doesn't have min drawing
                minCalData = yAxis.dataMin;
            }

            var max = !infChart.util.isDefined(maxCalData) || maxCalData == yAxis.dataMax ? null : maxCalData + (maxCalData - minCalData) * yAxis.options.maxPadding,
                min = !infChart.util.isDefined(maxCalData) || minCalData == yAxis.dataMin ? null : minCalData - (maxCalData - minCalData) * yAxis.options.minPadding;

            if (min != yAxis.userMin || max != yAxis.userMax) {
                yAxis.setExtremes(min, max, true, false);
            }
        }
    };

    /**
     * initialize chart drawing
     * @param {*} container
     * @param {*} uniqueId
     * @param {*} parent
     * @private
     */
    var _setDrawing = function (container, uniqueId, parent) {
        var drawingTools = parent.find("a[inf-ctrl=drawing]");
        // var chart = infChart.manager.getChart(uniqueId).chart;
        var shape, drawingCategory, drawingCategoryCtrl, subType, iChart, hChart,
            drawingSettingsContainer = _getDrawingSettingsContainer(container),
            quickDrawingSettingsContainer = _getQuickDrawingSettingContainer(container);

        drawingTools.each(function () {
            $(this).unbind().click(function (event) {
                iChart = infChart.manager.getChart(uniqueId);
                hChart = iChart && iChart.chart;
                if (hChart && iChart._hasData()) {
                    shape = $(this).attr("inf-ctrl-shape");
                    subType = $(this).attr("inf-ctrl-subType");
                    infChart.structureManager.settings.hideAllSettingsPopups(_isDisableDrawingSettingsPanel);
                    _initializeDrawing(hChart, shape, drawingSettingsContainer, quickDrawingSettingsContainer, subType, true);

                    _setActiveDrawingToolOptions(uniqueId, parent);
                    if (hChart.selectedAnnotation) {
                        hChart.selectedAnnotation.events.deselect.call(hChart.selectedAnnotation, event, true);
                    }
                    parent.find("a[drawing-cat=" + $(this).attr("drawing-cat") + "]").removeClass('active');
                    drawingCategory = $(this).attr('drawing-cat');
                    drawingCategoryCtrl = parent.find("a[draw-cat=" + drawingCategory + "]");
                    drawingCategoryCtrl.html($(this).find('span[rel="icon-span"]')[0].outerHTML);
                    drawingCategoryCtrl.attr("inf-ctrl-shape", shape);
                    drawingCategoryCtrl.addClass('active');
                    $(this).addClass('active');
                    iChart._fireEventListeners("onDrawingOptionSelect");
                }
                event.preventDefault();
            });
        });
    };

    var _setDrawingFavoriteIcons = function (containerElem, containerId, config) {
        var parentFaveriteToolbar = $(infChart.structureManager.getContainer(containerElem[0], "favoriteMenuPanel"));
        var parentToolbar = $(infChart.structureManager.getContainer(containerElem[0], "drawingToolbar"));
        var drawingToolFavIcons = parentToolbar.find("span[inf-ctrl=drawing-fav]");
        drawingToolFavIcons.each(function () {
            $(this).unbind().click(function (event) {
                var favoriteToolbarList = parentFaveriteToolbar.find("ul[class=flt-tlbar__tools]");
                var drawingCat = this.getAttribute("drawing-cat");
                let shape = this.getAttribute("inf-ctrl-shape");
                var drawingToolConfig = config[drawingCat];
                if (drawingToolConfig.options) {
                    let favoriteItem = drawingToolConfig.options.filter(option => option.shape === shape)[0];
                    let filledStar = 'icom-star';
                    let borderStar = 'icom-star-o';
                    let starIcon = $(this).find("i[rel=icon-i]");
                    if (favoriteItem.isFavorite) {
                        if (favoriteToolbarList[0].children.length > 1) {
                            favoriteItem.isFavorite = false;
                            favoriteToolbarList.find('li[inf-fav-list=' + shape + ']').remove();
                            starIcon.removeClass(filledStar);
                            starIcon.addClass(borderStar);
                            $(this).attr('adv-chart-tooltip', infChart.manager.getLabel('label.addToFavorite'));
                        } else {
                            infChart.util.showMessage(this.id, infChart.manager.getLabel("msg.favoriteToolbarItemFallShort"));
                        }
                    } else {
                        if (favoriteToolbarList[0].children.length < 10) {
                            favoriteItem.isFavorite = true;                     
                            favoriteToolbarList.append(infChart.structureManager.drawingTools.getDrawing(favoriteItem, true));
                            starIcon.removeClass(borderStar);
                            starIcon.addClass(filledStar);
                            $(this).attr('adv-chart-tooltip', infChart.manager.getLabel('label.removeFromFavorite'));
                            let favoriteDrawingCat = favoriteToolbarList.find('a[inf-ctrl-shape=' + shape + ']');
                            favoriteDrawingCat.attr('adv-chart-tooltip', infChart.manager.getLabel(favoriteItem.label));
                            favoriteDrawingCat.attr('class', 'adv-chart-tooltip right');
                            $(favoriteDrawingCat).unbind().click(function (event) {
                                _drawingCategoryClick(containerElem, containerId, parentFaveriteToolbar, favoriteDrawingCat, event);
                            });
                        } else {
                            infChart.util.showMessage(this.id, infChart.manager.getLabel("msg.favoriteToolbarItemExceeded"));
                        }

                        _setFavoritePanelDrawing(containerElem, containerId);
                    }
                    _storeFavoriteDrawingConfigs(infChart.manager.getFavoriteToolBarConfigs(), {shape: shape, cat: drawingCat, isFavorite: favoriteItem.isFavorite});
                    _addChangedFavDrawingToolbarConfig(containerId, infChart.manager.getFavoriteToolBarConfigs());
                }
                _showFavoriteToolBarIfHide(containerElem, containerId);
                event.stopPropagation();
            });
        })
    };

    var _removeFavoriteDrawingFromContextMenu = function (uniqueId, drawingCat, drawingShape, chartId) {
      var containerElem = $("#" + uniqueId);
      var drawingCat = drawingCat;
      var shape = drawingShape;
      var config = _getDrawingConfigs(chartId);
      var toggleElm = infChart.structureManager.drawingTools.getFavoriteToggleElement(containerElem, drawingCat, shape, config);
      if(toggleElm) {
        toggleElm.click();
      }
    };

    var _storeFavoriteDrawingConfigs = function (configs, favoriteObject) {
        if (_isConfigExist(configs, favoriteObject.shape)) {
            let index = configs.findIndex(config => config.shape == favoriteObject.shape);
            configs.splice(index, 1);
            configs.push(favoriteObject);
        } else {
            configs.push(favoriteObject);
        }
    };

    var _isConfigExist = function(configs, shape) {
        let config = configs.filter(function(config) { 
            return config.shape === shape;
        });
        return config[0] && config[0] != null;
    };

    var _addChangedFavDrawingToolbarConfig = function(uniqueId, drawingToolbarConfigs) {
        let chart = infChart.manager.getChart(uniqueId);
        chart._onPropertyChange('favoriteDrawingToolbarConfigs', drawingToolbarConfigs);
    };

    var _showFavoriteToolBarIfHide = function(container, containerId) {
        var chart = infChart.manager.getChart(containerId);
        if (!chart.isFavoriteEnabled) {
            $(infChart.structureManager.getContainer($(container)[0], "favoriteMenuPanel")).show();
            chart.isFavoriteEnabled = true;
            _activeFavElement(container);
        }
    };

    var _activeFavElement = function(container) {
        $(infChart.structureManager.getContainer(container[0], "drawingToolbar")).find('a[inf-ctrl-role=favorite]').addClass('active');
    };

    var _setActiveSelectOption = function (container, crosshair) {
        var leftToolbar = infChart.structureManager.getContainer(container, 'drawingToolbar');
        var mainSelectItem = $(leftToolbar).find("a[inf-ctrl-role=disDrawing]");
        var options = mainSelectItem.parent().find("a[inf-ctrl=disDrawing]");
        var selectOption = $(options).filter('[inf-ctrl-subType="select"]');
        var crossHairOption = $(options).filter('[inf-ctrl-subType="all"]');
        var crossHairWithlastOption = $(options).filter('[inf-ctrl-subType="last"]');

        $(options).removeClass('active');
        if (crosshair.enabled) {
            if(crosshair.type == "all") {
                if($(crossHairOption).find('span[rel="icon-span"]')[0]){
                    $(mainSelectItem).html($(crossHairOption).find('span[rel="icon-span"]')[0].outerHTML);
                }
                $(crossHairOption).addClass('active');
            } else if(crosshair.type == "last"){
                if($(crossHairWithlastOption).find('span[rel="icon-span"]')[0]){
                    $(mainSelectItem).html($(crossHairWithlastOption).find('span[rel="icon-span"]')[0].outerHTML);
                }
                $(crossHairWithlastOption).addClass('active');
            }
        } else {
            if($(selectOption).find('span[rel="icon-span"]')[0]){
                $(mainSelectItem).html($(selectOption).find('span[rel="icon-span"]')[0].outerHTML);
            }
            $(selectOption).addClass('active');
        }
    };

    var _bindSelectOptions = function (container, uniqueId, parent) {
        var toolbarItems = parent.find("a[inf-ctrl=drawCat]");
        var mainSelectItem = $(toolbarItems).filter('[draw-cat="select"]');
        var options = parent.find("a[inf-ctrl=disDrawing]");
        var selectOption = $(options).filter('[inf-ctrl-subType="select"]');
        var crossHairOption = $(options).filter('[inf-ctrl-subType="all"]');
        var crossHairWithlastOption = $(options).filter('[inf-ctrl-subType="last"]');

        $(selectOption).unbind().click(function (event) {
            var iChart = infChart.manager.getChart(uniqueId);
            var hChart = iChart && iChart.chart;
            var crosshair = iChart.crosshair;

            $(mainSelectItem).html($(this).find('span[rel="icon-span"]')[0].outerHTML);

            if (crosshair.enabled) {
                iChart.toggleCrosshair('none', true);
            }
            if (_isMultipleDrawingsEnabled(uniqueId)) {
                _toggleMultipleDrawings(uniqueId);
            }
            _setActiveDrawingToolOptions(uniqueId, parent);

            for (let [key, option] of Object.entries(options)) {
                $(option).removeClass('active');
            }
            $(selectOption).addClass('active');
            $(mainSelectItem).addClass('active');

            _setIsActiveDrawing(false);
            _removeDrawingEvents(hChart);
            _deselectDeleteTool(hChart);
        });

        $(crossHairOption).unbind().click(function (event) {

            var iChart = infChart.manager.getChart(uniqueId);
            var hChart = iChart && iChart.chart;
            var crosshair = iChart.crosshair;

            if (_isMultipleDrawingsEnabled(uniqueId)) {
                _toggleMultipleDrawings(uniqueId);
            }
            _setActiveDrawingToolOptions(uniqueId, parent);

            for (let [key, option] of Object.entries(options)) {
                $(option).removeClass('active');
            }

            if (!crosshair.enabled || crosshair.type !== "all") {
                iChart.toggleCrosshair("all", true);
            }
            $(crossHairOption).addClass('active');
            $(mainSelectItem).addClass('active');
            $(mainSelectItem).html($(this).find('span[rel="icon-span"]')[0].outerHTML);

            _setIsActiveDrawing(false);
            _removeDrawingEvents(hChart);
            _deselectDeleteTool(hChart);
        });

        $(crossHairWithlastOption).unbind().click(function (event) {

            var iChart = infChart.manager.getChart(uniqueId);
            var hChart = iChart && iChart.chart;
            var crosshair = iChart.crosshair;

            if (_isMultipleDrawingsEnabled(uniqueId)) {
                _toggleMultipleDrawings(uniqueId);
            }
            _setActiveDrawingToolOptions(uniqueId, parent);

            for (let [key, option] of Object.entries(options)) {
                $(option).removeClass('active');
            }
            if (!crosshair.enabled ||crosshair.type !== "last") {
                iChart.toggleCrosshair("last", true);
            }
            $(crossHairWithlastOption).addClass('active');
            $(mainSelectItem).addClass('active');
            $(mainSelectItem).html($(this).find('span[rel="icon-span"]')[0].outerHTML);

            _setIsActiveDrawing(false);
            _removeDrawingEvents(hChart);
            _deselectDeleteTool(hChart);
        });
    };

    var _setSelectOptions = function (container, uniqueId, parent) {
        var iChartInstance = infChart.manager.getChart(uniqueId);
        var crosshair = iChartInstance.crosshair;
        _setActiveSelectOption(container, crosshair);
        _bindSelectOptions(container, uniqueId, parent);
    };

    var _setDeleteOptions = function(container, uniqueId, parent){
        var toolbarItems = parent.find("a[inf-ctrl=drawCat]");
        var mainSelectItem = $(toolbarItems).filter('[draw-cat="delete"]');
        var options = parent.find("a[inf-ctrl=delDrawing]");
        var deleteDrawingOption = $(options).filter('[inf-ctrl-subType="deleteDrawing"]');
        var deleteLevelsOption = $(options).filter('[inf-ctrl-subType="deleteLevels"]');
        var deleteAllOption = $(options).filter('[inf-ctrl-subType="deleteAllDrawing"]');

        $(deleteDrawingOption).unbind().click(function (event) {
            var iChart = infChart.manager.getChart(uniqueId);
            var hChart = iChart && iChart.chart;
            if(hChart.annotationChangeInProgress) {
                events.annotationEnd(hChart);
            }
            infChart.structureManager.settings.hideAllSettingsPopups(_isDisableDrawingSettingsPanel);
            if (_isMultipleDrawingsEnabled(uniqueId)) {
                _toggleMultipleDrawings(uniqueId);
            }
            _setActiveDrawingToolOptions(uniqueId, parent, undefined, true);
            if (hChart.selectedAnnotation) {
                hChart.selectedAnnotation.events.deselect.call(hChart.selectedAnnotation, event, true);
            }
            for (let [key, option] of Object.entries(options)) {
                $(option).removeClass('active');
            }
            $(deleteDrawingOption).addClass('active');
            $(mainSelectItem).addClass('active');
            $(mainSelectItem).html($(this).find('span[rel="icon-span"]')[0].outerHTML);
            $(mainSelectItem).attr('inf-ctrl-role','delDrawing');
            _setIsActiveDrawing(false);
            _setIsActiveEraseMode(_getChartIdFromHighchartInstance(hChart), false);
            _setIsActiveDeleteTool(_getChartIdFromHighchartInstance(hChart), true);
            _removeDrawingEvents(hChart);
            if (hChart.annotations) {
                annotations = hChart.annotations.allItems;
                for (var i = 0, length = annotations.length; i < length; i++) {
                    annotation = annotations[i];
                    drawingObj = _getDrawingObject(uniqueId, annotation.options.id);

                    if (annotation.options.drawingType === infChart.constants.drawingTypes.shape) {
                        var catConfig = drawingConfigs[uniqueId][$(this).attr('drawing-cat')];
                        var url = catConfig.options[0].cursorUrl ? catConfig.options[0].cursorUrl : '../img/del_cursor.png';
                        if (annotation.shape) {
                            annotation.shape.element.style.removeProperty("cursor");
                            annotation.shape.css({'cursor': 'url("' + url + '"), default'});
                        } else if (annotation.title) {
                            annotation.title.element.style.removeProperty("cursor");
                            annotation.title.attr({'cursor': 'url("' + url + '"), default'});
                        }

                        $.each(drawingObj.dragSupporters, function (id, value) {
                            value.element.style.setProperty('cursor', 'url("' + url + '"), default');
                        });
                        if(drawingObj.specificCursorChange){
                            drawingObj.specificCursorChange(url);
                        }
                    }
                }
            }
            if (hChart.selectedAnnotation) {
                var selectedAnnotation = hChart.selectedAnnotation;
                selectedAnnotation.events.deselect.call(selectedAnnotation, undefined, true);
            }
            iChart._fireEventListeners("onDrawingOptionSelect");
        });

        $(deleteLevelsOption).unbind().click(function (event) {
            var iChart = infChart.manager.getChart(uniqueId);
            var hChart = iChart && iChart.chart;
            if(hChart.annotationChangeInProgress) {
                events.annotationEnd(hChart);
            }
            infChart.structureManager.settings.hideAllSettingsPopups(_isDisableDrawingSettingsPanel);
            if (_isMultipleDrawingsEnabled(uniqueId)) {
                _toggleMultipleDrawings(uniqueId);
            }
            _setActiveDrawingToolOptions(uniqueId, parent, undefined, true );
            if (hChart.selectedAnnotation) {
                hChart.selectedAnnotation.events.deselect.call(hChart.selectedAnnotation, event, true);
            }
            for (let [key, option] of Object.entries(options)) {
                $(option).removeClass('active');
            }
            $(deleteLevelsOption).addClass('active');
            $(mainSelectItem).addClass('active');
            $(mainSelectItem).html($(this).find('span[rel="icon-span"]')[0].outerHTML);
            $(mainSelectItem).attr('inf-ctrl-role','delLevel');
            _setIsActiveDrawing(false);
            _setIsActiveDeleteTool(_getChartIdFromHighchartInstance(hChart), false);
            _setIsActiveEraseMode(_getChartIdFromHighchartInstance(hChart), true);
            _removeDrawingEvents(hChart);
            if (hChart.annotations) {
                annotations = hChart.annotations.allItems;
                for (var i = 0, length = annotations.length; i < length; i++) {
                    annotation = annotations[i];
                    drawingObj = _getDrawingObject(uniqueId, annotation.options.id);

                    if (annotation.options.drawingType === infChart.constants.drawingTypes.shape) {
                        var catConfig = drawingConfigs[uniqueId][$(this).attr('drawing-cat')];
                        var url = catConfig.options[1].cursorUrl ? catConfig.options[1].cursorUrl : '../img/del-levels.png';
                        if (annotation.shape) {
                            annotation.shape.element.style.removeProperty("cursor");
                            annotation.shape.css({'cursor': 'url("' + url + '"), default'});
                        } else if (annotation.title) {
                            annotation.title.element.style.removeProperty("cursor");
                            annotation.title.attr({'cursor': 'url("' + url + '"), default'});
                        }

                        $.each(drawingObj.dragSupporters, function (id, value) {
                            value.element.style.setProperty('cursor', 'url("' + url + '"), default');
                        });
                        if(drawingObj.specificCursorChange){
                            drawingObj.specificCursorChange(url);
                        }
                    }
                }
            }
            if (hChart.selectedAnnotation) {
                var selectedAnnotation = hChart.selectedAnnotation;
                selectedAnnotation.events.deselect.call(selectedAnnotation, undefined, true);
            }
        });

         $(deleteAllOption).unbind().click(function (event) {
            var iChart = infChart.manager.getChart(uniqueId);
            var hChart = iChart && iChart.chart;
            if(hChart.annotationChangeInProgress) {
                events.annotationEnd(hChart);
             }

            for (let [key, option] of Object.entries(options)) {
                $(option).removeClass('active');
            }

            $(deleteAllOption).addClass('active');
            //$(mainSelectItem).addClass('active');
            $(mainSelectItem).html($(this).find('span[rel="icon-span"]')[0].outerHTML);
            $(mainSelectItem).attr('inf-ctrl-role','deleteAllDrawing');
            _setIsActiveDeleteTool(_getChartIdFromHighchartInstance(hChart), false);
            _setIsActiveEraseMode(_getChartIdFromHighchartInstance(hChart), false);

             _removeAllDrawings(_getChartIdFromHighchartInstance(hChart.annotations.chart), true);
             iChart.isGloballyLocked = false;
             iChart._fireEventListeners("onDrawingOptionSelect");
             if (!_isMultipleDrawingsEnabled(uniqueId)){
                 _disableDrawing(uniqueId);
             }
             iChart._fireEventListeners("onDrawingOptionSelect");
         });
    };

    var _setSelectToolbarIconOnReset = function(uniqueId, container) {
        var containerElm = container ? container : $('#' + uniqueId);
        var toolbarParent = $(infChart.structureManager.getContainer(containerElm[0], "drawingToolbar"));
        var toolbarItems = toolbarParent.find("a[inf-ctrl=drawCat]");
        var mainSelectItem = $(toolbarItems).filter('[draw-cat="select"]');
        var options = toolbarParent.find("a[inf-ctrl=disDrawing]");
        var selectOption = $(options).filter('[inf-ctrl-subType="select"]');
        var crossHairOption = $(options).filter('[inf-ctrl-subType="all"]');
        var crossHairWithlastOption = $(options).filter('[inf-ctrl-subType="last"]');

        // setTimeout(function() {
            var iChartInstance = infChart.manager.getChart(uniqueId);
            var crosshair = iChartInstance.crosshair;
            if(crosshair.enabled){
                if (crosshair.type == "all") {
                    $(crossHairOption).click();
                }
                else if(crosshair.type == "last") {
                    $(crossHairWithlastOption).click();
                }
            }
            else {
                $(selectOption).click();
            }
        // }, 0);
    };

    /**
     * get drawing settings container
     * @param {object} container - chart container
     * @returns {object}
     */
    var _getDrawingSettingsContainer = function (container) {
        if (!_isDisableDrawingSettingsPanel) {
            return $(infChart.structureManager.getContainer(container[0], 'drawingToolPanelView'));
        } else {
            return $(infChart.structureManager.getContainer(container[0], 'drawing'));
        }
    };

    var _getQuickDrawingSettingContainer = function (container) {
        return $(infChart.structureManager.getContainer(container[0], 'quickDrawingSettingsPanel'));
    };

    /**
     * Delete tool for chart drawings
     * @param container
     * @param uniqueId
     * @param parent
     * @param config
     * @private
     */
    var _setDrawingCategory = function (container, uniqueId, parent, config, isGloballyLocked) {
        var drawingCategories = parent.find("a[inf-ctrl=drawCat]");
        var stockChart = infChart.manager.getChart(uniqueId);

        $.each(drawingCategories, function (index, cat) {
            if ($(this).attr("inf-ctrl-role") === 'favorite') {
                $(this).addClass('active has-text-highlight');
            }

            if($(this).attr("inf-ctrl-role") === 'globalLock'){
                if (isGloballyLocked){
                    _setActiveDrawingToolOptions(uniqueId, parent);
                     $(this).addClass('active');
                     $(this).attr({'adv-chart-tooltip' : infChart.manager.getLabel('label.globalUnlock')});
                     $($(this).children()[0]).attr({class: 'icom icom-lock'})
                }else {
                     $(this).removeClass('active');
                     $(this).attr({'adv-chart-tooltip' : infChart.manager.getLabel('label.globalLock')});
                     $($(this).children()[0]).attr({class: 'icom icom-unlock'})
                }
            }

            $(cat).unbind().click(function (event) {
                _drawingCategoryClick(container, uniqueId, parent, this, event);
                stockChart._fireEventListeners("onDrawingOptionSelect");
                event.preventDefault();
            });       

        });
    };

    var _setFavoritePanelDrawing = function (container, uniqueId) {
        var parentFaveriteToolbar = $(infChart.structureManager.getContainer(container[0], "favoriteMenuPanel"));
        var favoriteToolbarList = parentFaveriteToolbar.find("ul[rel=fav-panel-drawing-list]");
        var favIconList = favoriteToolbarList.find("li[rel=fav-toolbar-item]");
        favIconList.each(function () {
            $(this).off().on("contextmenu", function (event) {
                _favoriteDrawingRightClick(event, uniqueId, this);
            });
        })
    }

    var _favoriteDrawingRightClick = function(event, uniqueId, cat) {
        if (event.which === 3) {
            var chartId = infChart.manager.getChart(uniqueId).id;
            let chart = infChart.manager.getChart(chartId);
            let options = chart.settings.contextMenu.favoriteDrawing.options;
            var drawingCat = $(cat).children().attr("draw-cat");
            var drawingShape = $(cat).children().attr("inf-ctrl-shape");
            options.uniqueId = uniqueId;
            options.drawingCat = drawingCat;
            options.drawingShape = drawingShape;

            infChart.contextMenuManager.openContextMenu(chartId, {
                top: event.clientY,
                left: event.clientX
            }, infChart.constants.contextMenuTypes.favoriteDrawing, options, event);
        }
        event.preventDefault();
    }

    var _drawingCategoryClick = function (container, uniqueId, parent, cat, event) {
        var hChart;
        var annotations, annotation, drawingObj, shape, role, subType, iChart,
            drawingSettingsContainer = _getDrawingSettingsContainer(container), //parent.find("div[inf-container=drawing_settings]");
            quickDrawingSettingsContainer = _getQuickDrawingSettingContainer(container);

        iChart = infChart.manager.getChart(uniqueId);
        hChart = iChart && iChart.chart;
        if (hChart && iChart._hasData()) {
            role = $(cat).attr("inf-ctrl-role");
            switch (role) {
                case "drawing":
                    //if (infChart.drawingsManager.isMultipleDrawingsEnabled()) {
                    //    drawingCategories.not('a[inf-ctrl-role="multipleDrawing"]').removeClass('active');
                    //} else {
                    //    drawingCategories.removeClass('active');
                    //}
                    infChart.structureManager.settings.hideAllSettingsPopups(_isDisableDrawingSettingsPanel);

                    _setActiveDrawingToolOptions(uniqueId, parent);
                    if (hChart.selectedAnnotation) {
                        hChart.selectedAnnotation.events.deselect.call(hChart.selectedAnnotation, event, true);
                    }

                    $(cat).addClass('active');
                    shape = $(cat).attr("inf-ctrl-shape");
                    subType = $(cat).attr("inf-ctrl-subType");
                    _initializeDrawing(hChart, shape, drawingSettingsContainer, quickDrawingSettingsContainer, subType, true);
                    if (_isMultipleDrawingsEnabled(uniqueId)) {
                        _setIsActiveDrawing(false);
                    }
                    break;
                case "disDrawing":
                    if (_isMultipleDrawingsEnabled(uniqueId)) {
                        _toggleMultipleDrawings(uniqueId);
                    }

                    if (!iChart.isGloballyLocked){
                        _setActiveDrawingToolOptions(uniqueId, parent);
                    }
                    $(cat).addClass('active');
                    _setIsActiveDrawing(false);
                    _removeDrawingEvents(hChart);
                    _deselectDeleteTool(hChart);
                    break;
                case "delDrawing" :
                    if(hChart.annotationChangeInProgress) {
                        events.annotationEnd(hChart);
                    }
                    infChart.structureManager.settings.hideAllSettingsPopups(_isDisableDrawingSettingsPanel);
                    if (_isMultipleDrawingsEnabled(uniqueId)) {
                        _toggleMultipleDrawings(uniqueId);
                    }
                    _setActiveDrawingToolOptions(uniqueId, parent, true);
                    if (hChart.selectedAnnotation) {
                        hChart.selectedAnnotation.events.deselect.call(hChart.selectedAnnotation, event, true);
                    }
                    $(cat).addClass('active');
                    _setIsActiveDrawing(false);
                    _setIsActiveEraseMode(_getChartIdFromHighchartInstance(hChart), false);
                    _setIsActiveDeleteTool(_getChartIdFromHighchartInstance(hChart), true);
                    _removeDrawingEvents(hChart);
                    if (hChart.annotations) {
                        annotations = hChart.annotations.allItems;
                        for (var i = 0, length = annotations.length; i < length; i++) {
                            annotation = annotations[i];
                            drawingObj = _getDrawingObject(uniqueId, annotation.options.id);

                            if (annotation.options.drawingType === infChart.constants.drawingTypes.shape) {
                                var catConfig = drawingConfigs[uniqueId][$(cat).attr('draw-cat')];
                                var url = catConfig.options[0].cursorUrl ? catConfig.options[0].cursorUrl : '../img/del_cursor.png';
                                if (annotation.shape) {
                                    annotation.shape.element.style.removeProperty("cursor");
                                    annotation.shape.css({'cursor': 'url("' + url + '"), default'});
                                } else if (annotation.title) {
                                    annotation.title.element.style.removeProperty("cursor");
                                    annotation.title.attr({'cursor': 'url("' + url + '"), default'});
                                }

                                $.each(drawingObj.dragSupporters, function (id, value) {
                                    value.element.style.setProperty('cursor', 'url("' + url + '"), default');
                                });
                                if(drawingObj.specificCursorChange){
                                    drawingObj.specificCursorChange(url);
                                }
                            }
                        }
                    }
                    if (hChart.selectedAnnotation) {
                        var selectedAnnotation = hChart.selectedAnnotation;
                        selectedAnnotation.events.deselect.call(selectedAnnotation, undefined, true);
                    }
                    break;
                case "delLevel" :
                    toolbarParent = $(infChart.structureManager.getContainer($(document).find("div[id='" + uniqueId + "']")[0], "drawingToolbar"));
                    var toolbarItems = toolbarParent.find("a[inf-ctrl=drawCat]");
                    var mainSelectItem = $(toolbarItems).filter('[draw-cat="delete"]');
                    if(hChart.annotationChangeInProgress) {
                        events.annotationEnd(hChart);
                    }
                    infChart.structureManager.settings.hideAllSettingsPopups(_isDisableDrawingSettingsPanel);
                    if (_isMultipleDrawingsEnabled(uniqueId)) {
                        _toggleMultipleDrawings(uniqueId);
                    }
                    _setActiveDrawingToolOptions(uniqueId, toolbarParent, true);
                    if (hChart.selectedAnnotation) {
                        hChart.selectedAnnotation.events.deselect.call(hChart.selectedAnnotation, event, true);
                    }
                    var deleteToolBarElement = $(toolbarParent.find('a[inf-ctrl="drawCat"][draw-cat="delete"]'));
                    deleteToolBarElement.addClass('active');
                    var options = toolbarParent.find("a[inf-ctrl=delDrawing]");
                    var deleteLevelsOption = $(options).filter('[inf-ctrl-subType="deleteLevels"]');
                    for (let [key, option] of Object.entries(options)) {
                        $(option).removeClass('active');
                    }
                    $(deleteLevelsOption).addClass('active');
                    $(mainSelectItem).addClass('active');
                    $(mainSelectItem).html($(deleteLevelsOption).find('span[rel="icon-span"]')[0].outerHTML);
                    $(mainSelectItem).attr('inf-ctrl-role','delLevel');
                    _setIsActiveDrawing(false);
                    _setIsActiveEraseMode(_getChartIdFromHighchartInstance(hChart), true);
                    _setIsActiveDeleteTool(_getChartIdFromHighchartInstance(hChart), false);
                    _removeDrawingEvents(hChart);
                    if (hChart.annotations) {
                        annotations = hChart.annotations.allItems;
                        for (var i = 0, length = annotations.length; i < length; i++) {
                            annotation = annotations[i];
                            drawingObj = _getDrawingObject(uniqueId, annotation.options.id);

                            if (annotation.options.drawingType === infChart.constants.drawingTypes.shape) {
                                var catConfig = drawingConfigs[uniqueId][deleteToolBarElement.attr('draw-cat')];
                                var url = catConfig.options[1].cursorUrl ? catConfig.options[1].cursorUrl : '../img/del-levels.png';
                                if (annotation.shape) {
                                    annotation.shape.element.style.removeProperty("cursor");
                                    annotation.shape.css({ 'cursor': 'url("' + url + '"), default' });
                                } else if (annotation.title) {
                                    annotation.title.element.style.removeProperty("cursor");
                                    annotation.title.attr({ 'cursor': 'url("' + url + '"), default' });
                                }

                                $.each(drawingObj.dragSupporters, function (id, value) {
                                    value.element.style.setProperty('cursor', 'url("' + url + '"), default');
                                });
                                if(drawingObj.specificCursorChange){
                                    drawingObj.specificCursorChange(url);
                                }
                            }
                        }
                    }
                    if (hChart.selectedAnnotation) {
                        var selectedAnnotation = hChart.selectedAnnotation;
                        selectedAnnotation.events.deselect.call(selectedAnnotation, undefined, true);
                    }
                    break;
                case "deleteAllDrawing" :
                    if(hChart.annotationChangeInProgress) {
                        events.annotationEnd(hChart);
                    }
                    _removeAllDrawings(_getChartIdFromHighchartInstance(hChart.annotations.chart), true);
                    iChart.isGloballyLocked = false;
                    break;
                case "globalLock":
                    infChart.structureManager.settings.hideAllSettingsPopups(_isDisableDrawingSettingsPanel);
                    _setActiveDrawingToolOptions(uniqueId, parent);
                    if (hChart.selectedAnnotation) {
                        hChart.selectedAnnotation.events.deselect.call(hChart.selectedAnnotation, event, true);
                    }

                    if (iChart) {
                        iChart.isGloballyLocked = !iChart.isGloballyLocked;

                        infChart.drawingUtils.common.globalLockToggle(cat, iChart.isGloballyLocked)
                    };
                    iChart._onPropertyChange("isGloballyLocked", iChart.isGloballyLocked);
                    break;
                case "multipleDrawing":
                    infChart.structureManager.settings.hideAllSettingsPopups(_isDisableDrawingSettingsPanel);
                    var activeEle = $(this).parents("ul").find("a.active[inf-ctrl='drawCat']").not('a[inf-ctrl-role="multipleDrawing"]');
                    role = activeEle.attr("inf-ctrl-role");
                    var enabled = _isMultipleDrawingsEnabled(uniqueId);
                    if (enabled) {
                        _toggleMultipleDrawings(uniqueId);
                        $(cat).removeClass('active');
                        // _disableDrawing(uniqueId);
                    } else {
                        if (role === 'drawing') {
                            _toggleMultipleDrawings(uniqueId);
                            $(cat).addClass('active');

                            shape = activeEle.attr("inf-ctrl-shape");
                            subType = activeEle.attr("inf-ctrl-subType");
                            _initializeDrawing(hChart, shape, drawingSettingsContainer, quickDrawingSettingsContainer, subType, true);
                        } else {
                            _setIsActiveDrawing(false);
                            isActiveEraseMode[uniqueId] = false;
                            isActiveDeleteTool[uniqueId] = false;
                            _deselectDeleteTool(hChart);
                            _setActiveDrawingToolOptions(uniqueId, parent);
                            _toggleMultipleDrawings(uniqueId);
                            $(cat).addClass('active');
                        }
                    }
                    if (hChart.selectedAnnotation) {
                        hChart.selectedAnnotation.events.deselect.call(hChart.selectedAnnotation, event, true);
                    }
                    break;
                case "favorite" : {
                    var favoriteMenu = $(infChart.structureManager.getContainer($(container)[0], "favoriteMenuPanel"));
                    _toggleFavorite(favoriteMenu, uniqueId);
                }
               break;
            }
        }
    }

    var _setDeleteMode = function (chartId) {
        var iChart = infChart.manager.getChart(chartId);
        var hChart = iChart && iChart.chart;
        var toolbarParent = $(infChart.structureManager.getContainer($(document).find("div[id='" + chartId + "']")[0], "drawingToolbar"));
        var toolbarItems = toolbarParent.find("a[inf-ctrl=drawCat]");
        var mainSelectItem = $(toolbarItems).filter('[draw-cat="delete"]');
        infChart.structureManager.settings.hideAllSettingsPopups(_isDisableDrawingSettingsPanel);
        if (_isMultipleDrawingsEnabled(chartId)) {
            _toggleMultipleDrawings(chartId);
        }
        _setActiveDrawingToolOptions(chartId, toolbarParent, true );
        if (hChart.selectedAnnotation) {
            hChart.selectedAnnotation.events.deselect.call(hChart.selectedAnnotation, event, true);
        }
        var deleteToolBarElement = $(toolbarParent.find('a[inf-ctrl="drawCat"][draw-cat="delete"]'));
        deleteToolBarElement.addClass('active');
        var options = toolbarParent.find("a[inf-ctrl=delDrawing]");
        var deleteLevelsOption = $(options).filter('[inf-ctrl-subType="deleteLevels"]');
        for (let [key, option] of Object.entries(options)) {
            $(option).removeClass('active');
        }
        $(deleteLevelsOption).addClass('active');
        $(mainSelectItem).addClass('active');
        $(mainSelectItem).html($(deleteLevelsOption).find('span[rel="icon-span"]')[0].outerHTML);
        $(mainSelectItem).attr('inf-ctrl-role','delLevel');
        _setIsActiveDrawing(false);
        _removeDrawingEvents(hChart);
        _setIsActiveDeleteTool(_getChartIdFromHighchartInstance(hChart), false);
        _setIsActiveEraseMode(_getChartIdFromHighchartInstance(hChart), true);
        if (hChart.annotations) {
            annotations = hChart.annotations.allItems;
            for (var i = 0, length = annotations.length; i < length; i++) {
                annotation = annotations[i];
                drawingObj = _getDrawingObject(chartId, annotation.options.id);

                if (annotation.options.drawingType === infChart.constants.drawingTypes.shape) {
                    var catConfig = drawingConfigs[chartId][deleteToolBarElement.attr('draw-cat')];
                    var url = catConfig.options[1] && catConfig.options[1].cursorUrl ? catConfig.options[1].cursorUrl : '../img/del-levels.png';
                    if (annotation.shape) {
                        annotation.shape.element.style.removeProperty("cursor");
                        annotation.shape.css({ 'cursor': 'url("' + url + '"), default' });
                    } else if (annotation.title) {
                        annotation.title.element.style.removeProperty("cursor");
                        annotation.title.attr({ 'cursor': 'url("' + url + '"), default' });
                    }

                    $.each(drawingObj.dragSupporters, function (id, value) {
                        value.element.style.setProperty('cursor', 'url("' + url + '"), default');
                    });
                    if(drawingObj.specificCursorChange){
                        drawingObj.specificCursorChange(url);
                    }
                }
            }
        }
        if (hChart.selectedAnnotation) {
            var selectedAnnotation = hChart.selectedAnnotation;
            selectedAnnotation.events.deselect.call(selectedAnnotation, undefined, true);
        }
    };

    var _offDeleteMode = function(chartId){
        var iChart = infChart.manager.getChart(chartId);
        var hChart = iChart && iChart.chart;
        var toolbarParent = $(infChart.structureManager.getContainer($(document).find("div[id='" + chartId + "']")[0], "drawingToolbar"));
        if (_isMultipleDrawingsEnabled(chartId)) {
            _toggleMultipleDrawings(chartId);
        }
        isActiveEraseMode[chartId] = false;
        _setActiveDrawingToolOptions(chartId, toolbarParent, true);
        toolbarParent.find("a[draw-cat='select']").addClass('active');
        _setIsActiveDrawing(false);
        _removeDrawingEvents(hChart);
        _deselectDeleteTool(hChart);
    };

    var _setDeleteCursor = function (drawingConfigs) {
        if (drawingConfigs["delete"] && drawingConfigs["delete"].options[0] && !drawingConfigs["delete"].options[0].cursorUrl) {
            drawingConfigs["delete"].options[0].cursorUrl = '../img/del_cursor.png'
        }
    };

    var _setEraseModeCursor = function (drawingConfigs) {
        if (drawingConfigs["delete"] && drawingConfigs["delete"].options[1] && !drawingConfigs["delete"].options[1].cursorUrl) {
            drawingConfigs["delete"].options[1].cursorUrl = '../img/del-levels.png'
        }
    };

    /**
     * set drawing toolbar - add click event
     * @param {object} parent - parent element
     * @param {string} uniqueId - chart id
     * @param {object} config - drawing toolbar toggle button config
     * @param {boolean} showDrawingTbButtons - show/hide drawing toolbar buttons
     */
    var _setDrawingToolBarToggle = function (parent, uniqueId, config, showDrawingTbButtons) {
        _setDrawingToolbarProperties(uniqueId, showDrawingTbButtons);
        if (!showDrawingTbButtons) {
            $(parent).addClass('hide-toolbar');
            $(parent).find("button[inf-ctrl='tb-drawing-toggle']").find("i").removeClass().addClass(config.hideCls);
        }
        parent.find("button[inf-ctrl='tb-drawing-toggle']").bind("click", function (event) {
            var isShowDrawingToolbar = _toggleDrawingToolbar(parent, uniqueId, true);
            $(this).find('i').removeClass().addClass(isShowDrawingToolbar ? config.showCls : config.hideCls);
            event.preventDefault();
        });
    };

    /**
     * set scroll to drawing toolbar and bind click event
     * @param {object} container - container element
     */
    var _setDrawingToolbarScrollButtons = function (container) {
        var drawingTBNav = container.find('ul[inf-pnl="tb-drawing-nav"]');
        var scrollTopBtn = container.find('[inf-ctrl="tb-drawing-scroll-top"]');
        var scrollBottomBtn = container.find('[inf-ctrl="tb-drawing-scroll-bottom"]');

        $(scrollTopBtn).bind('click', function (event) {
            $(drawingTBNav).animate({scrollTop: 0}, 'slow');
            $(scrollBottomBtn).show();
            $(this).hide();
            event.preventDefault();
        });

        $(scrollBottomBtn).bind('click', function (event) {
            $(drawingTBNav).animate({scrollTop: $(drawingTBNav)[0].scrollHeight}, 'slow');
            $(scrollTopBtn).show();
            $(this).hide();
            event.preventDefault();
        });
    };

    /**
     * scroll left toolbar event
     * @param {object} navContainer - left toolbar button container
     * @param {object} scrollTopBtn  - scroll top button
     * @param {object} scrollBottomBtn - scroll bottom button
     */
    var _scrollDrawingToolbar = function (navContainer, scrollTopBtn, scrollBottomBtn) {
        var scrollPos = navContainer.scrollTop;

        if (scrollPos === 0) {
            $(scrollTopBtn).hide();
            $(scrollBottomBtn).show();
        } else if (navContainer.scrollHeight - scrollPos === navContainer.clientHeight) {
            $(scrollTopBtn).show();
            $(scrollBottomBtn).hide();
        } else {
            $(scrollTopBtn).show();
            $(scrollBottomBtn).show();
        }
    };

    /**
     * show and hide left toolbar
     * @param {object} container - container that need to update
     * @param {string} uniqueId - chart id
     * @param {boolean} isPropertyChange - is property change
     * @returns {boolean} show/hide left toolbar
     */
    var _toggleDrawingToolbar = function (container, uniqueId, isPropertyChange) {
        var chart = infChart.manager.getChart(uniqueId);
        var showDrawingToolbarButtons = !_getDrawingToolbarProperties(uniqueId);
        _setDrawingToolbarProperties(uniqueId, showDrawingToolbarButtons);
        $(container).toggleClass('hide-toolbar', !showDrawingToolbarButtons);
        if (isPropertyChange) {
            chart._onPropertyChange('showDrawingToolbarButtons', showDrawingToolbarButtons);
            chart.resizeChart();
        }
        return showDrawingToolbarButtons;
    };

    /**
     * rearrange drawing toolbar
     * @param {object} container - left toolbar
     */
    var _rearrangeDrawingToolbar = function (container) {
        var chartHeight = $(container).height();
        var drawingTbNav = container.querySelector('[inf-pnl="tb-drawing-nav"]');
        var scrollTopBtn = container.querySelector('[inf-ctrl="tb-drawing-scroll-top"]');
        var scrollBottomBtn = container.querySelector('[inf-ctrl="tb-drawing-scroll-bottom"]');
        $(drawingTbNav).unbind('scroll');

        if(drawingTbNav){
            if (drawingTbNav.scrollHeight <= chartHeight) {
                $(drawingTbNav).css('height', '');
                $(scrollTopBtn).hide();
                $(scrollBottomBtn).hide();
            } else {
                $(drawingTbNav).height(chartHeight);
                _scrollDrawingToolbar(drawingTbNav, scrollTopBtn, scrollBottomBtn);
                $(drawingTbNav).bind('scroll', function (event) {
                    _scrollDrawingToolbar(event.target, scrollTopBtn, scrollBottomBtn);
                });
            }
        }
    };

    var _afterRedrawXAxisWithoutSetExtremes = function (chartId) {
        var drawings = chartDrawingObjects[chartId];
        if (drawings) {
            $.each(drawings, function (key, drawing) {
                if (drawing.annotation.chart && drawing.afterRedrawXAxisWithoutSetExtremes) {
                    drawing.afterRedrawXAxisWithoutSetExtremes();
                }
            });
        }
    };

    /**
     * open drawing settings window/popup
     * @param {object} drawingObj - drawing object
     * @param {boolean} isHide - true if hide
     * @param {object} popupPosition - position object
     */
    var _openSettings = function (drawingObj, isHide, popupPosition) {
        drawingObj.openDrawingSettings.call(drawingObj, isHide, {
            "isDisableDrawingSettingsPanel": _isDisableDrawingSettingsPanel,
            "popupPosition": popupPosition
        });
    };


    var _toggleSettings = function (drawingObj, isHide, popupPosition) {
        if (drawingObj.settingsPopup) {
            drawingObj.settingsPopup.remove();
            drawingObj.settingsPopup = null;
        }
        if (!drawingObj.isQuickSetting) {
            if (!drawingObj.disableQuickSettingPanel) {
                drawingObj.loadQuickSettingPopup.call(drawingObj);
            }
        } else {
            drawingObj.openDrawingSettings.call(drawingObj, isHide, {
                "isDisableDrawingSettingsPanel": _isDisableDrawingSettingsPanel,
                "popupPosition": popupPosition
            });
        }
    };

    /**
     * load drawing object setting window/popup
     * @param {object} drawingObj - draiwng object
     */
    var _loadSettings = function (drawingObj) {
        drawingObj.loadSettingWindow(true, {"isDisableDrawingSettingsPanel": _isDisableDrawingSettingsPanel});
    };

    var _loadQuickSettings = function (drawingObj) {
        if (!drawingObj.disableQuickSettingPanel) {
            drawingObj.loadQuickSettingPopup(drawingObj.annotation.options.isLocked);
        }
    };

    //region public

    var _changeGlobalLockStatus = function (chart) {
        var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart);
        var chartInstance = infChart.manager.getChart(stockChartId);
        if (chartInstance.isGloballyLocked) {
            chartInstance.isGloballyLocked = !chartInstance.isGloballyLocked

            if (chartInstance.container){
                var leftPanel = $(chartInstance.container).find('div[inf-pnl=tb-drawing-nav-container]');
                if (leftPanel){
                    var globalLockTool =leftPanel.find('a[inf-ctrl-role=globalLock]')
                    if (globalLockTool){
                        globalLockTool.removeClass('active')
                    }
                }
            }
        }
    };

    var _initializeDrawing = function (chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer, subType, isPropertyChange) {
        drawingSettingsContainer  = undefined;
        quickDrawingSettingsContainer = undefined;
        isActiveDrawing = true;
        isActiveDrawingInprogress = true;
        _deselectDeleteTool(chartObj);

        var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chartObj);
        var chartInstance = infChart.manager.getChart(stockChartId);
        if (chartInstance.isGloballyLocked){
            chartInstance.isGloballyLocked = !chartInstance.isGloballyLocked
        }

        events.bindEvents(chartObj, shapeId, drawingSettingsContainer, quickDrawingSettingsContainer, subType, isPropertyChange);
    };

    var _getActiveDrawing = function () {
        return activeDrawing;
    };

    var _setActiveDrawing = function (drawing) {
        activeDrawing = drawing;
    };

    var _removeActiveDrawing = function (isPropertyChange) {
        if (activeDrawing) {
            var drawingId = activeDrawing.options.id,
                stockChartId = _getChartIdFromHighchartInstance(activeDrawing.chart);
            _removeDrawing(stockChartId, drawingId, undefined, isPropertyChange);
        }
    };

    /**
     * set active drawing settings / show or activate the tab
     * @param {object} drawingObject - drawing object
     * @param {object} popupPosition - popup position
     */
    var _setActiveDrawingSettings = function (drawingObject, popupPosition) {
        activeDrawingSettings = drawingObject.settingsPopup;
        if (!_isDisableDrawingSettingsPanel) {
            drawingObject.stockChart.showRightPanelWithTab((drawingObject.stockChartId + "_" + "drawingToolPanelView"));
            if (!drawingObject.settingsPopup.find('div.panel-collapse').is(":visible")) {
                drawingObject.settingsPopup.find('div.panel-heading a').trigger('click');
            }
        } else {
            infChart.structureManager.settings.hideAllSettingsPopups(_isDisableDrawingSettingsPanel);
            infChart.structureManager.settings.setPopupPositionAndHeight(drawingObject.container, drawingObject.settingsPopup, popupPosition);
            $(drawingObject.settingsPopup).show();
        }

    };

    var _setActiveDrawingToolOptions = function (uniqueId, parent, isSetDeleteModeOn, isDeleteMode) {
        var chartInstance = infChart.manager.getChart(uniqueId);
        parent.find("a[inf-ctrl=drawCat]").removeClass('active');
        let element = parent.find('a[inf-ctrl-role="globalLock"]')
        infChart.drawingUtils.common.globalLockToggle(element, false);

        if (_isMultipleDrawingsEnabled(uniqueId)) {
            parent.find('a[inf-ctrl-role="multipleDrawing"]').addClass('active');
        }

        if (chartInstance.isGloballyLocked && (isDeleteMode || isSetDeleteModeOn) ) {
            let element = parent.find('a[inf-ctrl-role="globalLock"]')
            infChart.drawingUtils.common.globalLockToggle(element, true);
        }

        if (_isFavoriteEnabled(uniqueId)) {
            parent.find('a[inf-ctrl-role="favorite"]').addClass('active');
        }
        _deselectFavDrawingTool(uniqueId);
    };

    var _deselectFavDrawingTool = function (uniqueId) {
        var containerElem = $('#' + uniqueId);
        var parentElement = $(infChart.structureManager.getContainer(containerElem[0], "favoriteMenuPanel"));
        parentElement.find("a[inf-ctrl=drawCat]").removeClass('active');
    };

    var _removeAllDrawings = function (chartId, isPropertyChange) {
        var drawings = chartDrawingObjects[chartId];
        var chartRedrawRequired = false;
        var stockChart = infChart.manager.getChart(chartId);
        if (drawings) {
            $.each(drawings, function (drawingId) {
                var redrawStatus = _removeDrawingInner(chartId, drawingId, isPropertyChange);
                if (!chartRedrawRequired) {
                    chartRedrawRequired = redrawStatus;
                }
            });
            if (chartRedrawRequired) {
                stockChart.redrawChart();
            }
        }
        if(!infChart.drawingsManager.isDrawnDrawingsAvailable(chartId) && _getIsActiveEraseMode(chartId)){
            _setIsActiveEraseMode(chartId, false);
            _setSelectToolbarIconOnReset(chartId);
        }
    };

    var _positionElliotWaveDrawingLabels = function (chartId, updateValues) {
        var drawings = chartDrawingObjects[chartId];
        var pointValues = [];
        if (drawings) {
            $.each(drawings, function (drawingId, drawing) {
                if (drawing.shape == 'elliotTriangleWave' || drawing.shape == 'elliotImpulseWave' || drawing.shape == 'elliotCorrectiveWave' || drawing.shape == 'correctiveTripleWave' || drawing.shape == 'elliotCorrectiveDoubleWave') {
                    var elliotDrawing = drawing;
                    var lineShapes = drawing.getPatternShapes(updateValues);
                    infChart.util.forEach(lineShapes.positions.pointLabels, function (positionId, position) {
                        var count = 0;
                        infChart.util.forEach(pointValues, function (index, point) {
                            if (point.xValue == position.xValue && point.yValue == position.yValue && point.topOfThePoint == position.topOfThePoint) {
                                count = count + 1;
                            }
                        })
                        if (elliotDrawing.additionalDrawings.labels[positionId + "Label"]) {
                            elliotDrawing.additionalDrawings.labels[positionId + "Label"].attr({
                                y: (position.topOfThePoint) ? position.y - 14 * count : position.y + 14 * count
                            });
                        }
                        if (elliotDrawing.additionalDrawings.labels[positionId + "Label"] && elliotDrawing.additionalDrawings.labels[positionId + "Label"].visibility != "hidden") {
                            pointValues.push({
                                xValue: position.xValue,
                                yValue: position.yValue,
                                topOfThePoint: position.topOfThePoint
                            });
                        }
                    })
                }
            });
        }
    };

    var _removeDrawing = function (chartId, drawingId, setExtremes, isPropertyChange) {
        var drawings = chartDrawingObjects[chartId];
        var stockChart = infChart.manager.getChart(chartId);
        if (drawings && drawings[drawingId]) {
            var drawingObj = drawings[drawingId], ann = drawingObj.annotation, chart = ann.chart,
                annOptions = ann.options,
                isTabSwitchRequired = annOptions.drawingType === infChart.constants.drawingTypes.shape,
                isSetExtremesRequired = _validateExtremes(annOptions);
            if (chart.activeAnnotation === ann) {
                chart.activeAnnotation = null;
                chart.annotationChangeInProgress = false;
                chart.annotations.allowZoom = true;
                _setActiveAnnotationInprogress(null);
                stockChart.onAnnotationRelease();
            }
            if (chart.selectedAnnotation === ann) {
                drawingObj.annotation.events.deselect.call(drawingObj.annotation);
            }

            var drawingProperties = _getDrawingProperties(ann);
            _deleteDrawingObject(chartId, drawingId);
            if (isPropertyChange) {
                drawingObj.onPropertyChange("drawings");
            }
            var chartRedrawRequired = drawingObj.destroy(isPropertyChange, drawingProperties);

            if (isSetExtremesRequired && (typeof setExtremes === 'undefined' || setExtremes === true)) {
                // _setExtremes(chartId);
                _setExtremesOnRemove(chartId, drawingId);
            } else {
                var yAxis = stockChart && stockChart.getMainYAxis();
                if (yAxis.infMaxAnnotation === drawingId) {
                    yAxis.infMaxAnnotation = null;
                }
                if (yAxis.infMinAnnotation === drawingId) {
                    yAxis.infMinAnnotation = null;
                }
                // redraw chart if plot area is adjusted according to the deleted drawing
                if (chartRedrawRequired) {
                    stockChart.redrawChart();
                }

            }
            if (isTabSwitchRequired) {
                _switchSettingsTab(chartId);
            }
        }
        if(!infChart.drawingsManager.isDrawnDrawingsAvailable(chartId)){
            _setIsActiveEraseMode(chartId, false);
            _setSelectToolbarIconOnReset(chartId);
        }
    };

    var _updateIsGloballyLockInDelete = function(chartId){
        var drawings = chartDrawingObjects[chartId];
        var stockChart = infChart.manager.getChart(chartId);
        if (drawings && Object.keys(drawings).length === 0) {
            stockChart.isGloballyLocked = false;
        }
        stockChart._onPropertyChange("isGloballyLocked", stockChart.isGloballyLocked);
    };

    var _closeActiveDrawingSettings = function () {
        if (activeDrawingSettings) {
            //activeDrawingSettings.hide();
            //activeDrawingSettings.removeClass('active');

            //if(activeDrawingSettings.find('div[drawing-collapsible-panel]').is(":visible")) {
            //    activeDrawingSettings.find('div.panel-heading a').trigger('click');
            //}
        }
    };

    var _removeDrawingEvents = function (chartObj) {
        events.unbindEvents(chartObj);
    };

    var _deselectDeleteTool = function (chart) {
        var annotations, annotation, drawingObj, stockChartId;
        var chartId = _getChartIdFromHighchartInstance(chart)
        isActiveDeleteTool[chartId] = false;
        isActiveEraseMode[chartId] = false;


        if (chart.annotations) {
            annotations = chart.annotations.allItems;

            for (var i = 0, length = annotations.length; i < length; i++) {
                annotation = annotations[i];
                stockChartId = _getChartIdFromHighchartInstance(annotation.chart);
                drawingObj = _getDrawingObject(stockChartId, annotation.options.id);

                if (annotation.options.drawingType === infChart.constants.drawingTypes.shape) {
                    if (annotation.shape) {
                        annotation.shape.element.style.removeProperty("cursor");
                        infChart.util.setCursor(annotation.shape, 'move');
                        //annotation.shape.css({'cursor': 'move'});
                    } else if (annotation.title) {
                        annotation.title.element.style.removeProperty("cursor");
                        annotation.title.attr({'cursor': 'move'});
                        // infChart.util.setCursor(annotation.title.css, 'move');
                        //annotation.title.css({'cursor': 'move'});
                    }

                    $.each(drawingObj.dragSupporters, function (id, value) {
                        value.element.style.removeProperty("cursor");
                        infChart.util.setCursor(value, 'move');
                        //value.css({'cursor': 'move'});
                    });
                    if(drawingObj.specificCursorChange){
                        drawingObj.specificCursorChange();
                    }
                }
            }
        }
    };

    var _getDrawingObject = function (chartId, drawingId) {
        return chartDrawingObjects[chartId] && chartDrawingObjects[chartId][drawingId];
    };

    var _getAllDrawings = function (chartId) {
        return chartDrawingObjects[chartId];
    };

    var _getIsActiveDrawing = function () {
        return isActiveDrawing;
    };

    var _getIsActiveDrawingInprogress = function () {
        return isActiveDrawingInprogress;
    };

    var _setIsActiveDrawing = function (isActiveDraw) {
        isActiveDrawing = isActiveDraw;
    };

    var _getIsActiveDeleteTool = function (chartId) {
        return isActiveDeleteTool[chartId];
    };

    var _setIsActiveDeleteTool = function (chartId, isActDelTool) {
        isActiveDeleteTool[chartId] = isActDelTool;
    };

    var _getIsActiveEraseMode = function (chartId) {
        return isActiveEraseMode[chartId];
    };

    var _setIsActiveEraseMode = function (chartId, isActEraseTool) {
        isActiveEraseMode[chartId] = isActEraseTool;
    };

    var _isMultipleDrawingsEnabled = function (chartId) {
        return _multipleDrawingsEnabledProperties[chartId];
    };

    var _toggleMultipleDrawings = function (chartId) {
        _multipleDrawingsEnabledProperties[chartId] = !_multipleDrawingsEnabledProperties[chartId];
        if (_multipleDrawingsEnabledProperties[chartId]) {
            _addChartAreaKeyDownListener(chartId, ESC_KEY, function (key) {
                _multipleDrawingsEnabledProperties[chartId] = false;
                _removeChartAreaKeyDownListener(chartId, ESC_KEY);
                _disableDrawing(chartId);
            });
        } else {
            _removeChartAreaKeyDownListener(chartId, ESC_KEY);
        }
        return _multipleDrawingsEnabledProperties[chartId];
    };

    /**
     *
     * @param {*} chartId Unique ID for chart instance
     * @param {*} key key to add listener "*" will add listener to all keys
     * @param {*} listenerFunction callbank function
     */
    var _addChartAreaKeyDownListener = function (chartId, key, listenerFunction) {
        if (typeof listenerFunction !== 'function') {
            console.error("listenerFunction Should be a function");
        }
        var onKeyDown = function (event) {
            var chart = infChart.manager.getChart(chartId);
            if (!chart.chart.infMouseIn) {
                return;
            }
            var keyCode = event.which || event.keyCode;
            if (key === "*") {
                listenerFunction(keyCode);
            } else if (key === keyCode) {
                listenerFunction(keyCode);
            } else {
                console.info("Listener is not listening to Provided (" + key + ") user press on" + keyCode);
            }
        }
        $(document).on('keydown', onKeyDown);
        _chartAreaKeyDownFunctions[chartId + "_" + key] = onKeyDown;
    }


    /**
     * @param {*} chartId Unique ID for chart instance
     * @param {*} key key to add listener "*" will add listener to all keys
     */
    var _removeChartAreaKeyDownListener = function (chartId, key) {
        $(document).off('keydown', _chartAreaKeyDownFunctions[chartId + "_" + key]);
        delete _chartAreaKeyDownFunctions[chartId + "_" + key];
    }

    var _toggleFavorite = function (favoriteMenu, containerId) {
        var favElement = $(event.target);
        if (favElement.is("span")) {
            favElement = $(event.target).parent("a");
        }
        var chart = infChart.manager.getChart(containerId);
        if (chart.isFavoriteEnabled) {
            favoriteMenu.hide();
            favElement.removeClass('active');
        } else {
            favoriteMenu.show();
            favElement.addClass('active');
        }
        chart.isFavoriteEnabled = !chart.isFavoriteEnabled;
    };

    var _isFavoriteEnabled = function (containerId) {
        var chart = infChart.manager.getChart(containerId);
        return chart.isFavoriteEnabled;
    };

    var _getDrawingProperties = function (annotation) {
        var stockChartId = _getChartIdFromHighchartInstance(annotation.chart);
        var drawingObj = _getDrawingObject(stockChartId, annotation.options.id);
        var properties = drawingObj.getConfig() || {};
        properties.yValue = infChart.drawingUtils.common.getBaseYValues.call(drawingObj, properties.yValue);
        properties.yValueEnd = infChart.drawingUtils.common.getBaseYValues.call(drawingObj, properties.yValueEnd);
        properties.trendYValue = infChart.drawingUtils.common.getBaseYValues.call(drawingObj, properties.trendYValue);
        if (properties.intermediatePoints && properties.intermediatePoints.length) {
            var intermediatePoints = [];
            infChart.util.forEach(properties.intermediatePoints, function (index, value) {
                intermediatePoints.push({
                    xValue: value.xValue,
                    yValue: infChart.drawingUtils.common.getBaseYValues.call(drawingObj, value.yValue)
                });
            });
            properties["intermediatePoints"] = intermediatePoints;
        }
        return properties;
    };

    /**
     * update drawing object from given properties
     * @param {string} stockChartId chart id
     * @param drawingId
     * @param properties
     */
    var updateDrawingProperties = function (stockChartId, drawingId, properties) {
        var drawingObj = _getDrawingObject(stockChartId, drawingId);
        drawingObj.update(properties);
    };

    /**
     * Returns the properties to copy from the selected drawing
     * @param {object} annotation selected annotation
     * @returns {object} properties
     * @private
     */
    var _getDrawingPropertiesToCopy = function (annotation) {
        var stockChartId = _getChartIdFromHighchartInstance(annotation.chart);
        var chartInstance = infChart.manager.getChart(stockChartId);
        var drawingObj = _getDrawingObject(stockChartId, annotation.options.id);
        var properties = drawingObj.getConfigToCopy();

        properties.yValue = infChart.drawingUtils.common.getBaseYValues.call(drawingObj, properties.yValue);
        properties.yValueEnd = infChart.drawingUtils.common.getBaseYValues.call(drawingObj, properties.yValueEnd);
        properties.trendYValue = infChart.drawingUtils.common.getBaseYValues.call(drawingObj, properties.trendYValue);
        if (properties.intermediatePoints) {
            var intermediatePoints = [];
            infChart.util.forEach(properties.intermediatePoints, function (index, value) {
                intermediatePoints.push({
                    xValue: value.xValue,
                    yValue: infChart.drawingUtils.common.getBaseYValues.call(drawingObj, value.yValue)
                });
            });
            properties["intermediatePoints"] = intermediatePoints;
        }
        return properties;
    };

    var _getAllDrawingProperties = function (chartId, includeDrawingId) {
        var drawings = [];
        for (var drawingId in chartDrawingObjects[chartId]) {
            if (chartDrawingObjects[chartId].hasOwnProperty(drawingId)) {
                var drawing = chartDrawingObjects[chartId][drawingId], annotation = drawing.annotation;
                if (annotation.options.drawingType === infChart.constants.drawingTypes.shape) {
                    var properties = _getDrawingProperties(annotation);
                    if (includeDrawingId) {
                        properties.drawingId = drawingId;
                    }
                    drawings.push(properties);
                }
            }
        }
        return drawings;
    };

    /**
     * get drawing toolbar properties (show/hide)
     * @param {string} chartId - chart id
     * @returns {boolean} show/hide drawing toolbar
     */
    var _getDrawingToolbarProperties = function (chartId) {
        return drawingToolBarProperties[chartId];
    };

    /**
     * set drawnig toolbar properties
     * @param {string} chartId - chart id
     * @param {boolean} value - show/hide drawing toolbar
     */
    var _setDrawingToolbarProperties = function (chartId, value) {
        drawingToolBarProperties[chartId] = value;
    };

    /**
     *
     * @param {object} drawingObj of the drawing
     * @param {object} chartObj
     * @param {object} drawingSettingsContainer
     * @param {object} properties
     * @returns drawing
     */
    var _drawDrawingFromProperties = function (drawingObj, chartObj, drawingSettingsContainer, properties) {
        var drawingObj = _addAnnotation(drawingObj, chartObj, drawingObj.shape, properties, true);
        var chartInstance = infChart.manager.getChart(drawingObj.stockChartId);
        if (drawingObj.chartRedrawRequired) {
            // redraw chart when plot area needs to be adjusted acording to the added annotation
            chartInstance.redrawChart();
        } else {
            // scale drawing is executed through resize event
            drawingObj.scaleDrawing(true, true);
        }
        // set drawing settings if panel is open
        // var isHideSettingPanel = !_isDisableDrawingSettingsPanel ? !chartInstance.isRightPanelOpen() : true;
        // drawingObj.openDrawingSettings.call(drawingObj, isHideSettingPanel, {"isDisableDrawingSettingsPanel": _isDisableDrawingSettingsPanel});
        // drawingObj.showDrawingSettings.call(drawingObj, isHideSettingPanel, {"isDisableDrawingSettingsPanel": _isDisableDrawingSettingsPanel});
        drawingObj.annotation.events.deselect.call(drawingObj.annotation);
        // infChart.drawingUtils.common.onPropertyChange.call(drawingObj);
        return drawingObj;
    };

    /**
     * scale drawing
     * @param {string} chartId - chart unique id
     * @param {boolean} isCalculateNewValueForScale - is redraw from chart properties
     */
    var _scaleDrawings = function (chartId, isCalculateNewValueForScale) {
        if (scaleDrawingPausedCharts.indexOf(chartId) === -1) {
            _scaleDrawingsInner(chartId, isCalculateNewValueForScale);
        } else {
            if (scaleDrawingCalledWhenPaused.indexOf(chartId) === -1) {
                scaleDrawingCalledWhenPaused.push(chartId);
            }
        }
    };

    /**
     * scale the timestampMarker drawings in chart
     * @param {string} chartId
     */
    var _scaleDrawingOnChartTypeChange = function (chartId) {
        var drawings = chartDrawingObjects[chartId];

        if (drawings) {
            $.each(drawings, function (key, drawing) {
                switch (drawing.shape) {
                    case 'timestampMarker':
                        drawing.scale();
                        break;
                }
            });
        }
    };

    var _pauseScaleDrawings = function (chartId) {
        if (scaleDrawingPausedCharts.indexOf(chartId) === -1) {
            scaleDrawingPausedCharts.push(chartId);
        }
    };

    var _unPauseScaleDrawings = function (chartId) {
        var index = scaleDrawingPausedCharts.indexOf(chartId);
        if (index !== -1) {
            var pauseIndex = scaleDrawingCalledWhenPaused.indexOf(chartId);
            if (pauseIndex !== -1) {
                _scaleDrawingsInner(chartId);
                scaleDrawingCalledWhenPaused.splice(index, 1);
            }
            scaleDrawingPausedCharts.splice(index, 1);
        }
    };

    var _setActiveAnnotationInprogress = function (annotation) {
        activeAnnotationInprogress = annotation;
    };

    var _getActiveAnnotationInprogress = function () {
        return activeAnnotationInprogress;
    };

    /**
     * called when user grabs the drawing before dragging
     * @param annotation
     */
    var _onAnnotationStore = function (annotation) {
        var chartId = _getChartIdFromHighchartInstance(annotation.chart),
            drawing = _getDrawingObject(chartId, annotation.options.id);
        infChart.manager.onAnnotationStore(chartId, drawing);
    };

    /**
     * called when user releases the drawing after dragging
     * @param annotation
     */
    var _onAnnotationRelease = function (annotation) {
        var chartId = _getChartIdFromHighchartInstance(annotation.chart),
            drawing = _getDrawingObject(chartId, annotation.options.id);
        _setYExtremesOnAnnotationUpdate(chartId, annotation);
        infChart.manager.onAnnotationRelease(chartId, drawing);
    };

    /**
     * set y extremes when show orders on chart.
     * @param {string} chartId
     * @param {object} annotation
     */
    var _setYExtremesOnExternalChanges = function (chartId, annotation) {
        _setYExtremesOnAnnotationUpdate(chartId, annotation);
    };

    /**
     * create drawing toolbar (left toolbar) and bind events
     * @param {object} containerElem - container element
     * @param {string} containerId - chart container id
     * @param {Array} toolbarItems - left toolbar items array
     * @param {object} config - chart toolbar config
     * @param {boolean} display - show/hide left toolbar panel
     * @param {boolean} showDrawingTbButtons - show/hide drawing toolbar buttons
     * @param {boolean} isFavoriteToolBar - specify whether favorite tool bar or drawing tool bar
     * @param {boolean} subLevelToolTipEnabled - specify whether level II tool tip enabed
     */
    var _createDrawingToolbar = function (containerElem, containerId, toolbarItems, config, display, showDrawingTbButtons, isFavoriteToolBar, subLevelToolTipEnabled, isGloballyLocked) {
       var toolbarParent;
        if (isFavoriteToolBar) {
            toolbarParent = $(infChart.structureManager.getContainer(containerElem[0], "favoriteMenuPanel"));
            infChart.structureManager.drawingTools.getfavoriteToolBarHTML(toolbarParent, toolbarItems, config);
            infChart.structureManager.toolbar.bindFavoriteMenuEvents(containerElem, toolbarParent, containerId);
        } else {
            toolbarParent = $(infChart.structureManager.getContainer(containerElem[0], "drawingToolbar"));
            infChart.structureManager.drawingTools.getDrawingToolBarHTML(toolbarParent, toolbarItems, config, subLevelToolTipEnabled);
        }
        _setDrawingToolBarToggle(toolbarParent, containerId, config.leftTBToggleButton, showDrawingTbButtons);
        _setDrawingToolbarScrollButtons(toolbarParent);
        drawingConfigs[containerId] = {};
        infChart.util.forEach(toolbarItems, function (i, val) {
            switch (val) {
                case "select":
                    _setSelectOptions(containerElem[0], containerId, toolbarParent, config[val]);
                    drawingConfigs[containerId][val] = config[val];
                    break;
                case "delete":
                    _setDeleteOptions(containerElem, containerId, toolbarParent, config[val]);
                    drawingConfigs[containerId][val] = config[val];
                    break;
                default:
                    drawingConfigs[containerId][val] = config[val];
                    _setDrawing(containerElem, containerId, toolbarParent, config[val]);
                    _setDrawingCategory(containerElem, containerId, toolbarParent, config[val], isGloballyLocked);
                    _setFavoritePanelDrawing(containerElem, containerId, toolbarParent, config[val]);
                    _setDrawingFavoriteIcons(containerElem, containerId, config);
                    break;
            }
        });
        if (!display) {
            toolbarParent.hide();
        }
    };

    var _getDrawingConfigs = function (chartId) {
        var drawingConfig = drawingConfigs[chartId];
        _setDeleteCursor(drawingConfig);
        return drawingConfig;
    };

    var _getDrawingEraseModeConfigs = function (chartId) {
        var drawingConfig = drawingConfigs[chartId];
        _setEraseModeCursor(drawingConfig);
        return drawingConfig;
    };

    var _getDeleteCursor = function (chartId) {
        var drawingConfig = _getDrawingConfigs(chartId);
        var deleteCursor = drawingConfig && drawingConfig["delete"]  && drawingConfig["delete"].options[0] && drawingConfig["delete"].options[0].cursorUrl || "../img/del_cursor.png";
        return deleteCursor;
    };

    var _getEraseModeCursor = function (chartId) {
        var drawingConfig = _getDrawingEraseModeConfigs(chartId);
        var deleteCursor = drawingConfig && drawingConfig["delete"] && drawingConfig["delete"].options[1] && drawingConfig["delete"].options[1].cursorUrl || "../img/del-levels.png";
        return deleteCursor;
    };

    /**
     * Returns the maximum axis offset needed for the drawings in the chart
     * @param chartId
     * @param axis
     * @returns {number}
     * @private
     */
    var _getAxisLabelOffset = function (chartId, axis) {

        var drawings = chartDrawingObjects[chartId],
            axisLabelOffset = 0;

        if (drawings) {

            $.each(drawings, function (key, drawing) {
                if (drawing.annotation && drawing.annotation.chart) {
                    var offset;
                    if (drawing.getAxisOffset) {
                        offset = drawing.getAxisOffset(axis);
                    } else {
                        offset = 0;
                    }
                    if (offset) {
                        axisLabelOffset = Math.max(axisLabelOffset, offset);
                    }
                }
            });

        }

        return axisLabelOffset;
    };

    /**
     * get events to be bind in drawing object
     * @param {string} drawingId - drawing id
     * @param {string} chartId - chart id
     * @param {string} drawingType - drawing type
     * @returns {{click: Function, dblclick: Function, mousedown: Function, mouseup: Function, touchstart: Function, touchend: Function}}
     * @private
     */
    var _getDrawingEvents = function (drawingId, chartId, drawingType) {
        var drawingEvents = {
            // click: function (event) {
            //     var ann = this,
            //         annotationOptions = ann.options,
            //         drawingId = annotationOptions.id,
            //         stockChartId = _getChartIdFromHighchartInstance(ann.chart),
            //         drawingObj = _getDrawingObject(stockChartId, drawingId);

            //     if (!_isMultipleDrawingsEnabled(chartId) && !_getIsActiveDrawingInprogress() && !_getIsActiveDeleteTool(stockChartId) && !_getIsActiveEraseMode(stockChartId) && !ann.chart.isAnnotationSelected && !annotationOptions.isDisplayOnly) {
            //         if (!_isDisableDrawingSettingsPanel) {
            //             _openSettings(drawingObj, false);
            //         }
            //         if (drawingObj.select) {
            //             drawingObj.select();
            //         }
            //         if (drawingObj.onClick) {
            //             drawingObj.onClick(event);
            //         }
            //     }
            // },
            // dblclick: function (event) {
            //     var ann = this,
            //         annotationOptions = ann.options,
            //         drawingId = annotationOptions.id,
            //         stockChartId = _getChartIdFromHighchartInstance(ann.chart),
            //         drawingObj = _getDrawingObject(stockChartId, drawingId);

            //     if (!_isMultipleDrawingsEnabled(chartId) && !_getIsActiveDrawingInprogress() && !_getIsActiveDeleteTool(stockChartId) && !_getIsActiveEraseMode(stockChartId) && !ann.chart.isAnnotationSelected && !annotationOptions.isDisplayOnly) {
            //         if (!_isDisableDrawingSettingsPanel) {
            //             _openSettings(drawingObj, false);
            //         }
            //         if (drawingObj.select) {
            //             drawingObj.select();
            //         }
            //         if (drawingObj.onDoubleClick) {
            //             drawingObj.onDoubleClick(event);
            //         }
            //     }

            //     if (drawingType === infChart.constants.drawingTypes.indicator && this.options.indicatorId) {
            //         infChart.indicatorMgr.indicatorLegendClick(_getChartIdFromHighchartInstance(ann.chart), ann.chart.get(this.options.indicatorId).options.id);
            //     }
            // },
            // mousedown: function (e) {
            //     var ann = this,
            //         annotationOptions = ann.options,
            //         drawingId = annotationOptions.id,
            //         stockChartId = _getChartIdFromHighchartInstance(ann.chart),
            //         drawingObj = _getDrawingObject(stockChartId, drawingId),
            //         stockChart = infChart.manager.getChart(stockChartId),
            //         isPropergateEvent = annotationOptions.isLocked || stockChart.isGloballyLocked;

            //     if (e.detail === 2 && drawingObj.onDoubleClick && !isActiveDrawingInprogress && !_getIsActiveDeleteTool(stockChartId) && !_getIsActiveEraseMode(stockChartId)){
            //             drawingObj.onDoubleClick(e);
            //     }

            //     if (_getIsActiveDeleteTool(stockChartId) && e.which == 1) {
            //         if (drawingObj && annotationOptions.drawingType === infChart.constants.drawingTypes.shape) {
            //             ann.chart.isAnnotationSelected = false;
            //             _removeDrawing(stockChartId, drawingId, undefined, true);
            //             _updateIsGloballyLockInDelete(stockChartId);
            //         }
            //     } else if(_getIsActiveEraseMode(stockChartId) && e.which == 1){
            //         var drawingType = e.target.getAttribute('type');
            //         var selectedLevel = e.target.getAttribute('level');
            //         if(!selectedLevel && e.target.parentNode && (drawingObj.shape ==  "fibVerRetracements" || drawingObj.shape ==  "fib2PointTimeProjection" || drawingObj.shape ==  "fib3PointTimeProjection")){
            //             if (e.target.parentNode.getAttribute('level')) {
            //                 selectedLevel = e.target.parentNode.getAttribute('level');
            //                 drawingType = e.target.parentNode.getAttribute('type');
            //             } else if (e.target.parentNode.parentNode && e.target.parentNode.parentNode.getAttribute('level')) {
            //                 selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
            //                 drawingType = e.target.parentNode.parentNode.getAttribute('type');
            //             }
            //         }
            //         if(drawingType == "additionalDrawing" && selectedLevel){
            //             if (drawingObj.isVisibleLastLevel()) {
            //                 _removeDrawing(stockChartId, drawingId, undefined, true);
            //                 _updateIsGloballyLockInDelete(stockChartId);
            //             } else {
            //                 if(drawingObj.shape == "fibFans"){
            //                     drawingObj.onFibFansLevelChange(selectedLevel, false, true);
            //                 } else if (drawingObj.shape ==  "fibArcs"){
            //                     drawingObj.onFibArcsLevelChange(selectedLevel, false, true);
            //                 } else if (drawingObj.shape ==  "fibVerRetracements" || drawingObj.shape ==  "fib2PointTimeProjection" || drawingObj.shape ==  "fib3PointTimeProjection"){
            //                     drawingObj.eraseFibLevel(selectedLevel, false, true);
            //                 } else if (drawingObj.shape ==  "shortLine" || drawingObj.shape ==  "longLine"){
            //                     infChart.drawingUtils.common.settings.onApplyLine.call(drawingObj, false, selectedLevel, true);
            //                 } else if (drawingObj.shape == "andrewsPitchfork"){
            //                     drawingObj.onChangeFibLines(drawingObj.getFibLevelById(selectedLevel), 'enable', false, true);
            //                 } else {
            //                     infChart.drawingUtils.common.settings.onFibLevelChange.call(drawingObj, selectedLevel, false, true, true);
            //                 }
            //             }
            //         } else if(drawingType == "fibLevelDrawing"){
            //             var subType = e.target.getAttribute('subType');
            //             if (drawingObj.isVisibleLastLevel()) {
            //                 _removeDrawing(stockChartId, drawingId, undefined, true);
            //                 _updateIsGloballyLockInDelete(stockChartId);
            //             } else {
            //                 drawingObj.onFibLevelChange(selectedLevel, false, subType, true);
            //             }
            //         } else {
            //             if (drawingObj && annotationOptions.drawingType === infChart.constants.drawingTypes.shape) {
            //                 ann.chart.isAnnotationSelected = false;
            //                 _removeDrawing(stockChartId, drawingId, undefined, true);
            //                 _updateIsGloballyLockInDelete(stockChartId);
            //             }
            //         }
            //     } else {
            //         if (!_getIsActiveDrawing()) {
            //             // ann.events.deselect.call(ann, e);
            //             //infChart.drawingsManager.closeActiveDrawingSettings();
            //         }

            //         if (drawingObj && ann.options.drawingType === infChart.constants.drawingTypes.shape) {
            //             _unbindKeyDown(stockChartId);
            //         }

            //         if (!isPropergateEvent && drawingObj && ann.chart.isAnnotationSelected) {
            //             e.stopPropagation();
            //         }

            //     }
            // },
            // mouseup: function (e) {
            //     var ann = this, annotationOptions = ann.options;
            //     var stockChartId = _getChartIdFromHighchartInstance(ann.chart),
            //         drawingObj = _getDrawingObject(stockChartId, annotationOptions.id);

            //     if (drawingObj && annotationOptions.drawingType === infChart.constants.drawingTypes.shape) {
            //         _bindKeyDown(ann);
            //     }

            //     if (!_getIsActiveDeleteTool(stockChartId) && !_getIsActiveEraseMode(stockChartId) && ann.chart.isAnnotationSelected) {
            //         if (!annotationOptions.isDisplayOnly && ann.chart.selectedAnnotation === ann) {
            //             drawingObj.selectAndBindResize();
            //             ann.chart.selectedAnnotation = ann;
            //             // drawingObj.openDrawingSettings.call(drawingObj);
            //             if (e.detail !== 2 && !ann.chart.isContextMenuOpen){
            //                     drawingObj.showQuickDrawingSettings.call(drawingObj);
            //             }
            //         }

            //         ann.chart.isAnnotationSelected = false;
            //         _disableDrawing(stockChartId);
            //     }

            //     if(!_getIsActiveDeleteTool(stockChartId) && !_getIsActiveEraseMode(stockChartId) && !_getIsActiveDrawingInprogress() && drawingObj.initialSettingPanelLoad){
            //         drawingObj.openSettingPanel();
            //         drawingObj.initialSettingPanelLoad = false;
            //     }
            // },
            touchstart: function (e) {
                var ann = this,
                    annotationOptions = ann.options,
                    drawingId = annotationOptions.id,
                    stockChartId = _getChartIdFromHighchartInstance(ann.chart),
                    drawingObj = _getDrawingObject(stockChartId, drawingId),
                    chartInstance = infChart.manager.getChart(stockChartId);

                var _onLongTouch = function(event, ann, chartId, drawingType){
                    if (!_isMultipleDrawingsEnabled(chartId)) {
                        var options = ann.options;
                        if (options.drawingType === infChart.constants.drawingTypes.shape)  {
                            if (ann.chart.selectedAnnotation) {
                                ann.chart.selectedAnnotation.events.deselect.call(ann.chart.selectedAnnotation, event, true);
                            }
                            var chartId = _getChartIdFromHighchartInstance(ann.chart);
                            var drawingId = ann.options.id;
                            var config = infChart.mobileDrawingSettingsManager.getConfigForDrawing(chartId, infChart.constants.contextMenuTypes.drawing, {drawingId: ann.options.id});
                            var settingsProperties = {config: config, drawingId: drawingId, chartId: chartId, type:'drawingSettingsPanel'};
                            infChart.util.postMessageToReactNative(settingsProperties);
                        } else if (drawingType === infChart.constants.drawingTypes.indicator && this.options.indicatorId) {
                            infChart.indicatorMgr.openContextMenu(this.chart.renderTo.id, event, this.chart.get(this.options.indicatorId));
                        }
            
                        event.stopPropagation();
                    }
                };
                
                if(ann && drawingObj) {
                    chartInstance.touchTimer = setTimeout(function () {
                        _onLongTouch(e, ann, chartId, drawingType);
                    }, 500);
                }
                
                if (_getIsActiveDeleteTool(stockChartId)) {
                    if (drawingObj && annotationOptions.drawingType === infChart.constants.drawingTypes.shape) {
                        ann.chart.isAnnotationSelected = false;
                        _removeDrawing(stockChartId, drawingId, undefined, true);
                    }
                } else if(_getIsActiveEraseMode(stockChartId)) {
                    var drawingType = e.target.getAttribute('type');
                    var selectedLevel = e.target.getAttribute('level');
                    if(drawingType == "additionalDrawing" && selectedLevel){
                        if (drawingObj.isVisibleLastLevel()) {
                            _removeDrawing(stockChartId, drawingId, undefined, true);
                        } else {
                            infChart.drawingUtils.common.settings.onFibLevelChange.call(drawingObj, selectedLevel, false, true, true);
                        }
                    } else if(drawingType == "fibLevelDrawing"){
                        var subType = e.target.getAttribute('subType');
                        if (drawingObj.isVisibleLastLevel()) {
                            _removeDrawing(stockChartId, drawingId, undefined, true);
                        } else {
                            drawingObj.onFibLevelChange(selectedLevel, false, subType, true);
                        }
                    } else {
                        if (drawingObj && annotationOptions.drawingType === infChart.constants.drawingTypes.shape) {
                            ann.chart.isAnnotationSelected = false;
                            _removeDrawing(stockChartId, drawingId, undefined, true);
                        }
                    }
                } else {
                    if (!_getIsActiveDrawing()) {
                        // ann.events.deselect.call(ann, e);
                        //infChart.drawingsManager.closeActiveDrawingSettings();
                    }

                    if (drawingObj && ann.options.drawingType === infChart.constants.drawingTypes.shape) {
                        _unbindKeyDown(stockChartId);
                    }

                    if (drawingObj && ann.chart.isAnnotationSelected) {
                        e.stopPropagation();
                    }
                }
            },
            touchend: function () {
                var ann = this, annotationOptions = ann.options;
                var stockChartId = _getChartIdFromHighchartInstance(ann.chart),
                    drawingObj = _getDrawingObject(stockChartId, annotationOptions.id),
                    chartInstance = infChart.manager.getChart(stockChartId);

                if (drawingObj && annotationOptions.drawingType === infChart.constants.drawingTypes.shape) {
                    _bindKeyDown(ann);
                }
                if (chartInstance.touchTimer){
                    clearTimeout(chartInstance.touchTimer);
                    chartInstance.touchTimer = undefined;
                }

                if (ann.chart.isAnnotationSelected) {
                    if (!annotationOptions.isDisplayOnly) {
                        drawingObj.selectAndBindResize();
                        ann.chart.selectedAnnotation = ann;
                        // drawingObj.openDrawingSettings.call(drawingObj);
                    }

                    ann.chart.isAnnotationSelected = false;
                    _disableDrawing(stockChartId);
                }
            }
        };
        if (infChart.contextMenuManager && infChart.contextMenuManager.isContextMenuEnabled(chartId) && (drawingType === infChart.constants.drawingTypes.shape || drawingType === infChart.constants.drawingTypes.indicator)) {
            drawingEvents.contextmenu = function (event) {
                if (!_isMultipleDrawingsEnabled(chartId)) {
                    if (drawingType === infChart.constants.drawingTypes.shape)  {
                        var ann = this;
                        if (ann.chart.selectedAnnotation) {
                            ann.chart.selectedAnnotation.events.deselect.call(ann.chart.selectedAnnotation, event, true);
                        }
                        var chartId = _getChartIdFromHighchartInstance(ann.chart);
                        var drawingId = ann.options.id;
                        var config = infChart.mobileDrawingSettingsManager.getConfigForDrawing(chartId, infChart.constants.contextMenuTypes.drawing, {drawingId: ann.options.id});
                        var settingsProperties = {config: config, drawingId: drawingId, chartId: chartId, type:'drawingSettingsPanel'};
                        infChart.util.postMessageToReactNative(settingsProperties);
                    } else if (drawingType === infChart.constants.drawingTypes.indicator && this.options.indicatorId) {
                        infChart.indicatorMgr.openContextMenu(this.chart.renderTo.id, event, this.chart.get(this.options.indicatorId));
                    }

                    event.stopPropagation();
                }

            }
        }
        return drawingEvents;
    };
    //endregion

    /**
     * update saved drawing options
     * @param {string} chartId - chart id
     * @param {string} shapeId - shape id
     * @param {string} drawingId - drawing id
     * @param {boolean} setToDefault - true, if saved id need to be removed
     * @private
     */
    var _updateSavedDrawingProperties = function (chartId, shapeId, drawingId, setToDefault) {
        var drawingProviderType = _chartDrawingProviderTypes[chartId];
        if (drawingProviderType) {
            if (!_savedDrawingOptionsMap[drawingProviderType]) {
                _savedDrawingOptionsMap[drawingProviderType] = {};
            }
            var drawingObject = _getDrawingObject(chartId, drawingId);
            if (drawingObject) {
                if (setToDefault) {
                    _savedDrawingOptionsMap[drawingProviderType][shapeId] = undefined;
                    infChart.drawingsManager.resetDrawing(chartId, drawingId, _getDrawingProperties(drawingObject.annotation));
                } else {
                    let drawingPropertiesClone = JSON.parse(JSON.stringify(_getDrawingPropertiesToSave(chartId, drawingId)));
                    _savedDrawingOptionsMap[drawingProviderType][shapeId] = drawingPropertiesClone;
                }
                _providerInstances[drawingProviderType].saveDefaultDrawingTemplates(_savedDrawingOptionsMap[drawingProviderType]);
            }
        }
    };


    var _resetToUserDefaultDrawingProperties = function (chartId, shapeId, drawingId) {
        var drawingObject = _getDrawingObject(chartId, drawingId);
        var drawingTemplateProperties = $.extend(true, {}, _getUserDefaultDrawingProperties(chartId, shapeId));
        infChart.drawingsManager.applyTemplateProperties(chartId, drawingId, _getDrawingProperties(drawingObject.annotation), drawingTemplateProperties);
        _reloadSettings(chartId, drawingId);
    };


    var _getUserDefaultDrawingProperties = function (chartId, shapeId) {
        var drawingProviderType = _chartDrawingProviderTypes[chartId];
        return _savedDrawingOptionsMap[drawingProviderType]?.[shapeId];
    };

    /**
     * get drawing settings to save
     * @param {string} chartId - chart id
     * @param {string} drawingId - drawing id
     * @private
     */
    var _getDrawingPropertiesToSave = function (chartId, drawingId) {
        var drawingPropertiesToSave = {};
        var drawingObject = _getDrawingObject(chartId, drawingId);
        if (drawingObject) {
            var drawingProperties = _getDrawingProperties(drawingObject.annotation);
            if (drawingProperties) {
                for (var property in drawingProperties) {
                    if (!_isRequiredProperty(drawingObject, property)) {
                        drawingPropertiesToSave[property] = drawingProperties[property];
                    }
                }
            }
        }
        return drawingPropertiesToSave;
    };

    /**
     * reset drawing properties
     * @param {string} chartId - chart id
     * @param {string} drawingId - drawing id
     * @param {object} currentDrawingProperties - properties of current drawing object
     * @private
     */
    var _resetDrawingProperties = function (chartId, drawingId, currentDrawingProperties) {
        var currentPopupPosition = infChart.structureManager.settings.getPopupPosition(_getDrawingObject(chartId, drawingId).settingsPopup);
        var drawingObject = _getDrawingObject(chartId, drawingId);

        var properties = {
            shape: currentDrawingProperties.shape
        };
        for (var property in currentDrawingProperties) {
            if (_isRequiredProperty(drawingObject, property, true)) {
                properties[property] = currentDrawingProperties[property];
            }
        }

        _removeDrawing(chartId, drawingId);
        var drawingObj = _createDrawing(infChart.manager.getChart(chartId).chart, properties.shape, _getSettingsContainer(chartId), _getQuickSettingsContainer(chartId), drawingId);
        _drawDrawingFromProperties(drawingObj, infChart.manager.getChart(chartId).chart, _getSettingsContainer(chartId), properties);
        var newDrawingObj = _getDrawingObject(chartId, drawingId);
        _openSettings(newDrawingObj, false, currentPopupPosition);
        newDrawingObj.onPropertyChange("drawings");
        return properties;
    };

    /**
     * check if given property is required when saving and resetting the drawing
     * @param {Object} drawingObject - drawing object
     * @param {string} propertyId - property id
     * @returns {boolean} - true if position related property
     * @private
     */
    var _isRequiredProperty = function (drawingObject, propertyId, reset) {
        var isPositionProperty;

        if (drawingObject && drawingObject.isRequiredProperty) {
            isPositionProperty = drawingObject.isRequiredProperty(propertyId, reset);
        }

        if (isPositionProperty === undefined) {
            switch (propertyId) {
                case "yValue":
                case "yValueEnd":
                case "xValue":
                case "xValueEnd":
                case "trendYValue":
                case "trendXValue":
                case "intermediatePoints":
                case "linePointValues":
                case "clickCords" :
                case "text":
                case "textValue":
                case "jointLineValue":
                case "xValueDataIndex":
                case "xValueEndDataIndex":
                case "isLocked":
                    isPositionProperty = true;
                    break;
                default :
                    isPositionProperty = false;
                    break;
            }
        }

        return isPositionProperty;
    };

    /**
     * set data provider
     * @param {string} chartId - chart id
     * @param {string} providerObj - - chart id
     * @private
     */
    var _setDataProvider = function (chartId, providerObj) {
        if (providerObj) {
            if (!_providerInstances[providerObj.type]) {
                var dataProvider;
                switch (providerObj.type) {
                    case 'infinit':
                        dataProvider = new infChart.xinDrawingDataProvider(providerObj.source);
                        break;
                    default:
                        dataProvider = new infChart.mockDrawingDataProvider(providerObj.source);
                        break;
                }
                _providerInstances[providerObj.type] = dataProvider;
                _loadDrawingTemplates(providerObj.type);
            }
            _chartDrawingProviderTypes[chartId] = providerObj.type;
        }
    };

    /**
     * get contect menu options
     * @param {string} chartId
     * @param {string} drawingId
     * @param {object} event
     * @returns {object} options
     */
    var _getContextMenuOptions = function (chartId, drawingId, event) {
        var drawingObj = infChart.drawingsManager.getDrawingObject(chartId, drawingId);
        var option = _getDrawingContextMenuOptions(chartId);
        if (drawingObj.getContextMenuOptions) {
            options = drawingObj.getContextMenuOptions(chartId,
                drawingId,
                option,
                event
            );
        } else {
            options = infChart.drawingUtils.common.getContextMenuOptions(chartId,
                drawingId,
                option,
                event
            );
        }
        return options;
    };

    var _getDrawingContextMenuOptions = function (chartId) {
        var options = infChart.manager.getChart(chartId).settings.contextMenu.drawing.options;
        return options;
    };

    var _getFavoriteDrawingContextMenuOptions = function (chartId, options) {
        var contextMenu =  {
            "favoriteDrawing" : {
                icon : options.remove.icon,
                displayText : options.remove.displayText,
                action : function () {
                    _removeFavoriteDrawingFromContextMenu(options.uniqueId, options.drawingCat, options.drawingShape, chartId);
                }
            }
        };
        return contextMenu;
    };

    /**
     * get default drawing properties for the shape
     * @param {string} chartId - chart id
     * @param {string} shapeId - shape id
     * @returns {object} - default properties
     * @private
     */
    var _getDefaultDrawingProperties = function (chartId, shapeId) {
        var savedOptions = _savedDrawingOptionsMap?.[_chartDrawingProviderTypes[chartId]]?.[shapeId];
        return savedOptions || {};
    };

    /**
     * load drawing templates for given provider type
     * @param providerType
     * @private
     */
    var _loadDrawingTemplates = function (providerType) {
        _providerInstances[providerType].getSavedDrawingTemplates(function (data) {
            _drawingTemplates[providerType] = data;
        });
        _loadDefaultDrawingTemplates(providerType);
    };

    var _loadSavedDrawingTemplates = function (chartId) {
        var drawingProviderType = _chartDrawingProviderTypes[chartId];
        _loadDrawingTemplates(drawingProviderType);
    };


    /**
     * load drawing templates for given provider type
     * @param providerType
     * @private
     */
    var _loadDefaultDrawingTemplates = function (providerType) {
        _providerInstances[providerType].getDefaultSavedDrawingTemplates(function (data) {
            _savedDrawingOptionsMap[providerType] = data;
        });
    };

    /**
     * save drawing templates
     * @param {string} chartId - chart id
     * @param {string} drawingId - drawing id
     * @param {string} shapeId - shape id
     * @param {string} templateId - template id
     * @private
     */
    var _saveDrawingTemplate = function (chartId, drawingId, shape, templateId) {
        var drawingProviderType = _chartDrawingProviderTypes[chartId];
        if (drawingProviderType) {
            if (!_drawingTemplates[drawingProviderType]) {
                _drawingTemplates[drawingProviderType] = {};
            }
            if (!_drawingTemplates[drawingProviderType][shape]) {
                _drawingTemplates[drawingProviderType][shape] = {};
            }
            var drawingObject = _getDrawingObject(chartId, drawingId);
            if (drawingObject) {
                _drawingTemplates[drawingProviderType][shape][templateId] = $.extend(true, {}, _getDrawingPropertiesToSave(chartId, drawingId));
                _providerInstances[drawingProviderType].saveDrawingTemplates(_drawingTemplates[drawingProviderType]);
                _reloadSettings(chartId, drawingId);
            }
        }
    };

    /**
     * delete given template
     * @param {string} chartId - chart id
     * @param {string} shapeId - shape id
     * @param {string} templateId - template id
     * @private
     */
    var _deleteDrawingTemplate = function (chartId, drawingId, shape, templateId) {
        var drawingProviderType = _chartDrawingProviderTypes[chartId];
        if (drawingProviderType) {
            delete _drawingTemplates[drawingProviderType][shape][templateId]
            _providerInstances[drawingProviderType].saveDrawingTemplates(_drawingTemplates[drawingProviderType]);
            _reloadSettings(chartId, drawingId);
        }
    };

    /**
     * apply given drawing template for given drawing
     * @param {string} chartId - chart id
     * @param {string} drawingId - drawing id
     * @param {string} shapeId - shape id
     * @param {string} templateId - template id
     * @private
     */
    var _applyDrawingTemplate = function (chartId, drawingId, shape, templateId) {
        var drawingProviderType = _chartDrawingProviderTypes[chartId];
        var drawingObject = _getDrawingObject(chartId, drawingId);
        if (drawingProviderType) {
            var drawingTemplateProperties = $.extend(true, {}, _drawingTemplates[drawingProviderType][shape][templateId]);
            infChart.drawingsManager.applyTemplateProperties(chartId, drawingId, _getDrawingProperties(drawingObject.annotation), drawingTemplateProperties);
            _reloadSettings(chartId, drawingId);
        }
    };

    /**
     * get drawing templates for given drawing id
     * @param {string} chartId - chart id
     * @param {string} shapeId - shape id
     * @returns {Array} - list of templates
     * @private
     */
    var _getDrawingTemplates = function (chartId, shape) {
        var templatesMap = _drawingTemplates?.[_chartDrawingProviderTypes[chartId]]?.[shape];
        return templatesMap ? Object.keys(templatesMap).sort() : [];
    };

    /**
     * apply template properties
     * @param {string} chartId - chart id
     * @param {string} drawingId - drawing id
     * @param {object} currentDrawingProperties - current drawing properties
     * @param {object} templateProperties - template properties
     * @private
     */
    var _applyTemplateProperties = function (chartId, drawingId, currentDrawingProperties, templateProperties) {
        var currentPopupPosition = infChart.structureManager.settings.getPopupPosition(_getDrawingObject(chartId, drawingId).settingsPopup);
        var drawingObject = _getDrawingObject(chartId, drawingId);
        var ann = drawingObject.annotation;
        var chart = ann.chart;
        var properties = {
            shape: currentDrawingProperties.shape
        };
        for (var property in currentDrawingProperties) {
            if (_isRequiredProperty(drawingObject, property, true)) {
                properties[property] = currentDrawingProperties[property];
            }
        }
        for (var templateProperty in templateProperties) {
            if (!_isRequiredProperty(drawingObject, templateProperty, true)) {
                properties[templateProperty] = templateProperties[templateProperty];
            }
        }
        _removeDrawing(chartId, drawingId);
        var drawingObj = _createDrawing(infChart.manager.getChart(chartId).chart, properties.shape, _getSettingsContainer(chartId), _getQuickSettingsContainer(chartId), drawingId);
        _drawDrawingFromProperties(drawingObj, infChart.manager.getChart(chartId).chart, _getSettingsContainer(chartId), properties);
        drawingObj.selectAndBindResize();
        ann = drawingObj.annotation;
        chart.selectedAnnotation = ann;
        var newDrawingObj = _getDrawingObject(chartId, drawingId);
        _openSettings(newDrawingObj, false, currentPopupPosition);
        newDrawingObj.onPropertyChange("drawings");
        return properties;
    };

    /**
     * reload settings window
     * @param {string} chartId - chart id
     * @param {string} drawingId - drawing id
     * @private
     */
    var _reloadSettings = function (chartId, drawingId) {
        var drawingObject = _getDrawingObject(chartId, drawingId);
        if (drawingObject.settingsPopup && !drawingObject.isQuickSetting) {
            var currentPopupPosition = infChart.structureManager.settings.getPopupPosition(drawingObject.settingsPopup);
            drawingObject.settingsPopup.remove();
            drawingObject.settingsPopup = null;
            _openSettings(drawingObject, false, currentPopupPosition);
        }
    };

    var _getTotalPoints = function (chart) {
        var iChart = chart && infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id));
        var totalPoints = iChart.calculateTotalPoints(chart);
        return totalPoints;
    };

    /**
     * whether drawn drawings available
     * @param {string} chartId - chart id
     * @retruns {boolean} whether drawn drawings available
     * @private
     */
    var _isDrawnDrawingsAvailable = function (chartId) {
        let drawings = chartDrawingObjects[chartId];

        for (let drawingId in drawings) {
            if (drawings.hasOwnProperty(drawingId)) {
                if (drawings[drawingId].annotation.options.drawingType === infChart.constants.drawingTypes.shape) {
                    return true;
                }
            }
        }

        return false;
    };

    var _resetEnabledMyDefaultButton = function(chartId, shape, currentDrawingId, value){
        var drawings = chartDrawingObjects[chartId];

        if (drawings) {
            for (let drawingId in drawings) {
                var drawingObj = _getDrawingObject(chartId, drawingId);
                if(shape == drawingObj.shape && drawingId != currentDrawingId){
                    if(drawingObj.annotation && drawingObj.annotation.options){
                        drawingObj.annotation.options.enabledMyDefaultButton = value;
                    }
                }
            }
        }
    };

    var _hasPositionChanged = function (shapeId, options) {
        var isPositionChanged = true;
        switch (shapeId) {
            case 'fibRetracements':
                if (options.xValue === options.xValueStore && options.yValue === options.yValueStore &&
                    options.xValueEnd === options.xValueEndStore && options.yValueEndStore === options.yValueEnd &&
                    options.nearestXValue === options.nearestXValueStore && options.nearestXValueEnd === options.nearestXValueEndStore &&
                    options.nearestYValue === options.nearestYValueStore && options.nearestYValueEnd === options.nearestYValueEndStore) {
                        isPositionChanged = false;
                }
                break;
            case 'fib3PointPriceProjectionHLH':
            case 'fib3PointPriceProjectionLHL':
            case 'fib3PointPriceProjectionGeneric':
                if (options.xValue === options.xValueStore && options.yValue === options.yValueStore &&
                    options.xValueEnd === options.xValueEndStore && options.yValueEnd === options.yValueEndStore &&
                    options.trendXValue === options.trendXValueStore &&  options.trendYValue === options.trendYValueStore &&
                    options.nearestXValue === options.nearestXValueStore && options.nearestXValueEnd === options.nearestXValueEndStore &&
                    options.nearestYValue === options.nearestYValueStore && options.nearestYValueEnd === options.nearestYValueEndStore &&
                    options.nearestTrendYValue === options.nearestTrendYValueStore && options.nearestTrendXValue === options.nearestTrendXValueStore) {
                        isPositionChanged = false;
                }
                break;
            default:
                break;
        }
        return isPositionChanged;
    }

    return {
        initializeDrawing: _initializeDrawing,
        setActiveDrawing: _setActiveDrawing,
        setActiveDrawingSettings: _setActiveDrawingSettings,
        getActiveDrawing: _getActiveDrawing,
        removeActiveDrawing: _removeActiveDrawing,
        closeActiveDrawingSettings: _closeActiveDrawingSettings,
        removeAllDrawings: _removeAllDrawings,
        removeDrawing: _removeDrawing,
        //removeDrawingEvents: _removeDrawingEvents,
        //deselectDeleteTool: _deselectDeleteTool,
        getDrawingObject: _getDrawingObject,
        getIsActiveDrawing: _getIsActiveDrawing,
        getIsActiveDrawingInprogress: _getIsActiveDrawingInprogress,
        //setIsActiveDrawing: _setIsActiveDrawing,
        getIsActiveDeleteTool: _getIsActiveDeleteTool,
        getIsActiveEraseMode: _getIsActiveEraseMode,
        //setIsActiveDeleteTool: _setIsActiveDeleteTool,
        isMultipleDrawingsEnabled: _isMultipleDrawingsEnabled,
        //toggleMultipleDrawings: _toggleMultipleDrawings,
        getDrawingProperties: _getDrawingProperties,
        getAllDrawingProperties: _getAllDrawingProperties,
        getAllDrawings: _getAllDrawings,
        drawDrawingFromProperties: _drawDrawingFromProperties,
        // scaleDrawings: _scaleDrawings,
        //pauseScaleDrawings: _pauseScaleDrawings,
        //unPauseScaleDrawings: _unPauseScaleDrawings,
        setActiveAnnotationInprogress: _setActiveAnnotationInprogress,
        getActiveAnnotationInprogress: _getActiveAnnotationInprogress,
        onAnnotationStore: _onAnnotationStore,
        onAnnotationRelease: _onAnnotationRelease,
        setYExtremesOnExternalChanges: _setYExtremesOnExternalChanges,
        applyNewDrawings: _onNewProperties,
        initialize: _onInitialize,
        destroy: _onDestroy,
        createDrawingToolbar: _createDrawingToolbar,
        getDrawingConfigs: _getDrawingConfigs,
        getDeleteCursor: _getDeleteCursor,
        getEraseModeCursor:_getEraseModeCursor,
        resetYExtremes: _resetYExtremes,
        getAxisLabelOffset: _getAxisLabelOffset,
        getSettingsContainer: _getSettingsContainer,
        getChartIdFromHighchartInstance: _getChartIdFromHighchartInstance,
        pasteNewItem: pasteNewItem,
        updateDrawingProperties: updateDrawingProperties,
        rearrangeDrawingToolbar: _rearrangeDrawingToolbar,
        getDrawingToolbarProperties: _getDrawingToolbarProperties,
        updateSavedDrawingProperties: _updateSavedDrawingProperties,
        resetDrawing: _resetDrawingProperties,
        openSettings: _openSettings,
        createDrawing: _createDrawing,
        getContextMenuOptions: _getContextMenuOptions,
        toggleFavorite: _toggleFavorite,
        toggleSettings: _toggleSettings,
        getQuickSettingsContainer: _getQuickSettingsContainer,
        addChartAreaKeyDownListener: _addChartAreaKeyDownListener,
        removeChartAreaKeyDownListener: _removeChartAreaKeyDownListener,
        saveDrawingTemplate: _saveDrawingTemplate,
        deleteDrawingTemplate: _deleteDrawingTemplate,
        applyDrawingTemplate: _applyDrawingTemplate,
        getDrawingTemplates: _getDrawingTemplates,
        applyTemplateProperties: _applyTemplateProperties,
        loadSavedDrawingTemplates: _loadSavedDrawingTemplates,
        positionElliotWaveDrawingLabels: _positionElliotWaveDrawingLabels,
        deselectDrawingTools: _deselectDrawingTools,
        resetToUserDefaultDrawingProperties: _resetToUserDefaultDrawingProperties,
        reloadSettings: _reloadSettings,
        getUserDefaultDrawingProperties: _getUserDefaultDrawingProperties,
        getTotalPoints: _getTotalPoints,
        isDrawnDrawingsAvailable: _isDrawnDrawingsAvailable,
        setSelectToolbarIconOnReset: _setSelectToolbarIconOnReset,
        setDeleteMode: _setDeleteMode,
        offDeleteMode: _offDeleteMode,
        hasPositionChanged: _hasPositionChanged,
        resetEnabledMyDefaultButton: _resetEnabledMyDefaultButton,
        getFavoriteDrawingContextMenuOptions: _getFavoriteDrawingContextMenuOptions,
        setActiveSelectOption: _setActiveSelectOption,
        updateIsGloballyLockInDelete: _updateIsGloballyLockInDelete,
        setActiveDrawingToolOptions: _setActiveDrawingToolOptions
    }

})(jQuery, infChart);

infChart.structureManager.drawingTools = (function ($, infChart) {

    /**
     * text input
     * @returns {{title, body, isLabel}|rowItem}
     * @private
     */
    var _getTextRowItem = function (maxLength) {
        var maxLengthStr = maxLength ? ' maxlength="' + maxLength + '" ' : '';
        var html = '<textarea class = "form-control is-label" inf-ctrl="text" rows="3" type="text" placeholder="Add text"' + maxLengthStr + '></textarea>';
        return infChart.structureManager.settings.getRowItem(html, 'label.text');
    };

    var _getLineTextRowItem = function (maxLength) {
        var maxLengthStr = maxLength ? ' maxlength="' + maxLength + '" ' : '';
        var titleHtml = '<input inf-ctrl="textToggle" type="checkbox"  id="' + '" > <span>Text</span>' ;
        bodyHtml = '<div class="fib-options-wrapper"><textArea class = "form-control is-label" inf-ctrl="line-text" wrap="off" type="text" placeholder="Add text"' + maxLengthStr + '></textArea></div>';
        return infChart.structureManager.settings.getRowItem(bodyHtml,titleHtml, false, undefined, 'w--100');
    };

    var _getTextAreaRowItem = function (textToggleRef , textRef) {
        var titleHtml = '<input inf-ctrl= '+ textToggleRef +' type="checkbox"  id="' + '" > <span>Text</span>' ;
        bodyHtml = '<div class="fib-options-wrapper"><textarea class = "form-control is-label" inf-ctrl='+ textRef+'  type="text" placeholder="Add text"></textarea></div>';
        return infChart.structureManager.settings.getRowItem(bodyHtml,titleHtml, false, undefined, 'w--100');
    };

    var _getDropDownList =  function (dropDownTypes, alignType) {   
        bodyHtml = '<div class="fib-options-wrapper open-from-top"><div class="dropdown has-vertical-list " inf-ctrl="'+ alignType + '">' +
        '<button class="btn btn-default dropdown-toggle" type="button" data-toggle="dropdown" rel="dropDownButton" aria-haspopup="true" aria-expanded="true">' +
        '<span rel="selectItem">'+ dropDownTypes[0] +'</span> <span class="caret"></span> ' +
        '</button>' +
        '<ul inf-ctrl="dropDown" class="dropdown-menu w--100">';

        Object.keys(dropDownTypes).forEach(function (dropDownType) {
            bodyHtml += '<li rel="'+ alignType + '"  inf-data="' + dropDownTypes[dropDownType] + '"><a>' + dropDownTypes[dropDownType] + '</a></li>';
        })
        bodyHtml += '</ul></div></div>';

        return infChart.structureManager.settings.getRowItem(bodyHtml, undefined, false, undefined, undefined);
    }

    /**
     * line settings
     * @param color
     * @param labelDataItems
     * @returns {string}
     * @private
     */
    var _getLineSettings = function (color, labelDataItems, isLineText, fontSize, textFontColor, opacity, isExtendAvailable, isArrowAvaialable) {
        var sectionRows = [];
        var rowItems = [];
        var maxLength = 200;
        row2Items = [];

        sectionRows.push(infChart.structureManager.settings.getSectionRow([
            infChart.structureManager.settings.getLineStyleRowItem(),
            infChart.structureManager.settings.getLineWeightRowItem(),
            infChart.structureManager.settings.getColorPickerRowItem('lineColorPicker', color, opacity, 'color', 'top left', 'label.lineColor')
        ]));

        if(isArrowAvaialable){
            row2Items.push(infChart.structureManager.settings.getArrowHeadRowItem(undefined, 'start', 'label.startarrowtype'));
            row2Items.push(infChart.structureManager.settings.getArrowHeadRowItem(undefined, 'end', 'label.endarrowtype'));
            sectionRows.push(infChart.structureManager.settings.getSectionRow(row2Items, 'two-col-row'));
        }

        if(isExtendAvailable){
            sectionRows.push(infChart.structureManager.settings.getSectionRow([
                infChart.structureManager.settings.getRowItem("", _getApplyOptionCheckbox('extendToLeft', 'label.extendToLeft'), false),
                infChart.structureManager.settings.getRowItem("", _getApplyOptionCheckbox('extendToRight', 'label.extendToRight'), false)
            ], 'section-row--add-extra-padding-top'));
        }

        if(labelDataItems && labelDataItems.length > 0) {
            labelDataItems.forEach(function (labelDataItem, index) {
                var uniqueId = labelDataItem.id + new Date().getTime();
                var labelDataItemHTML = '<span class="c-checkbox-secondary c-checkbox-secondary--15">'+
                                            '<input class="c-checkbox-secondary__checkbox" inf-ctrl="labelDataItem" type="checkbox" checked="checked" id="' + uniqueId + '" data-value="' + labelDataItem.id + '">'+
                                            '<span class="c-checkbox-secondary__alias">' +
                                                '<i class="icom"></i>' +
                                            '</span>'+
                                            '<label class="c-checkbox-secondary__label" for="' + uniqueId + '">'+ labelDataItem.displayName +'</label>'
                                        '</span>';

                rowItems.push(infChart.structureManager.settings.getRowItem( "", labelDataItemHTML, false));
            });

            sectionRows.push(infChart.structureManager.settings.getSectionRow(rowItems , 'section-row--separator-to-top'));
        }
        
        if(isLineText) {
            sectionRows.push(infChart.structureManager.settings.getSectionRow([
                _getLineTextRowItem(maxLength)
            ], 'section-row--separator-to-top section-row--textfield'));

            sectionRows.push(infChart.structureManager.settings.getSectionRow([
                infChart.structureManager.settings.getFontSizeRowItem(fontSize, 'dropup'),
            ]));

            sectionRows.push(infChart.structureManager.settings.getSectionRow([
                infChart.structureManager.settings.getColorPickerRowItem('textColorPicker', textFontColor, opacity, 'color', 'top left', 'label.textColor')])
            );

            sectionRows.push(infChart.structureManager.settings.getSectionRow([
            infChart.structureManager.settings.getFontWeightRowItem()
            ]));
        }

        return  infChart.structureManager.settings.getPanelBodyHTML([infChart.structureManager.settings.getSection(sectionRows)]) +
                _getResetToDefaultHTML();

    };

    var _getLineQuickSettings = function (color, opacity) {
        var html = "";
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getLineStyleHTML(), "has-list items--2", infChart.manager.getLabel("label.lineStyle"), "right");
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML('lineColorPicker', 'color', color, opacity, 'top left'), "has-color-picker", infChart.manager.getLabel("label.lineColor"), "right");
        return html;
    };

    var _getPriceLineQuickSettings = function () {
        return "";
    };

    var _getPriceLineSettings = function (takeProfitLevels, stopLossLevels, yValue) {
        
        var sectionRows = [],
            rowItems = [];

        var entryPriceTitle = '<label>' + infChart.manager.getLabel("label.entryPrice") + '</label>';
        var entryPriceRow = '<input inf-ctrl="entryValue" class="fib-levels-input c-form-control text--right" maxlength="20" type="text" value="' + parseFloat(yValue).toFixed(3) + '" >';
        rowItems.push({body: entryPriceRow, isLabel: false, id: undefined, title: entryPriceTitle});

        rowItems.push({
            title: '<label class="text--positive">' + infChart.manager.getLabel("label.takeProfit") + '</label>', 
            isLabel: false, 
            id: undefined, 
            body: "" 
        });

        takeProfitLevels.forEach(function (priceLineLevel, index) {
            var title = '<input inf-ctrl="applyPriceLine" inf-value="' + priceLineLevel.id + '" type="checkbox" checked="checked" data-value="' + priceLineLevel.id + '"><span>' + infChart.manager.getLabel("label." + priceLineLevel.id + "") + '</span>';
            
            rowItems.push(_getPriceLevelSettingsRowItem('priceLineLevel', priceLineLevel.lineWidth, priceLineLevel.lineStyle, priceLineLevel.id, priceLineLevel.yValue, title, false, priceLineLevel.lineColor, 'top left'));
        });

        rowItems.push({
            title: '<label class="text--negative">' + infChart.manager.getLabel("label.stopLoss") + '</label>',
            isLabel: false,
            id: undefined,
            body: ""
        });

        stopLossLevels.forEach(function (priceLineLevel, index) {

            var title = '<input inf-ctrl="applyPriceLine" inf-value="' + priceLineLevel.id + '" type="checkbox" checked="checked" data-value="' + priceLineLevel.id + '"><span>' + infChart.manager.getLabel("label." + priceLineLevel.id + "") + '</span>';

            rowItems.push(_getPriceLevelSettingsRowItem('priceLineLevel', priceLineLevel.lineWidth, priceLineLevel.lineStyle, priceLineLevel.id, priceLineLevel.yValue, title, false, priceLineLevel.lineColor, 'top left'));
        });

        sectionRows.push(infChart.structureManager.settings.getSectionRow(rowItems, 'setting-section'));

        return '<div class="long-short-settings">' + infChart.structureManager.settings.getPanelBodyHTML([infChart.structureManager.settings.getSection(sectionRows)]) +
            _getResetToDefaultHTML() + '</div>';

    };

    /**
     * common setting to rectangle, ellipse, regression line and andrew's pitchfork
     * @param title
     * @param lineColor
     * @param fillColor
     * @param fillOpacity
     * @returns {string}
     * @private
     */
    var _getBasicDrawingSettings = function (title, lineColor, fillColor, fillOpacity, shape, fontSize, textFontColor) {
        var rowItems = [], sectionRows = [],  textRef = 'rect-text';
        var verticalPositions = {0 :"Top", 1: "Inside", 2: "Bottom"};
        var horizontalPositions = {0 :"Left", 1: "Center", 2: "Right"};
        
        sectionRows.push(infChart.structureManager.settings.getSectionRow([infChart.structureManager.settings.getLineWeightRowItem()]));

        rowItems.push(infChart.structureManager.settings.getColorPickerRowItem('lineColorPicker', lineColor, false, 'lineColor', 'top left', 'label.lineColor'));
        if (fillColor) {
            rowItems.push(infChart.structureManager.settings.getColorPickerRowItem('fillColorPicker', fillColor, fillOpacity, 'fillColor', 'top right', 'label.fillColor'));
        }
        sectionRows.push(infChart.structureManager.settings.getSectionRow(rowItems, 'two-col-row'));


        if (shape === 'ellipse' || shape === 'rectangle') {
            var textRef = shape === 'rectangle' ? 'rect-text' : 'ellipse-text';
            sectionRows.push(infChart.structureManager.settings.getSectionRow([
                _getTextAreaRowItem('textToggle', textRef)
            ], ''));

            sectionRows.push(infChart.structureManager.settings.getSectionRow([
                infChart.structureManager.settings.getColorPickerRowItem('textColorPicker', textFontColor, false, 'textColor', 'top left', 'label.textColor')])
            );

            sectionRows.push(infChart.structureManager.settings.getSectionRow([
                infChart.structureManager.settings.getFontSizeRowItem(fontSize,(shape === 'ellipse' ? 'dropup' : '')),
            ]));
        }
        
        if (shape === 'rectangle') {
            sectionRows.push(infChart.structureManager.settings.getSectionRow([
                infChart.structureManager.settings.getRowItem("","Text Alignment", false, undefined, 'w--100')
            ], ''));
            rowItems = [];
            rowItems.push(_getDropDownList(verticalPositions, "verticalType"));
            rowItems.push(_getDropDownList(horizontalPositions, "horizontalType"));
            sectionRows.push(infChart.structureManager.settings.getSectionRow(rowItems, 'two-col-row'));

            sectionRows.push(infChart.structureManager.settings.getSectionRow([
                infChart.structureManager.settings.getRowItem("", _getApplyOptionCheckbox('extendToLeft', 'label.extendToLeft'), false)
            ],'two-col-row'));

            sectionRows.push(infChart.structureManager.settings.getSectionRow([
                infChart.structureManager.settings.getRowItem("", _getApplyOptionCheckbox('extendToRight', 'label.extendToRight'), false)
            ],'two-col-row'));
        }
        return infChart.structureManager.settings.getPanelBodyHTML([infChart.structureManager.settings.getSection(sectionRows)]) +
               _getResetToDefaultHTML();
    };

    var _getApplyOptionCheckbox = function (infCtrl, label) {
        return '<input inf-ctrl="' + infCtrl + '" type="checkbox"><label data-localize="' + label + '">' + infChart.manager.getLabel(label) + '</label>'
    };

    var _getRectangleQuickSettings = function (lineColor, fillColor, fillOpacity) {
        var html = "";
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML('lineColorPicker', 'lineColor', lineColor, false, 'top left'), "has-color-picker", infChart.manager.getLabel("label.lineColor"), "right");
        if (fillColor) {
            html += infChart.structureManager.settings.getQuicksettingListItemHTML(
                infChart.structureManager.settings.getColorPaletteHTML('fillColorPicker', 'fillColor', fillColor, fillOpacity, 'top left'), "has-color-picker", infChart.manager.getLabel("label.fillColor"), "right");
        }
        return html;
    };

    /**
     * get andrews pitchfork settings
     * rectangle + fib settings 
     * @param {settingOptions} options 
     * @returns {string} HTML
     */
    var _getAndrewsPitchForkSettings = function (options) {
        let rowItems = [];
        let sectionRows = [];
        let fibSettingsHTML = "", html = "";

        rowItems.push(infChart.structureManager.settings.getLineWeightRowItem(undefined, 'andrewsPitchfork'));
        rowItems.push(infChart.structureManager.settings.getColorPickerRowItem('lineColorPicker', options.medianLineColor, false, 'lineColor', 'top left', 'label.lineColor'));
        sectionRows.push(infChart.structureManager.settings.getSectionRow(rowItems, 'two-col-row'));

        html = infChart.structureManager.settings.getPanelBodyHTML([infChart.structureManager.settings.getSection(sectionRows, 'label.andrewsPitchforkMedian')])
        var properties = {
            fillColor: options.fillColor,
            fillOpacity: options.fillOpacity,
            lineColor: options.lineColor,
            lineWidth: options.lineWidth,
            fontColor: options.fontColor,
            fontSize: options.fontSize,
            fontWeight: options.fontWeight,
            fibLevels: options.fibLevels,
            title: 'label.levels'
        }
        fibSettingsHTML = _getFibSettings(properties);
        html += fibSettingsHTML;
        html += _getResetToDefaultHTML();

        return html;
    };

    /**
     * arrow settings
     * @param color
     * @returns {string}
     * @private
     */
    var _getArrowSettings = function (color, textMaxContent, textFontColor, textFontSize) {
        var sectionRows = [];
        sectionRows.push(infChart.structureManager.settings.getSectionRow([
            infChart.structureManager.settings.getColorPickerRowItem('colorPicker', color, false, 'color', 'top left', 'label.color')
        ], 'two-col-row'));
        
        sectionRows.push(infChart.structureManager.settings.getSectionRow([
            _getTextRowItem(textMaxContent), 
            infChart.structureManager.settings.getFontSizeRowItem(textFontSize)
        ]));

        sectionRows.push(infChart.structureManager.settings.getSectionRow([
            infChart.structureManager.settings.getColorPickerRowItem('textColorPicker', textFontColor, false, 'textColor', 'top left', 'label.textColor')])
        );

        return infChart.structureManager.settings.getPanelBodyHTML([infChart.structureManager.settings.getSection(sectionRows)]) +
               _getResetToDefaultHTML();
    };

    var _getArrowQuickSettings = function(color) {
        return infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML('colorPicker', 'color', color, false, 'top left'), "has-color-picker", infChart.manager.getLabel("label.fillColor"), "right");
    };

    /**
     * fibonacci settings
     * @param color
     * @param fibLevels
     * @returns {string}
     * @private
     */
    var _getFibSettings = function (properties) {
        var fillColor = properties.fillColor,
            fillOpacity = properties.fillOpacity,
            lineColor = properties.lineColor,
            lineWidth = properties.lineWidth,
            fontColor = properties.fontColor,
            fontSize = properties.fontSize,
            fontWeight = properties.fontWeight,
            fibLevels = properties.fibLevels,
            showFibModeToggle = properties.showFibModeToggle,
            fibModeLabel = properties.fibModeLabel,
            templates = properties.templates,
            title = properties.title,
            userDefaultSettings = properties.userDefaultSettings,
            showSnapToHighLowToggle = properties.showSnapToHighLowToggle,
            showTrendLineAlwaysToggle = properties.showTrendLineAlwaysToggle,
            trendLineColor = properties.trendLineColor,
            trendLineOpacity = properties.trendLineOpacity,
            trendLineWidth = properties.trendLineWidth,
            trendLineStyle = properties.trendLineStyle;

        var sections = [], sectionRows = [];
        var rowItems = [];
        var footerHtml = "";
        var fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);
        fibLevels.forEach(function (fibLevel, index) {
            var fillOpacity = fibLevel.hasOwnProperty('fillOpacity') ? fibLevel.fillOpacity : infChart.drawingUtils.common.baseFillOpacity;
            // var fontWeight = fibLevel.fontWeight || 'normal';

            var title = '<input inf-ctrl="fibLevel" type="checkbox" checked="checked" data-value="' + fibLevel.id + '">' +
            '<input inf-ctrl="fibLevelValue" class="fib-levels-input" maxlength="8" type="text" data-value="' + fibLevel.id + '" value="' + infChart.drawingUtils.common.formatValue((fibLevel.value/100), 3) + '" >';

            var position = index % 2 === 1 ? 'top right' : 'top left';
            rowItems.push(_getFibLevelSettingsRowItem('fibLevel', fibLevel.fillColor, fillOpacity, fibLevel.lineColor, fibLevel.lineWidth, fibLevel.fontColor, fibLevel.fontSize, fibLevel.fontWeight, fibLevel.id, position, title, false, false));
        });

        var modeOptions = [];

        if(showFibModeToggle) {
            var modeToggleCheckBox = '<input inf-ctrl="modeToggle" type="checkbox" data-value="P_all">' + fibModeLabel;
            modeOptions.push(infChart.structureManager.settings.getRowItem('', modeToggleCheckBox, false));
        }
        
        if(showSnapToHighLowToggle) {
            modeOptions.push(infChart.structureManager.settings.getRowItem('', _getSnapToHighLowToggleHTML(), false));
        }
        
        sections.push(infChart.structureManager.settings.getSection([infChart.structureManager.settings.getSectionRow(modeOptions, 'two-col-row')], 'Modes'));
        
        if (showTrendLineAlwaysToggle) {
            sections.push(infChart.structureManager.settings.getSection([infChart.structureManager.settings.getSectionRow([
            infChart.structureManager.settings.getRowItem("", _getApplyOptionCheckbox('showTrendLineAlways', 'label.ShowTrendLinesAlways'), false), ],'one-col-row'), infChart.structureManager.settings.getSectionRow([
                infChart.structureManager.settings.getRowItem(infChart.structureManager.settings.getColorPaletteHTML('trendLineColorPicker', 'P_all', trendLineColor, trendLineOpacity, 'bottom left'), 'Line Color'),
                infChart.structureManager.settings.getLineWeightRowItem(undefined, 'trendLine'),
                infChart.structureManager.settings.getLineStyleRowItem(undefined, 'trendLine')
            ],'three-col-row')], 'Trend Line'));
        }

        //one color setting
        var checkBoxTitle = '<input inf-ctrl="singleFillColorControl" type="checkbox" data-value="P_all">' +
            '<span><label data-localize="label.applyOneColor">' + infChart.manager.getLabel('label.applyOneColor') + '</label></span>';
        var singleColorSettings = infChart.structureManager.settings.getSectionRow([_getFibLevelSettingsRowItem('single', fillColor, fillOpacity,
            lineColor, lineWidth, fontColor, fontSize, fontWeight, 'P_all', 'bottom left', checkBoxTitle, false, true)], 'fib-section');
        var itemsWithSingleColor = [singleColorSettings, infChart.structureManager.settings.getSectionRow(rowItems, 'two-col-row fib-section')];
        sections.push(infChart.structureManager.settings.getSection(itemsWithSingleColor, (title ? title : 'label.fibLevels')));
        if (templates) {
            footerHtml +=  ("<div class='footer-section'>" + _getTemplateSelectionDropDownHTML(templates, userDefaultSettings) + "</div>");
        }
        
        return  infChart.structureManager.settings.getPanelBodyHTML(sections) + footerHtml;
                
    };

    /**
     * fibonacci settings
     * @param color
     * @param fibLevels
     * @returns {string}
     * @private
     */
    var _getGenericFibSettings = function (properties) {
        var extentionFillColor = properties.extentionFillColor,
            extentionFillOpacity = properties.extentionFillOpacity,
            extentionLineColor = properties.extentionLineColor,
            extentionLineWidth = properties.extentionLineWidth,
            extentionFontColor = properties.extentionFontColor,
            extentionFontSize = properties.extentionFontSize,
            extentionFontWeight = properties.extentionFontWeight,
            retrancementFillColor = properties.retrancementFillColor,
            retrancementFillOpacity = properties.retrancementFillOpacity,
            retrancementLineColor = properties.retrancementLineColor,
            retrancementLineWidth =  properties.retrancementLineWidth,
            retrancementFontColor = properties.retrancementFontColor,
            retrancementFontSize = properties.retrancementFontSize,
            retrancementFontWeight = properties.retrancementFontWeight,
            fibExtentionLevels = properties.fibExtentionLevels,
            fibRetrancementLevels = properties.fibRetrancementLevels,
            templates = properties.templates,
            showFibModeToggle = properties.showFibModeToggle,
            showSnapToHighLowToggle = properties.showSnapToHighLowToggle,
            userDefaultSettings = properties.userDefaultSettings,
            showTrendLineAlwaysToggle = properties.showTrendLineAlwaysToggle;
            trendLineColor = properties.trendLineColor,
            trendLineOpacity = properties.trendLineOpacity,
            trendLineWidth = properties.trendLineWidth,
            trendLineStyle = properties.trendLineStyle;

        var sections = [], sectionRows = [], sectionNew = [];

        var rowItemsExtention = [],
            rowItemsRetrancement = [],
        fibExtentionLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibExtentionLevels);
        fibExtentionLevels.forEach(function (fibLevel, index) {
            var fillOpacity = fibLevel.hasOwnProperty('fillOpacity') ? fibLevel.fillOpacity : infChart.drawingUtils.common.baseFillOpacity;
            var fontWeight = fibLevel.fontWeight || 'normal';

            var title = '<input inf-ctrl="fibLevel" sub-type="fibExtention" type="checkbox" checked="checked" data-value="' + fibLevel.id + '">' +
                '<input inf-ctrl="fibLevelValue" sub-type="fibExtention" class="fib-levels-input" maxlength="8" type="text" data-value="' + fibLevel.id + '" value="' + infChart.drawingUtils.common.formatValue((fibLevel.value / 100), 3) + '" >';

            var position = index % 2 === 1 ? 'top right' : 'top left';
            rowItemsExtention.push(_getFibLevelSettingsRowItem('fibLevel', fibLevel.fillColor, fillOpacity, fibLevel.lineColor, fibLevel.lineWidth, fibLevel.fontColor, fibLevel.fontSize, fontWeight, fibLevel.id, position, title, false, false, 'fibExtention'));
        });

        fibRetrancementLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibRetrancementLevels);
        fibRetrancementLevels.forEach(function (fibLevel, index) {
            var fillOpacity = fibLevel.hasOwnProperty('fillOpacity') ? fibLevel.fillOpacity : infChart.drawingUtils.common.baseFillOpacity;
            var fontWeight = fibLevel.fontWeight || 'normal';

            var title = '<input inf-ctrl="fibLevel" sub-type="fibRetracement" type="checkbox" checked="checked" data-value="' + fibLevel.id + '">' +
                '<input inf-ctrl="fibLevelValue" sub-type="fibRetracement" class="fib-levels-input" maxlength="8" type="text" data-value="' + fibLevel.id + '" value="' + infChart.drawingUtils.common.formatValue((fibLevel.value / 100), 3) + '" >';

            var position = index % 2 === 1 ? 'top right' : 'top left';
            rowItemsRetrancement.push(_getFibLevelSettingsRowItem('fibLevel', fibLevel.fillColor, fillOpacity, fibLevel.lineColor, fibLevel.lineWidth, fibLevel.fontColor, fibLevel.fontSize, fontWeight, fibLevel.id, position, title, false, false, 'fibRetracement'));
        });

        var modeOptions = [];

        if(showFibModeToggle) {
            var modeToggleCheckBox = '<input inf-ctrl="modeToggle" type="checkbox" data-value="P_all">' + fibModeLabel;
            modeOptions.push(infChart.structureManager.settings.getRowItem('', modeToggleCheckBox, false));
        }
        
        if(showSnapToHighLowToggle) {
            modeOptions.push(infChart.structureManager.settings.getRowItem('', _getSnapToHighLowToggleHTML(), false));
        }
        
        sections.push(infChart.structureManager.settings.getSection([infChart.structureManager.settings.getSectionRow(modeOptions, 'two-col-row')], 'Modes'));
        

        if(showTrendLineAlwaysToggle) {
            sections.push(infChart.structureManager.settings.getSection([infChart.structureManager.settings.getSectionRow([
            infChart.structureManager.settings.getRowItem("", _getApplyOptionCheckbox('showTrendLineAlways', 'label.ShowTrendLinesAlways'), false),], 'one-col-row'), infChart.structureManager.settings.getSectionRow([
                infChart.structureManager.settings.getRowItem(infChart.structureManager.settings.getColorPaletteHTML('trendLineColorPicker', 'P_all', trendLineColor, trendLineOpacity, 'bottom left'), 'Line Color'),
                infChart.structureManager.settings.getLineWeightRowItem(undefined, 'trendLine'),
                infChart.structureManager.settings.getLineStyleRowItem(undefined, 'trendLine')
            ],'three-col-row')], 'Trend Line'));
        }

        //one color setting
        var checkBoxTitleExtention = '<input inf-ctrl="singleExtentionFillColorControl" type="checkbox" data-value="P_all">' +
            '<span><label data-localize="label.applyOneColor">' + infChart.manager.getLabel('label.applyOneColor') + '</label></span>';
        var checkBoxTitleRetrancement = '<input inf-ctrl="singleRetrancementFillColorControl" type="checkbox" data-value="P_all">' +
            '<span><label data-localize="label.applyOneColor">' + infChart.manager.getLabel('label.applyOneColor') + '</label></span>';

        
        var extentionSingleColorSettings = infChart.structureManager.settings.getSectionRow([_getFibLevelSettingsRowItem('single', extentionFillColor, extentionFillOpacity,
        extentionLineColor, extentionLineWidth, extentionFontColor, extentionFontSize, extentionFontWeight, 'P_all', 'bottom left', checkBoxTitleExtention, false, true, 'fibExtention', 'apply-to-all')], 'fib-section has-one-color');
        var extentionAlignSettings = infChart.structureManager.settings.getSectionRow([infChart.structureManager.settings.getTextAlignRowItem("fibExtentionAlign")],'fib-section text-align');
        var retrancementSingleColorSettings = infChart.structureManager.settings.getSectionRow([_getFibLevelSettingsRowItem('single', retrancementFillColor, retrancementFillOpacity,
        retrancementLineColor, retrancementLineWidth, retrancementFontColor, retrancementFontSize, retrancementFontWeight, 'P_all', 'bottom left', checkBoxTitleRetrancement, false, true, 'fibRetracement', 'apply-to-all')], 'fib-section has-one-color');
        var retracementAlignSettings = infChart.structureManager.settings.getSectionRow([infChart.structureManager.settings.getTextAlignRowItem("fibRetracementAlign")],'fib-section text-align');
        
        var itemsExtentionWithSingleColor = [extentionAlignSettings, extentionSingleColorSettings, infChart.structureManager.settings.getSectionRow(rowItemsExtention, 'fib-section')];
        var itemsRetrancementWithSingleColor = [retracementAlignSettings, retrancementSingleColorSettings, infChart.structureManager.settings.getSectionRow(rowItemsRetrancement, 'fib-section')];
        sectionNew.push(infChart.structureManager.settings.getSection(itemsExtentionWithSingleColor, 'label.fibExtentionLevels'));
        sectionNew.push(infChart.structureManager.settings.getSection(itemsRetrancementWithSingleColor, 'label.fibRetrancementLevels'));
        return "<div class ='gen-tool-settings'>" +
            infChart.structureManager.settings.getPanelBodyHTML(sections) +
            infChart.structureManager.settings.getSectionBodyHTML(sectionNew) +
            "<div class='footer-section'>" +
            _getTemplateSelectionDropDownHTML(templates, userDefaultSettings) +
            "</div>" +
            "</div>";
    };

    var _getGenericQuickFibSettings = function () {
        return "";
    };

    var _getFibQuickSettings = function (ctrlType, fillColor, fillOpacity, lineColor, fontColor, fontSize) {
        var html = "";
        var singleFillColor = '<input inf-ctrl="singleFillColorControl" type="checkbox" data-value="P_all">';
        var fontSizeDropDown = '<div class="dropdown font-size">' +
                '<button class="dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">' +
                    '<span inf-ctrl="' + ctrlType + 'SelectedFontSize" inf-ctrl-val="P_all" inf-size="' + fontSize + '">' + fontSize + '</span>' +
                    '<span class="caret"></span>' +
                '</button>' +
                _getFibFontSizeHTML('dropdown-menu', ctrlType) +
            '</div>';
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(singleFillColor, "d--none");
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML(ctrlType + 'FillColorPicker', 'P_all', fillColor, fillOpacity, 'top left'), "has-color-picker", infChart.manager.getLabel("label.fillColor"), "right");
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML(ctrlType + 'LineColorPicker', 'P_all', lineColor, false, 'top left'), "has-color-picker", infChart.manager.getLabel("label.lineColor"), "right");
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(fontSizeDropDown, "has-dropdown" , infChart.manager.getLabel("label.fontSize"), "right");
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML(ctrlType + 'FontColorPicker', 'P_all', fontColor, false, 'top left'), "has-color-picker", infChart.manager.getLabel("label.fontColor"), "right");
        return html;
    };

    /**
     * label settings
     * @returns {string}
     * @private
     */
    var _getLabelSettings = function (fontSize) {
        var sectionRows = [];
        var maxCharacterLength = 200;

        sectionRows.push(infChart.structureManager.settings.getSectionRow([
            _getTextRowItem(maxCharacterLength),
            infChart.structureManager.settings.getFontSizeRowItem(fontSize),
            infChart.structureManager.settings.getFontWeightRowItem()
        ]));

        sectionRows.push(infChart.structureManager.settings.getSectionRow([
                infChart.structureManager.settings.getColorPickerRowItem('colorPicker', infChart.labelDrawing.borderColor, false, 'color', 'top left', 'label.color')])
        );

        sectionRows.push(infChart.structureManager.settings.getSectionRow([
            infChart.structureManager.settings.getRowItem("", _getColorPickerWithCheckbox('borderColorPicker', 'color', infChart.labelDrawing.borderColor, false, 'top left', 'borderColorEnabled', 'label.borderColor'), false),
            infChart.structureManager.settings.getRowItem("", _getColorPickerWithCheckbox('backgroundColorPicker', 'color', infChart.labelDrawing.backgroundColor, false, 'top left', 'backgroundColorEnabled', 'label.backgroundColor'), false)
        ],'two-col-row'));

        return infChart.structureManager.settings.getPanelBodyHTML([infChart.structureManager.settings.getSection(sectionRows)]) +
                _getResetToDefaultHTML();
    };

    var _getColorPickerWithCheckbox = function (ctrlType, ctrlValue, color, opacity, position, infCtrl, label) {
        var html = "";
        html += '<input inf-ctrl="' + infCtrl + '" type="checkbox"><label data-localize="' + label + '">' + infChart.manager.getLabel(label) + '</label>' + infChart.structureManager.settings.getColorPaletteHTML(ctrlType, ctrlValue, color, opacity, position)

        return html;
    };

    var _getLabelQuickSettings = function (fontSize) {
        var html = "";
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getFontSizeHTML(fontSize), "has-dropdown", infChart.manager.getLabel("label.fontSize"), "right" );
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML('colorPicker', 'color', infChart.labelDrawing.borderColor, false, 'top left'), "has-color-picker", infChart.manager.getLabel("label.fontColor"), "right");
        return html;
    };

    /**
     * high/low labels settings
     * @returns {string}
     * @private
     */
    var _getHighLowLabelsSettings = function (labelDataItems) {
        var sectionRows = [];

        var rowItems = [];

        labelDataItems.forEach(function (labelDataItem, index) {
            var uniqueId = labelDataItem.id + new Date().getTime();
            var labelDataItemHTML = '<input inf-ctrl="labelDataItem" type="checkbox" checked="checked" id="' + uniqueId + '" data-value="' + labelDataItem.id + '">' +
                '<label for="' + uniqueId + '">'+ labelDataItem.displayName +'</label>';

            rowItems.push(infChart.structureManager.settings.getRowItem( "", labelDataItemHTML, false));
        });

        sectionRows.push(infChart.structureManager.settings.getSectionRow(rowItems , 'setting-section'));

        sectionRows.push(infChart.structureManager.settings.getSectionRow([
            infChart.structureManager.settings.getColorPickerRowItem('colorPicker', infChart.labelDrawing.borderColor, false, 'color', 'top left', 'label.color')], 'two-col-row')
        );

        return  infChart.structureManager.settings.getPanelBodyHTML([infChart.structureManager.settings.getSection(sectionRows)]) +
                _getResetToDefaultHTML();
    };

    var _getHighLowLabelsQuickSettings = function () {
        return infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML('colorPicker', 'color', infChart.labelDrawing.borderColor, false, 'top left'), "has-color-picker", infChart.manager.getLabel("label.fontColor"), "right");
    };

    /**
     * regression channel settings
     * @param levels
     * @returns {string}
     * @private
     */
    var _getRegressionChannelSettings = function (levels, lineColor, lineWidth) {
        var rowItems = [];
        rowItems.push(infChart.structureManager.settings.getColorPickerRowItem('lineColorPicker', lineColor || infChart.drawingUtils.common.baseBorderColor, false, 'lineColor', 'top left', 'label.lineColor'));
        var i = 1;
        $.each(levels, function (id, level) {
            var fillOpacity = level.fillOpacity ? level.fillOpacity : infChart.drawingUtils.common.baseFillOpacity;
            var fillColor = level.fillColor ? level.fillColor : infChart.drawingUtils.common.baseFillColor;
            var position = i % 2 === 1 ? 'top right' : 'top left';
            i++;
            rowItems.push(infChart.structureManager.settings.getColorPickerRowItem('fillColorPicker', fillColor, fillOpacity, level.id, position, level.label));
        });

        var sectionRows = [];
        sectionRows.push(infChart.structureManager.settings.getSectionRow([infChart.structureManager.settings.getLineWeightRowItem()]));
        sectionRows.push(infChart.structureManager.settings.getSectionRow(rowItems, 'two-col-row'));

        return infChart.structureManager.settings.getPanelBodyHTML([infChart.structureManager.settings.getSection(sectionRows)]) +
               _getResetToDefaultHTML();
    };

    var _getRegressionChannelQuickSettings = function (levels, lineColor) {
        var html = '';
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML('lineColorPicker', 'color', lineColor || infChart.drawingUtils.common.baseBorderColor, false, 'top left'), "has-color-picker", infChart.manager.getLabel("label.lineColor"), "right");
        $.each(levels, function (id, level) {
            var fillOpacity = level.fillOpacity ? level.fillOpacity : infChart.drawingUtils.common.baseFillOpacity;
            var fillColor = level.fillColor ? level.fillColor : infChart.drawingUtils.common.baseFillColor;
            html += infChart.structureManager.settings.getQuicksettingListItemHTML(infChart.structureManager.settings.getColorPaletteHTML('fillColorPicker', level.id, fillColor, fillOpacity, 'top left'), "has-color-picker", infChart.manager.getLabel("label.fillColor"), "right");
        });
        return html;
    };

    var _getDrawing = function (setting, isFavorite) {
        var span, visibleSpan, visibleShape, visibleSubType, category, options, link, linkClass, label = '', extraSpan, toolTip, favoriteIcon = '', favoriteListAttribute = '';
        var listStyle = "dropdown"
        if (setting.options && setting.options.length > 0) {
            options = '<ul class="dropdown-menu" role="menu">';
            linkClass = 'dropdown-option';
            infChart.util.forEach(setting.options, function (i, obj) {
                span = '<span rel="icon-span" class="' + obj.cls + '"' + (obj.style ? 'style="' + obj.style + '"' : '' ) + '></span>';
                label = obj.label ? obj.label : "";
                extraSpan = '<span class="drawing-line-text"  data-localize="' + label +'">' + infChart.manager.getLabel(label) + '</span>';
                if (obj.isFavorite != undefined) {
                    favoriteIcon = '<span rel="icon-span" class="favourite-option" inf-ctrl=drawing-fav drawing-cat="' + setting.cat + '" inf-ctrl-shape="' + obj.shape + '"'
                    + infChart.structureManager.toolbar.getToolTipAttributes(_getFavoriteTooltip(obj.isFavorite), "top") + '><i rel="icon-i" class="icom ' + _getStarIcon(obj.isFavorite) + '"></i></span>';
                } 
                if (obj.active === true) {
                    visibleSpan = span;
                    visibleShape = obj.shape;
                    visibleSubType = obj.subType;
                    options += '<li><a target="_self" ' + toolTip + 'class="active" inf-ctrl="' + setting.role + '" inf-ctrl-shape="' + obj.shape + '" inf-ctrl-subType="' 
                    + obj.subType + '" drawing-cat="' + setting.cat + '" ' + '>' + span + extraSpan + favoriteIcon +'</a></li>';
                } else {
                    options += '<li><a target="_self" ' + toolTip + ' inf-ctrl="' + setting.role + '" inf-ctrl-shape="' + obj.shape + '" inf-ctrl-subType="' + obj.subType + '" drawing-cat="' 
                    + setting.cat + '" ' + '><span rel="icon-span" class="' + obj.cls + '"' + (obj.style ? 'style="' + obj.style + '"' : '' ) + '"></span>' + extraSpan + favoriteIcon +'</a></li>';
                }
            });
            options += '</ul>';
        } else {
            options = '';
            if (setting.role === 'drawing' && setting.shape) {
                visibleShape = setting.shape;
            }
            if (setting.role === 'drawing' && setting.subType) {
                visibleSubType = setting.subType;
            }
            visibleSpan = '<span class="' + setting.cls + '"' + (setting.style ? 'style="' + setting.style + '"' : '' ) + '></span>';
        }
        if (setting.active === true && !_isAllowedToAddFavorite(setting)) {
            linkClass = linkClass ? linkClass + ' active' : 'active';
        }
        label = setting.label ? setting.label : "";
        if (setting.role === 'drawing') {

            link = '<a  target="_self"  inf-ctrl="drawCat" inf-ctrl-role="' + setting.role + '" ' + ' draw-cat="' + setting.cat + '" inf-ctrl-shape="' + visibleShape + '"' +
                (visibleSubType ? ' inf-ctrl-subType="' + visibleSubType + '"' : '') + '  role="button" ' +
                (linkClass ? ' class="' + linkClass + '"' : '') + '   ' + infChart.structureManager.toolbar.getToolTipAttributes(label, "right") + ' >' + visibleSpan + '</a>';
        } else {
            link = '<a target="_self"  inf-ctrl="drawCat" inf-ctrl-role="' + setting.role + '" ' + ' draw-cat="' + setting.cat + '" role="button" ' +
                (linkClass ? ' class="' + linkClass + '"' : '') + '  ' + infChart.structureManager.toolbar.getToolTipAttributes(label, "right") + ' >' + visibleSpan + '</a>';
        }
        if(isFavorite){
            listStyle = "flt-tlbar__item";
            favoriteListAttribute = ' inf-fav-list="' + setting.shape + '" ' + " " + 'rel="fav-toolbar-item"'
        }
        return '<li class=' + listStyle + favoriteListAttribute + '>' + link + options + '</li>';
    };

    var _getStarIcon = function(isFavorite) {
        if (isFavorite) {
            return 'icom-star';
        } else {
            return 'icom-star-o';
        }
    };

    var _getFavoriteTooltip = function(isFavorite) {
        if (isFavorite) {
            return 'label.removeFromFavorite';
        } else {
            return 'label.addToFavorite';
        }
    };

    var _isAllowedToAddFavorite = function(setting) {
        return setting && setting.isFavorite;
    };

    /**
     * get drawing toolbar HTML
     * @param {object} container - main container - tb-left
     * @param {object} leftTb - left toolbar settings
     * @param {object} config - toolbar config
     */
    var _getDrawingToolBarHTML = function (container, leftTb, config) {
        if (leftTb.length > 0){
            var html = '';
            html += _getDrawingToolBarToggleButtonHTML(config.leftTBToggleButton);
            html += '<div inf-pnl="tb-drawing-nav-container" class="toolbar-container">' + _getDrawingToolBarScrollButtonsHTML(config.leftTBScrollButtons);
            html += '<ul inf-pnl="tb-drawing-nav" class="nav navbar-nav2 chart-drawing">';
            infChart.util.forEach(leftTb, function (i, key) {
                html += _getDrawing(config[key], false);
            });
            html += '</ul></div>';
            container.addClass('chart-left-toolbar');
            container.html(html);
        }
    };

    /**
     * get favorite toolbar HTML
     * @param {object} container - main container - tb-left
     * @param {object} leftTb - left toolbar settings
     * @param {object} config - toolbar config
     */
    var _getfavoriteToolBarHTML = function (container, leftTb, config) {
        var html = '';
        var drgHandleeToolTip = infChart.structureManager.toolbar.getToolTipAttributes(infChart.manager.getLabel("label.dragToolbar"), "right");
        html += '<div class="flt-tlbar" inf-container="favorite-menu">';
        html += '<div class="flt-tlbar__item flt-tlbar__handler flt-tlbar__drag" ' + drgHandleeToolTip + '> <i class="icon ico-braille"></i></div>';
        html += '<ul rel="fav-panel-drawing-list" class="flt-tlbar__tools">';
        const favoriteDrawings = [];
        infChart.util.forEach(leftTb, function (i, key) {
            if (config[key].options) {
                config[key].options.forEach(option => {
                    if (option.isFavorite) {
                        option.role = config[key].role;
                        option.cat = config[key].cat;
                        favoriteDrawings.push(option);
                    }
                });
            } else {
                if (config[key].isFavorite) {
                    favoriteDrawings.push(config[key]);
                }
            }
        });

        favoriteDrawings.forEach(fav => {
            html += _getDrawing(fav,true);
        });
        html += '</ul>';
       // html += '<div class="flt-tlbar__item flt-tlbar__handler flt-tlbar__close" inf-ctrl="closeFavorite"> <i class="icom icom-close"></i></div>';
        html += '</div>';
        container.html(html);
    };

    /**
     * get drawing toolbar toggle button HTML
     * @param {object} config
     * @returns {string} toolbar toggle btn html
     */
    var _getDrawingToolBarToggleButtonHTML = function (config) {
        return '<button class="panel-toggle" inf-ctrl="tb-drawing-toggle"' + infChart.structureManager.toolbar.getToolTipAttributes(config.label, "right") +
            '><i class="' + config.showCls + '"></i></button>';
    };

    /**
     * get left tool bar scroll buttons
     * @param {object} config
     * @returns {string} toolbar scroll btns html
     */
    var _getDrawingToolBarScrollButtonsHTML = function (config) {
        return '<button inf-ctrl="tb-drawing-scroll-top" class="btn-scroll top"><i class="' + config.top.cls + '"></i></button>' +
            '<button inf-ctrl="tb-drawing-scroll-bottom" class="btn-scroll bottom"><i class="' + config.bottom.cls + '"></i></button>';
    };

    /**
     * bind line settings
     * @param {object} $container - main container
     * @param {function} onColorChange - color change function
     * @param {function} onLineWidthChange - line width change function
     * @param {function} onLineStyleChange - line style change function
     * @param {function} onLabelItemsChange - On Label change function
     */
    var _bindLineSettings = function ($container, callBackFnLineSettingsEvents) {
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=lineColorPicker]"), undefined, function (rgba, value, opacity) {
            callBackFnLineSettingsEvents.onLineColorChange(rgba, value, opacity);
        });
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=textColorPicker]"), undefined, callBackFnLineSettingsEvents.onTextColorChange);
        _bindSeriesLineWidthEvents($container, callBackFnLineSettingsEvents.onLineWidthChange);
        $container.find("li[inf-ctrl=lineStyle]").on('click', function (e) {
            var dashStyle = $(this).attr("inf-style");
            $container.find("li[inf-ctrl=lineStyle]").removeClass('active');
            $(this).addClass('active');
            callBackFnLineSettingsEvents.onLineStyleChange(dashStyle);
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=labelDataItem]").on('click', function (e) {
            callBackFnLineSettingsEvents.onLabelItemsChange($(this).attr("data-value"), $(this).is(":checked"));
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=extendToLeft]").on('click', function (e) {
            callBackFnLineSettingsEvents.onLineExtendToLeft($(this).is(":checked"));
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=extendToRight]").on('click', function (e) {
            callBackFnLineSettingsEvents.onLineExtendToRight($(this).is(":checked"));
            e.stopPropagation();
        });

        $container.find('li[inf-ctrl=startArrowHeadType]').on('click', function (e) {
            var arrowHeadType = $(this).attr("inf-type");
            $container.find('li[inf-ctrl=startArrowHeadType]').removeClass('active');
            $(this).addClass('active');
            var type = arrowHeadType === 'arrowHead';
            callBackFnLineSettingsEvents.onStartArrowHeadTypeChange(type);
            e.stopPropagation();
        });

        $container.find('li[inf-ctrl=endArrowHeadType]').on('click', function (e) {
            var arrowHeadType = $(this).attr("inf-type");
            $container.find('li[inf-ctrl=endArrowHeadType]').removeClass('active');
            $(this).addClass('active');
            var type = arrowHeadType === 'arrowHead';
            callBackFnLineSettingsEvents.onEndArrowHeadTypeChange(type);
            e.stopPropagation();
        });

        $container.find("li[inf-ctrl=fontSize]").on('click', function (e) {
            var fontSize = $(this).attr('inf-size');
            callBackFnLineSettingsEvents.onTextSizeChange(fontSize);
            var ctrlType = $(this).parent().attr('inf-ctrl');
            $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedFontSize]").text($(this).text()).attr('inf-size', fontSize);
        });

        $container.find("textarea[inf-ctrl=line-text]").on('keyup', function (event) {
            callBackFnLineSettingsEvents.onLineTextChange($(this).val());
        });

        $container.find("textarea[inf-ctrl=line-text]").on('input', function (event) {
            if (event.originalEvent.inputType === "insertFromDrop") {
            callBackFnLineSettingsEvents.onLineTextChange($(this).val());
            }
        });

        $container.find("li[inf-ctrl=fontStyle]").on('click', function (e) {
            var style = $(this).attr('inf-style'), checked = $(this).hasClass('active');
            if(style === 'italic'){
                callBackFnLineSettingsEvents.onTextFontStyleChange(style, !checked);
            }
            if(style === 'bold') {
                callBackFnLineSettingsEvents.onTextFontWeightChange(style, !checked);
            }
            if(style === 'underline'){
                callBackFnLineSettingsEvents.onTextFontDecorationChange(style, !checked);
            }
            if (checked) {
                $(this).removeClass('active');
            } else {
                $(this).addClass('active');
            }
            e.stopPropagation();
        });


        $container.find("input[inf-ctrl=textToggle]").on('click', function (e) {
            callBackFnLineSettingsEvents.onToggleLineText($(this).is(":checked"));
                $container.find("input[inf-ctrl=line-text]").focus()
            e.stopPropagation();
        });

        _bindResetToDefaultEvent($container , callBackFnLineSettingsEvents.onResetToDefault);
    };

    var _updateLineSettings = function ($container, settings, labelDataItems, styles, lineText) {
        $container.find('li[inf-ctrl="lineWidth"]').removeClass('active');
        $container.find('li[inf-ctrl="lineStyle"]').removeClass('active');
        $container.find('li[inf-ctrl="lineWidth"][inf-size="' + settings.lineWidth + '"]').addClass('active');
        $container.find('li[inf-ctrl="lineStyle"][inf-style="' + settings.lineStyle + '"]').addClass('active');
        
        let lineColorEle = $container.find('input[inf-ctrl="lineColorPicker"]');
        lineColorEle.data('minicolors-initialized', false);
        lineColorEle.mainColorPanel('value', settings.lineColor);
        lineColorEle.mainColorPanel('opacity', settings.lineOpacity);
        lineColorEle.data('minicolors-initialized', true);

        $container.find('li[inf-ctrl="startArrowHeadType"]').removeClass('active');
        $container.find('li[inf-ctrl="endArrowHeadType"]').removeClass('active');
        var startArrowHeadType = settings.isStartPoint ? 'arrowHead' : 'normalHead';
        var endArrowHeadType = settings.isEndPoint ? 'arrowHead' : 'normalHead';
        $container.find('li[inf-ctrl="startArrowHeadType"][inf-type="' + startArrowHeadType + '"]').addClass('active');
        $container.find('li[inf-ctrl="endArrowHeadType"][inf-type="' + endArrowHeadType + '"]').addClass('active');

        
        let textColorEle = $container.find('input[inf-ctrl="textColorPicker"]');
        textColorEle.data('minicolors-initialized', false);
        textColorEle.mainColorPanel('value', settings.textColor);
        textColorEle.mainColorPanel('opacity', settings.textOpacity);
        textColorEle.data('minicolors-initialized', true);

        if(labelDataItems && labelDataItems.length > 0){
            $.each(labelDataItems, function (key, labelDataItem) {
                $container.find('input[inf-ctrl="labelDataItem"][data-value="' + labelDataItem.id + '"]').prop('checked', labelDataItem.enabled);
            });
        }
        if(lineText !== undefined) {
            $container.find("textarea[inf-ctrl=line-text]").val(lineText);
        }
        if(settings.lineTextChecked) {
            $container.find('input[inf-ctrl="textToggle"]').prop('checked', settings.lineTextChecked);
            $container.find("input[inf-ctrl=line-text]").removeAttr("disabled");
            $container.find("input[inf-ctrl=textColorPicker]").removeAttr("disabled");
            $($container.find("span[inf-ctrl=singleSelectedFontSize]")[0]).parent().removeAttr("disabled");
            setTimeout(() => {
                $container.find("textarea[inf-ctrl=line-text]").focus();
            }, 0);
        } else if (settings.lineTextChecked === false){
            $container.find("textarea[inf-ctrl=line-text]").attr("disabled","disabled");
            $container.find("input[inf-ctrl=textColorPicker]").attr("disabled","disabled");
            $($container.find("span[inf-ctrl=singleSelectedFontSize]")[0]).parent().attr("disabled","disabled");
        }
        $container.find('span[inf-ctrl="singleSelectedFontSize"][inf-ctrl-val="P_all"]').text(settings.textFontSize);
        $container.find('span[inf-ctrl="singleSelectedFontSize"][inf-ctrl-val="P_all"]').attr('inf-size', settings.textFontSize);
        $container.find('input[inf-ctrl="extendToRight"]').prop('checked', settings.isExtendRight);
        $container.find('input[inf-ctrl="extendToLeft"]').prop('checked', settings.isExtendLeft);

        $container.find('li[inf-ctrl=fontStyle]').removeClass('active');
        infChart.util.forEach(styles, function (i, style) {
            $container.find('li[inf-ctrl=fontStyle][inf-style="' + style + '"]').addClass('active');
        });
    };

    /**
     * bind line settings
     * @param {object} $container - main container
     * @param {function} onColorChange - color change function
     * @param {function} onLineWidthChange - line width change function
     * @param {function} onLineStyleChange - line style change function
     * @param {function} onLabelItemsChange - On Label change function
     */
    var _bindPriceLineSettings = function ($container, onEntryValueChange, onLineApply, onPriceValueChange, onPriceLineWidthChange, onPriceLineStyleChange, onResetToDefault, onSubLineColorChange, priceLines) {

        $container.find("input[inf-ctrl=entryValue]").on('keypress', function (e) {
            if (e.which == 13) {
                e.preventDefault();
                $(this).trigger("blur");
            }
        });

        $container.find("input[inf-ctrl=entryValue]").on('blur', function (e) {
            var entryValue = $(this).val();
            if (entryValue !== "" && !isNaN(entryValue)) {
                onEntryValueChange($(this), entryValue);
            } else {
                $(this).parent().addClass('has-error');
            }
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=entryValue]").on('click', function (e) {
            $(this).parent().removeClass('has-error');
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=applyPriceLine]").on('click', function (e) {
            onLineApply($(this).is(":checked"), $(this).attr("inf-value"));
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=labelDataItem]").on('click', function (e) {
            onLabelItemsChange($(this).attr("data-value"), $(this).is(":checked"));
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=priceLevelValue]").on('keypress', function (e) {
            if (e.which == 13) {
                e.preventDefault();
                $(this).trigger("blur");
            }
        });

        $container.find("input[inf-ctrl=priceLevelValue]").on('blur', function (e) {
            var priceValue = $(this).val();
            var type = $(this).attr('inf-value');
            if (priceValue !== "" && !isNaN(priceValue)) {
                onPriceValueChange($(this), priceValue, type);
            } else {
                $(this).parent().addClass('has-error');
            }
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=priceLevelValue]").on('click', function (e) {
            $(this).parent().removeClass('has-error');
            e.stopPropagation();
        });

        $container.find('li[inf-ctrl=lineWidth]').on('click', function (e) {
            var strokeWidth = $(this).attr("inf-size");
            var ctrlType = $(this).parent().attr('inf-ctrl');
            var id = $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedLineWidth]").attr('inf-ctrl-val');
            $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedLineWidth]").text($(this).text());
            $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedLineWidth]").attr('inf-size', strokeWidth);
            onPriceLineWidthChange(id, strokeWidth);
        });

        $container.find('li[inf-ctrl=lineStyle]').on('click', function (e) {
            var lineStyle = $(this).attr("inf-style");
            var ctrlType = $(this).parent().attr('inf-ctrl');
            var id = $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedLineStyle]").attr('inf-ctrl-val');
            var childEle = ($(this).children().children()).clone();
            $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedLineStyle]").html(childEle);
            $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedLineStyle]").attr('inf-style', lineStyle);
            onPriceLineStyleChange(id, lineStyle);
        });

        priceLines.takeProfits.forEach(function(priceLineLevel){
            infChart.util.bindColorPicker($container.find("input[inf-ctrl=lineColorPicker][inf-ctrl-val=" + priceLineLevel.id + "]"), undefined, function(rgb, value){
                onSubLineColorChange(rgb, value, $(this).attr("inf-ctrl-val"))
            });
        });

        priceLines.stopLoss.forEach(function(priceLineLevel){
            infChart.util.bindColorPicker($container.find("input[inf-ctrl=lineColorPicker][inf-ctrl-val=" + priceLineLevel.id + "]"), undefined,function(rgb, value){
                onSubLineColorChange(rgb, value, $(this).attr("inf-ctrl-val"))
            });
        });        

        _bindResetToDefaultEvent($container, onResetToDefault);
    };

    /**
     * bind rectangle settings
     * @param {object} $container - main container
     * @param {function} onColorChange - color change function
     * @param {function} onLineWidthChange - line width change function
     * @param {function} onFillColorChange - fill color change function
     */
    var _bindBasicDrawingSettings = function ($container, callBackFn, shape) {
        var textRef = shape === 'rectangle' ? 'rect-text': 'ellipse-text';
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=lineColorPicker]"), undefined, callBackFn.onColorChange);
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=textColorPicker]"), undefined, callBackFn.onTextColorChange);
        if (callBackFn.onFillColorChange) {
            infChart.util.bindColorPicker($container.find("input[inf-ctrl=fillColorPicker]"), undefined, callBackFn.onFillColorChange);
        }

        $container.find("textarea[inf-ctrl=" + textRef + " ]").on('keyup', function (event) {
            var text = $(this).val();
            if(event.which == 27 || event.keyCode === 13){
                text = text + '<br/>';
            }
            callBackFn.onBasicDrawingTextChange(text);
        });

        $container.find("li[inf-ctrl=fontSize]").on('click', function (e) {
            var fontSize = $(this).attr('inf-size');
            callBackFn.onTextSizeChange(fontSize);
            var ctrlType = $(this).parent().attr('inf-ctrl');
            $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedFontSize]").text($(this).text()).attr('inf-size', fontSize);
        });

        $container.find("input[inf-ctrl=textToggle]").on('click', function (e) {
            callBackFn.onToggleBasicDrawingText($(this).is(":checked"));
            $container.find("textarea[inf-ctrl=" + textRef + " ]").focus();
            e.stopPropagation();
        });

        $container.find("ul[inf-ctrl=dropDown]").find("li[rel=verticalType]").on('click', function (event) {
            $container.find("div[inf-ctrl=verticalType]").find("span[rel=selectItem]").text($(this).find('a').text());
            callBackFn.onVerticalPositionSelect($(this).find('a').text());
            $container.find("div[inf-ctrl=verticalType]").find('[rel=dropDownButton]').click();
            event.stopPropagation();      
        });

        $container.find("ul[inf-ctrl=dropDown]").find("li[rel=horizontalType]").on('click', function (event) {
            $container.find("div[inf-ctrl=horizontalType]").find("span[rel=selectItem]").text($(this).find('a').text());
            callBackFn.onHorizontalPositionSelect($(this).find('a').text());
            $container.find("div[inf-ctrl=horizontalType]").find('[rel=dropDownButton]').click()
            event.stopPropagation();       
        });

        $container.find("input[inf-ctrl=extendToLeft]").on('click', function (e) {
            callBackFn.onExtendToLeft($(this).is(":checked"));
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=extendToRight]").on('click', function (e) {
            callBackFn.onExtendToRight($(this).is(":checked"));
            e.stopPropagation();
        });

        _bindSeriesLineWidthEvents($container, callBackFn.onLineWidthChange);
        _bindResetToDefaultEvent($container , callBackFn.onResetToDefault);
    };

    var _bindAndrewsPitchForkSettings = function ($container, bindOptions) {
        _bindSeriesLineWidthEvents($container.find('ul[inf-ctrl=andrewsPitchfork]'), bindOptions.onLineWidthChange);
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=lineColorPicker]"), undefined, bindOptions.onColorChange);
        _bindFibSettings($container, bindOptions);
        _bindResetToDefaultEvent($container, bindOptions.onResetToDefault);
    };

    /**
     * bind arrow settings
     * @param {object} $container - main container
     * @param {function} onColorChange - color change function
     */
    var _bindArrowSettings = function ($container, arrowDrawingEvents) {
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=colorPicker]"), undefined, arrowDrawingEvents.onColorChange);
        _bindFontTextSetting($container, arrowDrawingEvents.onTextChange);
        _bindFontSizeSetting($container, arrowDrawingEvents.onFontSizeChange);
        _bindResetToDefaultEvent($container , arrowDrawingEvents.onResetToDefault);
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=textColorPicker]"), undefined, arrowDrawingEvents.onFontColorChange);
    };

    var _bindFontSizeSetting = function($container, onFontSizeChange) {
        $container.find("li[inf-ctrl=fontSize]").on('click', function (e) {
            var fontSize = $(this).attr('inf-size');
            onFontSizeChange(fontSize);
            var ctrlType = $(this).parent().attr('inf-ctrl');
            $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedFontSize]").text($(this).text()).attr('inf-size', fontSize);
        });
    }

    var _bindFontTextSetting = function($container, onTextChange) {
        $container.find("textarea[inf-ctrl=text]").on('keyup', function () {
            onTextChange($(this).val());
        }).on('blur', function () {
            var text = $(this).val();

            if (text === "") {
                $(this).val("");
                onTextChange("");
            }
        });
    }

    /**
     * get fib level input field values
     * @param {Object} $container - main container
     * @returns {Object} previous fib options
     */
    var _getFibLevelInputValues = function ($container) {
        var prevOptions = {};
        var fillColorPickers = $container.find("input[inf-ctrl=fibLevelFillColorPicker]");
        var lineColorPickers = $container.find("input[inf-ctrl=fibLevelLineColorPicker]");
        var lineWidthSelectors = $container.find("span[inf-ctrl=fibLevelSelectedLineWidth]");
        var fontColorPickers = $container.find("input[inf-ctrl=fibLevelFontColorPicker]");
        var fontSizeSelectors = $container.find("span[inf-ctrl=fibLevelSelectedFontSize]");
        var fontWeightSelectors = $container.find("button[inf-ctrl=fibLevelToggleFontWeight]");
        for (var i = 0; i < fillColorPickers.length; i++) {
            var fibLevelId = $(fillColorPickers[i]).attr('inf-ctrl-val');
            prevOptions[fibLevelId] = {
                fillColor: $(fillColorPickers[i]).val(),
                fillOpacity: $(fillColorPickers[i]).attr('data-opacity'),
                lineColor: $(lineColorPickers[i]).val(),
                lineWidth: $(lineWidthSelectors[i]).attr('inf-size'),
                fontColor: $(fontColorPickers[i]).val(),
                fontSize: $(fontSizeSelectors[i]).attr('inf-size'),
                fontWeight : $(fontWeightSelectors[i]).attr('inf-font-weight')
            };
        }
        return prevOptions;
    };

    /**
     * get fib level input field values
     * @param {Object} $container - main container
     * @returns {Object} previous fib options
     */
    var _getFibGenericLevelInputValues = function ($container, subType) {
        var prevOptions = {};
        var fillColorPickers = $container.find("input[inf-ctrl=fibLevelFillColorPicker][sub-type=" + subType + "]");
        var lineColorPickers = $container.find("input[inf-ctrl=fibLevelLineColorPicker][sub-type=" + subType + "]");
        var lineWidthSelectors = $container.find("span[inf-ctrl=fibLevelSelectedLineWidth][sub-type=" + subType + "]");
        var fontColorPickers = $container.find("input[inf-ctrl=fibLevelFontColorPicker][sub-type=" + subType + "]");
        var fontSizeSelectors = $container.find("span[inf-ctrl=fibLevelSelectedFontSize][sub-type=" + subType + "]");
        var fontWeightSelectors = $container.find("button[inf-ctrl=fibLevelToggleFontWeight][sub-type=" + subType + "]");
        for (var i = 0; i < fillColorPickers.length; i++) {
            var fibLevelId = $(fillColorPickers[i]).attr('inf-ctrl-val');
            prevOptions[fibLevelId] = {
                fillColor: $(fillColorPickers[i]).val(),
                fillOpacity: $(fillColorPickers[i]).attr('data-opacity'),
                lineColor: $(lineColorPickers[i]).val(),
                lineWidth: $(lineWidthSelectors[i]).attr('inf-size'),
                fontColor: $(fontColorPickers[i]).val(),
                fontSize: $(fontSizeSelectors[i]).attr('inf-size'),
                fontWeight : $(fontWeightSelectors[i]).attr('inf-font-weight')
            };
        }
        return prevOptions;
    };

    var _enableResetButtons = function ($container, enalbeResetBtn){
        var setAsUserDefaultButtonElement = $container.find("button[inf-ctrl=set-as-my-default-selector]");
        setAsUserDefaultButtonElement.removeClass("disabled");
        setAsUserDefaultButtonElement.removeAttr('disabled');

        if (enalbeResetBtn) {
            var resetToMyDefaultElement = $container.find("a[inf-ctrl=reset-to-my-default-selector]");
            resetToMyDefaultElement.removeClass("disabled");
            resetToMyDefaultElement.removeAttr('disabled');
        }
    }

    var _disableResetButtons = function ($container, disableResetBtn){
        var setAsUserDefaultButtonElement = $container.find("button[inf-ctrl=set-as-my-default-selector]");
        setAsUserDefaultButtonElement.addClass("disabled");
        setAsUserDefaultButtonElement.attr('disabled', 'disabled');
     
        if (disableResetBtn) {
            var resetToMyDefaultElement = $container.find("a[inf-ctrl=reset-to-my-default-selector]");
            resetToMyDefaultElement.addClass("disabled");
            resetToMyDefaultElement.attr('disabled', 'disabled');
        }
    }
    /**
     * bind fib drawing settings
     * @param {object} $container - main container
     * @param {function} onSingleLineColorChange - single line color change function
     * @param {function} onSingleFillColorChange - single fill color change function
     * @param {function} onSingleLineWidthChange - single line width change function
     * @param {function} onSingleOptionChange - single option change function
     * @param {function} onFibLevelFillColorChange - fib level fill color change function
     * @param {function} onFibLevelLineColorChange - fib level line color change function
     * @param {function} onFibLevelLineWidthChange - fib level line width change function
     * @param {function} onFibLevelChange - fib level change function
     * @param {function} onFibLevelValueChange - fib level value change function
     * @param {function} onFibModeChange - fib mode change function
     */
    var _bindFibSettings = function ($container, callBackFnFibSettings) {
        var onSingleLineColorChange = callBackFnFibSettings.onSingleLineColorChange,
            onSingleFillColorChange = callBackFnFibSettings.onSingleFillColorChange,
            onSingleLineWidthChange =  callBackFnFibSettings.onSingleLineWidthChange,
            onSingleOptionChange = callBackFnFibSettings.onSingleOptionChange,
            onFibLevelFillColorChange = callBackFnFibSettings.onFibLevelFillColorChange,
            onFibLevelLineColorChange = callBackFnFibSettings.onFibLevelLineColorChange,
            onFibLevelLineWidthChange = callBackFnFibSettings.onFibLevelLineWidthChange,
            onFibLevelChange = callBackFnFibSettings.onToggleFibLevel,
            onFibLevelValueChange = callBackFnFibSettings.onFibLvlValueChange,
            onFibModeChange = callBackFnFibSettings.onToggleFibMode,
            onSingleFontColorChange = callBackFnFibSettings.onSingleFontColorChange,
            onFibLevelFontColorChange = callBackFnFibSettings.onFibLevelFontColorChange,
            onSingleFontSizeChange = callBackFnFibSettings.onSingleFontSizeChange,
            onFibLevelFontSizeChange =  callBackFnFibSettings.onFibLevelFontSizeChange,
            onFibLevelFontWeightChange = callBackFnFibSettings.onFibLevelFontWeightChange,
            onSingleFontWeightChange = callBackFnFibSettings.onFibSingleFontWeightChange,
            onToggleSnapToHighLow = callBackFnFibSettings.onToggleSnapToHighLow,
            onSaveTemplate = callBackFnFibSettings.onSaveTemplate,
            onApplyTemplate = callBackFnFibSettings.onApplyTemplate,
            onDeleteTemplate = callBackFnFibSettings.onDeleteTemplate,
            onFibApplyAllButtonClick = callBackFnFibSettings.onFibApplyAllButtonClick,
            onSetAsMyDefaultSettings = callBackFnFibSettings.onSetAsMyDefaultSettings,
            onResetToAppDefaultSettings = callBackFnFibSettings.onResetToAppDefaultSettings,
            onResetToMyDefaultSettings = callBackFnFibSettings.onResetToMyDefaultSettings,
            onTrendLineToggleShow = callBackFnFibSettings.onTrendLineToggleShow,
            enabledMyDefaultButton = callBackFnFibSettings.enabledMyDefaultButton,
            onTrendLineColorChange = callBackFnFibSettings.onTrendLineColorChange,
            onTrendLineWidthChange = callBackFnFibSettings.onTrendLineWidthChange,
            onTrendLineStyleChange = callBackFnFibSettings.onTrendLineStyleChange;

        var parentContainer = $container.parent();
        var chartContainer = $container.parents().closest('[inf-container="chart_container"]');
        var popupMask;
        var setAsUserDefaultButtonElement = $container.find("button[inf-ctrl=set-as-my-default-selector]");
        var enableMyDefault;
        if (enabledMyDefaultButton && typeof enabledMyDefaultButton.getEnabledMyDefaultButton === 'function') {
           enableMyDefault = enabledMyDefaultButton.getEnabledMyDefaultButton(); 
        }
        if (enableMyDefault) {
            _enableResetButtons($container,false);
        } else {
            _disableResetButtons($container,false);
        }

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=trendLineColorPicker]"), undefined, function (rgb, color, opacity) {
            onTrendLineColorChange(rgb, color, opacity);
            _enableResetButtons($container,false);
        });

        $container.find('li[inf-ctrl=lineWidth]').on('click', function (e) {
            var strokeWidth = $(this).attr("inf-size");
            var ctrlType = $(this).parent().attr('inf-ctrl');
            if (ctrlType === 'trendLine'){
                $container.find('li[inf-ctrl=lineWidth]').removeClass('active');
                $(this).addClass('active');
                onTrendLineWidthChange(strokeWidth);
                _enableResetButtons($container,false);
                e.stopPropagation();
            }
        });

        $container.find("li[inf-ctrl=lineStyle]").on('click', function (e) {
            var dashStyle = $(this).attr("inf-style");
            var ctrlType = $(this).parent().attr('inf-ctrl');
            if (ctrlType === 'trendLine'){
                $container.find("li[inf-ctrl=lineStyle]").removeClass('active');
                $(this).addClass('active');
                onTrendLineStyleChange(dashStyle);
                _enableResetButtons($container,false);
                e.stopPropagation();
            }
        });

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=singleLineColorPicker]"), undefined, function (rgb, value) {
            var sfcCtrl = $container.find("input[inf-ctrl=singleFillColorControl]");
            if(!$(sfcCtrl).is(":checked")) {
                $(sfcCtrl).trigger('click');
            } else {
                onSingleLineColorChange(rgb, value, true);
                _enableResetButtons($container,false);
            }
        });

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=singleFillColorPicker]"), undefined, function (rgb, value, opacity) {
            var sfcCtrl = $container.find("input[inf-ctrl=singleFillColorControl]");
            if(!$(sfcCtrl).is(":checked")) {
                $(sfcCtrl).trigger('click');
            } else {
                onSingleFillColorChange(rgb, value, opacity, true);
                _enableResetButtons($container,false);
            }
        });

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=singleFontColorPicker]"), undefined, function (rgb, value) {
            var sfcCtrl = $container.find("input[inf-ctrl=singleFillColorControl]");
            if(!$(sfcCtrl).is(":checked")) {
                $(sfcCtrl).trigger('click');
            } else {
                onSingleFontColorChange(rgb, value, true);
                _enableResetButtons($container, false);
            }
        });

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=fibLevelFillColorPicker]"), undefined, function (rgb, value, opacity) {
            var sfcCtrl = $container.find("input[inf-ctrl=singleFillColorControl]");
            if($(sfcCtrl).is(":checked")) {
                $(sfcCtrl).trigger('click');
            } else {
                onFibLevelFillColorChange(rgb, value, opacity, $(this).attr("inf-ctrl-val"));
                _enableResetButtons($container, false);
            }
        });

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=fibLevelLineColorPicker]"), undefined, function (rgb, value) {
            var sfcCtrl = $container.find("input[inf-ctrl=singleFillColorControl]");
            if($(sfcCtrl).is(":checked")) {
                $(sfcCtrl).trigger('click');
            } else {
                onFibLevelLineColorChange(rgb, value, $(this).attr("inf-ctrl-val"));
                _enableResetButtons($container, false);
            }
        });

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=fibLevelFontColorPicker]"), undefined, function (rgb, value) {
            var sfcCtrl = $container.find("input[inf-ctrl=singleFillColorControl]");
            if($(sfcCtrl).is(":checked")) {
                $(sfcCtrl).trigger('click');
            } else {
                onFibLevelFontColorChange(rgb, value, $(this).attr("inf-ctrl-val"));
                _enableResetButtons($container, false);
            }
        });

        $container.find('li[inf-ctrl=lineWidth]').on('click', function (e) {
            var strokeWidth = $(this).attr("inf-size");
            var ctrlType = $(this).parent().attr('inf-ctrl');
            var sfcCtrl = $container.find("input[inf-ctrl=singleFillColorControl]");
            var id = $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedLineWidth]").attr('inf-ctrl-val');
            if (id) {
                $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedLineWidth]").text($(this).text());
                $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedLineWidth]").attr('inf-size', strokeWidth);
                if (ctrlType === "single") {
                    if (!$(sfcCtrl).is(":checked")) {
                        $(sfcCtrl).trigger('click');
                    } else {
                        onSingleLineWidthChange(strokeWidth, true);
                        _enableResetButtons($container, false);
                    }
                } else {
                    if ($(sfcCtrl).is(":checked")) {
                        $(sfcCtrl).trigger('click');
                    } else {
                        onFibLevelLineWidthChange(strokeWidth, id);
                        _enableResetButtons($container, false);
                    }
                }
            }
        });

        $container.find('li[inf-ctrl=fontSize]').on('click', function (e) {
            var fontSize = $(this).attr("inf-size");
            var ctrlType = $(this).parent().attr('inf-ctrl');
            var sfcCtrl = $container.find("input[inf-ctrl=singleFillColorControl]");
            var id = $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedFontSize]").attr('inf-ctrl-val');
            $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedFontSize]").text($(this).text());
            $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedFontSize]").attr('inf-size', fontSize);
            if (ctrlType === "single") {
                if (!$(sfcCtrl).is(":checked")) {
                    $(sfcCtrl).trigger('click');
                } else {
                    onSingleFontSizeChange(fontSize, true);
                    _enableResetButtons($container, false);
                }
            } else {
                if ($(sfcCtrl).is(":checked")) {
                    $(sfcCtrl).trigger('click');
                } else {
                    onFibLevelFontSizeChange(fontSize, id);
                    _enableResetButtons($container, false);
                }
            }
        });

        $container.find("input[inf-ctrl=fibLevel]").on('click', function (e) {
            onFibLevelChange($(this).is(":checked"), $(this).attr("data-value"));
            _enableResetButtons($container, false);
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=fibLevelValue]").on('keypress', function (e) {
            if (e.which == 13) {
                e.preventDefault();
                $(this).trigger("blur");
            } else {
                _enableResetButtons($container, false);
            }
        });

        $container.find("input[inf-ctrl=fibLevelValue]").on('click', function (e) {
            $(this).parent().removeClass('has-error');
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=fibLevelValue]").on('blur', function (e) {
            var fibLevelValue = $(this).val();
            if (fibLevelValue !== "" && !isNaN(fibLevelValue)) {
                onFibLevelValueChange($(this).attr("data-value"), fibLevelValue * 100);
            } else {
                $(this).parent().addClass('has-error');
            }
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=singleFillColorControl]").on('click', function (e) {
            var color = $container.find("input[inf-ctrl=singleFillColorPicker]").val();
            var opacity = $container.find("input[inf-ctrl=singleFillColorPicker]").attr('data-opacity');
            var lineColor = $container.find("input[inf-ctrl=singleLineColorPicker]").val();
            var lineWidth = $container.find("span[inf-ctrl=singleSelectedLineWidth]").attr('inf-size');
            lineWidth = lineWidth ? lineWidth : 1;
            var fontColor = $container.find("input[inf-ctrl=singleFontColorPicker]").val();
            var fontSize = $container.find("span[inf-ctrl=singleSelectedFontSize]").attr('inf-size');
            var isSingleColor = $(this).is(":checked");
            var fontWeight = $container.find("button[inf-ctrl=singleToggleFontWeight]").attr('inf-font-weight');
            $container.find("button[inf-ctrl=singleApplyAll]").toggleClass('disabled', !isSingleColor).prop('disabled', !isSingleColor);

            var prevOptions = {};
            if(!isSingleColor) {
                prevOptions = _getFibLevelInputValues($container);
            }
            onSingleOptionChange(color, opacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, isSingleColor);
            _enableResetButtons($container, false);
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=modeToggle]").on('click', function (e) {
            onFibModeChange($(this).is(":checked"));
            _enableResetButtons($container, false);
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=snapToHighLowToggle]").on('click', function (e) {
            onToggleSnapToHighLow($(this).is(":checked"));
            _enableResetButtons($container, false);
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=showTrendLineAlways]").on('click', function (e) {
            onTrendLineToggleShow($(this).is(":checked"));
            _enableResetButtons($container, false);
            e.stopPropagation();
        });

        $container.find("button[inf-ctrl=fibLevelToggleFontWeight]").on('click', function (e) {
            var sfcCtrl = $container.find("input[inf-ctrl=singleFillColorControl]");
            $(this).toggleClass( "active" );
            var newFontWeight = $(this).hasClass( "active" ) ? "bold" : "normal";
            $(this).attr("inf-font-weight", newFontWeight);
            if ($(sfcCtrl).is(":checked")) {
                $(sfcCtrl).trigger('click');
            } else {
                onFibLevelFontWeightChange($(this).attr('inf-ctrl-val'), newFontWeight, true);
                _enableResetButtons($container, false);
            }
            e.stopPropagation();
        });

        $container.find("button[inf-ctrl=singleToggleFontWeight]").on('click', function (e) {
            var sfcCtrl = $container.find("input[inf-ctrl=singleFillColorControl]");
            $(this).toggleClass( "active" );
            var newFontWeight = $(this).hasClass( "active" ) ? "bold" : "normal";
            $(this).attr("inf-font-weight", newFontWeight);
            if ($(sfcCtrl).is(":checked")) {
                onSingleFontWeightChange(newFontWeight, true, {}, true);
                _enableResetButtons($container, false);
            } else {
                $(sfcCtrl).trigger('click');
            }
            e.stopPropagation();
        });

        $container.find("button[inf-ctrl=singleApplyAll]").on('click', function (e) {
            removePopups();
            var sfcCtrl = $container.find("input[inf-ctrl=singleFillColorControl]");
            if ($(sfcCtrl).is(":checked")) {
                var color = $container.find("input[inf-ctrl=singleFillColorPicker]").val();
                var opacity = $container.find("input[inf-ctrl=singleFillColorPicker]").attr('data-opacity');
                var lineColor = $container.find("input[inf-ctrl=singleLineColorPicker]").val();
                var lineWidth = $container.find("span[inf-ctrl=singleSelectedLineWidth]").attr('inf-size');
                lineWidth = lineWidth ? lineWidth : 1;
                var fontColor = $container.find("input[inf-ctrl=singleFontColorPicker]").val();
                var fontSize = $container.find("span[inf-ctrl=singleSelectedFontSize]").attr('inf-size');
                var fontWeight = $container.find("button[inf-ctrl=singleToggleFontWeight]").attr('inf-font-weight');
                prevOptions = _getFibLevelInputValues($container);
                var confirmationMessage = "Are you sure want to apply one format for all levels? Formats set on individual levels will be overwritten.";
                _loadConfirmationPopup($container, confirmationMessage, function(){
                    onFibApplyAllButtonClick(color, opacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions);
                    _enableResetButtons($container, false);
                }, onClosePopups, getPosition(360), 360);
                onOpenPopups();
            }
            e.stopPropagation();
        });

        setAsUserDefaultButtonElement.on('click', function (e) {
            if(enabledMyDefaultButton && enabledMyDefaultButton.getEnabledMyDefaultButton){
                var enableMyDefault = enabledMyDefaultButton.getEnabledMyDefaultButton();
                if(enableMyDefault === undefined || enableMyDefault){
                    onSetAsMyDefaultSettings();
                    enabledMyDefaultButton.resetEnabledMyDefaultButton(enabledMyDefaultButton.chartId, enabledMyDefaultButton.shape, enabledMyDefaultButton.drawingId, true);
                    _disableResetButtons($container, true);
                    $container.find("a[inf-ctrl=reset-to-my-default-selector]").removeClass('disabled');
                    $container.find("a[inf-ctrl=reset-to-my-default-selector]").removeAttr('disabled');
                    e.stopPropagation();
                }
            }
        });

        $container.find("a[inf-ctrl=reset-to-app-default-selector]").on('click', function (e) {
            var confirmationMessage = "Do you want to erase your saved settings?";
            _loadConfirmationPopup($container, confirmationMessage, function(){
                onResetToAppDefaultSettings();
            }, onClosePopups, getPosition(360), 360);
            e.stopPropagation();
        });

        $container.find("a[inf-ctrl=reset-to-my-default-selector]").on('click', function (e) {
            if($(this).hasClass("disabled")){
                return;
            }
            if(enabledMyDefaultButton && enabledMyDefaultButton.getEnabledMyDefaultButton){
                var enableMyDefault = enabledMyDefaultButton.getEnabledMyDefaultButton();
                if(enableMyDefault === undefined || enableMyDefault){
                    onResetToMyDefaultSettings();
                    _disableResetButtons($container, true);
                    e.stopPropagation();
                }
            }
        });

        function removePopups () {
            parentContainer.find('[inf-container="confirmation"]').remove();
            onClosePopups();
        }

        function onOpenPopups () {
            popupMask = $(_getCustomMaskHTML());
            chartContainer.append(popupMask);
            infChart.util.bindEvent(popupMask, 'mousedown', function(){
                removePopups();
            });
        }

        function onClosePopups () {
            if (popupMask && popupMask.length > 0) {
                popupMask.remove();
            }
        }

        function getPosition(width) {
            return {
                top: $($container).position().top + $($container).height() / 4,
                left: $($container).position().left + ($($container).width() - width)/2
            };
        }

        _bindTemplateSelectionEvents($container, onSaveTemplate, onApplyTemplate, onDeleteTemplate);
    };

        /**
     * bind fib drawing settings
     * @param {object} $container - main container
     * @param {function} onSingleLineColorChange - single line color change function
     * @param {function} onSingleFillColorChange - single fill color change function
     * @param {function} onSingleLineWidthChange - single line width change function
     * @param {function} onSingleOptionChange - single option change function
     * @param {function} onFibLevelFillColorChange - fib level fill color change function
     * @param {function} onFibLevelLineColorChange - fib level line color change function
     * @param {function} onFibLevelLineWidthChange - fib level line width change function
     * @param {function} onFibLevelChange - fib level change function
     * @param {function} onFibLevelValueChange - fib level value change function
     * @param {function} onFibModeChange - fib mode change function
     */
    var _bindFibGenericSettings = function ($container, callBackFnFibGenSettings) {
        var onSingleLineColorChange = callBackFnFibGenSettings.onSingleLineColorChange,
            onSingleFillColorChange = callBackFnFibGenSettings.onSingleFillColorChange,
            onSingleLineWidthChange = callBackFnFibGenSettings.onSingleLineWidthChange,
            onSingleOptionChange = callBackFnFibGenSettings.onSingleOptionChange,
            onFibLevelFillColorChange = callBackFnFibGenSettings.onFibLevelFillColorChange,
            onFibLevelLineColorChange = callBackFnFibGenSettings.onFibLevelLineColorChange,
            onFibLevelLineWidthChange = callBackFnFibGenSettings.onFibLevelLineWidthChange,
            onFibLevelChange = callBackFnFibGenSettings.onToggleFibLevel,
            onFibLevelValueChange = callBackFnFibGenSettings.onFibLvlValueChange,
            onFibModeChange = callBackFnFibGenSettings.onToggleFibMode,
            onSingleFontColorChange = callBackFnFibGenSettings.onSingleFontColorChange,
            onFibLevelFontColorChange = callBackFnFibGenSettings.onFibLevelFontColorChange,
            onSingleFontSizeChange = callBackFnFibGenSettings.onSingleFontSizeChange,
            onFibLevelFontSizeChange = callBackFnFibGenSettings.onFibLevelFontSizeChange,
            onFibLevelFontWeightChange = callBackFnFibGenSettings.onFibLevelFontWeightChange,
            onSingleFontWeightChange = callBackFnFibGenSettings.onFibSingleFontWeightChange,
            onAlignStyleChange = callBackFnFibGenSettings.onAlignStyleChange,
            onToggleSnapToHighLow = callBackFnFibGenSettings.onToggleSnapToHighLow,
            onSaveTemplate = callBackFnFibGenSettings.onSaveTemplate,
            onApplyTemplate = callBackFnFibGenSettings.onApplyTemplate,
            onDeleteTemplate = callBackFnFibGenSettings.onDeleteTemplate,
            onFibApplyAllButtonClick = callBackFnFibGenSettings.onFibApplyAllButtonClick,
            onSetAsMyDefaultSettings = callBackFnFibGenSettings.onSetAsMyDefaultSettings,
            onResetToAppDefaultSettings = callBackFnFibGenSettings.onResetToAppDefaultSettings,
            onResetToMyDefaultSettings = callBackFnFibGenSettings.onResetToMyDefaultSettings,
            onTrendLineToggleShow = callBackFnFibGenSettings.onTrendLineToggleShow,
            enabledMyDefaultButton = callBackFnFibGenSettings.enabledMyDefaultButton,
            onTrendLineColorChange = callBackFnFibGenSettings.onTrendLineColorChange,
            onTrendLineWidthChange = callBackFnFibGenSettings.onTrendLineWidthChange,
            onTrendLineStyleChange = callBackFnFibGenSettings.onTrendLineStyleChange;

        
        var parentContainer = $container.parent();
        var chartContainer = $container.parents().closest('[inf-container="chart_container"]');
        var popupMask;
        var setAsUserDefaultButtonElement = $container.find("button[inf-ctrl=set-as-my-default-selector]");
        
        if(enabledMyDefaultButton && enabledMyDefaultButton.getEnabledMyDefaultButton){
            var enableMyDefault = enabledMyDefaultButton.getEnabledMyDefaultButton();
            if (enableMyDefault) {
                _enableResetButtons($container,false);
            } else {
                _disableResetButtons($container,false);
            }
        }

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=trendLineColorPicker]"), undefined, function (rgb, color, opacity) {
            onTrendLineColorChange(rgb, color, opacity);
            _enableResetButtons($container,false);
        });

        $container.find('li[inf-ctrl=lineWidth]').on('click', function (e) {
            var strokeWidth = $(this).attr("inf-size");
            var ctrlType = $(this).parent().attr('inf-ctrl');
            if (ctrlType === 'trendLine'){
                $container.find('li[inf-ctrl=lineWidth]').removeClass('active');
                $(this).addClass('active');
                onTrendLineWidthChange(strokeWidth);
                _enableResetButtons($container,false);
                e.stopPropagation();
            }
        });

        $container.find("li[inf-ctrl=lineStyle]").on('click', function (e) {
            var dashStyle = $(this).attr("inf-style");
            var ctrlType = $(this).parent().attr('inf-ctrl');
            if (ctrlType === 'trendLine') {
                $container.find("li[inf-ctrl=lineStyle]").removeClass('active');
                $(this).addClass('active');
                onTrendLineStyleChange(dashStyle);
                _enableResetButtons($container,false);
                e.stopPropagation();
            }
        });

        $container.find("li[inf-ctrl=alignStyle]").on('click', function (e) {
            var linePosition = $(this).attr('inf-style');
            var type = $(this).parent().attr('inf-ctrl');
            if(type == "fibExtentionAlign"){
                $container.find('ul[inf-ctrl="fibExtentionAlign"]').find('li[inf-ctrl="alignStyle"]').removeClass('active');
                var subType = "fibExtention";
            }
            if(type == "fibRetracementAlign"){
                $container.find('ul[inf-ctrl="fibRetracementAlign"]').find('li[inf-ctrl="alignStyle"]').removeClass('active');
                var subType = "fibRetracement";
            }
            $(this).addClass('active');
            onAlignStyleChange(linePosition, subType);
            _enableResetButtons($container,false);
            e.stopPropagation();
        });

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=singleLineColorPicker]"), undefined, function (rgb, value) {
            if($(this).attr('sub-type') == "fibExtention"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleExtentionFillColorControl]");
            }
            if($(this).attr('sub-type') == "fibRetracement"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleRetrancementFillColorControl]");
            }
            if(!$(sfcCtrl).is(":checked")) {
                $(sfcCtrl).trigger('click');
            } else {
                onSingleLineColorChange(rgb, value, true, undefined, $(this).attr('sub-type'));
                _enableResetButtons($container,false);
            }
        });

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=singleFillColorPicker]"), undefined, function (rgb, value, opacity) {
            if($(this).attr('sub-type') == "fibExtention"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleExtentionFillColorControl]");
            }
            if($(this).attr('sub-type') == "fibRetracement"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleRetrancementFillColorControl]");
            }
            if(!$(sfcCtrl).is(":checked")) {
                $(sfcCtrl).trigger('click');
            } else {
                onSingleFillColorChange(rgb, value, opacity, true, undefined, $(this).attr('sub-type'));
                _enableResetButtons($container,false);
            }
        });

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=singleFontColorPicker]"), undefined, function (rgb, value) {
            if($(this).attr('sub-type') == "fibExtention"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleExtentionFillColorControl]");
            }
            if($(this).attr('sub-type') == "fibRetracement"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleRetrancementFillColorControl]");
            }
            if(!$(sfcCtrl).is(":checked")) {
                $(sfcCtrl).trigger('click');
            } else {
                onSingleFontColorChange(rgb, value, true, undefined, $(this).attr('sub-type'));
                _enableResetButtons($container, false);
            }
        });

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=fibLevelFillColorPicker]"), undefined, function (rgb, value, opacity) {
            if($(this).attr('sub-type') == "fibExtention"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleExtentionFillColorControl]");
            }
            if($(this).attr('sub-type') == "fibRetracement"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleRetrancementFillColorControl]");
            }
            if($(sfcCtrl).is(":checked")) {
                $(sfcCtrl).trigger('click');
            } else {
                onFibLevelFillColorChange(rgb, value, opacity, $(this).attr("inf-ctrl-val"), $(this).attr('sub-type'));
                _enableResetButtons($container, false);
            }
        });

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=fibLevelLineColorPicker]"), undefined, function (rgb, value) {
            if($(this).attr('sub-type') == "fibExtention"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleExtentionFillColorControl]");
            }
            if($(this).attr('sub-type') == "fibRetracement"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleRetrancementFillColorControl]");
            }
            if($(sfcCtrl).is(":checked")) {
                $(sfcCtrl).trigger('click');
            } else {
                onFibLevelLineColorChange(rgb, value, $(this).attr("inf-ctrl-val"), $(this).attr('sub-type'));
                _enableResetButtons($container, false);
            }
        });

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=fibLevelFontColorPicker]"), undefined, function (rgb, value) {
            if($(this).attr('sub-type') == "fibExtention"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleExtentionFillColorControl]");
            }
            if($(this).attr('sub-type') == "fibRetracement"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleRetrancementFillColorControl]");
            }
            if($(sfcCtrl).is(":checked")) {
                $(sfcCtrl).trigger('click');
            } else {
                onFibLevelFontColorChange(rgb, value, $(this).attr("inf-ctrl-val"), $(this).attr('sub-type'));
                _enableResetButtons($container, false);
            }
        });

        $container.find('li[inf-ctrl=lineWidth]').on('click', function (e) {
            var strokeWidth = $(this).attr("inf-size");
            var ctrlType = $(this).parent().attr('inf-ctrl');
            var subType = $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedLineWidth]").attr('sub-type');
            if(subType == "fibExtention"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleExtentionFillColorControl]");
            }
            if(subType == "fibRetracement"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleRetrancementFillColorControl]");
            }
            var id = $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedLineWidth]").attr('inf-ctrl-val');
            if(id) {
                $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedLineWidth]").text($(this).text());
                $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedLineWidth]").attr('inf-size', strokeWidth);
                
                if (ctrlType === "single") {
                    if (!$(sfcCtrl).is(":checked")) {
                        $(sfcCtrl).trigger('click');
                    } else {
                        onSingleLineWidthChange(strokeWidth, true, undefined, subType);
                        _enableResetButtons($container, false);
                    }
                } else {
                    if ($(sfcCtrl).is(":checked")) {
                        $(sfcCtrl).trigger('click');
                    } else {
                        onFibLevelLineWidthChange(strokeWidth, id, subType);
                        _enableResetButtons($container, false);
                    }
                }
            }   
        });

        $container.find('li[inf-ctrl=fontSize]').on('click', function (e) {
            var fontSize = $(this).attr("inf-size");
            var ctrlType = $(this).parent().attr('inf-ctrl');
            var subType = $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedFontSize]").attr('sub-type');
            if(subType == "fibExtention"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleExtentionFillColorControl]");
            }
            if(subType == "fibRetracement"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleRetrancementFillColorControl]");
            }
            var id = $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedFontSize]").attr('inf-ctrl-val');
            $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedFontSize]").text($(this).text());
            $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedFontSize]").attr('inf-size', fontSize);
            if (ctrlType === "single") {
                if (!$(sfcCtrl).is(":checked")) {
                    $(sfcCtrl).trigger('click');
                } else {
                    onSingleFontSizeChange(fontSize, true, undefined, subType);
                    _enableResetButtons($container, false);
                }
            } else {
                if ($(sfcCtrl).is(":checked")) {
                    $(sfcCtrl).trigger('click');
                } else {
                    onFibLevelFontSizeChange(fontSize, id, subType);
                    _enableResetButtons($container, false);
                }
            }
        });

        $container.find("input[inf-ctrl=fibLevel]").on('click', function (e) {
            onFibLevelChange($(this).is(":checked"), $(this).attr("data-value"), $(this).attr("sub-type"));
            _enableResetButtons($container, false);
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=showTrendLineAlways]").on('click', function (e) {
            onTrendLineToggleShow($(this).is(":checked"));
            _enableResetButtons($container, false);
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=fibLevelValue]").on('keypress', function (e) {
            if (e.which == 13) {
                e.preventDefault();
                $(this).trigger("blur");
            }
            _enableResetButtons($container, false);
        });

        $container.find("input[inf-ctrl=fibLevelValue]").on('click', function (e) {
            $(this).parent().removeClass('has-error');
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=fibLevelValue]").on('blur', function (e) {
            var fibLevelValue = $(this).val();
            if (fibLevelValue !== "" && !isNaN(fibLevelValue)) {
                onFibLevelValueChange($(this).attr("data-value"), fibLevelValue * 100, $(this).attr("sub-type"));
            } else {
                $(this).parent().addClass('has-error');
            }
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=singleExtentionFillColorControl]").on('click', function (e) {
            var color = $container.find("input[inf-ctrl=singleFillColorPicker][sub-type=fibExtention]").val();
            var opacity = $container.find("input[inf-ctrl=singleFillColorPicker][sub-type=fibExtention]").attr('data-opacity');
            var lineColor = $container.find("input[inf-ctrl=singleLineColorPicker][sub-type=fibExtention]").val();
            var lineWidth = $container.find("span[inf-ctrl=singleSelectedLineWidth][sub-type=fibExtention]").attr('inf-size');
            lineWidth = lineWidth ? lineWidth : 1;
            var fontColor = $container.find("input[inf-ctrl=singleFontColorPicker][sub-type=fibExtention]").val();
            var fontSize = $container.find("span[inf-ctrl=singleSelectedFontSize][sub-type=fibExtention]").attr('inf-size');
            var isSingleColor = $(this).is(":checked");
            var fontWeight = $container.find("button[inf-ctrl=singleToggleFontWeight][sub-type=fibExtention]").attr('inf-font-weight');

            $container.find("button[inf-ctrl=singleApplyAll][sub-type=fibExtention]").toggleClass('disabled', !isSingleColor).prop('disabled', !isSingleColor);

            var prevOptions = {};
            if(!isSingleColor) {
                prevOptions = _getFibGenericLevelInputValues($container, "fibExtention");
            }
            onSingleOptionChange(color, opacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, isSingleColor, "fibExtention");
            _enableResetButtons($container, false);
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=singleRetrancementFillColorControl]").on('click', function (e) {
            var color = $container.find("input[inf-ctrl=singleFillColorPicker][sub-type=fibRetracement]").val();
            var opacity = $container.find("input[inf-ctrl=singleFillColorPicker][sub-type=fibRetracement]").attr('data-opacity');
            var lineColor = $container.find("input[inf-ctrl=singleLineColorPicker][sub-type=fibRetracement]").val();
            var lineWidth = $container.find("span[inf-ctrl=singleSelectedLineWidth][sub-type=fibRetracement]").attr('inf-size');
            lineWidth = lineWidth ? lineWidth : 1;
            var fontColor = $container.find("input[inf-ctrl=singleFontColorPicker][sub-type=fibRetracement]").val();
            var fontSize = $container.find("span[inf-ctrl=singleSelectedFontSize][sub-type=fibRetracement]").attr('inf-size');
            var isSingleColor = $(this).is(":checked");
            var fontWeight = $container.find("button[inf-ctrl=singleToggleFontWeight][sub-type=fibRetracement]").attr('inf-font-weight');
            $container.find("button[inf-ctrl=singleApplyAll][sub-type=fibRetracement]").toggleClass('disabled', !isSingleColor).prop('disabled', !isSingleColor);

            var prevOptions = {};
            if(!isSingleColor) {
                prevOptions = _getFibGenericLevelInputValues($container, "fibRetracement");
            }
            onSingleOptionChange(color, opacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, isSingleColor, "fibRetracement");
            _enableResetButtons($container, false);
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=snapToHighLowToggle]").on('click', function (e) {
            onToggleSnapToHighLow($(this).is(":checked"));
            _enableResetButtons($container, false);
            e.stopPropagation();
        });

        $container.find("button[inf-ctrl=fibLevelToggleFontWeight]").on('click', function (e) {
            if($(this).attr('sub-type') == "fibExtention"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleExtentionFillColorControl]");
            }
            if($(this).attr('sub-type') == "fibRetracement"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleRetrancementFillColorControl]");
            }
            $(this).toggleClass( "active" );
            var newFontWeight = $(this).hasClass( "active" ) ? "bold" : "normal";
            $(this).attr("inf-font-weight", newFontWeight);
            if ($(sfcCtrl).is(":checked")) {
                $(sfcCtrl).trigger('click');
            } else {
                onFibLevelFontWeightChange($(this).attr('inf-ctrl-val'), newFontWeight, $(this).attr('sub-type'), true);
                _enableResetButtons($container, false);
            }
            e.stopPropagation();
        });

        $container.find("button[inf-ctrl=singleToggleFontWeight]").on('click', function (e) {
            if($(this).attr('sub-type') == "fibExtention"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleExtentionFillColorControl]");
            }
            if($(this).attr('sub-type') == "fibRetracement"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleRetrancementFillColorControl]");
            }
            $(this).toggleClass( "active" );
            var newFontWeight = $(this).hasClass( "active" ) ? "bold" : "normal";
            $(this).attr("inf-font-weight", newFontWeight);
            if ($(sfcCtrl).is(":checked")) {
                onSingleFontWeightChange(newFontWeight, true, {}, $(this).attr('sub-type'), true);
                _enableResetButtons($container, false);
            } else {
                $(sfcCtrl).trigger('click');
            }
            e.stopPropagation();
        });

        $container.find("button[inf-ctrl=singleApplyAll]").on('click', function (e) {
            removePopups();
            var subType = $(this).attr('sub-type');
            if(subType == "fibExtention"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleExtentionFillColorControl]");
            }
            if(subType == "fibRetracement"){
                var sfcCtrl = $container.find("input[inf-ctrl=singleRetrancementFillColorControl]");
            }
            if ($(sfcCtrl).is(":checked")) {
                var color = $container.find("input[inf-ctrl=singleFillColorPicker][sub-type=" + subType + "]").val();
                var opacity = $container.find("input[inf-ctrl=singleFillColorPicker][sub-type=" + subType + "]").attr('data-opacity');
                var lineColor = $container.find("input[inf-ctrl=singleLineColorPicker][sub-type=" + subType + "]").val();
                var lineWidth = $container.find("span[inf-ctrl=singleSelectedLineWidth][sub-type=" + subType + "]").attr('inf-size');
                lineWidth = lineWidth ? lineWidth : 1;
                var fontColor = $container.find("input[inf-ctrl=singleFontColorPicker][sub-type=" + subType + "]").val();
                var fontSize = $container.find("span[inf-ctrl=singleSelectedFontSize][sub-type=" + subType + "]").attr('inf-size');
                var fontWeight = $container.find("button[inf-ctrl=singleToggleFontWeight][sub-type=" + subType + "]").attr('inf-font-weight');
                prevOptions = _getFibGenericLevelInputValues($container, subType);
                var confirmationMessage = "Are you sure want to apply one format for all levels? Formats set on individual levels will be overwritten.";
                _loadConfirmationPopup($container, confirmationMessage, function(){
                    onFibApplyAllButtonClick(color, opacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, subType);
                }, onClosePopups, getPosition(360), 360);
                onOpenPopups();
                _enableResetButtons($container, false);
            }
            e.stopPropagation();
        });

        setAsUserDefaultButtonElement.on('click', function (e) {
            if(enabledMyDefaultButton && enabledMyDefaultButton.getEnabledMyDefaultButton){
                var enableMyDefault = enabledMyDefaultButton.getEnabledMyDefaultButton();
                if(enableMyDefault === undefined || enableMyDefault){
                    onSetAsMyDefaultSettings();
                    enabledMyDefaultButton.resetEnabledMyDefaultButton(enabledMyDefaultButton.chartId, enabledMyDefaultButton.shape, enabledMyDefaultButton.drawingId, true);
                    _disableResetButtons($container, true);
                    $container.find("a[inf-ctrl=reset-to-my-default-selector]").removeClass('disabled');
                    $container.find("a[inf-ctrl=reset-to-my-default-selector]").removeAttr('disabled');
                    e.stopPropagation();
                }
            }
        });

        $container.find("a[inf-ctrl=reset-to-app-default-selector]").on('click', function (e) {
            var confirmationMessage = "Do you want to erase your saved settings?";
            _loadConfirmationPopup($container, confirmationMessage, function(){
                onResetToAppDefaultSettings();
            }, onClosePopups, getPosition(360), 360);
            e.stopPropagation();
        });

        $container.find("a[inf-ctrl=reset-to-my-default-selector]").on('click', function (e) {
            if($(this).hasClass("disabled")){
                return;
            }
            if(enabledMyDefaultButton && enabledMyDefaultButton.getEnabledMyDefaultButton){
                var enableMyDefault = enabledMyDefaultButton.getEnabledMyDefaultButton();
                if(enableMyDefault === undefined || enableMyDefault){
                    onResetToMyDefaultSettings();
                    _disableResetButtons($container, true);
                    e.stopPropagation();
                }
            }
        });

        function removePopups () {
            parentContainer.find('[inf-container="confirmation"]').remove();
            onClosePopups();
        }

        function onOpenPopups () {
            popupMask = $(_getCustomMaskHTML());
            chartContainer.append(popupMask);
            infChart.util.bindEvent(popupMask, 'mousedown', function(){
                removePopups();
            });
        }

        function onClosePopups () {
            if (popupMask && popupMask.length > 0) {
                popupMask.remove();
            }
        }

        function getPosition(width) {
            return {
                top: $($container).position().top + $($container).height() / 4,
                left: $($container).position().left + ($($container).width() - width)/2
            };
        }

        _bindTemplateSelectionEvents($container, onSaveTemplate, onApplyTemplate, onDeleteTemplate);
    };

    /**
     * bind label settings
     * @param {object} $container - main container
     * @param {function} onColorChange - color change function
     * @param {function} onFontSizeChange - font size change function
     * @param {function} onFontStyleChange - font style change function
     * @param {function} onTextChange - text change function
     */
    var _bindLabelSettings = function ($container, onColorChange, onFontSizeChange, onFontStyleChange, onTextChange, onBorderColorChange, onBackgroundColorChange, onApplyBorderColor, onApplyBackgroundColor, onResetToDefault) {
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=colorPicker]"), undefined, onColorChange);
        $container.find("li[inf-ctrl=fontSize]").on('click', function (e) {
            var fontSize = $(this).attr('inf-size');
            onFontSizeChange(fontSize);
            var ctrlType = $(this).parent().attr('inf-ctrl');
            $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedFontSize]").text($(this).text()).attr('inf-size', fontSize);
            //e.stopPropagation();
        });

        $container.find("input[inf-ctrl=backgroundColorEnabled]").on('click', function (e) {
            var color = $container.find("input[inf-ctrl=backgroundColorPicker]").attr('value');
            onApplyBackgroundColor($(this).is(":checked"), color);
            e.stopPropagation();
        });

        $container.find("input[inf-ctrl=borderColorEnabled]").on('click', function (e) {
            var color = $container.find("input[inf-ctrl=borderColorPicker]").attr('value');
            onApplyBorderColor($(this).is(":checked"), color);
            e.stopPropagation();
        });

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=borderColorPicker]"), undefined, function (rgb, value, opacity) {
            var sfcCtrl = $container.find("input[inf-ctrl=borderColorEnabled]");
            if(!$(sfcCtrl).is(":checked")) {
                onBorderColorChange(rgb, value, opacity, false, true);
            } else {
                onBorderColorChange(rgb, value, opacity, true, true);
            }
        });

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=backgroundColorPicker]"), undefined, function (rgb, value, opacity) {
            var sfcCtrl = $container.find("input[inf-ctrl=backgroundColorEnabled]");
            if(!$(sfcCtrl).is(":checked")) {
                onBackgroundColorChange(rgb, value, opacity, false, true);
            } else {
                onBackgroundColorChange(rgb, value, opacity, true, true);
            }
        });

        $container.find("li[inf-ctrl=fontStyle]").on('click', function (e) {
            var style = $(this).attr('inf-style'), checked = $(this).hasClass('active');
            onFontStyleChange(style, checked);
            if (checked) {
                $(this).removeClass('active');
            } else {
                $(this).addClass('active');
            }
            e.stopPropagation();
        });

        $container.find("textarea[inf-ctrl=text]").on('keyup', function () {
            onTextChange($(this).val());
        }).on('blur', function () {
            var text = $(this).val();

            if (text === "") {
                $(this).val("");
                onTextChange("");
            }
        });

        _bindResetToDefaultEvent($container , onResetToDefault);
    };

    /**
     * bind high / low labels settings
     * @param {object} $container - main container
     * @param {function} onColorChange - color change function
     * @param {function} onLabelItemsChange - label item change function
     */
    var _bindHighLowLabelsSettings = function ($container, onColorChange, onLabelItemsChange, onResetToDefault) {
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=colorPicker]"), undefined, onColorChange);

        $container.find("input[inf-ctrl=labelDataItem]").on('click', function (e) {
            onLabelItemsChange($(this).attr("data-value"), $(this).is(":checked"));
            e.stopPropagation();
        });

        _bindResetToDefaultEvent($container , onResetToDefault);
    };

    /**
     * bind regression channel settings
     * @param {object} $container - main container
     * @param {function} onColorChange - color change function
     * @param {function} onFillColorChange - fill color change function
     * @param {function} onLineWidthChange - line width change function
     */
    var _bindRegressionChannelSettings = function ($container, onColorChange, onFillColorChange, onLineWidthChange, onResetToDefault) {
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=lineColorPicker]"), undefined, onColorChange);

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=fillColorPicker]"), undefined, function (rgb, value, opacity) {
            onFillColorChange(rgb, value, opacity, $(this).attr("inf-ctrl-val"));
        });

        _bindSeriesLineWidthEvents($container, onLineWidthChange);

        _bindResetToDefaultEvent($container , onResetToDefault);
    };

    var _bindSeriesLineWidthEvents = function ($container, callbackFn, enableMyDefault) {
        // set line styles
        $container.find('li[inf-ctrl=lineWidth]').on('click', function (e) {
            var strokeWidth = parseInt($(this).attr("inf-size"));
            $container.find('li[inf-ctrl=lineWidth]').removeClass('active');
            $(this).addClass('active');
            callbackFn(strokeWidth);
            if (enableMyDefault){
                enableMyDefault($container, false);
            }
            e.stopPropagation();
        });
    };

    var _updatePriceLineSettings = function ($container, takeProfit, stopLoss, yValue) {
        $container.find('input[inf-ctrl="entryValue"]').val(parseFloat(yValue).toFixed(3));
        var combinedAdditionalDrawingArr = takeProfit.concat(stopLoss);
        $.each(combinedAdditionalDrawingArr, function(key, value){
            $container.find('input[inf-ctrl=priceLevelValue][inf-value=' + value.id + ']').val(parseFloat(value.yValue).toFixed(3));
            $container.find('input[inf-ctrl=applyPriceLine][inf-value=' + value.id + ']').prop('checked', value.enable);
            $container.find('input[inf-ctrl="lineColorPicker"][inf-ctrl-val=' + value.id + ']').data('minicolors-initialized', false);
            $container.find('input[inf-ctrl="lineColorPicker"][inf-ctrl-val=' + value.id + ']').minicolors('value', value.lineColor);
            $container.find('input[inf-ctrl="lineColorPicker"][inf-ctrl-val=' + value.id + ']').data('minicolors-initialized', true);

            var element = $container.find('span[inf-ctrl="priceLineLevelSelectedLineWidth"][inf-ctrl-val=' + value.id + ']').parent().parent();
            var widthText = $(element.find('li[inf-ctrl="lineWidth"][inf-size="' + value.lineWidth + '"]')).find('span').text();
            $(element.find('span[inf-ctrl="priceLineLevelSelectedLineWidth"]')).text(widthText);
            $(element.find('span[inf-ctrl="priceLineLevelSelectedLineWidth"]')).attr('inf-size', value.lineWidth);

            var element = $container.find('span[inf-ctrl="priceLineLevelSelectedLineStyle"][inf-ctrl-val=' + value.id + ']').parent().parent();
            var lineStyleEle = $(element.find('li[inf-ctrl="lineStyle"][inf-style="' + value.lineStyle + '"]')).children().children().clone();
            $(element.find("span[inf-ctrl=priceLineLevelSelectedLineStyle]")).html(lineStyleEle);
            $(element.find("span[inf-ctrl=priceLineLevelSelectedLineStyle]")).attr('inf-style', value.lineStyle);
        });
    };

    //common function to update settings of rectangle, ellipse, regression line, andrew's pitchfork
    var _updateBasicDrawingSettings = function ($container, color, lineWidth, fillColor, fillOpacity, text, checked, verticalPosition, horizontalPosition, shape, selectFirstdropDown, isExtendToRight, isExtendToLeft, fontColor, fontSize) {
        textRef = shape === "rectangle" ? "rect-text": "ellipse-text";
        $container.find('li[inf-ctrl="lineWidth"]').removeClass('active');
        $container.find('input[inf-ctrl="textColorPicker"]').mainColorPanel('value', fontColor);

        if(selectFirstdropDown){
            $($container.find('li[inf-ctrl="lineWidth"][inf-size="' + lineWidth + '"]')[0]).addClass('active');
        } else {
            $container.find('li[inf-ctrl="lineWidth"][inf-size="' + lineWidth + '"]').addClass('active');
        }
        $container.find('input[inf-ctrl="lineColorPicker"]').mainColorPanel('value', color);
        if (fillColor) {
            $container.find('input[inf-ctrl="fillColorPicker"]').mainColorPanel('value', fillColor);
            $container.find('input[inf-ctrl="fillColorPicker"]').mainColorPanel('opacity', fillOpacity);
        }

        if(text !== undefined) {
            $container.find("textarea[inf-ctrl= "+ textRef+"]").val(text);
        }

        if (shape === "rectangle") {
            $container.find("div[inf-ctrl=verticalType]").find("span[rel=selectItem]").text(verticalPosition);
            $container.find("div[inf-ctrl=horizontalType]").find("span[rel=selectItem]").text(horizontalPosition);
            $container.find('input[inf-ctrl="extendToRight"]').prop('checked', isExtendToRight);
            $container.find('input[inf-ctrl="extendToLeft"]').prop('checked', isExtendToLeft);
        }
        
        if(checked) {
            $container.find('input[inf-ctrl="textToggle"]').prop('checked', checked);    
            $container.find("textarea[inf-ctrl=" + textRef + "]").removeAttr("disabled");
            $container.find("input[inf-ctrl=textColorPicker]").removeAttr("disabled");
            $($container.find("span[inf-ctrl=singleSelectedFontSize]")[0]).parent().removeAttr("disabled");
            setTimeout(() => {
                $container.find("textarea[inf-ctrl=" + textRef + " ]").focus();
            }, 0);
            if(shape === "rectangle") {
                $container.find("div[inf-ctrl=verticalType]").find('button').prop('disabled', false);
                $container.find("div[inf-ctrl=horizontalType]").find('button').prop('disabled', false);
            }
            
        } else if (checked === false){
            $container.find("textarea[inf-ctrl=" + textRef +"]").attr("disabled","disabled");
            if ( shape === "rectangle") {
                $container.find("div[inf-ctrl=verticalType]").find('button').prop('disabled', true);
            $container.find("div[inf-ctrl=horizontalType]").find('button').prop('disabled', true);
            }
            $container.find("input[inf-ctrl=textColorPicker]").attr("disabled","disabled");
            $($container.find("span[inf-ctrl=singleSelectedFontSize]")[0]).parent().attr("disabled","disabled");
        }

        $container.find('span[inf-ctrl="singleSelectedFontSize"][inf-ctrl-val="P_all"]').text(fontSize);
        $container.find('span[inf-ctrl="singleSelectedFontSize"][inf-ctrl-val="P_all"]').attr('inf-size', fontSize);

    };

    var _updateAndrewsPitchForkSettings = function ($container, options) {
        _updateBasicDrawingSettings($container, options.medianLineColor, options.medianLineWidth, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);
        var updateProperties = {
            fillColor: options.fillColor,
            fillOpacity: options.fillOpacity,
            lineColor: options.borderColor,
            lineWidth: options.strokeWidth,
            isSingleColor: options.isSingleColor,
            fibLevels: options.fibLevels,
        }
        _updateFibSettings($container, updateProperties);
    };

    var _updateArrowSettings = function ($container, color, labelText) {
        if (color) {
            $container.find('input[inf-ctrl="colorPicker"]').mainColorPanel('value', color);
        }
        if (labelText) {
            $container.find('textArea[inf-ctrl="text"]').val(labelText);
        }
    };

    /**
     * update fib settings panel elements with drowing properties
     * @param {object} $container - setting panel html object
     * @param {string} fillColor - hex fill color (single color)
     * @param {number} fillOpacity - fill opacity
     * @param {string} lineColor - hex line color (single color)
     * @param {number} lineWidth - line width
     * @param {boolean} isSingleColor - is single color enable - apply one color enable
     * @param {Array} fibLevels - fib levels
     */
    var _updateFibSettings = function ($container, updateProperties) {
        var fillColor = updateProperties.fillColor,
            fillOpacity = updateProperties.fillOpacity,
            lineColor = updateProperties.lineColor,
            lineWidth = updateProperties.lineWidth,
            fontSize = updateProperties.fontSize,
            fontColor = updateProperties.fontColor,
            isSingleColor = updateProperties.isSingleColor,
            fibLevels = updateProperties.fibLevels,
            isFibModeEnabled = updateProperties.isFibModeEnabled,
            isSnapTopHighLowEnabled = updateProperties.isSnapTopHighLowEnabled,
            isTrendLineAlwaysEnabled = updateProperties.isTrendLineAlwaysEnabled
            trendLineColor = updateProperties.trendLineColor,
            trendLineOpacity = updateProperties.trendLineOpacity,
            trendLineWidth = updateProperties.trendLineWidth,
            trendLineStyle = updateProperties.trendLineStyle;

        $container.find('input[inf-ctrl="trendLineColorPicker"]').data('minicolors-initialized', false);
        $container.find('input[inf-ctrl="trendLineColorPicker"]').mainColorPanel('value', trendLineColor);

        $container.find('li[inf-ctrl="lineWidth"]').removeClass('active');
        $container.find('li[inf-ctrl="lineWidth"][inf-size="' + trendLineWidth + '"]').addClass('active');

        $container.find('li[inf-ctrl="lineStyle"]').removeClass('active');
        $container.find('li[inf-ctrl="lineStyle"][inf-style="' + trendLineStyle + '"]').addClass('active');

        
        $container.find('input[inf-ctrl="singleFillColorPicker"]').data('minicolors-initialized', false);
        $container.find('input[inf-ctrl="singleLineColorPicker"]').data('minicolors-initialized', false);
        $container.find('input[inf-ctrl="singleFontColorPicker"]').data('minicolors-initialized', false);

        $container.find('input[inf-ctrl="singleFillColorControl"]').prop('checked', !!isSingleColor);
        $container.find("button[inf-ctrl=singleApplyAll]").toggleClass('disabled', !isSingleColor).prop('disabled', !isSingleColor);

        $container.find('input[inf-ctrl="singleFillColorPicker"]').mainColorPanel('value', fillColor);
        $container.find('input[inf-ctrl="singleFillColorPicker"]').mainColorPanel('opacity', fillOpacity);
        $container.find('input[inf-ctrl="singleLineColorPicker"]').mainColorPanel('value', lineColor);
        $container.find('input[inf-ctrl="singleFontColorPicker"]').mainColorPanel('value', fontColor);

        var widthText = $($container.find('li[inf-ctrl="lineWidth"][inf-size="' + lineWidth + '"]')[0]).find('span').text();
        $container.find('span[inf-ctrl="singleSelectedLineWidth"]').text(widthText);
        $container.find('span[inf-ctrl="singleSelectedLineWidth"]').attr('inf-size', lineWidth);

        $container.find('input[inf-ctrl="modeToggle"]').prop('checked', isFibModeEnabled);
        $container.find('input[inf-ctrl="snapToHighLowToggle"]').prop('checked', isSnapTopHighLowEnabled);
        $container.find('input[inf-ctrl="showTrendLineAlways"]').prop('checked', isTrendLineAlwaysEnabled);
        $container.find('input[inf-ctrl="fibLevel"]').prop('checked', false);

        $container.find('span[inf-ctrl="singleSelectedFontSize"][inf-ctrl-val="P_all"]').text(fontSize);
        $container.find('span[inf-ctrl="singleSelectedFontSize"][inf-ctrl-val="P_all"]').attr('inf-size', fontSize);

        $.each(fibLevels, function (key, fibLevel) {
            $container.find('input[inf-ctrl="fibLevelFillColorPicker"][inf-ctrl-val="' + fibLevel.id + '"]').data('minicolors-initialized', false);
            $container.find('input[inf-ctrl="fibLevelLineColorPicker"][inf-ctrl-val="' + fibLevel.id + '"]').data('minicolors-initialized', false);
            $container.find('input[inf-ctrl="fibLevelFontColorPicker"][inf-ctrl-val="' + fibLevel.id + '"]').data('minicolors-initialized', false);

            $container.find('input[inf-ctrl="fibLevel"][data-value="' + fibLevel.id + '"]').prop('checked', fibLevel.enable);
            $container.find('input[inf-ctrl="fibLevelValue"][data-value="' + fibLevel.id + '"]').val(infChart.drawingUtils.common.formatValue((fibLevel.value/100), 3));

            $container.find('input[inf-ctrl="fibLevelFillColorPicker"][inf-ctrl-val="' + fibLevel.id + '"]').mainColorPanel('value', fibLevel.fillColor);
            $container.find('input[inf-ctrl="fibLevelFillColorPicker"][inf-ctrl-val="' + fibLevel.id + '"]').mainColorPanel('opacity', fibLevel.fillOpacity);
            $container.find('input[inf-ctrl="fibLevelLineColorPicker"][inf-ctrl-val="' + fibLevel.id + '"]').mainColorPanel('value', fibLevel.lineColor);
            $container.find('input[inf-ctrl="fibLevelFontColorPicker"][inf-ctrl-val="' + fibLevel.id + '"]').mainColorPanel('value', fibLevel.fontColor);

            var lineWeightText = $($container.find('li[inf-ctrl="lineWidth"][inf-size="' + fibLevel.lineWidth + '"]')[0]).find('span').text();
            $container.find('span[inf-ctrl="fibLevelSelectedLineWidth"][inf-ctrl-val="' + fibLevel.id + '"]').text(lineWeightText);
            $container.find('span[inf-ctrl="fibLevelSelectedLineWidth"][inf-ctrl-val="' + fibLevel.id + '"]').attr('inf-size', fibLevel.lineWidth);

            $container.find('span[inf-ctrl="fibLevelSelectedFontSize"][inf-ctrl-val="' + fibLevel.id + '"]').text(fibLevel.fontSize);
            $container.find('span[inf-ctrl="fibLevelSelectedFontSize"][inf-ctrl-val="' + fibLevel.id + '"]').attr('inf-size', fibLevel.fontSize);

            $container.find('button[inf-ctrl="fibLevelToggleFontWeight"][inf-ctrl-val="' + fibLevel.id + '"]').toggleClass("active", fibLevel.fontWeight === "bold").attr("inf-font-weight", fibLevel.fontWeight);
        });

        $.each(fibLevels, function (key, fibLevel) {
            $container.find('input[inf-ctrl="fibLevelFillColorPicker"][inf-ctrl-val="' + fibLevel.id + '"]').data('minicolors-initialized', true);
            $container.find('input[inf-ctrl="fibLevelLineColorPicker"][inf-ctrl-val="' + fibLevel.id + '"]').data('minicolors-initialized', true);
            $container.find('input[inf-ctrl="fibLevelFontColorPicker"][inf-ctrl-val="' + fibLevel.id + '"]').data('minicolors-initialized', true);
        });

        $container.find('input[inf-ctrl="singleFillColorPicker"]').data('minicolors-initialized', true);
        $container.find('input[inf-ctrl="singleLineColorPicker"]').data('minicolors-initialized', true);
        $container.find('input[inf-ctrl="singleFontColorPicker"]').data('minicolors-initialized', true);
        $container.find('input[inf-ctrl="trendLineColorPicker"]').data('minicolors-initialized', true);
    };

        /**
     * update fib settings panel elements with drowing properties
     * @param {object} $container - setting panel html object
     * @param {string} fillColor - hex fill color (single color)
     * @param {number} fillOpacity - fill opacity
     * @param {string} lineColor - hex line color (single color)
     * @param {number} lineWidth - line width
     * @param {boolean} isSingleColor - is single color enable - apply one color enable
     * @param {Array} fibLevels - fib levels
     */
    var _updateGenericFibSettings = function ($container, updateProperties) {
        var extentionFillColor = updateProperties.extentionFillColor,
            extentionFillOpacity = updateProperties.extentionFillOpacity,
            extentionLineColor = updateProperties.extentionLineColor,
            extentionLineWidth = updateProperties.extentionLineWidth,
            extentionFontSize = updateProperties.extentionFontSize,
            extentionFontColor = updateProperties.extentionFontColor,
            extentionFontWeight = updateProperties.extentionFontWeight,
            extentionLabelPosition = updateProperties.extentionLabelPosition,
            retrancementFillColor = updateProperties.retrancementFillColor,
            retrancementFillOpacity = updateProperties.retrancementFillOpacity,
            retrancementLineColor = updateProperties.retrancementLineColor,
            retrancementLineWidth = updateProperties.retrancementLineWidth,
            retrancementFontSize = updateProperties.retrancementFontSize,
            retrancementFontColor = updateProperties.retrancementFontColor,
            retrancementFontWeight = updateProperties.retrancementFontWeight,
            retracementLabelPosition = updateProperties.retracementLabelPosition,
            isSingleColorExtention = updateProperties.isSingleColorExtention,
            isSingleColorRetracement = updateProperties.isSingleColorRetracement,
            fibExtentionLevels = updateProperties.fibExtentionLevels,
            fibRetrancementLevels = updateProperties.fibRetrancementLevels,
            isFibModeEnabled = updateProperties.isFibModeEnabled,
            isSnapTopHighLowEnabled = updateProperties.isSnapTopHighLowEnabled,
            isTrendLineAlwaysEnabled = updateProperties.isTrendLineAlwaysEnabled,
            trendLineColor = updateProperties.trendLineColor,
            trendLineWidth = updateProperties.trendLineWidth,
            trendLineStyle = updateProperties.trendLineStyle;

        $container.find('input[inf-ctrl="trendLineColorPicker"]').data('minicolors-initialized', false);
        $container.find('input[inf-ctrl="trendLineColorPicker"]').mainColorPanel('value', trendLineColor);
        

        $container.find('li[inf-ctrl="lineWidth"]').removeClass('active');
        $container.find('li[inf-ctrl="lineWidth"][inf-size="' + trendLineWidth + '"]').addClass('active');


        $container.find('li[inf-ctrl="lineStyle"]').removeClass('active');
        $container.find('li[inf-ctrl="lineStyle"][inf-style="' + trendLineStyle + '"]').addClass('active');

        //fibExtention Levels
        $container.find('input[inf-ctrl="singleFillColorPicker"][sub-type="fibExtention"]').data('minicolors-initialized', false);
        $container.find('input[inf-ctrl="singleLineColorPicker"][sub-type="fibExtention"]').data('minicolors-initialized', false);
        $container.find('input[inf-ctrl="singleFontColorPicker"][sub-type="fibExtention"]').data('minicolors-initialized', false);

        $container.find('input[inf-ctrl="singleExtentionFillColorControl"]').prop('checked', !!isSingleColorExtention);
        $container.find('button[inf-ctrl=singleApplyAll][sub-type="fibExtention"]').toggleClass('disabled', !isSingleColorExtention).prop('disabled', !isSingleColorExtention);

        $container.find('input[inf-ctrl="singleFillColorPicker"][sub-type="fibExtention"]').mainColorPanel('value', extentionFillColor);
        $container.find('input[inf-ctrl="singleFillColorPicker"][sub-type="fibExtention"]').mainColorPanel('opacity', extentionFillOpacity);
        $container.find('input[inf-ctrl="singleLineColorPicker"][sub-type="fibExtention"]').mainColorPanel('value', extentionLineColor);
        $container.find('input[inf-ctrl="singleFontColorPicker"][sub-type="fibExtention"]').mainColorPanel('value', extentionFontColor);

        var widthText = $($container.find('li[inf-ctrl="lineWidth"][inf-size="' + extentionLineWidth + '"]')[0]).find('span').text();
        $container.find('span[inf-ctrl="singleSelectedLineWidth"][sub-type="fibExtention"]').text(widthText);
        $container.find('span[inf-ctrl="singleSelectedLineWidth"][sub-type="fibExtention"]').attr('inf-size', extentionLineWidth);

        $container.find('ul[inf-ctrl="fibExtentionAlign"]').find('li[inf-ctrl="alignStyle"]').removeClass('active');
        $container.find('ul[inf-ctrl="fibExtentionAlign"]').find('li[inf-ctrl="alignStyle"][inf-style="' + extentionLabelPosition + '"]').addClass('active');

        $container.find('input[inf-ctrl="snapToHighLowToggle"]').prop('checked', isSnapTopHighLowEnabled);
        $container.find('input[inf-ctrl="showTrendLineAlways"]').prop('checked', isTrendLineAlwaysEnabled);
        $container.find('input[inf-ctrl="fibLevel"][sub-type="fibExtention"]').prop('checked', false);

        $container.find('span[inf-ctrl="singleSelectedFontSize"][inf-ctrl-val="P_all"][sub-type="fibExtention"]').text(extentionFontSize);
        $container.find('span[inf-ctrl="singleSelectedFontSize"][inf-ctrl-val="P_all"][sub-type="fibExtention"]').attr('inf-size', extentionFontSize);

        $.each(fibExtentionLevels, function (key, fibLevel) {
            $container.find('input[inf-ctrl="fibLevelFillColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibExtention"]').data('minicolors-initialized', false);
            $container.find('input[inf-ctrl="fibLevelLineColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibExtention"]').data('minicolors-initialized', false);
            $container.find('input[inf-ctrl="fibLevelFontColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibExtention"]').data('minicolors-initialized', false);

            $container.find('input[inf-ctrl="fibLevel"][data-value="' + fibLevel.id + '"][sub-type="fibExtention"]').prop('checked', fibLevel.enable);
            $container.find('input[inf-ctrl="fibLevelValue"][sub-type="fibExtention"][data-value="' + fibLevel.id + '"]').val(infChart.drawingUtils.common.formatValue((fibLevel.value/100), 3));

            $container.find('input[inf-ctrl="fibLevelFillColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibExtention"]').mainColorPanel('value', fibLevel.fillColor);
            $container.find('input[inf-ctrl="fibLevelFillColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibExtention"]').mainColorPanel('opacity', fibLevel.fillOpacity);
            $container.find('input[inf-ctrl="fibLevelLineColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibExtention"]').mainColorPanel('value', fibLevel.lineColor);
            $container.find('input[inf-ctrl="fibLevelFontColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibExtention"]').mainColorPanel('value', fibLevel.fontColor);

            var lineWeightText = $($container.find('li[inf-ctrl="lineWidth"][inf-size="' + fibLevel.lineWidth + '"]')[0]).find('span').text();
            $container.find('span[inf-ctrl="fibLevelSelectedLineWidth"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibExtention"]').text(lineWeightText);
            $container.find('span[inf-ctrl="fibLevelSelectedLineWidth"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibExtention"]').attr('inf-size', fibLevel.lineWidth);

            $container.find('span[inf-ctrl="fibLevelSelectedFontSize"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibExtention"]').text(fibLevel.fontSize);
            $container.find('span[inf-ctrl="fibLevelSelectedFontSize"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibExtention"]').attr('inf-size', fibLevel.fontSize);

            $container.find('button[inf-ctrl="fibLevelToggleFontWeight"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibExtention"]').toggleClass("active", fibLevel.fontWeight === "bold").attr("inf-font-weight", fibLevel.fontWeight);
        });

        $.each(fibExtentionLevels, function (key, fibLevel) {
            $container.find('input[inf-ctrl="fibLevelFillColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibExtention"]').data('minicolors-initialized', true);
            $container.find('input[inf-ctrl="fibLevelLineColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibExtention"]').data('minicolors-initialized', true);
            $container.find('input[inf-ctrl="fibLevelFontColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibExtention"]').data('minicolors-initialized', true);
        });

        $container.find('input[inf-ctrl="singleFillColorPicker"][sub-type="fibExtention"]').data('minicolors-initialized', true);
        $container.find('input[inf-ctrl="singleLineColorPicker"][sub-type="fibExtention"]').data('minicolors-initialized', true);
        $container.find('input[inf-ctrl="singleFontColorPicker"][sub-type="fibExtention"]').data('minicolors-initialized', true);

        //fibRetrancement Levels
        $container.find('input[inf-ctrl="singleFillColorPicker"][sub-type="fibRetracement"]').data('minicolors-initialized', false);
        $container.find('input[inf-ctrl="singleLineColorPicker"][sub-type="fibRetracement"]').data('minicolors-initialized', false);
        $container.find('input[inf-ctrl="singleFontColorPicker"][sub-type="fibRetracement"]').data('minicolors-initialized', false);

        $container.find('input[inf-ctrl="singleRetrancementFillColorControl"]').prop('checked', !!isSingleColorRetracement);
        $container.find('button[inf-ctrl=singleApplyAll][sub-type="fibRetracement"]').toggleClass('disabled', !isSingleColorRetracement).prop('disabled', !isSingleColorRetracement);

        $container.find('input[inf-ctrl="singleFillColorPicker"][sub-type="fibRetracement"]').mainColorPanel('value', retrancementFillColor);
        $container.find('input[inf-ctrl="singleFillColorPicker"][sub-type="fibRetracement"]').mainColorPanel('opacity', retrancementFillOpacity);
        $container.find('input[inf-ctrl="singleLineColorPicker"][sub-type="fibRetracement"]').mainColorPanel('value', retrancementLineColor);
        $container.find('input[inf-ctrl="singleFontColorPicker"][sub-type="fibRetracement"]').mainColorPanel('value', retrancementFontColor);

        var widthText = $($container.find('li[inf-ctrl="lineWidth"][inf-size="' + retrancementLineWidth + '"]')[0]).find('span').text();
        $container.find('span[inf-ctrl="singleSelectedLineWidth"][sub-type="fibRetracement"]').text(widthText);
        $container.find('span[inf-ctrl="singleSelectedLineWidth"][sub-type="fibRetracement"]').attr('inf-size', retrancementLineWidth);

        $container.find('ul[inf-ctrl="fibRetracementAlign"]').find('li[inf-ctrl="alignStyle"]').removeClass('active');
        $container.find('ul[inf-ctrl="fibRetracementAlign"]').find('li[inf-ctrl="alignStyle"][inf-style="' + retracementLabelPosition + '"]').addClass('active');

        $container.find('input[inf-ctrl="fibLevel"][sub-type="fibRetracement"]').prop('checked', false);

        $container.find('span[inf-ctrl="singleSelectedFontSize"][inf-ctrl-val="P_all"][sub-type="fibRetracement"]').text(retrancementFontSize);
        $container.find('span[inf-ctrl="singleSelectedFontSize"][inf-ctrl-val="P_all"][sub-type="fibRetracement"]').attr('inf-size', retrancementFontSize);

        $.each(fibRetrancementLevels, function (key, fibLevel) {
            $container.find('input[inf-ctrl="fibLevelFillColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibRetracement"]').data('minicolors-initialized', false);
            $container.find('input[inf-ctrl="fibLevelLineColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibRetracement"]').data('minicolors-initialized', false);
            $container.find('input[inf-ctrl="fibLevelFontColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibRetracement"]').data('minicolors-initialized', false);

            $container.find('input[inf-ctrl="fibLevel"][data-value="' + fibLevel.id + '"][sub-type="fibRetracement"]').prop('checked', fibLevel.enable);
            $container.find('input[inf-ctrl="fibLevelValue"][sub-type="fibRetracement"][data-value="' + fibLevel.id + '"]').val(infChart.drawingUtils.common.formatValue((fibLevel.value/100), 3));

            $container.find('input[inf-ctrl="fibLevelFillColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibRetracement"]').mainColorPanel('value', fibLevel.fillColor);
            $container.find('input[inf-ctrl="fibLevelFillColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibRetracement"]').mainColorPanel('opacity', fibLevel.fillOpacity);
            $container.find('input[inf-ctrl="fibLevelLineColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibRetracement"]').mainColorPanel('value', fibLevel.lineColor);
            $container.find('input[inf-ctrl="fibLevelFontColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibRetracement"]').mainColorPanel('value', fibLevel.fontColor);

            var lineWeightText = $($container.find('li[inf-ctrl="lineWidth"][inf-size="' + fibLevel.lineWidth + '"]')[0]).find('span').text();
            $container.find('span[inf-ctrl="fibLevelSelectedLineWidth"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibRetracement"]').text(lineWeightText);
            $container.find('span[inf-ctrl="fibLevelSelectedLineWidth"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibRetracement"]').attr('inf-size', fibLevel.lineWidth);

            $container.find('span[inf-ctrl="fibLevelSelectedFontSize"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibRetracement"]').text(fibLevel.fontSize);
            $container.find('span[inf-ctrl="fibLevelSelectedFontSize"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibRetracement"]').attr('inf-size', fibLevel.fontSize);

            $container.find('button[inf-ctrl="fibLevelToggleFontWeight"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibRetracement"]').toggleClass("active", fibLevel.fontWeight === "bold").attr("inf-font-weight", fibLevel.fontWeight);
        });

        $.each(fibRetrancementLevels, function (key, fibLevel) {
            $container.find('input[inf-ctrl="fibLevelFillColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibRetracement"]').data('minicolors-initialized', true);
            $container.find('input[inf-ctrl="fibLevelLineColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibRetracement"]').data('minicolors-initialized', true);
            $container.find('input[inf-ctrl="fibLevelFontColorPicker"][inf-ctrl-val="' + fibLevel.id + '"][sub-type="fibRetracement"]').data('minicolors-initialized', true);
        });

        $container.find('input[inf-ctrl="singleFillColorPicker"][sub-type="fibRetracement"]').data('minicolors-initialized', true);
        $container.find('input[inf-ctrl="singleLineColorPicker"][sub-type="fibRetracement"]').data('minicolors-initialized', true);
        $container.find('input[inf-ctrl="singleFontColorPicker"][sub-type="fibRetracement"]').data('minicolors-initialized', true);
        $container.find('input[inf-ctrl="trendLineColorPicker"]').data('minicolors-initialized', true);
    };

    var _updateLabelSettings = function ($container, color, text, backgroundColor, stroke, isBorderEnabled, isBackgroundEnabled, selectedFontStyles, textOnly) {
        $container.find("textarea[inf-ctrl=text]").val(text);
        if (!textOnly) {
            $container.find('li[inf-ctrl=fontStyle]').removeClass('active');
            infChart.util.forEach(selectedFontStyles, function (i, style) {
                $container.find('li[inf-ctrl=fontStyle][inf-style="' + style + '"]').addClass('active');
            });
            $container.find('input[inf-ctrl="colorPicker"]').mainColorPanel('value', color);
            $container.find('input[inf-ctrl="backgroundColorPicker"]').mainColorPanel('value', backgroundColor);
            $container.find('input[inf-ctrl="borderColorPicker"]').mainColorPanel('value', stroke);
            $container.find('input[inf-ctrl="borderColorEnabled"]').prop('checked',isBorderEnabled);
            $container.find('input[inf-ctrl="backgroundColorEnabled"]').prop('checked',isBackgroundEnabled);
            $container.find("input[inf-ctrl=text]").focus();
        }
    };

    var _updateHighLowLabelsSettings = function ($container, color, labelDataItems) {
        $container.find('input[inf-ctrl="colorPicker"]').mainColorPanel('value', color);

        $.each(labelDataItems, function (key, labelDataItem) {
            $container.find('input[inf-ctrl="labelDataItem"][data-value="' + labelDataItem.id + '"]').prop('checked', labelDataItem.enabled);
        });
    };

    var _updateRegressionChannelSettings = function ($container, color, lineWidth, levels) {
        $container.find('li[inf-ctrl="lineWidth"]').removeClass('active');
        $container.find('li[inf-ctrl="lineWidth"][inf-size="' + lineWidth + '"]').addClass('active');
        $container.find('input[inf-ctrl="lineColorPicker"]').mainColorPanel('value', color);

        for (var id in levels) {
            if (levels.hasOwnProperty(id)) {
                $container.find('input[inf-ctrl="fillColorPicker"][inf-ctrl-val="' + id + '"]').mainColorPanel('value', levels[id].fillColor);
                $container.find('input[inf-ctrl="fillColorPicker"][inf-ctrl-val="' + id + '"]').mainColorPanel('opacity', levels[id].fillOpacity);
            }
        }
    };

    /**
     * brush settings
     * @param color
     * @returns {string}
     * @private
     */
    var _getBrushSettings = function (color, opacity) {
        var sectionRows = [];
        sectionRows.push(infChart.structureManager.settings.getSectionRow([
            infChart.structureManager.settings.getLineWeightRowItem()
        ]));

        sectionRows.push(infChart.structureManager.settings.getSectionRow([
            infChart.structureManager.settings.getColorPickerRowItem('lineColorPicker', color, opacity, 'color', 'top left', 'label.lineColor')
        ], 'two-col-row'));

        return infChart.structureManager.settings.getPanelBodyHTML([infChart.structureManager.settings.getSection(sectionRows)]) +
               _getResetToDefaultHTML();
    };

    var _getBrushQuickSettings = function (color, opacity) {
        var html = "";
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML('lineColorPicker', 'color', color, opacity, 'top left'), "has-color-picker line-color", infChart.manager.getLabel("label.lineColor"), "right");
        return html;
    };

    /**
     * Update brush settings
     * @param $container
     * @param color
     * @param lineWidth
     * @param lineStyle
     * @private
     */
    var _updateBrushSettings = function ($container, settings) {
        $container.find('li[inf-ctrl="lineWidth"]').removeClass('active');
        $container.find('li[inf-ctrl="lineWidth"][inf-size="' + settings.lineWidth + '"]').addClass('active');
        $container.find('input[inf-ctrl="lineColorPicker"]').mainColorPanel('value', settings.lineColor);
        $container.find('input[inf-ctrl="lineColorPicker"]').mainColorPanel('opacity', settings.lineOpacity);
    };

    /**
     * XABCD settings
     * @param color
     * @returns {string}
     * @private
     */
     var _getXabcdSettings = function (lineColor, fillColor, fillOpacity, fontColor, fontSize) {
        var rowItems = [], sectionRows = [];
        sectionRows.push(infChart.structureManager.settings.getSectionRow([infChart.structureManager.settings.getLineWeightRowItem()]));

        rowItems.push(infChart.structureManager.settings.getColorPickerRowItem('lineColorPicker', lineColor, false, 'lineColor', 'top left', 'label.lineColor'));
        if (fillColor) {
            rowItems.push(infChart.structureManager.settings.getColorPickerRowItem('fillColorPicker', fillColor, fillOpacity, 'fillColor', 'top right', 'label.fillColor'));
        }
        sectionRows.push(infChart.structureManager.settings.getSectionRow(rowItems, 'two-col-row'));

        rowItems.push(infChart.structureManager.settings.getColorPickerRowItem('textColorPicker', fontColor, false, 'textColor', 'top left', 'label.labelColor'));

        sectionRows.push(infChart.structureManager.settings.getSectionRow([
            infChart.structureManager.settings.getFontSizeRowItem(fontSize, 'dropup', 8, 24, 'label.labelSize'),
        ]));

        return  infChart.structureManager.settings.getPanelBodyHTML([infChart.structureManager.settings.getSection(sectionRows)]) +
                _getResetToDefaultHTML();
    };

    var _getXabcdQuickSettings = function (lineColor, fillColor, fillOpacity) {
        var html = "";
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML('lineColorPicker', 'lineColor', lineColor, false, 'bottom left'), "has-color-picker line-color", infChart.manager.getLabel("label.lineColor"), "right");
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML('fillColorPicker', 'fillColor', fillColor, fillOpacity, 'top left'), "has-color-picker fill-color", infChart.manager.getLabel("label.fillColor"), "right");
        return html;
    };

    /**
     * Update XABCD settings
     * @param $container
     * @param color
     * @param lineWidth
     * @param lineStyle
     * @private
     */
    var _updateXabcdSettings = function ($container, color, lineWidth, fillColor, fillOpacity, fontColor, fontSize) {

            $container.find('input[inf-ctrl="lineColorPicker"]').data('minicolors-initialized', false);

            $container.find('li[inf-ctrl="lineWidth"]').removeClass('active');
            $container.find('li[inf-ctrl="lineWidth"][inf-size="' + lineWidth + '"]').addClass('active');
            $container.find('input[inf-ctrl="lineColorPicker"]').mainColorPanel('value', color);
            if (fillColor) {
                $container.find('input[inf-ctrl="fillColorPicker"]').mainColorPanel('value', fillColor);
                $container.find('input[inf-ctrl="fillColorPicker"]').mainColorPanel('opacity', fillOpacity);
            }
            $container.find('input[inf-ctrl="textColorPicker"]').mainColorPanel('value', fontColor);

            $container.find('span[inf-ctrl="singleSelectedFontSize"][inf-ctrl-val="P_all"]').text(fontSize).attr('inf-size', fontSize);

            $container.find('input[inf-ctrl="lineColorPicker"]').data('minicolors-initialized', true)
    };


    var _bindXabcdSettings = function ($container, callBackFnXabcdSettings) {
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=lineColorPicker]"), undefined, callBackFnXabcdSettings.onColorChange);

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=fillColorPicker]"), undefined, callBackFnXabcdSettings.onFillColorChange);

        _bindSeriesLineWidthEvents($container, callBackFnXabcdSettings.onLineWidthChange);

        infChart.structureManager.settings.bindPanel($container, callBackFnXabcdSettings.onClose);

        _bindResetToDefaultEvent($container , callBackFnXabcdSettings.onResetToDefault);

        infChart.util.bindColorPicker($container.find("input[inf-ctrl=textColorPicker]"), undefined, callBackFnXabcdSettings.onLabelTextColorChange);

        $container.find("li[inf-ctrl=fontSize]").on('click', function (e) {
            var fontSize = $(this).attr('inf-size');
            callBackFnXabcdSettings.onLabelTextSizeChange(fontSize);
            var ctrlType = $(this).parent().attr('inf-ctrl');
            $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedFontSize]").text($(this).text()).attr('inf-size', fontSize);
        });

    };

    /**
     * ABCD settings
     * @param color
     * @returns {string}
     * @private
     */
    var _getAbcdSettings = function (lineColor, fontColor, fontSize) {
        var rowItems = [], sectionRows = [];
        sectionRows.push(infChart.structureManager.settings.getSectionRow([infChart.structureManager.settings.getLineWeightRowItem()]));
        rowItems.push(infChart.structureManager.settings.getColorPickerRowItem('lineColorPicker', lineColor, false, 'lineColor', 'top left', 'label.lineColor'));
        sectionRows.push(infChart.structureManager.settings.getSectionRow(rowItems, 'two-col-row'));
        rowItems.push(infChart.structureManager.settings.getColorPickerRowItem('textColorPicker', fontColor, false, 'textColor', 'top right', 'label.labelColor'));

        sectionRows.push(infChart.structureManager.settings.getSectionRow([
            infChart.structureManager.settings.getFontSizeRowItem(fontSize, 'dropup', 8, 24, 'label.labelSize'),
        ]));

        return infChart.structureManager.settings.getPanelBodyHTML([infChart.structureManager.settings.getSection(sectionRows)]) +
            _getResetToDefaultHTML();
    };

    var _getAbcdQuickSettings = function (lineColor) {
        var html = "";
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML('lineColorPicker', 'lineColor', lineColor, false, 'top left'), "has-color-picker line-color", infChart.manager.getLabel("label.lineColor"), "right");
        return html;
    };

    /**
     * Update ABCD settings
     * @param $container
     * @param color
     * @param lineWidth
     * @param lineStyle
     * @private
     */
    var _updateAbcdSettings = function ($container, color, lineWidth, fontColor, fontSize) {

        $container.find('input[inf-ctrl="lineColorPicker"]').data('minicolors-initialized', false);

        $container.find('li[inf-ctrl="lineWidth"]').removeClass('active');
        $container.find('li[inf-ctrl="lineWidth"][inf-size="' + lineWidth + '"]').addClass('active');
        $container.find('input[inf-ctrl="lineColorPicker"]').mainColorPanel('value', color);
        $container.find('input[inf-ctrl="textColorPicker"]').mainColorPanel('value', fontColor);

        $container.find('span[inf-ctrl="singleSelectedFontSize"][inf-ctrl-val="P_all"]').text(fontSize).attr('inf-size', fontSize);

        $container.find('input[inf-ctrl="lineColorPicker"]').data('minicolors-initialized', true)
    };

    /**
     * Polyline settings
     * @param color
     * @returns {string}
     * @private
     */
    var _getPolylineSettings = function (lineColor, fillColor, fillOpacity) {
        var rowItems = [], sectionRows = [];
        sectionRows.push(infChart.structureManager.settings.getSectionRow([infChart.structureManager.settings.getLineWeightRowItem()]));
        sectionRows.push(infChart.structureManager.settings.getSectionRow([infChart.structureManager.settings.getLineStyleRowItem()]));
        rowItems.push(infChart.structureManager.settings.getColorPickerRowItem('lineColorPicker', lineColor, false, 'lineColor', 'top left', 'label.lineColor'));
        rowItems.push(infChart.structureManager.settings.getColorPickerRowItem('fillColorPicker', fillColor, fillOpacity, 'fillColor', 'top right', 'label.fillColor'));
        sectionRows.push(infChart.structureManager.settings.getSectionRow(rowItems, 'two-col-row'));
        return infChart.structureManager.settings.getPanelBodyHTML([infChart.structureManager.settings.getSection(sectionRows)]) +
            _getResetToDefaultHTML();
    };

    var _getPolylineQuickSettings = function (lineColor, fillColor, fillOpacity) {
        var html = "";
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML('lineColorPicker', 'lineColor', lineColor, false, 'top left'), "has-color-picker line-color", infChart.manager.getLabel("label.lineColor"), "right");
        if (fillColor) {
            html += infChart.structureManager.settings.getQuicksettingListItemHTML(
                infChart.structureManager.settings.getColorPaletteHTML('fillColorPicker', 'fillColor', fillColor, fillOpacity, 'top left'), "has-color-picker", infChart.manager.getLabel("label.fillColor"), "right");
        }
        return html;
    };

    /**
     * Update Polyline settings
     * @param $container
     * @param color
     * @param lineWidth
     * @private
     */
    var _updatePolylineSettings = function ($container, color, lineWidth, fillColor, fillOpacity, lineStyle) {
        $container.find('li[inf-ctrl="lineWidth"]').removeClass('active');
        $container.find('li[inf-ctrl="lineWidth"][inf-size="' + lineWidth + '"]').addClass('active');
        $container.find('input[inf-ctrl="lineColorPicker"]').mainColorPanel('value', color);
        $container.find('input[inf-ctrl="fillColorPicker"]').mainColorPanel('value', fillColor);
        $container.find('input[inf-ctrl="fillColorPicker"]').mainColorPanel('opacity', fillOpacity);
        $container.find('li[inf-ctrl="lineStyle"][inf-style="' + lineStyle + '"]').addClass('active');
    };

    /**
     * Elliot Wave settings
     * @param color
     * @returns {string}
     * @private
     */
    var _getElliotWaveSettings = function (lineColor, baseBorderColor, waveDegree, waveDegreesList, fontSize) {
        var rowItems = [], sectionRows = [];
        sectionRows.push(infChart.structureManager.settings.getSectionRow([infChart.structureManager.settings.getRowItem('<p class="item-label">' + _getSnapToHighLowToggleHTML() + '</p>', '')]));
        sectionRows.push(infChart.structureManager.settings.getSectionRow([infChart.structureManager.settings.getLineWeightRowItem()]));

        sectionRows.push(infChart.structureManager.settings.getSectionRow([
            infChart.structureManager.settings.getFontSizeRowItem(fontSize, 'dropdown', 8, 24),
        ]));

        rowItems.push(infChart.structureManager.settings.getColorPickerRowItem('lineColorPicker', lineColor, false, 'lineColor', 'top left', 'label.lineColor'));
        sectionRows.push(infChart.structureManager.settings.getSectionRow(rowItems, 'two-col-row'));
        sectionRows.push(infChart.structureManager.settings.getSectionRow([
            infChart.structureManager.settings.getWaveDegreeRowItem(waveDegree, waveDegreesList),
        ]));
        return infChart.structureManager.settings.getPanelBodyHTML([infChart.structureManager.settings.getSection(sectionRows)]) +
            _getResetToDefaultHTML();
    };
    
    var _getElliotWaveQuickSettings = function (lineColor) {
        var html = "";
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML('lineColorPicker', 'lineColor', lineColor, false, 'top left'), "has-color-picker line-color", infChart.manager.getLabel("label.lineColor"), "right");
        return html;
    };
    
    /**
     * Update Elliot Wave settings
     * @param $container
     * @param color
     * @param lineWidth
     * @param lineStyle
     * @private
     */
    var _updateElliotWaveSettings = function ($container, color, lineWidth,currentWaveDegree, isSnapTopHighLowEnabled, fontSize) {
        $container.find('li[inf-ctrl="lineWidth"]').removeClass('active');
        $container.find('li[inf-ctrl="lineWidth"][inf-size="' + lineWidth + '"]').addClass('active');
        $container.find('input[inf-ctrl="lineColorPicker"]').mainColorPanel('value', color);
        $container.find('input[inf-ctrl="snapToHighLowToggle"]').prop('checked', isSnapTopHighLowEnabled);
        $container.find('span[inf-ctrl="singleSelectedFontSize"][inf-ctrl-val="P_all"]').text(fontSize).attr('inf-size', fontSize);
    };

    var _bindElliotWaveSettings = function ($container, callBackFnElliotWaveSettingsEvents) {
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=lineColorPicker]"), undefined, callBackFnElliotWaveSettingsEvents.onColorChange);
        _bindSeriesLineWidthEvents($container, callBackFnElliotWaveSettingsEvents.onLineWidthChange);
        $container.find("li[inf-ctrl=waveDegree]").on('click', function (e) {
            $(this).addClass("active");
            var waveDegree = $(this).attr('inf-type');
            callBackFnElliotWaveSettingsEvents.onWaveDegreeChange(waveDegree, $(this).parent());
            var ctrlType = $(this).parent().attr('inf-ctrl');
            $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedWaveDegree]").text($(this).text()).attr('inf-type', waveDegree);
        });
        infChart.structureManager.settings.bindPanel($container, callBackFnElliotWaveSettingsEvents.onClose);
        _bindResetToDefaultEvent($container , callBackFnElliotWaveSettingsEvents.onResetToDefault);

        $container.find("input[inf-ctrl=snapToHighLowToggle]").on('click', function (e) {
            callBackFnElliotWaveSettingsEvents.onToggleSnapToHighLow($(this).is(":checked"));
            e.stopPropagation();
        });

        $container.find("li[inf-ctrl=fontSize]").on('click', function (e) {
            var fontSize = $(this).attr('inf-size');
            callBackFnElliotWaveSettingsEvents.onLabelTextSizeChange(fontSize);
            var ctrlType = $(this).parent().attr('inf-ctrl');
            $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedFontSize]").text($(this).text()).attr('inf-size', fontSize);
        });
    };

    var _bindAbcdSettings = function ($container, callBackFnAbcdSettings) {
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=lineColorPicker]"), undefined, callBackFnAbcdSettings.onColorChange);
        _bindSeriesLineWidthEvents($container, callBackFnAbcdSettings.onLineWidthChange);
        infChart.structureManager.settings.bindPanel($container, callBackFnAbcdSettings.onClose);
        _bindResetToDefaultEvent($container , callBackFnAbcdSettings.onResetToDefault);
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=textColorPicker]"), undefined, callBackFnAbcdSettings.onLabelTextColorChange);

        $container.find("li[inf-ctrl=fontSize]").on('click', function (e) {
            var fontSize = $(this).attr('inf-size');
            callBackFnAbcdSettings.onLabelTextSizeChange(fontSize);
            var ctrlType = $(this).parent().attr('inf-ctrl');
            $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedFontSize]").text($(this).text()).attr('inf-size', fontSize);
        });

    };

    var _bindPolylineSettings = function ($container, onClose, onPolylineColorChange, onPolylineWidthChange, onPolylineFillColorChange, onPolyLineStyleChange, onResetToDefault) {
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=lineColorPicker]"), undefined, onPolylineColorChange);
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=fillColorPicker]"), undefined, onPolylineFillColorChange);
        _bindSeriesLineWidthEvents($container, onPolylineWidthChange);
        $container.find("li[inf-ctrl=lineStyle]").on('click', function (e) {
            var dashStyle = $(this).attr("inf-style");
            $container.find("li[inf-ctrl=lineStyle]").removeClass('active');
            $(this).addClass('active');
            onPolyLineStyleChange(dashStyle);
            e.stopPropagation();
        });
        infChart.structureManager.settings.bindPanel($container, onClose);
        _bindResetToDefaultEvent($container , onResetToDefault);
    };

    var _getFibFontSizeHTML = function (typeClass, ctrlType) {
        return '<ul class="' + (typeClass ? typeClass : 'selection-types') + '"' + (ctrlType ? 'inf-ctrl="' + ctrlType + '"' : '') + '>' +
            '<li inf-ctrl="fontSize" inf-size="8"><a><span class="line-weight-space">8</span></a></li>' +
            '<li inf-ctrl="fontSize" inf-size="9"><a><span class="line-weight-space">9</span></a></li>' +
            '<li inf-ctrl="fontSize" inf-size="10"><a><span class="line-weight-space">10</span></a></li>' +
            '<li inf-ctrl="fontSize" inf-size="11"><a><span class="line-weight-space">11</span></a></li>' +
            '<li inf-ctrl="fontSize" inf-size="12"><a><span class="line-weight-space">12</span></a></li>' +
            '</ul>';
    };

    /**
       * get fib level rettinf row HTML
       * @param {stirng} ctrlType - tag used to identify the control
       * @param {string} fillColor - fill color hex
       * @param {number} opacity - opacity 0-1
       * @param {string} lineColor - line color hex
       * @param {number} lineWidth - line width 1,2,3
       * @param {string} ctrlValue - fib level id - P_all for all control
       * @param {string} position - used to show the minicolor palette
       * @returns
       */
    var _getFibLevelSettingRowHTML = function (ctrlType, fillColor, opacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, ctrlValue, position, isApplyAllButton, subType, applyToAllClass) {
        let settingHTML = '<div class="fib-options-wrapper">';
        settingHTML += infChart.structureManager.settings.getMiniColorPaletteHTML(ctrlType + 'FillColorPicker', ctrlValue, fillColor, position, opacity, 'fa fa-tint', undefined, subType);
        if (lineColor) {
            settingHTML += infChart.structureManager.settings.getMiniColorPaletteHTML(ctrlType + 'LineColorPicker', ctrlValue, lineColor, position, undefined, 'icon ico-ang-dash', 'line-color', subType);
        }
        if (lineWidth) {
            let lineWidthHTML = '<div class="dropdown line-weights">' +
                    '<button class="dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">' +
                        '<span inf-ctrl="' + ctrlType + 'SelectedLineWidth" sub-type="' + (subType ? subType : '') + '"  class="weight-line" inf-ctrl-val="' + ctrlValue + '" inf-size="' + lineWidth + '">&#x2F;</span>' +
                        '<span class="caret"></span>' +
                    '</button>' +
                    infChart.structureManager.settings.getLineWeightHTML('dropdown-menu', ctrlType) +
                '</div>';
            settingHTML += lineWidthHTML;
        }
        if (fontSize) {
            let fontSizeHTML = '<div class="dropdown font-size">' +
                    '<button class="dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">' +
                        '<span inf-ctrl="' + ctrlType + 'SelectedFontSize" sub-type="' + (subType ? subType : '') + '" inf-ctrl-val="' + ctrlValue + '" inf-size="' + fontSize + '">' + fontSize + '</span>' +
                        '<span class="caret"></span>' +
                    '</button>' +
                    _getFibFontSizeHTML('dropdown-menu', ctrlType) +
                '</div>';
            settingHTML += fontSizeHTML;
        }
        if (fontColor) {
            settingHTML += infChart.structureManager.settings.getMiniColorPaletteHTML(ctrlType + 'FontColorPicker', ctrlValue, fontColor, position, undefined, 'fa fa-tint', 'font-color', subType);
        }
        if (fontWeight) {
            let fontWeightHTML = '<div  class="has-btn">' +
                        '<button inf-ctrl-val="' + ctrlValue + '" inf-ctrl="' + ctrlType + 'ToggleFontWeight" sub-type="' + (subType ? subType : '') + '" inf-font-weight="' + fontWeight + '" class="btn btn-default '+ (fontWeight === 'bold' ? 'active' : '' ) + '">' +
                            '<i class="icon ico-bold-2"></i>' +
                        '</button>' +
                '</div>';
            settingHTML += fontWeightHTML;
        }
        settingHTML += (isApplyAllButton ? '<div class="has-btn ' + (applyToAllClass ? applyToAllClass : '') + '"><button class="btn btn-default disabled" disabled="true" type="button" sub-type="' + (subType ? subType : '') + '" inf-ctrl="' + ctrlType + 'ApplyAll" >Apply now to all Levels</button></div>' : '');
        settingHTML += '</div>';
        return settingHTML;
    };

    var _getPriceLevelSettingRowHTML = function (ctrlType, lineWidth, lineStyle, ctrlValue, yValue, lineColor, position) {
        return '<div class="fib-options-wrapper">' +
            '<input inf-ctrl="priceLevelValue" inf-value="' + ctrlValue + '"  class="fib-levels-input c-form-control text--right" maxlength="20" type="text" data-value="' + ctrlValue + '" value="' + (parseFloat(yValue)).toFixed(3) + '" >' +
            '<div class="c-dropdown dropdown line-weights">' +
                '<button class="c-dropdown__toggle c-btn c-btn--default dropdown-toggle h--100" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">' +
                    '<span inf-ctrl="' + ctrlType + 'SelectedLineWidth" class="weight-line" inf-ctrl-val="' + ctrlValue + '" inf-size="' + lineWidth + '">&#x2F;</span>' +
                    '<span class="caret"></span>' +
                '</button>' +
                infChart.structureManager.settings.getLineWeightHTML('dropdown-menu c-dropdown__menu', ctrlType) +
            '</div>' +
            '<div class="c-dropdown dropdown line-styles">' +
                '<button class="c-dropdown__toggle c-btn c-btn--default dropdown-toggle h--100" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">' +
                '<span inf-ctrl="' + ctrlType + 'SelectedLineStyle" inf-ctrl-val="' + ctrlValue + '" inf-size="' + lineStyle + '"><i class="icon ico-minus-1"></i></span>' +
                    '<span class="caret"></span>' +
                '</button>' +
                infChart.structureManager.settings.getLineStyleHTML('dropdown-menu c-dropdown__menu', ctrlType) +
            '</div>' +
            infChart.structureManager.settings.getMiniColorPaletteHTML('lineColorPicker', ctrlValue, lineColor, position, undefined, 'fa fa-tint') +
            '</div>';
    };

    /**
       * get fib level setting row item
       * @param {string} ctrlType - tag used to identify the control
       * @param {string} fillColor - fill color hex
       * @param {number} opacity - fill opacity 0-1
       * @param {string} lineColor - line color hex
       * @param {number} lineWidth - line width 1,2,3
       * @param {string} ctrlValue - fib level id - P_all - all settings
       * @param {string} position - position for mini color palette
       * @param {string} title - title string / html
       * @param {boolean} isLabel - is a label or not (html)
       * @returns
       */
    var _getFibLevelSettingsRowItem = function (ctrlType, fillColor, opacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, ctrlValue, position, title, isLabel, isApplyAllButton, subType, applyToAllClass) {
        return infChart.structureManager.settings.getRowItem(_getFibLevelSettingRowHTML(ctrlType, fillColor, opacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, ctrlValue, position, isApplyAllButton, subType, applyToAllClass), title, isLabel);
    };

    var _getPriceLevelSettingsRowItem = function (ctrlType, lineWidth, lineStyle, ctrlValue, yValue, title, isLabel, lineColor, position) {
        return infChart.structureManager.settings.getRowItem(_getPriceLevelSettingRowHTML(ctrlType, lineWidth, lineStyle, ctrlValue, yValue, lineColor, position), title, isLabel);
    };

    var _getQuickSettingsPopupHTML = function (content, isLocked) {
        var config = infChart.settings.toolbar.config && infChart.settings.toolbar.config.quickDrawingSettings;
        var drgHandleeToolTip = infChart.structureManager.toolbar.getToolTipAttributes(infChart.manager.getLabel("label.dragToolbar"), "right");
        var html = ''
        html += '<div class="flt-tlbar" data-inf-quick-drawing-settings-pop-up="">';
        html += '<div inf-pnl="quick-panel-drag-handle" class="flt-tlbar__item flt-tlbar__handler flt-tlbar__drag" ' + drgHandleeToolTip + ' > <i class="icon ico-braille"></i></div>';
        html += '<ul class="flt-tlbar__tools">'+ content;
        if (config) {
            for (var key in config) {
                if (config.hasOwnProperty(key)) {
                    let icon = config[key].cls;
                    let tooltip = infChart.manager.getLabel(config[key].label);

                    if (key === "lock" && isLocked) {
                        icon = config[key].secondaryCls;
                        tooltip = infChart.manager.getLabel(config[key].secondaryLabel);
                    }

                    html += infChart.structureManager.settings.getQuicksettingListItemHTML(
                        _getQuickSettingButtonHTML("quick-setting-" + config[key].ctrl, icon ),
                        config[key].btnClass, tooltip, "left");
                }
            }
        }
        html += '</ul></div>';
        return html;
    };

    var _bindQuickSettingsPopup = function (containerId, quickSettingPopup, onDelete, onShowSettings, toggleLock) {
        var chart = infChart.manager.getChart(containerId);
        var containment = $($(chart.container)).find('div[inf-container=chart]');

        function startFix(event, ui) {
            ui.position.left = 0;
            ui.position.top = 0;
        }

        function dragFix(event, ui) {
            infChart.util.dragFix(chart, event, ui)
        }

        $(quickSettingPopup).find("a[inf-ctrl=quick-setting-delete]").on('click', function (e) {
            onDelete();
            e.stopPropagation();
        });
        $(quickSettingPopup).find("a[inf-ctrl=quick-setting-settings]").on('click', function (e) {
            onShowSettings();
            e.stopPropagation();
        });
        $(quickSettingPopup).find("a[inf-ctrl=quick-setting-lock]").on('click', function (e) {
            toggleLock($(this));
            e.stopPropagation();
        });
        quickSettingPopup.draggable({
            handle: "div[inf-pnl=quick-panel-drag-handle]",
            containment: containment,
            drag: dragFix,
            start: startFix
        });
        _positionQuickMenu(containerId, quickSettingPopup);
    };

    var _positionQuickMenu = function (containerId, quickSettingPopup) {
        var chart = infChart.manager.getChart(containerId);
        var $container = $(chart.container);
        var chartElement = $container.find('[inf-container="chart_container"]');
        var quickSettingsElement = $(quickSettingPopup);

        if(chartElement){
            quickSettingsElement.css("left", quickSettingsElement.outerWidth(true));
            quickSettingsElement.css("top", quickSettingsElement.height());
        }
    };

    var _getQuickSettingButtonHTML = function (ctrlType, icon) {
        return '<a inf-ctrl="' + ctrlType + '"><span class="' + icon + '"></span></a>';
    };

    /**
     * fibonacci settings
     * @param color
     * @param fibLevels
     * @returns {string}
     * @private
     */
    var _getPositionsSettings = function (currency, style) {
        var sections = [],
            mainSectionRowItems = [],
            takeProfitSectionRowItems = [],
            stopLossSectionRowItems = [],
            styleSectionRows = [],
            riskDropDownHTML = '<div class="dropdown has-vertical-list risk-currency" inf-ctrl="riskTypes">' +
            '<button class="btn btn-default dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">' +
            '<span rel="selectItem">%</span> <span class="caret"></span> ' +
            '</button>' +
            '<ul inf-ctrl="riskDropDown" class="dropdown-menu">' +
            '<li rel="riskType" inf-ctrl="percentage" inf-data="%"><a>%</a></li>' +
            '<li rel="riskType" inf-ctrl="size" inf-data="' + currency + '"><a>' + currency + '</a></li>' +
            '</ul>' +
            '</div>',
            currencyLabel = '<label>' + currency + '</label>', //for="' + accountSizeUniqueId + '"
            controls = [
                {ctrl: "accountSize", label: "Account Size", appendHTML: currencyLabel, rowItems: mainSectionRowItems},
                {ctrl: "lotSize", label: "Lot Size", appendHTML: "", rowItems: mainSectionRowItems},
                {ctrl: "risk", label: "Risk", appendHTML: riskDropDownHTML, rowItems: mainSectionRowItems},
                {ctrl: "entryPrice", label: "Entry Price", appendHTML: "", rowItems: mainSectionRowItems},
                {ctrl: "takeProfitTicks", label: "Ticks", appendHTML: "", rowItems: takeProfitSectionRowItems},
                {ctrl: "takeProfitPrice", label: "Price", appendHTML: "", rowItems: takeProfitSectionRowItems},
                {ctrl: "stopLossTicks", label: "Ticks", appendHTML: "", rowItems: stopLossSectionRowItems},
                {ctrl: "stopLossPrice", label: "Price", appendHTML: "", rowItems: stopLossSectionRowItems},
            ],
            controlUniqueId, controlHTML;

        controls.forEach(function (control) {
            controlUniqueId = new Date().getTime();
            controlLabelHTML = '<label for="' + controlUniqueId + '">'+ control.label +'</label>';
            controlBobyHTML = '<div class="fib-options-wrapper"><input inf-ctrl="'+ control.ctrl +'" type="text"  id="' + controlUniqueId + '">' + control.appendHTML + '</div>';
            control.rowItems.push(infChart.structureManager.settings.getRowItem(controlBobyHTML,controlLabelHTML, false));
        });

        sections.push(infChart.structureManager.settings.getSection([infChart.structureManager.settings.getSectionRow(mainSectionRowItems , 'two-col-row fib-section')]));
        sections.push(infChart.structureManager.settings.getSection([infChart.structureManager.settings.getSectionRow(takeProfitSectionRowItems , 'two-col-row fib-section')], "Profit Level"));
        sections.push(infChart.structureManager.settings.getSection([infChart.structureManager.settings.getSectionRow(stopLossSectionRowItems , 'two-col-row fib-section')], "Stop Level"));

        var lineStyleHTML = '<div class="fib-options-wrapper">' +
            infChart.structureManager.settings.getMiniColorPaletteHTML('lineColorPicker', "", style.lineColor, undefined, style.lineOpacity, 'fa fa-tint') +
            '<div class="dropdown line-weights">' +
            '<button class="dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">' +
            '<span inf-ctrl="selectedLineWidth" class="weight-line" inf-size="'+ style.lineWidth +'">&#x2F;</span>' +
            '<span class="caret"></span>' +
            '</button>' +
            infChart.structureManager.settings.getLineWeightHTML('dropdown-menu') +
            '</div>' +
            '</div>';
        styleSectionRows.push(infChart.structureManager.settings.getRowItem(lineStyleHTML, "Lines", false));
        styleSectionRows.push(infChart.structureManager.settings.getRowItem(
            '<div class="fib-options-wrapper">' + infChart.structureManager.settings.getMiniColorPaletteHTML('stopLossColorPicker', "", style.stopLossColor, undefined, style.stopLossFillOpacity, 'fa fa-tint') + '</div>', infChart.manager.getLabel("label.stopColor"), false));
        styleSectionRows.push(infChart.structureManager.settings.getRowItem(
            '<div class="fib-options-wrapper">' + infChart.structureManager.settings.getMiniColorPaletteHTML('takeProfitColorPicker', "", style.takeProfitColor, undefined, style.stopLossFillOpacity, 'fa fa-tint') + '</div>', infChart.manager.getLabel("label.targetColor"), false));
        
        var fontStyleHTML = '<div class="fib-options-wrapper">' +
            infChart.structureManager.settings.getMiniColorPaletteHTML('textColorPicker', "", style.textColor, undefined, style.textOpacity, 'fa fa-tint') +
            infChart.structureManager.settings.getFontSizeHTML(style.textFontSize, 'dropdown', 8, 24, 'dropdown-menu--list')             +
            '</div>';
        styleSectionRows.push(infChart.structureManager.settings.getRowItem(fontStyleHTML, "Text", false));

        var uniqueId = new Date().getTime();
        var compactStatsItemHTML = '<input inf-ctrl="compactStats" type="checkbox" checked="checked" id="' + uniqueId + '">' +
            '<label for="' + uniqueId + '">Compact stats mode</label>';

        styleSectionRows.push(infChart.structureManager.settings.getRowItem( "", compactStatsItemHTML, false));

        sections.push(infChart.structureManager.settings.getSection([infChart.structureManager.settings.getSectionRow(styleSectionRows , 'two-col-row fib-section')], "Style"));

        return '<div class="sl-tp-settings">' + infChart.structureManager.settings.getPanelBodyHTML(sections) + '</div>' +
                _getResetToDefaultHTML();
    };

    var _getPositionsQuickSettings = function (currency, style) {
        var html = "";

        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML('lineColorPicker', 'lineColor', style.lineColor, false, 'top left'), "has-color-picker", infChart.manager.getLabel("label.lineColor"), "right");
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML('stopLossColorPicker', 'fillColor', style.stopLossColor, style.stopLossFillOpacity, 'top left'), "has-color-picker", infChart.manager.getLabel("label.stopColor"), "right");
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML('takeProfitColorPicker', 'fillColor', style.takeProfitColor, style.stopLossFillOpacity, 'top left'), "has-color-picker", infChart.manager.getLabel("label.targetColor"), "right");
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML('textColorPicker', 'fillColor', style.textColor, style.stopLossFillOpacity, 'top left'), "has-color-picker", infChart.manager.getLabel("label.fontColor"), "right");

        return html;
    };

    var _bindPositionsSettings = function ($container, annotation, priceDifferenceFactor, CallBackFnPositionSettings) {
        var options = annotation.options;

        $container.find("li[inf-ctrl=fontSize]").on('click', function (e) {
            var fontSize = $(this).attr('inf-size');
            CallBackFnPositionSettings.onLabelTextSizeChange(fontSize);
            var ctrlType = $(this).parent().attr('inf-ctrl');
            $(this).parent().parent().find("span[inf-ctrl="+ ctrlType +"SelectedFontSize]").text($(this).text()).attr('inf-size', fontSize);
        });

        var controls = [
            {ctrl: "accountSize", eventHandler: CallBackFnPositionSettings.onAccountSizeChange},
            {ctrl: "lotSize", eventHandler: CallBackFnPositionSettings.onLotSizeChange},
            {ctrl: "risk", eventHandler: CallBackFnPositionSettings.onRiskChange},
            {ctrl: "entryPrice", eventHandler: CallBackFnPositionSettings.onEntryPriceChange, checkPrices: {min: options.isLongPositions ? "stopLossPrice": "takeProfitPrice", max: options.isLongPositions? "takeProfitPrice": "stopLossPrice"}},
            {ctrl: "takeProfitTicks", eventHandler: CallBackFnPositionSettings.onTakeProfitTicksChange},
            {ctrl: "takeProfitPrice", eventHandler: CallBackFnPositionSettings.onTakeProfitPriceChange, checkPrices: {min: options.isLongPositions ? "entryPrice": null, max: options.isLongPositions? null: "entryPrice"}},
            {ctrl: "stopLossTicks", eventHandler: CallBackFnPositionSettings.onStopLossTicksChange},
            {ctrl: "stopLossPrice", eventHandler: CallBackFnPositionSettings.onStopLossPriceChange, checkPrices: {min: options.isLongPositions ? null: "entryPrice", max: options.isLongPositions? "entryPrice": null}},
        ];
        var colorControls = [
            {ctrl: "lineColorPicker", eventHandler: CallBackFnPositionSettings.onLineColorChange},
            {ctrl: "stopLossColorPicker", eventHandler: CallBackFnPositionSettings.onStopLossColorChange},
            {ctrl: "takeProfitColorPicker", eventHandler: CallBackFnPositionSettings.onTakeProfitColorChange},
            {ctrl: "textColorPicker", eventHandler: CallBackFnPositionSettings.onTextColorChange}
        ];

        controls.forEach(function (control){
            $container.find("input[inf-ctrl=" + control.ctrl + "]").on('blur', function (e) {
                var options = annotation.options;
                var settings = options.settings,
                    minPrice, maxPrice;

                var value = $(this).val();

                if (value !== "" && !isNaN(value)) {
                    var newValue = parseFloat(value);

                    if(control.checkPrices) {
                        minPrice = control.checkPrices.min === "stopLossPrice"? settings.stopLoss.price: control.checkPrices.min === "takeProfitPrice"? settings.takeProfit.price : settings.entryPrice;
                        maxPrice = control.checkPrices.max === "stopLossPrice"? settings.stopLoss.price: control.checkPrices.max === "takeProfitPrice"? settings.takeProfit.price : settings.entryPrice;

                        if(control.checkPrices.min && newValue <= minPrice) {
                            newValue = minPrice + priceDifferenceFactor;
                            $(this).val(newValue);
                        } else if(control.checkPrices.max && newValue >= maxPrice) {
                            newValue = maxPrice - priceDifferenceFactor;
                            $(this).val(newValue);
                        }
                    }

                    control.eventHandler(newValue);
                } else {
                    $(this).parent().addClass('has-error');
                }
                e.stopPropagation();
            });
        });

        $container.find("ul[inf-ctrl=riskDropDown]").find("li[rel=riskType]").on('click', function (){
            $container.find("div[inf-ctrl=riskTypes]").find("span[rel=selectItem]").text($(this).attr("inf-data"));
            annotation.options.settings.risk.selectedItem = $(this).attr("inf-ctrl");
            $container.find("input[inf-ctrl=risk]").val(annotation.options.settings.risk[annotation.options.settings.risk.selectedItem]);
        });

        colorControls.forEach(function (control) {
            infChart.util.bindColorPicker($container.find("input[inf-ctrl=" + control.ctrl + "]"), undefined, function (rgb, value, opacity) {
                control.eventHandler(rgb, value, opacity);
            });
        });

        $container.find('li[inf-ctrl=lineWidth]').on('click', function (e) {
            var strokeWidth = $(this).attr("inf-size");
            $(this).parent().parent().find("span[inf-ctrl=selectedLineWidth]").text($(this).text());
            CallBackFnPositionSettings.onLineWidthChange(strokeWidth);
        });

        $container.find("input[inf-ctrl=compactStats]").on('click', function (e) {
            CallBackFnPositionSettings.onCompactStatsModeChange($(this).is(":checked"));
            e.stopPropagation();
        });

        _bindResetToDefaultEvent($container , CallBackFnPositionSettings.onResetToDefault);
    };

    var _updatePositionsSettings = function ($container, settings, styles, decimalPoints) {
        var colorControls = [
            {ctrl: "lineColorPicker", color: styles.lineColor, opacity: styles.lineOpacity},
            {ctrl: "stopLossColorPicker", color: styles.stopLossColor, opacity: styles.stopLossFillOpacity},
            {ctrl: "takeProfitColorPicker", color: styles.takeProfitColor, opacity: styles.stopLossFillOpacity},
            {ctrl: "textColorPicker", color: styles.textColor, opacity: styles.textOpacity}
        ];

        $container.find('span[inf-ctrl="singleSelectedFontSize"][inf-ctrl-val="P_all"]').text(styles.textFontSize).attr('inf-size', styles.textFontSize);

        $container.find("input[inf-ctrl=accountSize]").val(settings.accountSize);
        $container.find("input[inf-ctrl=lotSize]").val(settings.lotSize);
        $container.find("input[inf-ctrl=entryPrice]").val(settings.entryPrice.toFixed(decimalPoints));

        var riskText = settings.risk.selectedItem === "percentage"? settings.risk.percentage: settings.risk.size;
        $container.find("input[inf-ctrl=risk]").val(riskText);
        $container.find("div[inf-ctrl=riskTypes]").find("span[rel=selectItem]").text($container.find("ul[inf-ctrl=riskDropDown]").find("li[inf-ctrl="+ settings.risk.selectedItem +"]").attr("inf-data"));

        $container.find("input[inf-ctrl=takeProfitTicks]").val(settings.takeProfit.tickSize);
        $container.find("input[inf-ctrl=takeProfitPrice]").val(settings.takeProfit.price.toFixed(decimalPoints));
        $container.find("input[inf-ctrl=stopLossTicks]").val(settings.stopLoss.tickSize);
        $container.find("input[inf-ctrl=stopLossPrice]").val(settings.stopLoss.price.toFixed(decimalPoints));

        colorControls.forEach(function (control) {
            $container.find('input[inf-ctrl="'+ control.ctrl +'"]').mainColorPanel('value', control.color);
            $container.find('input[inf-ctrl="'+ control.ctrl +'"]').mainColorPanel('opacity', control.opacity);
        });

        var lineWeightText = $($container.find('li[inf-ctrl="lineWidth"][inf-size="' + styles.lineWidth + '"]')[0]).find('span').text();
        $container.find('span[inf-ctrl="selectedLineWidth"]').text(lineWeightText);
        $container.find('span[inf-ctrl="selectedLineWidth"]').attr('inf-size', styles.lineWidth);
        $container.find('input[inf-ctrl="compactStats"]').prop('checked', styles.isCompactStats);
    };

    /**
     * TrendChannel settings
     * @param title
     * @param lineColor
     * @param fillColor
     * @param fillOpacity
     * @returns {string}
     * @private
     */
    var _getTrendChannelSettings = function (lineColor, middleLineColor, fillColor, fillOpacity) {
        var sections = [],
            channelStyleSectionRows = [],
            middleLineSectionRows = [];

        channelStyleSectionRows.push(infChart.structureManager.settings.getRowItem(
            '<div class="fib-options-wrapper">' + infChart.structureManager.settings.getLineStyleHTML() + '</div>', "Line Style", false));
        channelStyleSectionRows.push(infChart.structureManager.settings.getRowItem(
            '<div class="fib-options-wrapper">' + infChart.structureManager.settings.getLineWeightHTML() + '</div>', "Line Width", false));
        channelStyleSectionRows.push(infChart.structureManager.settings.getRowItem(
            '<div class="fib-options-wrapper">' + infChart.structureManager.settings.getMiniColorPaletteHTML("channelColorPicker", "", lineColor, undefined, false, "fa fa-tint") + '</div>', "Line Color", false));
        channelStyleSectionRows.push(infChart.structureManager.settings.getRowItem(
            '<div class="fib-options-wrapper">' + infChart.structureManager.settings.getMiniColorPaletteHTML("fillColorPicker", "", fillColor, undefined, fillOpacity, "fa fa-tint") + '</div>', "Fill Color", false));
        sections.push(infChart.structureManager.settings.getSection([infChart.structureManager.settings.getSectionRow(channelStyleSectionRows , 'two-col-row fib-section channel-styles')], "Channel Styles"));

        middleLineSectionRows.push(infChart.structureManager.settings.getRowItem(
            '<div class="fib-options-wrapper">' + infChart.structureManager.settings.getLineStyleHTML() + '</div>', "Line Style", false));
        middleLineSectionRows.push(infChart.structureManager.settings.getRowItem(
            '<div class="fib-options-wrapper">' + infChart.structureManager.settings.getLineWeightHTML() + '</div>', "Line Width", false));
        middleLineSectionRows.push(infChart.structureManager.settings.getRowItem(
            '<div class="fib-options-wrapper">' + infChart.structureManager.settings.getMiniColorPaletteHTML("middleLineColorPicker", "", middleLineColor, undefined, false, "fa fa-tint") + '</div>', "Line Color", false));


        sections.push(infChart.structureManager.settings.getSection([infChart.structureManager.settings.getSectionRow(middleLineSectionRows , 'two-col-row fib-section middle-line-styles')], "Middle Line Styles"));

        return '<div class="sl-tp-settings">' + infChart.structureManager.settings.getPanelBodyHTML(sections) + '</div>' + _getResetToDefaultHTML();
    };

    var _getTrendChannelQuickSettings = function (lineColor, fillColor, fillOpacity) {
        var html = "";
        html += infChart.structureManager.settings.getQuicksettingListItemHTML(
            infChart.structureManager.settings.getColorPaletteHTML('channelColorPicker', '', lineColor, false, 'top left'), "has-color-picker", infChart.manager.getLabel("label.lineColor"), "right");
        // if (fillColor) {
            html += infChart.structureManager.settings.getQuicksettingListItemHTML(
                infChart.structureManager.settings.getColorPaletteHTML('fillColorPicker', 'fillColor', fillColor, fillOpacity, 'top left'), "has-color-picker", infChart.manager.getLabel("label.fillColor"), "right");
        // }
        return html;
    };

    /**
     * bind TrendChannel settings
     * @param {object} $container - main container
     * @param {function} onChannelLineColorChange - color change function
     * @param {function} onChannelLineWidthChange - line width change function
     * @param {function} onChannelLineStyleChange - line style change function
     * @param {function} onFillColorChange - fill color change function
     * @param {function} onMiddleLineColorChange - middle line color change function
     * @param {function} onMiddleLineWidthChange - middle line width change function
     * @param {function} onMiddleLineStyleChange - middle line style change function
     * @param {function} onResetToDefault
     */
    var _bindTrendChannelSettings = function ($container, onChannelLineColorChange, onChannelLineWidthChange, onChannelLineStyleChange, onFillColorChange, onMiddleLineColorChange, onMiddleLineWidthChange, onMiddleLineStyleChange, onResetToDefault) {
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=channelColorPicker]"), undefined, onChannelLineColorChange);
        infChart.util.bindColorPicker($container.find("input[inf-ctrl=middleLineColorPicker]"), undefined, onMiddleLineColorChange);

        if (onFillColorChange) {
            infChart.util.bindColorPicker($container.find("input[inf-ctrl=fillColorPicker]"), undefined, onFillColorChange);
        }

        _bindSeriesLineWidthEvents($container.find(".channel-styles"), onChannelLineWidthChange);
        _bindSeriesLineWidthEvents($container.find(".middle-line-styles"), onMiddleLineWidthChange);

        $container.find(".channel-styles").find("li[inf-ctrl=lineStyle]").on('click', function (e) {
            var dashStyle = $(this).attr("inf-style");
            $container.find(".channel-styles").find("li[inf-ctrl=lineStyle]").removeClass('active');
            $(this).addClass('active');
            onChannelLineStyleChange(dashStyle);
            e.stopPropagation();
        });

        $container.find(".middle-line-styles").find("li[inf-ctrl=lineStyle]").on('click', function (e) {
            var dashStyle = $(this).attr("inf-style");
            $container.find(".middle-line-styles").find("li[inf-ctrl=lineStyle]").removeClass('active');
            $(this).addClass('active');
            onMiddleLineStyleChange(dashStyle);
            e.stopPropagation();
        });

        _bindResetToDefaultEvent($container , onResetToDefault);
    };

    var _updateTrendChannelSettings = function ($container, channelLineColor, channelLineWidth, channelLineStyle, fillColor, fillOpacity, middleLineColor, middleLineWidth, middleLineStyle) {
        var channelStylesContainer = $container.find(".channel-styles"),
            middleLineStylesContainer = $container.find(".middle-line-styles");

        channelStylesContainer.find('li[inf-ctrl="lineWidth"]').removeClass('active');
        channelStylesContainer.find('li[inf-ctrl="lineStyle"]').removeClass('active');
        channelStylesContainer.find('li[inf-ctrl="lineWidth"][inf-size="' + channelLineWidth + '"]').addClass('active');
        channelStylesContainer.find('li[inf-ctrl="lineStyle"][inf-style="' + channelLineStyle + '"]').addClass('active');

        middleLineStylesContainer.find('li[inf-ctrl="lineWidth"]').removeClass('active');
        middleLineStylesContainer.find('li[inf-ctrl="lineStyle"]').removeClass('active');
        middleLineStylesContainer.find('li[inf-ctrl="lineWidth"][inf-size="' + middleLineWidth + '"]').addClass('active');
        middleLineStylesContainer.find('li[inf-ctrl="lineStyle"][inf-style="' + middleLineStyle + '"]').addClass('active');

        $container.find('input[inf-ctrl="channelColorPicker"]').mainColorPanel('value', channelLineColor);
        $container.find('input[inf-ctrl="middleLineColorPicker"]').mainColorPanel('value', middleLineColor);
        if (fillColor) {
            $container.find('input[inf-ctrl="fillColorPicker"]').mainColorPanel('value', fillColor);
            $container.find('input[inf-ctrl="fillColorPicker"]').mainColorPanel('opacity', fillOpacity);
        }
    };

    var _getVolumeProfileSettings = function (volumeTypes, settings) {
        var sections = [],
            inputSectionRowItems = [],
            settingAndStyleSectionRowItems = [],
            volumeDropDownHTML = '<div class="fib-options-wrapper"><div class="dropdown has-vertical-list volume" inf-ctrl="volumeTypes">' +
                '<button class="btn btn-default dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">' +
                '<span rel="selectItem">'+ volumeTypes.total.displayName +'</span> <span class="caret"></span> ' +
                '</button>' +
                '<ul inf-ctrl="volumeTypesDropDown" class="dropdown-menu w--100">';

        Object.keys(volumeTypes).forEach(function (volumeType) {
            volumeDropDownHTML += '<li rel="volumeType"  inf-data="' + volumeType + '"><a>' + volumeTypes[volumeType].displayName + '</a></li>';
        })
        volumeDropDownHTML += '</ul></div></div>';

        inputSectionRowItems.push(infChart.structureManager.settings.getRowItem(volumeDropDownHTML, '<label>Volume</label>', false));
        _setVolumeProfileSettingsTextBoxRow("valueAreaVolume", "Value Area Volume", "<span>%</span>", inputSectionRowItems);
        _setVolumeProfileSettingsTextBoxRow("barCount", "Bar Count", "", inputSectionRowItems);

        sections.push(infChart.structureManager.settings.getSection([infChart.structureManager.settings.getSectionRow(inputSectionRowItems, 'two-col-row fib-section')], "Inputs"));

        settingAndStyleSectionRowItems.push(infChart.structureManager.settings.getRowItem("", _getVolumeProfileCheckBox("showVolumeProfile", "Show Volume Profile"), false));
        settingAndStyleSectionRowItems.push(infChart.structureManager.settings.getRowItem("", "", false));
        _setVolumeProfileSettingsTextBoxRow("profileWidth", "Profile Width", "<span>%</span>", settingAndStyleSectionRowItems);
        // settingAndStyleSectionRowItems.push(infChart.structureManager.settings.getRowItem("", _getVolumeProfileCheckBox("flipChart", "Flip chart"), false));
        settingAndStyleSectionRowItems.push(infChart.structureManager.settings.getRowItem(
            '<div class="fib-options-wrapper">' + infChart.structureManager.settings.getMiniColorPaletteHTML('histogramBoxColor', "", settings.histogramBox.color, undefined, settings.histogramBox.opacity, 'fa fa-tint') + '</div>', "Histograms Area", false));


        settingAndStyleSectionRowItems.push(infChart.structureManager.settings.getRowItem(
            '<div class="fib-options-wrapper">' + infChart.structureManager.settings.getMiniColorPaletteHTML('upVolumeColor', "", settings.volumeProfile.upVolumeColor, undefined, settings.volumeProfile.upVolumeOpacity, 'fa fa-tint') + '</div>', "Up Volume", false));
        settingAndStyleSectionRowItems.push(infChart.structureManager.settings.getRowItem(
            '<div class="fib-options-wrapper">' + infChart.structureManager.settings.getMiniColorPaletteHTML('downVolumeColor', "", settings.volumeProfile.downVolumeColor, undefined, settings.volumeProfile.downVolumeOpacity, 'fa fa-tint') + '</div>', "Down Volume", false));
        settingAndStyleSectionRowItems.push(infChart.structureManager.settings.getRowItem(
            '<div class="fib-options-wrapper">' + infChart.structureManager.settings.getMiniColorPaletteHTML('volumeAreaUpColor', "", settings.volumeProfile.volumeAreaUpColor, undefined, settings.volumeProfile.volumeAreaUpOpacity, 'fa fa-tint') + '</div>', "Value Area Up", false));
        settingAndStyleSectionRowItems.push(infChart.structureManager.settings.getRowItem(
            '<div class="fib-options-wrapper">' + infChart.structureManager.settings.getMiniColorPaletteHTML('volumeAreaDownColor', "", settings.volumeProfile.volumeAreaDownColor, undefined, settings.volumeProfile.volumeAreaDownOpacity, 'fa fa-tint') + '</div>', "Value Area Down", false));

        _setVolumeProfileStyleRowWithCheckBox('vAH', 'VAH', settings.valueAreaHigh, true, settingAndStyleSectionRowItems);
        _setVolumeProfileStyleRowWithCheckBox('vAL', 'VAL', settings.valueAreaLow, true, settingAndStyleSectionRowItems);
        _setVolumeProfileStyleRowWithCheckBox('pOC', 'POC', settings.pointOfControl, true, settingAndStyleSectionRowItems);
        // _setVolumeProfileStyleRowWithCheckBox('values', 'Values', settings.values, false, settingAndStyleSectionRowItems);

        sections.push(infChart.structureManager.settings.getSection([infChart.structureManager.settings.getSectionRow(settingAndStyleSectionRowItems, 'two-col-row fib-section')], "Settings & Styles"));

        return '<div class="vol-profile">' + infChart.structureManager.settings.getPanelBodyHTML(sections) + '</div>' + _getResetToDefaultHTML();
    };

    var _setVolumeProfileSettingsTextBoxRow = function (ctrl, label, appendHTML, rowItems) {
        var controlUniqueId = new Date().getTime();
        var controlLabelHTML = '<label for="' + controlUniqueId + '">' + label + '</label>';
        var controlBobyHTML = '<div class="fib-options-wrapper"><input inf-ctrl="' + ctrl + '" type="text"  id="' + controlUniqueId + '">' + appendHTML + '</div>';
        rowItems.push(infChart.structureManager.settings.getRowItem(controlBobyHTML, controlLabelHTML, false));
    }

    var _getVolumeProfileCheckBox = function (ctrl, label) {
        var uniqueId = new Date().getTime();
        return  '<input inf-ctrl="'+ ctrl +'" type="checkbox" checked="checked" id="' + uniqueId + '"><label for="' + uniqueId + '">'+ label +'</label>';
    }

    var _setVolumeProfileStyleRowWithCheckBox = function (ctrl , label, settings, addLineControls, rowItems) {
        var labelHTML = _getVolumeProfileCheckBox("check_" + ctrl, label);

        var lineStyleHTML = '<div class="fib-options-wrapper">' +
            infChart.structureManager.settings.getMiniColorPaletteHTML('color_' + ctrl, "", settings.color, undefined, settings.opacity, 'fa fa-tint');

        if(addLineControls) {
            lineStyleHTML += ('<div inf-ctrl="lineWidth_' + ctrl + '" class="dropdown line-weights">' +
            '<button class="dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">' +
            '<span inf-ctrl="selectedLineWidth" class="weight-line" inf-size="1">&#x2F;</span>' +
            '<span class="caret"></span>' +
            '</button>' +
            infChart.structureManager.settings.getLineWeightHTML('dropdown-menu') +
            '</div>' +
            '<div inf-ctrl="lineStyle_' + ctrl + '" class="dropdown line-style">' +
            '<button class="dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">' +
            '<span inf-ctrl="selectedLineStyle" class="weight-line" inf-style="solid"><i class="icon ico-minus-1"></i></span>' +
            '<span class="caret"></span>' +
            '</button>' +
            infChart.structureManager.settings.getLineStyleHTML('dropdown-menu') +
            '</div>');
        }

        lineStyleHTML += '</div>';
        rowItems.push(infChart.structureManager.settings.getRowItem(lineStyleHTML, labelHTML, false));
    }

    var _bindVolumeProfileSettings = function ($container, eventHandlers) {
        var controls = [
            {ctrl: "valueAreaVolume", eventHandler: eventHandlers.onValueAreaVolumeChange, range: {min: 0, max: 100}},
            {ctrl: "barCount", eventHandler: eventHandlers.onBarCountChange, range: {min: 1, max: 1000}},
            {ctrl: "profileWidth", eventHandler: eventHandlers.onProfileWidthChange, range: {min: 0, max: 100}},
        ];
        var colorControls = [
            {ctrl: "upVolumeColor", eventHandler: eventHandlers.onUpVolumeColorChange},
            {ctrl: "downVolumeColor", eventHandler: eventHandlers.onDownVolumeColorChange},
            {ctrl: "volumeAreaUpColor", eventHandler: eventHandlers.onVolumeAreaUpColorChange},
            {ctrl: "volumeAreaDownColor", eventHandler: eventHandlers.onVolumeAreaDownColorChange},
            {ctrl: "color_vAH", eventHandler: eventHandlers.onValueAreaHighColorChange},
            {ctrl: "color_vAL", eventHandler: eventHandlers.onValueAreaLowColorChange},
            {ctrl: "color_pOC", eventHandler: eventHandlers.onPointOfControlColorChange},
            {ctrl: "color_values", eventHandler: eventHandlers.onValuesColorChange},
            {ctrl: "histogramBoxColor", eventHandler: eventHandlers.onHistogramBoxColorChange}
        ];
        var lineWithAndStyleControls = [
            {ctrl: "vAH", lineWidthEventHandler: eventHandlers.onValueAreaHighLineWidthChange, lineStyleEventHandler: eventHandlers.onValueAreaHighLineStyleChange},
            {ctrl: "vAL", lineWidthEventHandler: eventHandlers.onValueAreaLowLineWidthChange, lineStyleEventHandler: eventHandlers.onValueAreaLowLineStyleChange},
            {ctrl: "pOC", lineWidthEventHandler: eventHandlers.onPointOfControlLineWidthChange, lineStyleEventHandler: eventHandlers.onPointOfControlLineStyleChange}
        ];
        var checkBoxControls = [
            {ctrl: "showVolumeProfile", eventHandler: eventHandlers.onToggleVolumeProfile},
            // {ctrl: "flipChart", eventHandler: eventHandlers.onToggleFlipChart},
            {ctrl: "check_vAH", eventHandler: eventHandlers.onToggleValueAreaHigh},
            {ctrl: "check_vAL", eventHandler: eventHandlers.onToggleValueAreaLow},
            {ctrl: "check_pOC", eventHandler: eventHandlers.onTogglePointOfControl}
            // ,
            // {ctrl: "check_values", eventHandler: eventHandlers.onToggleValues}
        ];

        controls.forEach(function (control){
            $container.find("input[inf-ctrl=" + control.ctrl + "]").on('blur', function (e) {
                var value = $(this).val();

                if (value !== "" && !isNaN(value)) {
                    var newValue = parseFloat(value);

                    if(newValue < control.range.min) {
                        newValue = control.range.min;
                        $(this).val(newValue);
                    } else if(newValue > control.range.max) {
                        newValue = control.range.max;
                        $(this).val(newValue);
                    }

                    control.eventHandler(newValue);
                } else {
                    $(this).parent().addClass('has-error');
                }
                e.stopPropagation();
            });
        });

        $container.find("ul[inf-ctrl=volumeTypesDropDown]").find("li[rel=volumeType]").on('click', function (){
            $container.find("div[inf-ctrl=volumeTypes]").find("span[rel=selectItem]").text($(this).find('a').text());
            eventHandlers.onVolumeTypeChange($(this).attr("inf-data"));
        });

        colorControls.forEach(function (control) {
            infChart.util.bindColorPicker($container.find("input[inf-ctrl=" + control.ctrl + "]"), undefined, function (rgb, value, opacity) {
                control.eventHandler(rgb, value, opacity);
            });
        });

        lineWithAndStyleControls.forEach(function (control) {
            $container.find('div[inf-ctrl=lineWidth_'+ control.ctrl +']').find("li[inf-ctrl=lineWidth]").on('click', function (e) {
                var strokeWidth = $(this).attr("inf-size");
                $(this).parent().parent().find("span[inf-ctrl=selectedLineWidth]").text($(this).text()).attr("inf-size", strokeWidth);
                control.lineWidthEventHandler(strokeWidth);
            });

            $container.find('div[inf-ctrl=lineStyle_'+ control.ctrl +']').find("li[inf-ctrl=lineStyle]").on('click', function (e) {
                var lineStyle = $(this).attr("inf-style");
                $(this).parent().parent().find("span[inf-ctrl=selectedLineStyle]").html($(this).html()).attr("inf-style", lineStyle);
                control.lineStyleEventHandler(lineStyle);
            });
        });

        checkBoxControls.forEach(function (control) {
            $container.find("input[inf-ctrl="+ control.ctrl +"]").on('click', function (e) {
                control.eventHandler($(this).is(":checked"));
                e.stopPropagation();
            });
        });

        _bindResetToDefaultEvent($container , eventHandlers.onResetToDefault);
    };

    var _updateVolumeProfileSettings = function ($container, volumeTypes, settings) {
        var colorControls = [
            {ctrl: "upVolumeColor", color: settings.volumeProfile.upVolumeColor, opacity: settings.volumeProfile.upVolumeOpacity},
            {ctrl: "downVolumeColor", color: settings.volumeProfile.downVolumeColor, opacity: settings.volumeProfile.downVolumeOpacity},
            {ctrl: "volumeAreaUpColor", color: settings.volumeProfile.volumeAreaUpColor, opacity: settings.volumeProfile.volumeAreaUpOpacity},
            {ctrl: "volumeAreaDownColor", color: settings.volumeProfile.volumeAreaDownColor, opacity: settings.volumeProfile.volumeAreaDownOpacity},
            {ctrl: "color_vAH", color: settings.valueAreaHigh.color, opacity: settings.valueAreaHigh.opacity},
            {ctrl: "color_vAL", color: settings.valueAreaLow.color, opacity: settings.valueAreaLow.opacity},
            {ctrl: "color_pOC", color: settings.pointOfControl.color, opacity: settings.pointOfControl.opacity},
            {ctrl: "color_values", color: settings.values.color, opacity: settings.values.opacity},
            {ctrl: "histogramBoxColor", color: settings.histogramBox.color, opacity: settings.histogramBox.opacity}
        ];
        var lineWithAndStyleControls = [
            {ctrl: "vAH", lineWidth: settings.valueAreaHigh.lineWidth, lineStyle: settings.valueAreaHigh.lineStyle},
            {ctrl: "vAL", lineWidth: settings.valueAreaLow.lineWidth, lineStyle: settings.valueAreaLow.lineStyle},
            {ctrl: "pOC", lineWidth: settings.pointOfControl.lineWidth, lineStyle: settings.pointOfControl.lineStyle}
        ];
        var checkBoxControls = [
            {ctrl: "showVolumeProfile", isChecked: settings.volumeProfile.enabled},
            // {ctrl: "flipChart", isChecked: settings.volumeProfile.flipChart},
            {ctrl: "check_vAH", isChecked: settings.valueAreaHigh.enabled},
            {ctrl: "check_vAL", isChecked: settings.valueAreaLow.enabled},
            {ctrl: "check_pOC", isChecked: settings.pointOfControl.enabled}
            // ,
            // {ctrl: "check_values", isChecked: settings.values.enabled}
        ];

        $container.find("input[inf-ctrl=valueAreaVolume]").val(settings.valueAreaVolume);
        $container.find("input[inf-ctrl=barCount]").val(settings.barCount);
        $container.find("input[inf-ctrl=profileWidth]").val(settings.volumeProfile.profileWidth);
        $container.find("div[inf-ctrl=volumeTypes]").find("span[rel=selectItem]").text(volumeTypes[settings.volume].displayName);

        colorControls.forEach(function (control) {
            $container.find('input[inf-ctrl="'+ control.ctrl +'"]').mainColorPanel('value', control.color);
            $container.find('input[inf-ctrl="'+ control.ctrl +'"]').mainColorPanel('opacity', control.opacity);
        });

        lineWithAndStyleControls.forEach(function (control) {
            var lineWidthText = $container.find('div[inf-ctrl=lineWidth_'+ control.ctrl +']').find('li[inf-ctrl="lineWidth"][inf-size="' + control.lineWidth + '"]').find('span').text();
            $container.find('div[inf-ctrl=lineWidth_'+ control.ctrl +']').find('span[inf-ctrl="selectedLineWidth"]').text(lineWidthText);
            $container.find('div[inf-ctrl=lineWidth_'+ control.ctrl +']').find('span[inf-ctrl="selectedLineWidth"]').attr('inf-size', control.lineWidth);

            var lineStyle = $container.find('div[inf-ctrl=lineStyle_'+ control.ctrl +']').find('li[inf-ctrl=lineStyle][inf-size="' + control.lineStyle + '"]').find('a').html();
            $container.find('div[inf-ctrl=lineStyle_'+ control.ctrl +']').find('span[inf-ctrl="selectedLineStyle"]').html(lineStyle);
            $container.find('div[inf-ctrl=lineStyle_'+ control.ctrl +']').find('span[inf-ctrl="selectedLineStyle"]').attr('inf-style', control.lineStyle);
        });

        checkBoxControls.forEach(function (control) {
            $container.find('input[inf-ctrl="' + control.ctrl + '"]').prop('checked', control.isChecked);
        });
    };

    /**
     * get html of template selection dropdown
     * @returns {string}
     * @private
     */
    var _getTemplateSelectionDropDownHTML = function (templates, userDefaultSettings) {
        var html = '<div inf-ctrl="drawing-template-selector" class="dropup save-custom-template footer-def-btn">' +
                    '<button class="c-btn c-btn--default" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">' +
                    'Drawing Template'+
                    '<i class="icom icom-caret-down"></i>' +
                    '</button>' +
                    '<ul class="dropdown-menu">';
        if (templates && templates.length > 0) {
            html += '<li class="custom-template"><ul>';
            templates.forEach(function (template) {
                html += '<li inf-ctrl="custom-template"  inf-value="'+template+'">' +
                            '<a><span>' + template + '</span><i inf-ctrl="delete-template" class="icom icom-cross"></i></a>' +
                        '</li>';
            });
            html += '</ul></li>';
        }
        html += '<li inf-ctrl="save-template" class="save-template"><a>Save As</a></li>';
        html += '</ul>';
        html += '</div>'
        html += _getDefaultSettingsHTML(userDefaultSettings);
        return html;
    };

    var _getDefaultSettingsHTML = function(userDefaultSettings) {
        return '<button rel="tooltip" tool-tip adv-chart-tooltip= "Save settings to be applied in next drawings" inf-ctrl="set-as-my-default-selector" class="c-btn c-btn--default footer-def-btn save-user-default adv-chart-tooltip top" type="button">Set as My Default Settings</button>' + 
        '<div class="dropup footer-def-btn reset-options">' + 
            '<button class="c-btn c-btn--default" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">Reset<i class="icom icom-caret-down"></i></button>' +
            '<ul class="dropdown-menu dropup-menu-right">' + 
                '<li class="reset-template">' + 
                    '<a inf-ctrl="reset-to-my-default-selector" class="' + (userDefaultSettings === undefined ? 'disabled' :'') + '">Reset to My Default</a>' +
                '</li>' +
                '<li class="reset-template">' +
                    '<a inf-ctrl="reset-to-app-default-selector">Reset to App Default</a>' +
                '</li>' +
            '</ul>' +
        '</div> ';
    }

    /**
     * bind template selection events
     * @param $container
     * @param saveTemplateFn
     * @param applyTemplateFn
     * @param deleteTemplateFn
     * @private
     */
    var _bindTemplateSelectionEvents = function ($container, saveTemplateFn, applyTemplateFn, deleteTemplateFn) {
        var parentContainer = $container.parent();
        var chartContainer = $container.parents().closest('[inf-container="chart_container"]');
        var availableTemplates = [];
        var popupMask;

        $container.find("li[inf-ctrl=custom-template]").each(function (key, element) {
            availableTemplates.push($(element).attr("inf-value"));
        });

        $container.find("li[inf-ctrl=save-template]").on('click', function (event) {
            removePopups();
            _loadSaveTemplatePopup($container, availableTemplates, saveTemplateFn, onClosePopups, getPopupPosition());
            onOpenPopups();
        });

        $container.find("li[inf-ctrl=custom-template]").on('click', function () {
            var templateId = $(this).attr("inf-value");
            applyTemplateFn(templateId);
        });

        $container.find("i[inf-ctrl=delete-template]").on('click', function (event) {
            removePopups();
            var templateId = $(this).parent().parent().attr("inf-value");
            var confirmationMessage = "Do you really want to delete drawing template '" + templateId + "'?";
            _loadConfirmationPopup($container, confirmationMessage, function () {
                deleteTemplateFn(templateId);
            }, onClosePopups, getPopupPosition());
            onOpenPopups();
            event.stopPropagation();
        });

        function getPopupPosition () {
            var templateSelectorElm = $container.find('[inf-ctrl="drawing-template-selector"]')
            var templateSelectorPosition = templateSelectorElm.position();
            var containerPosition = $container.position();
            return {
                top : containerPosition.top + templateSelectorPosition.top - 120,
                left : containerPosition.left + templateSelectorPosition.left +
                       (templateSelectorElm.outerWidth(true) - templateSelectorElm.width())
            };
        }

        function removePopups () {
            parentContainer.find('[inf-container="save-template"]').remove();
            parentContainer.find('[inf-container="confirmation"]').remove();
            onClosePopups();
        }

        function onOpenPopups () {
            popupMask = $(_getCustomMaskHTML());
            chartContainer.append(popupMask);
            infChart.util.bindEvent(popupMask, 'mousedown', function(){
                removePopups();
            });
        }

        function onClosePopups () {
            if (popupMask && popupMask.length > 0) {
                popupMask.remove();
            }
        }
    };

    /**
     * load pop-up to save template
     * @param $container
     * @param callbackOnBtnClick
     * @param availableTemplates
     * @param onClosePopup
     * @param position
     * @private
     */
    var _loadSaveTemplatePopup = function ($container, availableTemplates, callbackOnBtnClick, onClosePopup, position) {
        var html =  '<div inf-container="save-template" class="save-template-popup drawing_popup settings-modal">' +
                    '<div inf-pnl="popup-header" class="drawing_popup_header"> Drawing Template' +
                    '<ul><li class="header_ctrl" inf-ctrl="closeSettings"><span class="icon ico-close"></span> </li></ul></div>' +
                    '<div inf-pnl="popup-body" class="drawing_popup_body">' +
                    '<div class="drawing_popup_row form-group">' +
                    '<span class="form-label">Drawing Template Name</span> ' +
                    '<input class="form-control" type="text" value="" name="templateName" />' +
                    '</div>' +
                    '<div class="drawing_popup_row">' +
                    '<input inf-ctrl="action" disabled type="button" class="btn btn-default" value="Save Now"/>' +
                    '</div>' +
                    '</div>' +
                    '</div>';
        var popup = $(html).appendTo($container.parents().closest('[inf-container="drawing_settings"]'));
        var inputElm = popup.find('input[name=templateName]');
        var btnElm = popup.find("input[inf-ctrl=action]");

        popup.find("li[inf-ctrl=closeSettings]").click(function (event) {
            popup.remove();
            onClosePopup();
            event.preventDefault();
        });

        btnElm.click(function (event) {
            var templateName = inputElm.val().trim();
            if (availableTemplates.indexOf(templateName) === -1) {
                callbackOnBtnClick(templateName);
                popup.remove();
                onClosePopup();
            } else {
                var confirmationMessage = "Drawing Template '" + templateName + "' already exists. Do you really want to replace it ?";
                _loadConfirmationPopup($container, confirmationMessage, function () {
                    callbackOnBtnClick(templateName);
                    popup.remove();
                }, function () {}, position);
            }
            event.preventDefault();
        });

        inputElm.on('input change', function() {
            if($(this).val().trim() !== '') {
                btnElm.prop('disabled', false);
            } else {
                btnElm.prop('disabled', true);
            }
        });

        popup.css(position).show();

        inputElm.focus();
    };

    /***
     * load confirmation popup
     * @param $container
     * @param message
     * @param callbackOnSuccsess
     * @param onClosePopup
     * @param position
     * @private
     */
    var _loadConfirmationPopup  = function ($container, message, callbackOnSuccsess, onClosePopup, position, width) {
        var html = '<div inf-container="confirmation" class="drawing_popup confirmation-popup settings-modal">' +
            '<div inf-pnl="popup-header" class="drawing_popup_header">Confirmation' +
            '<ul>' +
            '<li class="header_ctrl" inf-ctrl="closeSettings">' +
            '<span class="icon ico-close"></span> ' +
            '</li>' +
            '</ul>' +
            '</div>' +
            '<div class="drawing_popup_row">' +
            '<span>'+ message +'</span> ' +
            '</div>' +
            '<div class="drawing_popup_row">' +
            '<input inf-ctrl="action-yes" type="button" class="btn btn-default" value="Yes"/>' +
            '<input inf-ctrl="action-no" type="button" class="btn btn-default" value="No" />' +
            '</div>' +
            '</div>';
        var confirmationPopup = $(html).appendTo($container.parents().closest('[inf-container="drawing_settings"]'));

        confirmationPopup.find('[inf-pnl="popup-header"]').css("cursor", "default");

        confirmationPopup.find("input[inf-ctrl=\"action-yes\"]").click(function (event) {
            callbackOnSuccsess();
            confirmationPopup.remove();
            if (onClosePopup) {
               onClosePopup()
            }
            event.preventDefault();
        });

        confirmationPopup.find("input[inf-ctrl=\"action-no\"]").click(function (event) {
            confirmationPopup.remove();
            if (onClosePopup) {
               onClosePopup()
            }
            event.preventDefault();
        });

        confirmationPopup.find("li[inf-ctrl=\"closeSettings\"]").click(function (event) {
            confirmationPopup.remove();
            if (onClosePopup) {
               onClosePopup()
            }
            event.preventDefault();
        });

        if (width) {
           confirmationPopup.css({'width': width + 'px'});
        }

        confirmationPopup.css(position).show();
    };

    /**
     * get apply as default html
     * @returns {string} - html
     * @private
     */
    var _getResetToDefaultHTML = function () {
        return '<button inf-ctrl="apply-as-default" class="c-btn c-btn--default reset-default-btn">Reset To Default</button>';
    };

    /**
     * bind apply as default options
     * @param {Object} $container - setting container
     * @param {Function} callback - call back function
     * @private
     */
    var _bindResetToDefaultEvent = function ($container, callback) {
        $container.find('button[inf-ctrl="apply-as-default"]').on('click', function () {
            callback();
        });
    };

    /**
     * get html structure for custom mask
     * @returns {string}
     * @private
     */
    var _getCustomMaskHTML = function () {
        return '<div class="chart-custom-popup-mask"></div>';
    };

    var _getSnapToHighLowToggleHTML = function(){
        return '<input inf-ctrl="snapToHighLowToggle" type="checkbox" data-value="P_all"> <label>Snap to High/Low</label>';
    }

    var _getFavoriteToggleElement = function(containerElem, drawingCat, shape) {
        var parentToolbar = $(infChart.structureManager.getContainer(containerElem[0], "drawingToolbar"));
        var drawingTool = parentToolbar.find("span[inf-ctrl=drawing-fav][drawing-cat='" + drawingCat + "'][inf-ctrl-shape='" + shape + "']");
        return drawingTool.find("i[rel=icon-i]");

    }
    return {
        getLineSettings: _getLineSettings,
        getPriceLineQuickSettings: _getPriceLineQuickSettings,
        getPriceLineSettings: _getPriceLineSettings,
        getBasicDrawingSettings: _getBasicDrawingSettings,
        getArrowSettings: _getArrowSettings,
        getArrowQuickSettings: _getArrowQuickSettings,
        getFibSettings: _getFibSettings,
        getGenericFibSettings: _getGenericFibSettings,
        getGenericQuickFibSettings: _getGenericQuickFibSettings,
        getFibQuickSettings: _getFibQuickSettings,
        getLabelSettings: _getLabelSettings,
        getHighLowLabelsSettings: _getHighLowLabelsSettings,
        getHighLowLabelsQuickSettings: _getHighLowLabelsQuickSettings,
        getRegressionChannelSettings: _getRegressionChannelSettings,
        getRegressionChannelQuickSettings: _getRegressionChannelQuickSettings,
        getLabelQuickSettings: _getLabelQuickSettings,
        getRectangleQuickSettings: _getRectangleQuickSettings,
        bindLineSettings: _bindLineSettings,
        bindPriceLineSettings: _bindPriceLineSettings,
        bindBasicDrawingSettings: _bindBasicDrawingSettings,
        bindArrowSettings: _bindArrowSettings,
        bindFibSettings: _bindFibSettings,
        bindFibGenericSettings: _bindFibGenericSettings,
        bindLabelSettings: _bindLabelSettings,
        bindHighLowLabelsSettings: _bindHighLowLabelsSettings,
        bindRegressionChannelSettings: _bindRegressionChannelSettings,
        updateLineSettings: _updateLineSettings,
        updateBasicDrawingSettings: _updateBasicDrawingSettings,
        updateArrowSettings: _updateArrowSettings,
        updateFibSettings: _updateFibSettings,
        updateLabelSettings: _updateLabelSettings,
        updateHighLowLabelsSettings: _updateHighLowLabelsSettings,
        updateRegressionChannelSettings: _updateRegressionChannelSettings,
        getDrawingToolBarHTML: _getDrawingToolBarHTML,
        getfavoriteToolBarHTML: _getfavoriteToolBarHTML,
        getDrawing: _getDrawing,
        getBrushSettings: _getBrushSettings,
        getBrushQuickSettings: _getBrushQuickSettings,
        updateBrushSettings: _updateBrushSettings,
        getXabcdSettings: _getXabcdSettings,
        getXabcdQuickSettings: _getXabcdQuickSettings,
        updateXabcdSettings: _updateXabcdSettings,
        bindXabcdSettings :_bindXabcdSettings,
        updateAbcdSettings:  _updateAbcdSettings,
        getAbcdSettings: _getAbcdSettings,
        getAbcdQuickSettings: _getAbcdQuickSettings,
        updatePolylineSettings:  _updatePolylineSettings,
        getPolylineSettings: _getPolylineSettings,
        getPolylineQuickSettings: _getPolylineQuickSettings,
        updateElliotWaveSettings:  _updateElliotWaveSettings,
        getElliotWaveSettings: _getElliotWaveSettings,
        getElliotWaveQuickSettings: _getElliotWaveQuickSettings,
        bindElliotWaveSettings: _bindElliotWaveSettings,
        bindAbcdSettings: _bindAbcdSettings,
        getQuickSettingsPopupHTML: _getQuickSettingsPopupHTML,
        getLineQuickSettings: _getLineQuickSettings,
        bindQuickSettingsPopup: _bindQuickSettingsPopup,
        getPositionsSettings: _getPositionsSettings,
        getPositionsQuickSettings: _getPositionsQuickSettings,
        bindPositionsSettings: _bindPositionsSettings,
        updatePositionsSettings: _updatePositionsSettings,
        bindPolylineSettings: _bindPolylineSettings,
        updatePriceLineSettings: _updatePriceLineSettings,
        getTrendChannelSettings: _getTrendChannelSettings,
        getTrendChannelQuickSettings: _getTrendChannelQuickSettings,
        bindTrendChannelSettings: _bindTrendChannelSettings,
        updateTrendChannelSettings: _updateTrendChannelSettings,
        updateGenericFibSettings: _updateGenericFibSettings,
        getVolumeProfileSettings: _getVolumeProfileSettings,
        bindVolumeProfileSettings: _bindVolumeProfileSettings,
        updateVolumeProfileSettings: _updateVolumeProfileSettings,
        getAndrewsPitchForkSettings: _getAndrewsPitchForkSettings,
        bindAndrewsPitchForkSettings: _bindAndrewsPitchForkSettings,
        updateAndrewsPitchForkSettings: _updateAndrewsPitchForkSettings,
        getFavoriteToggleElement: _getFavoriteToggleElement
    }
})(jQuery, infChart);

window.infChart = window.infChart || {};

(function (infChart, $) {

    /**
     * @typedef {Object} drawing
     * @property {function} getOptions - drawing options
     * @property {function} getConfig - drawing config
     * @property {function} step - start fn
     * @property {function} stop - end fn
     * @property {function} scale - scaling fn
     * @property {function} translate - translate fn
     * @property {function} additionalDrawings - draw additional drawings
     * @property {function} selectAndBindResize - resize fn
     * @property {function} updateSettings - settings update
     * @property {function} getSettingsPopup - settings popup
     * @property {function} bindSettingsEvents - bind settings events
     */

    infChart.drawingUtils = infChart.drawingUtils || {};

    infChart.drawingUtils.common = {
        baseBorderColor: '#959595',
        baseFillColor: '#959595',
        baseFillOpacity: 0.5,
        baseLineWidth: 1,
        baseLineStyle: 'solid',
        dragSupporterStyles: {
            'stroke-width': 15,
            stroke: 'transparent',
            fill: 'transparent',
            'z-index': 1,
            cursor: 'move'
        },
        correctionFactor: 100,
        baseFontWeight : 'normal',
        setTheme: function (forced) {
            var highChartTheme = infChart.themeManager.getTheme();
            if (forced || highChartTheme) {
                var defaultTheme = {
                    //TODO :: move other theme related default settings here and apply changes in the theme file if any
                    selectPointStyles: {
                        'stroke-width': 1,
                        stroke: '#959595',
                        fill: '#333',
                        dashstyle: 'solid',
                        'shape-rendering': 'crispEdges',
                        'z-index': 10,
                        cursor: 'crosshair',
                        'class': 'selection-marker'
                    },
                    upArrow: {
                        fillColor: "#52ac62"
                    },
                    downArrow: {
                        fillColor: "#d00a20"
                    },
                    defaultCopyDistance: 20,
                    fibonacci: {
                        singleFillColor: '#3A8DC9'
                    },
                    fibVerRetracements: {
                        fillOpacity: 0.5,
                        fibLevelFillColors: {
                            "level_0": "#726a6f",
                            "level_1": "#835974",
                            "level_2": "#7b6171",
                            "level_3": "#f8bce2",
                            "level_4": "#f075c3",
                            "level_5": "#eb40ab",
                            "level_6": "#c71585",
                            "level_7": "#800e56",
                            "level_8": "#4b0832",
                            "level_9": "#726a6f",
                            "level_10": "#835974",
                            "level_11": "#7b6171",
                            "level_12": "#f8bce2",
                            "level_13": "#f075c3",
                            "level_14": "#eb40ab",
                            "level_15": "#c71585"
                        }
                    },
                    fibArcs: {
                        fibLevelFillColors: {
                            "level_0": "#4b0832",
                            "level_1": "#f075c3",
                            "level_2": "#f6aada"
                        }
                    },
                    fibFans: {
                        fibLevelFillColors: {
                            "level_0": "#FFB6C1",
                            "level_1": "#ADD8E6",
                            "level_2": "#D3D3D3"
                        }
                    },
                    fibRetracements: {
                        fillOpacity: 0.5,
                        fibLevelFillColors: {
                            "level_0": "#726a6f",
                            "level_1": "#835974",
                            "level_2": "#7b6171",
                            "level_3": "#f8bce2",
                            "level_4": "#f075c3",
                            "level_5": "#eb40ab",
                            "level_6": "#c71585",
                            "level_7": "#800e56",
                            "level_8": "#4b0832",
                            "level_9": "#726a6f",
                            "level_10": "#835974",
                            "level_11": "#7b6171",
                            "level_12": "#f8bce2",
                            "level_13": "#f075c3",
                            "level_14": "#eb40ab",
                            "level_15": "#c71585"
                        }
                    },
                    regressionChannel: {
                        fillColors: {
                            "upper": "#726a6f",
                            "lower": "#835974"
                        }
                    }
                },
                theme;

                if (highChartTheme && highChartTheme.drawing) {
                    theme = infChart.util.merge({}, defaultTheme, highChartTheme.drawing);
                }

                if (theme && theme.base) {
                    if (theme.base.borderColor) {
                        infChart.drawingUtils.common.baseBorderColor = theme.base.borderColor;
                    }
                    if (theme.base.fillColor) {
                        infChart.drawingUtils.common.baseFillColor = theme.base.fillColor;
                    }
                    if (theme.base.fillOpacity) {
                        infChart.drawingUtils.common.baseFillOpacity = theme.base.fillOpacity;
                    }
                    if (!isNaN(theme.base.lineWidth)) {
                        infChart.drawingUtils.common.baseLineWidth = theme.base.lineWidth;
                    }
                    if (!isNaN(theme.base.dashstyle)) {
                        infChart.drawingUtils.common.baseLineStyle = theme.base.dashstyle;
                    }
                    if (theme.base.fontColor) {
                        infChart.drawingUtils.common.baseFontColor = theme.base.fontColor;
                    }
                    if (theme.base.fontSize) {
                        infChart.drawingUtils.common.baseFontSize = theme.base.fontSize;
                    }
                    if (theme.base.fontWeight) {
                        infChart.drawingUtils.common.baseFontWeight = theme.base.fontWeight;
                    }
                }
                infChart.drawingUtils.common.theme = theme || defaultTheme;
            }
        },
        getTheme: function () {
            if (!infChart.drawingUtils.common.theme) {
                infChart.drawingUtils.common.setTheme.call(this);
            }
            return infChart.drawingUtils.common.theme;
        },
        getDefaultOptions: function () {
            return {
                xValue: 0,
                yValue: 0,
                allowDragX: true,
                allowDragY: true,
                anchorX: 'left',
                anchorY: 'top',
                xAxis: 0,
                yAxis: 0,
                isSingleColor: false,
                //linkedTo : "c0",
                drawingType: infChart.constants.drawingTypes.shape,
                shape: {
                    type: 'path',
                    params: {
                        fill: infChart.drawingUtils.common.baseFillColor,
                        stroke: infChart.drawingUtils.common.baseBorderColor,
                        'fill-opacity': infChart.drawingUtils.common.baseFillOpacity,
                        'stroke-width': 1,
                        cursor: 'move',
                        'z-index': 2
                    }
                }
            }
        },
        removeDragSupporters: function (dragSupporters) {
            while (dragSupporters.length) {
                var supporter = dragSupporters.pop();
                supporter.destroy();
            }
        },
        /**
         * add drag supporters common method
         * @param {object} annotation - drawing annotation
         * @param {object} chart - chart object
         * @param {Array} path - path of svg
         * @param {Array} dragSupporters - existing drag supporters
         * @param {object} customAttributes
         * @param {object} dragSupporterStyles - drag supporters style properties
         */
        addDragSupporters: function (annotation, chart, path, dragSupporters, customAttributes, dragSupporterStyles) { //Todo: refactor add drag supporters
            var dragSupStyles = dragSupporterStyles ? dragSupporterStyles : infChart.drawingUtils.common.dragSupporterStyles;
            var dragSupportStyles = {};
            if(customAttributes){
                Object.assign(dragSupportStyles, dragSupStyles , customAttributes);
            }else{
                dragSupportStyles = dragSupStyles;
            }
            dragSupporters.push(chart.renderer.path(path).attr(dragSupportStyles).add(annotation.group));
            infChart.drawingUtils.common.setDeleteCursor.call(this); //#CCA-2958
            infChart.drawingUtils.common.setDeleteModeCursor.call(this);
        },
        addSelectionMarker: function (ann, x, y, selectPointStyles) {
            var padding = infChart.settings.config.isMobile ? 30 : 13,
                chart = ann.chart,
                point,
                themeSelP = infChart.drawingUtils.common.getTheme.call(this).selectPointStyles;

            selectPointStyles = selectPointStyles ? infChart.util.merge({}, themeSelP, selectPointStyles) : themeSelP;

            point = chart.renderer.circle(x, y, padding / 2).attr(selectPointStyles).add(ann.group);
            ann.selectionMarker.push(point);
            if(this.shape !== "shortLine" &&  this.shape !== "longLine"){
                ann.group.addClass('active-drawing');
            }

            return point;
        },
        addAdditionalDrawingSelectionMarker: function (ann, chart, x, y, selectPointStyles) {
            var padding = 13,
                chart = ann.chart,
                point,
                themeSelP = infChart.drawingUtils.common.getTheme.call(this).selectPointStyles;

            selectPointStyles = selectPointStyles ? infChart.util.merge({}, themeSelP, selectPointStyles) : themeSelP;

            point = chart.renderer.circle(x, y, padding / 2).attr(selectPointStyles).add(ann.group);
            return point;
        },
        addSelectionMarkerLabel: function (x, y, value, optionValue, isXAxis, labelTheme) {
            var ann = this.annotation;
            var label = infChart.drawingUtils.common.getAxisLabel.call(this, x, y, value, optionValue, isXAxis, labelTheme);
            ann.selectionMarker.push(label);
            return label;
        },
        onDeselect: function () {
            this.annotation && this.annotation.group.removeClass('active-drawing');
        },
        /**
             * Copy the text to clipboard from fib levels
             * * @param {string} currentLevel selected level of the fib level
             */
        onFibLevelCopy: function (currentLevel, subType) {
            var self = this;
            var shape = self.shape;
            switch (shape){
                case 'fibRetracements':
                case 'fib3PointPriceProjectionHLH':
                case 'fib3PointPriceProjectionLHL':
                    var label = self.fibonacciDrawings.lines[currentLevel].text.textStr;
                    break;
                case 'fibVerRetracements':
                case 'fib3PointTimeProjection':
                case 'fib2PointTimeProjection':
                    var label = self.additionalDrawings.labels[currentLevel].text.textStr.replace("<br/>", " ");
                    break;
                case 'fib3PointPriceProjectionGeneric':
                    if(subType == "fibExtention"){
                        var label = self.fibonacciDrawings.labels[currentLevel].text.textStr;
                    }
                    if(subType == "fibRetracement"){
                        var label = self.fibRetrancementAdditionalDrawing.labels[currentLevel].text.textStr;
                    }
                    break;
            }
            infChart.util.copyToClipBoard(label);
        },   
        addAndBindSelectionMarker: function (ann, x, y, stepFunction, stop, isStartPoint, selectPointStyles, properties) {
            var point = infChart.drawingUtils.common.addSelectionMarker(ann, x, y, selectPointStyles);
            this.selectPointEvents(point, stepFunction, stop, isStartPoint, properties);
            return point;
        },
        fixSelectionMarker: function (ann) {
            if (ann.selectionMarker) {
                for (var i = 0; i < ann.selectionMarker.length; i++) {
                    ann.selectionMarker[i].toFront();
                }
            }
        },
        saveBaseYValues: function (yValue, yValueEnd, trendYValue, intermediatePoints) {
            var self = this;
            this.yValue = yValue ? this.stockChart.getYLabel(yValue, false, true, true) : yValue;
            this.yValueEnd = yValueEnd ? this.stockChart.getYLabel(yValueEnd, false, true, true) : yValueEnd;
            this.trendYValue = trendYValue ? this.stockChart.getYLabel(trendYValue, false, true, true) : trendYValue;

            if (intermediatePoints) {
                var intermediatePointsNew = [];
                infChart.util.forEach(intermediatePoints, function (index, value) {
                    intermediatePointsNew.push({
                        xValue: value.xValue,
                        yValue: self.stockChart.getYLabel(value.yValue, false, true, true)
                    });
                });
                self.intermediatePoints = intermediatePointsNew;
            }

            this.isPercent = false;
            this.isLog = false;
            this.isCompare = false;
        },
        saveNearestBaseYValues: function (yValue, yValueEnd, trendYValue, nearestIntermediatePoints) {
            var self = this;
            this.nearestYValue = yValue ? this.stockChart.getYLabel(yValue, false, true, true) : yValue;
            this.nearestYValueEnd = yValueEnd ? this.stockChart.getYLabel(yValueEnd, false, true, true) : yValueEnd;
            this.nearestTrendYValue = trendYValue ? this.stockChart.getYLabel(trendYValue, false, true, true) : trendYValue; 

            if (nearestIntermediatePoints) {
                var nearestIntermediatePointsNew = [];
                infChart.util.forEach(nearestIntermediatePoints, function (index, value) {
                    nearestIntermediatePointsNew.push({
                        xValue: value.xValue,
                        yValue: self.stockChart.getYLabel(value.yValue, false, true, true),
                        topOfThePoint: value.topOfThePoint
                    });
                });
                self.nearestIntermediatePoints = nearestIntermediatePointsNew;
            }
        },
        getBaseYValues: function (yValue) {
            return yValue ? this.stockChart.getYLabel(yValue, false, true, true) : yValue;
        },
        getYValue: function (yValue) {
            var chartObj = this.stockChart,
                isPercent = chartObj.isPercent,
                isLog = chartObj.isLog,
                isCompare = chartObj.isCompare;

            if (this.isLog == isLog && this.isCompare == isCompare && this.isPercent == isPercent) {
                return yValue;
            }
            return chartObj.convertBaseYValue(yValue, isLog, isCompare, isPercent);
        },
        getBaseYValue: function (currentYValue) {
            var isPercent = this.stockChart.isPercent,
                isLog = this.stockChart.isLog,
                isCompare = this.stockChart.isCompare;

            return this.stockChart.getBaseValue(currentYValue, isLog, isCompare, isPercent);
        },
        formatValue: function (value, dp) {
            return infChart.util.formatNumber(value, dp);
        },
        calculateInitialPoints: function (e, ann, isStartPoint, correctionFactorX, correctionFactorY) {
            var chart = ann.chart,
                //bbox = chart.container.getBoundingClientRect(),
                x = e.chartX,
                y = e.chartY;
            /*x = e.clientX - bbox.left,
             y = e.clientY - bbox.top;
             if (chart.infScaleX) {
             x = x / chart.infScaleX;
             }
             if (chart.infScaleY) {
             y = y / chart.infScaleY;
             }*/
            var xAxis = chart.xAxis[ann.options.xAxis],
                yAxis = chart.yAxis[ann.options.yAxis],
                dx = x - xAxis.toPixels(ann.options.xValue),
                dy = y - yAxis.toPixels(ann.options.yValue);

            if (isStartPoint) {
                dx = xAxis.toPixels(ann.options.xValueEnd) - x;
                dy = yAxis.toPixels(ann.options.yValueEnd) - y;

                ann.update({
                    xValue: xAxis.toValue(x),
                    yValue: yAxis.toValue(y)
                });
            }

            correctionFactorX = dx > 0 ? correctionFactorX * -1 : correctionFactorX;
            correctionFactorY = dy > 0 ? correctionFactorY * -1 : correctionFactorY;

            return { xAxis: xAxis, x: x, dx: dx + correctionFactorX, yAxis: yAxis, y: y, dy: dy + correctionFactorY };
        },
        getLineSettings: function (title, color, labelDataItems, isLineText, textFontSize, textFontColor, opacity, isExtendAvailable, isArrowAvaialable) {
            return infChart.structureManager.drawingTools.getLineSettings(color, labelDataItems, isLineText, textFontSize, textFontColor, opacity, isExtendAvailable, isArrowAvaialable);
        },
        getLineQuickSettings: function (color, opacity) {
            return infChart.structureManager.drawingTools.getLineQuickSettings(color, opacity);
        },
        getPriceLineQuickSettings: function () {
            return infChart.structureManager.drawingTools.getPriceLineQuickSettings();
        },
        // common setting to rectangle, ellipse, regression line and andrew's pitchfork
        getBasicDrawingSettings: function (title, lineColor, fillColor, fillopacity, shape, textFontSize, textFontColor) {
            return infChart.structureManager.drawingTools.getBasicDrawingSettings(title, lineColor, fillColor, fillopacity, shape, textFontSize, textFontColor);
        },
        getRectangleQuickSettings: function (lineColor, fillColor, fillOpacity) {
            return infChart.structureManager.drawingTools.getRectangleQuickSettings(lineColor, fillColor, fillOpacity);
        },
        getArrowSettings: function (title, color, textMaxContent, textFontColor, textFontSize) {
            return infChart.structureManager.drawingTools.getArrowSettings(color, textMaxContent, textFontColor, textFontSize);
        },
        getFibSettings: function (properties) {
            return infChart.structureManager.drawingTools.getFibSettings(properties);
        },
        getGenericFibSettings: function (properties) {
            return infChart.structureManager.drawingTools.getGenericFibSettings(properties);
        },
        getGenericQuickFibSettings: function () {
            return infChart.structureManager.drawingTools.getGenericQuickFibSettings();
        },
        getFibQuickSettings: function (fillColor, fillOpacity, lineColor, fontColor, fontSize) {
            return infChart.structureManager.drawingTools.getFibQuickSettings('single', fillColor, fillOpacity, lineColor, fontColor, fontSize);
        },
        getPriceLineSettings: function (takeProfitLevels, stopLossLevels, yValue) {
            return infChart.structureManager.drawingTools.getPriceLineSettings(takeProfitLevels, stopLossLevels, yValue);
        },
        /**
         * sort fib level by the value
         * @param {Array} fibLevels - fib levels
         * @returns {Array} sorted fib levels
         */
        sortFibLevelsByValue: function (fibLevels) {
            fibLevels.sort(function (a, b) {
                return a.value >= b.value;
            });
            return fibLevels;
        },
        /**
         * add opacity to each fib level
         * @param {Array} fibLevels - fib levels
         * @param {number} baseFillOpacity - fill opacity
         * @returns
         */
        getFibLevelsWithOpacity: function (fibLevels, baseFillOpacity) {
            fibLevels.forEach(function (fibLevel) {
                if (!fibLevel.hasOwnProperty('fillOpacity')) {
                    fibLevel['fillOpacity'] = baseFillOpacity;
                }
            });
            return fibLevels;
        },
        getAndrewsPitchForkSettings: function(options) {
            return infChart.structureManager.drawingTools.getAndrewsPitchForkSettings(options);
        },
        removeDrawing: function () {
            var stockChart = this.stockChart;
            infChart.drawingsManager.removeDrawing(stockChart.id, this.drawingId, false, true);
            infChart.drawingsManager.updateIsGloballyLockInDelete(stockChart.id);
        },
        toggleSettings: function () {
            var stockChart = this.stockChart;
            infChart.drawingsManager.toggleSettings(infChart.drawingsManager.getDrawingObject(stockChart.id, this.drawingId), false);
        },
        saveDrawingProperties : function () {
            this.updateSavedDrawingProperties(false);
        },
        onPropertyChange: function (propertyName) {
            propertyName = propertyName || 'drawings';
            var drawingObj = this;
            if (drawingObj && drawingObj.annotation && drawingObj.annotation.options && drawingObj.annotation.options.drawingType == 'shape') {
                var stockChart = drawingObj.stockChart;
                stockChart._onPropertyChange(propertyName);
            }
        },
        bindLineSettingsEvents: function (onLabelItemsChange) {
            var self = this;
            if(self.annotation.options.lineTextChecked) {
                self.settingsPopup.find("input[inf-ctrl=line-text]").removeAttr("disabled");
            } else {
                self.settingsPopup.find("input[inf-ctrl=line-text]").attr("disabled","disabled");
            }
            function onLineWidthChange(strokeWidth) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                infChart.drawingUtils.common.settings.onLineWidthChange.call(self, strokeWidth, isPropertyChange);
            }
            function onColorChange(rgb, color) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                infChart.drawingUtils.common.settings.onLineColorChange.call(self, rgb, color, isPropertyChange);
            }
            function onTextColorChange(rgb, color) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                infChart.drawingUtils.common.settings.onTextColorChange.call(self, rgb, color, isPropertyChange);
            }
            function onTextSizeChange(newFontSize) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                infChart.drawingUtils.common.settings.onTextSizeChange.call(self, newFontSize, isPropertyChange);
            }
            function onLineStyleChange(dashStyle) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                infChart.drawingUtils.common.settings.onLineStyleChange.call(self, dashStyle, isPropertyChange);
            }

            function onLineTextChange(text) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange() && (text !== "" && self.annotation.options.lineText !== text);
                }
                infChart.drawingUtils.common.settings.onTextChange.call(self, text, isPropertyChange);
            }

            function onToggleLineText(checked) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                if (onToggleLineText) {
                    infChart.drawingUtils.common.settings.onToggleText.call(self, checked, isPropertyChange);
                }
            }

            function onResetToDefault () {
                self.updateSavedDrawingProperties(true);
            }

            var callBackFnLineSettingsEvents = {
                onColorChange: onColorChange,
                onLineWidthChange: onLineWidthChange,
                onLineStyleChange: onLineStyleChange,
                onResetToDefault: onResetToDefault,
                onLineTextChange: onLineTextChange,
                onToggleLineText: onToggleLineText,
                onTextColorChange: onTextColorChange,
                onTextSizeChange: onTextSizeChange,
                onLabelItemsChange: onLabelItemsChange
            }

            infChart.structureManager.drawingTools.bindLineSettings(self.settingsPopup, callBackFnLineSettingsEvents);
        },
        bindShortLongLineSettingsEvents: function (onLabelItemsChange) {
            var self = this;

            var priceLines = {
                takeProfits: this.takeProfit,
                stopLoss: this.stopLoss
            }

            function onEntryValueChange(element, value) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                infChart.drawingUtils.common.settings.onEntryValueChange.call(self, element, value, isPropertyChange);
            }

            function onApplyLine(checked, lineType) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                infChart.drawingUtils.common.settings.onApplyLine.call(self, checked, lineType, isPropertyChange);
            }


            function onPriceValueChange(element, priceValue, type) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                infChart.drawingUtils.common.settings.onPriceValueChange.call(self, element, priceValue, type, isPropertyChange);
            }

            function onPriceLineWidthChange(type, strokeWidth) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                infChart.drawingUtils.common.settings.onPriceLineWidthChange.call(self, type, strokeWidth, isPropertyChange);
            }

            function onPriceLineStyleChange(type, lineStyle) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                infChart.drawingUtils.common.settings.onPriceLineStyleChange.call(self, type, lineStyle, isPropertyChange);
            }

            function onResetToDefault () {
                self.updateSavedDrawingProperties(true);
            }

            function onColorChange(rgb, color, type) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                infChart.drawingUtils.common.settings.onPriceLineColorChange.call(self, color, type, isPropertyChange);
            }

            infChart.structureManager.drawingTools.bindPriceLineSettings(self.settingsPopup, onEntryValueChange, onApplyLine, onPriceValueChange, onPriceLineWidthChange, onPriceLineStyleChange, onResetToDefault, onColorChange, priceLines);
        },
        // common bind setting to rectangle, ellipse, regression line and andrew's pitchfork
        bindBasicDrawingSettingsEvents: function (lineColor, fillColor, onExtendToLeft, onExtendToRight) {
            var self = this;

            if (self.settingsPopup) {

                function onLineWidthChange(strokeWidth) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }
                    infChart.drawingUtils.common.settings.onLineWidthChange.call(self, strokeWidth, isPropertyChange);
                }

                function onColorChange(rgb, color) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }
                    infChart.drawingUtils.common.settings.onLineColorChange.call(self, rgb, color, isPropertyChange, "[inf-ctrl=lineColorPicker]");
                }

                function onFillColorChange(rgb, value, opacity) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }
                    infChart.drawingUtils.common.settings.onFillColorChange.call(self, rgb, value, opacity, isPropertyChange, "[inf-ctrl=fillColorPicker]");
                }

                function onBasicDrawingTextChange(text) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        var optionsText = self.shape === "rectangle" ?  self.annotation.options.rectText : self.annotation.options.ellipseText;
                        isPropertyChange = self.isSettingsPropertyChange() && (text !== "" && (optionsText !== text ));
                    }
                    infChart.drawingUtils.common.settings.onTextChange.call(self, text, isPropertyChange);
                }
    
                function onToggleBasicDrawingText(checked) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }
                    if (onToggleBasicDrawingText) {
                        infChart.drawingUtils.common.settings.onToggleText.call(self, checked, isPropertyChange);
                    }
                }

                function onVerticalPositionSelect(position) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange() && (position !== "" && self.annotation.options.verticalPosition !== position);
                    }
                    infChart.drawingUtils.common.settings.onVerticalPositionSelect.call(self, position, isPropertyChange);
                }

                function onHorizontalPositionSelect(position) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange() && (position !== "" && self.annotation.options.horizontalPosition !== position);
                    }
                    infChart.drawingUtils.common.settings.onHorizontalPositionSelect.call(self, position, isPropertyChange);
                }

                function onResetToDefault () {
                    self.updateSavedDrawingProperties(true);
                }

                function onTextColorChange(rgb, color) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }
                    infChart.drawingUtils.common.settings.onTextColorChange.call(self, rgb, color, isPropertyChange);
                }

                function onTextSizeChange(newFontSize) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }
                    infChart.drawingUtils.common.settings.onTextSizeChange.call(self, newFontSize, isPropertyChange);
                }

                var callBackFnBasicDrawing = {
                    onColorChange : onColorChange,
                    onLineWidthChange : onLineWidthChange,
                    onBasicDrawingTextChange : onBasicDrawingTextChange,
                    onToggleBasicDrawingText : onToggleBasicDrawingText,
                    onVerticalPositionSelect : onVerticalPositionSelect,
                    onHorizontalPositionSelect : onHorizontalPositionSelect,
                    onResetToDefault : onResetToDefault,
                    onExtendToLeft : onExtendToLeft,
                    onExtendToRight : onExtendToRight,
                    onTextColorChange : onTextColorChange,
                    onTextSizeChange : onTextSizeChange
                }

                if (fillColor) {
                    callBackFnBasicDrawing.onFillColorChange = onFillColorChange;
                    infChart.structureManager.drawingTools.bindBasicDrawingSettings(self.settingsPopup, callBackFnBasicDrawing, this.shape);
                } else {
                    infChart.structureManager.drawingTools.bindBasicDrawingSettings(self.settingsPopup, callBackFnBasicDrawing, this.shape);
                }
            }
        },
        bindXabcdSettingsEvents: function () {
            var self = this;

            if (self.settingsPopup) {

                function onLineWidthChange(strokeWidth) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }

                    infChart.drawingUtils.common.settings.onXabcdLineWidthChange.call(self, strokeWidth, isPropertyChange);

                }

                function onColorChange(rgb, color) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }

                    infChart.drawingUtils.common.settings.onXabcdLineColorChange.call(self, color, isPropertyChange, "[inf-ctrl=lineColorPicker]");

                }

                function onLabelTextColorChange(rgb, color) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }
                    infChart.drawingUtils.common.settings.onLabelTextColorChange.call(self, rgb, color, isPropertyChange);
                }

                function onLabelTextSizeChange(newFontSize) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }
                    infChart.drawingUtils.common.settings.onLabelTextSizeChange.call(self, newFontSize, isPropertyChange);
                }

                function onFillColorChange(rgb, value, opacity) {
                    var shapeTheme = infChart.drawingUtils.common.getTheme()["harmonicPattern"];
                    var opacity = opacity || shapeTheme && shapeTheme.fillOpacity || infChart.drawingUtils.common.baseFillOpacity;
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }

                    infChart.drawingUtils.common.settings.onXabcdFillColorChange.call(self, value, opacity, isPropertyChange);

                }

                function onClose() {
                    infChart.drawingUtils.common.removeDrawing.call(self);
                }

                function onResetToDefault () {
                    self.updateSavedDrawingProperties(true);
                }

                var callBackFnXabcdSettings = {
                    onClose: onClose,
                    onColorChange: onColorChange,
                    onLineWidthChange: onLineWidthChange,
                    onFillColorChange: onFillColorChange,
                    onResetToDefault: onResetToDefault,
                    onLabelTextColorChange: onLabelTextColorChange,
                    onLabelTextSizeChange: onLabelTextSizeChange
                }

                infChart.structureManager.drawingTools.bindXabcdSettings(self.settingsPopup, callBackFnXabcdSettings);
            }
        },
        bindAbcdSettingsEvents: function () {
            var self = this;

            if (self.settingsPopup) {

                function onLineWidthChange(strokeWidth) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }

                    infChart.drawingUtils.common.settings.onAbcdLineWidthChange.call(self, strokeWidth, isPropertyChange);

                }

                function onColorChange(rgb, color) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }

                    infChart.drawingUtils.common.settings.onAbcdLineColorChange.call(self, color, isPropertyChange, "[inf-ctrl=lineColorPicker]");

                }

                function onLabelTextColorChange(rgb, color) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }
                    infChart.drawingUtils.common.settings.onLabelTextColorChange.call(self, rgb, color, isPropertyChange);
                }

                function onLabelTextSizeChange(newFontSize) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }
                    infChart.drawingUtils.common.settings.onLabelTextSizeChange.call(self, newFontSize, isPropertyChange);
                }

                function onClose() {
                    infChart.drawingUtils.common.removeDrawing.call(self);
                }

                function onResetToDefault () {
                    self.updateSavedDrawingProperties(true);
                }

                var callBackFnAbcdSettings = {
                    onClose: onClose,
                    onColorChange: onColorChange,
                    onLineWidthChange: onLineWidthChange,
                    onResetToDefault: onResetToDefault,
                    onLabelTextColorChange: onLabelTextColorChange,
                    onLabelTextSizeChange: onLabelTextSizeChange
                }

                infChart.structureManager.drawingTools.bindAbcdSettings(self.settingsPopup, callBackFnAbcdSettings);
            }
        },
        bindPolylineSettingsEvents: function () {
            var self = this;

            if (self.settingsPopup) {

                function onLineWidthChange(strokeWidth) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }

                    infChart.drawingUtils.common.settings.onPolylineWidthChange.call(self, strokeWidth, isPropertyChange);

                }

                function onColorChange(rgb, color) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }

                    infChart.drawingUtils.common.settings.onPolylineColorChange.call(self, color, isPropertyChange, "[inf-ctrl=lineColorPicker]");

                }

                function onFillColorChange(rgb, value, opacity) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }
                    infChart.drawingUtils.common.settings.onPolylineFillColorChange.call(self, rgb, value, opacity, isPropertyChange, "[inf-ctrl=fillColorPicker]");
                }

                function onLineStyleChange(dashStyle) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }
                    infChart.drawingUtils.common.settings.onPolylineStyleChange.call(self, dashStyle, isPropertyChange);
                }

                function onClose() {
                    infChart.drawingUtils.common.removeDrawing.call(self);
                }

                function onResetToDefault () {
                    self.updateSavedDrawingProperties(true);
                }

                infChart.structureManager.drawingTools.bindPolylineSettings(self.settingsPopup, onClose, onColorChange, onLineWidthChange, onFillColorChange, onLineStyleChange, onResetToDefault);
            }
        },
        bindElliotWaveSettingsEvents: function (onChangeSnapToHighLow) {
            var self = this;

            if (self.settingsPopup) {

                function onLineWidthChange(strokeWidth) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }

                    infChart.drawingUtils.common.settings.onElliotWaveLineWidthChange.call(self, strokeWidth, isPropertyChange);
                }

                function onColorChange(rgb, color) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }

                    infChart.drawingUtils.common.settings.onElliotWaveLineColorChange.call(self, color, isPropertyChange, "[inf-ctrl=lineColorPicker]");
                }

                function onWaveDegreeChange(waveDegree, element) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }

                    infChart.drawingUtils.common.settings.onElliotWaveDegreeChange.call(self, waveDegree, element, isPropertyChange, "[inf-ctrl=lineColorPicker]");
                }

                function onClose() {
                    infChart.drawingUtils.common.removeDrawing.call(self);
                }

                function onResetToDefault () {
                    self.updateSavedDrawingProperties(true);
                }

                function onToggleSnapToHighLow(checked) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }
    
                    if (onChangeSnapToHighLow) {
                        onChangeSnapToHighLow.call(self, checked, isPropertyChange);
                    }
                }

                function onLabelTextSizeChange(newFontSize) {
                    var isPropertyChange = true;
                    if (self.settingsPopup) {
                        isPropertyChange = self.isSettingsPropertyChange();
                    }
                    infChart.drawingUtils.common.settings.onLabelTextSizeChange.call(self, newFontSize, isPropertyChange);
                }

            var callBackFnElliotWaveSettingsEvents = {
                onClose: onClose,
                onColorChange:onColorChange,
                onLineWidthChange:onLineWidthChange,
                onWaveDegreeChange:onWaveDegreeChange,
                onResetToDefault,onResetToDefault,
                onToggleSnapToHighLow:onToggleSnapToHighLow,
                onLabelTextSizeChange:onLabelTextSizeChange
            }
                
                infChart.structureManager.drawingTools.bindElliotWaveSettings(self.settingsPopup, callBackFnElliotWaveSettingsEvents);
            }
        },
        bindArrowSettingsEvents: function () {
            var self = this;

            function onColorChange(rgb, value, opacity) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                infChart.drawingUtils.common.settings.onFillColorChange.call(self, rgb, value, opacity, isPropertyChange);
            }

            function onResetToDefault () {
                self.updateSavedDrawingProperties(true);
            }

            infChart.structureManager.drawingTools.bindArrowSettings(self.settingsPopup, onColorChange, onResetToDefault);
        },
        bindFibSettingsEvents: function (color, lineWidth, onFibLevelChange, onFibModeChange, onChangeSnapToHighLow, onTrendLineToggleShow) {
            var self = this,
                ann = self.annotation,
                options = ann.options;
                chartId = ann.chart.renderTo.id,
                shape = self.shape,
                stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chartId));
           
            /**
             * single option change event
             * @param {string} fillColor - hex fill color
             * @param {number} fillOpacity - fill opacity
             * @param {string} lineColor - hex line color
             * @param {number} lineWidth - line width
             * @param {object} prevOptions - prev options object
             * @param {boolean} isSingleColor - is single color or not
             * @param {boolean} isPropertyChange - is property change or not
             */
            function onSingleOptionChange(fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, isSingleColor, isPropertyChange) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                infChart.drawingUtils.common.settings.onFibSingleOptionChange.call(self, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, isSingleColor, prevOptions, isPropertyChange);
            }

            /**
             * fib level line color change event
             * @param {object} rgb - color rgb
             * @param {string} value - hash color
             * @param {boolean} isPropertyChange - is property change
             * @param {object} fibLevelLineColors fib level line colors in settings panel
             */
            function onSingleLineColorChange(rgb, value, isSingleColor, fibLevelLineColors, isPropertyChange) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                infChart.drawingUtils.common.settings.onFibSingleLineColorChange.call(self, rgb, value, isSingleColor, fibLevelLineColors, isPropertyChange);
            }

            /**
             * change fibonacci drawing to single color or apply settings panle colors
             * @param {object} rgb color rgb
             * @param {string} value color hex
             * @param {number} opacity opacity
             * @param {boolean} isSingleColor is single color or not
             * @param {object} fibLevelColors fib level colors in settings panel
             */
            function onSingleFillColorChange(rgb, value, opacity, isSingleColor, fibLevelColors) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                infChart.drawingUtils.common.settings.onFibSingleFillColorChange.call(self, rgb, value, opacity, isSingleColor, fibLevelColors, isPropertyChange);
            }

            /**
             * change fibonacci single line width change
             * @param {number} strokeWidth - strock size
             * @param {boolean} isSingleColor - is single color or not
             * @param {object} fibLevelWidths - fib level widths in settings panel
             */
            function onSingleLineWidthChange(strokeWidth, isSingleColor, fibLevelWidths) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                infChart.drawingUtils.common.settings.onFibSingleLineWidthChange.call(self, strokeWidth, isSingleColor, fibLevelWidths, isPropertyChange);
            }

            function onSingleFontColorChange(rgb, value, isSingleColor, fibLevelFontColors, isPropertyChange) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                infChart.drawingUtils.common.settings.onFibSingleFontColorChange.call(self, rgb, value, isSingleColor, fibLevelFontColors, isPropertyChange);
            }

            function onSingleFontSizeChange(fontSize, isSingleColor, fibLevelFontSizes) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                infChart.drawingUtils.common.settings.onFibSingleFontSizeChange.call(self, fontSize, isSingleColor, fibLevelFontSizes, isPropertyChange);
            }

            /**
             * fib level line color change event
             * @param {object} rgb - color rgb
             * @param {string} value - hash color
             * @param {string} fibLevelId - fib level id
             * @param {boolean} isPropertyChange - is property change
             */
            function onFibLevelLineColorChange(rgb, value, fibLevelId, isPropertyChange) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                infChart.drawingUtils.common.settings.onFibLevelLineColorChange.call(self, rgb, value, fibLevelId, false, isPropertyChange);
            }

            /**
             * on fill color change event
             * @param {object} rgb - color rgb
             * @param {string} value - color hex
             * @param {number} opacity - opacity 0 - 1
             * @param {string} fibLevelId - fib level id
             * @param {boolean} isPropertyChange - is property change
             */
            function onFibLevelFillColorChange(rgb, value, opacity, fibLevelId, isPropertyChange) {
                if (typeof isPropertyChange === "undefined" && self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                var fibLevels = self.annotation.options.fibLevels;
                var fibLevel = fibLevels.find(function (level) {
                    return level.id === fibLevelId;
                });
                self.annotation.options.enabledMyDefaultButton = true;
                infChart.drawingUtils.common.settings.onFibFillColorChange.call(self, rgb, value, opacity, fibLevel, false, isPropertyChange);
            }

            /**
             * line width change event used for both single level and all level
             * @param {number} strokeWidth - stroke width
             * @param {string} fibLevelId - fib level id
             */
            function onFibLevelLineWidthChange(strokeWidth, fibLevelId) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                infChart.drawingUtils.common.settings.onFibLineWidthChange.call(self, strokeWidth, fibLevelId, false, isPropertyChange);
            }

            function onFibLevelFontColorChange(rgb, value, fibLevelId, isPropertyChange) {
                if (typeof isPropertyChange === "undefined" && self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                var fibLevels = self.annotation.options.fibLevels;
                var fibLevel = fibLevels.find(function (level) {
                    return level.id === fibLevelId;
                });
                self.annotation.options.enabledMyDefaultButton = true;
                infChart.drawingUtils.common.settings.onFibLevelFontColorChange.call(self, rgb, value, fibLevel, false, isPropertyChange);
            }

            function onFibLevelFontSizeChange(fontSize, fibLevelId) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                infChart.drawingUtils.common.settings.onFibLevelFontSizeChange.call(self, fontSize, fibLevelId, false, isPropertyChange);
            }

            function onFibLvlValueChange(currentLevel, value) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                infChart.drawingUtils.common.settings.onFibLevelValueChange.call(self, currentLevel, value, isPropertyChange);
            }

            function onToggleFibLevel(checked, currentLevel) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                if (onFibLevelChange) {
                    onFibLevelChange.call(self, checked, currentLevel, isPropertyChange);
                } else {
                    infChart.drawingUtils.common.settings.onFibLevelChange.call(self, currentLevel, checked, isPropertyChange);
                }
                self.annotation.options.enabledMyDefaultButton = true;
            }

            function onToggleFibMode(checked) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }

                if (onFibModeChange) {
                    onFibModeChange.call(self, checked, isPropertyChange);
                }
                self.annotation.options.enabledMyDefaultButton = true;
            }

            function onToggleSnapToHighLow(checked) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }

                if (onChangeSnapToHighLow) {
                    onChangeSnapToHighLow.call(self, checked, isPropertyChange);
                }
                self.annotation.options.enabledMyDefaultButton = true;
            }

            function onSetAsMyDefaultSettings() {
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
                options.enabledMyDefaultButton = false;
            }

            function onResetToAppDefaultSettings() {
                self.updateSavedDrawingProperties(true);
                options.enabledMyDefaultButton  = false;
                
            }

            function onResetToMyDefaultSettings() {
                self.resetToUserDefaultDrawingProperties();
                options.enabledMyDefaultButton = false;
            }

            function onFibLevelFontWeightChange(fibLevelId, value, isPropertyChange) {
                infChart.drawingUtils.common.settings.onFibLevelFontWeightChange.call(self, value, fibLevelId, false, isPropertyChange);
                self.annotation.options.enabledMyDefaultButton = true;
            }

            function onFibSingleFontWeightChange(value, isSingleColor, fibLevelOptions, isPropertyChange) {
                infChart.drawingUtils.common.settings.onFibSingleFontWeightChange.call(self, value, isSingleColor, fibLevelOptions, isPropertyChange);
                self.annotation.options.enabledMyDefaultButton = true;
            }

            function onFibApplyAllButtonClick(fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions) {
                infChart.drawingUtils.common.settings.onFibApplyAllButtonClick.call(self, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, true);
                self.annotation.options.enabledMyDefaultButton= true;
            }

            function onSaveTemplate (templateName) {
                self.saveDrawingTemplate(templateName);
            }

            function onApplyTemplate (templateName) {
                self.applyDrawingTemplate(templateName);
                options.enabledMyDefaultButton = true;
            }

            function onDeleteTemplate (templateName) {
                self.deleteDrawingTemplate(templateName);
            }

            function resetEnabledMyDefaultButton(chartId, shape, drawingId, value){
                infChart.drawingsManager.resetEnabledMyDefaultButton.call(self, chartId, shape, drawingId, value);
            }

            function getEnabledMyDefaultButton(){
                return self.annotation && self.annotation.options && self.annotation.options.enabledMyDefaultButton;
            }

            function onTrendLineColorChange(rgb, color, opacity) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.onTrendLineColorChange.call(self, rgb, color,opacity, isPropertyChange);
            }

            function onTrendLineWidthChange(strokeWidth) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.onTrendLineWidthChange.call(self, strokeWidth, isPropertyChange);
            }

            function onTrendLineStyleChange(dashStyle) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.onTrendLineStyleChange.call(self, dashStyle, isPropertyChange);
            }

            var enabledMyDefaultButton = {};
            enabledMyDefaultButton.shape = shape;
            enabledMyDefaultButton.chartId = stockChart.id;
            enabledMyDefaultButton.drawingId = self.drawingId;
            enabledMyDefaultButton.resetEnabledMyDefaultButton = resetEnabledMyDefaultButton;
            enabledMyDefaultButton.getEnabledMyDefaultButton = getEnabledMyDefaultButton;

            var callBackFnFibSettings = {
                onSingleLineColorChange: onSingleLineColorChange,
                onSingleFillColorChange: onSingleFillColorChange,
                onSingleLineWidthChange: onSingleLineWidthChange,
                onSingleOptionChange: onSingleOptionChange,
                onFibLevelFillColorChange: onFibLevelFillColorChange,
                onFibLevelLineColorChange: onFibLevelLineColorChange,
                onFibLevelLineWidthChange: onFibLevelLineWidthChange,
                onToggleFibLevel: onToggleFibLevel,
                onFibLvlValueChange: onFibLvlValueChange,
                onToggleFibMode: onToggleFibMode,
                onSingleFontColorChange: onSingleFontColorChange,
                onFibLevelFontColorChange: onFibLevelFontColorChange,
                onSingleFontSizeChange: onSingleFontSizeChange,
                onFibLevelFontSizeChange: onFibLevelFontSizeChange,
                onFibLevelFontWeightChange: onFibLevelFontWeightChange,
                onFibSingleFontWeightChange: onFibSingleFontWeightChange,
                onToggleSnapToHighLow: onToggleSnapToHighLow,
                onSaveTemplate: onSaveTemplate,
                onApplyTemplate: onApplyTemplate,
                onDeleteTemplate: onDeleteTemplate,
                onFibApplyAllButtonClick: onFibApplyAllButtonClick,
                onSetAsMyDefaultSettings: onSetAsMyDefaultSettings,
                onResetToAppDefaultSettings: onResetToAppDefaultSettings,
                onResetToMyDefaultSettings: onResetToMyDefaultSettings,
                onTrendLineToggleShow: onTrendLineToggleShow,
                enabledMyDefaultButton: enabledMyDefaultButton,
                onTrendLineColorChange: onTrendLineColorChange,
                onTrendLineWidthChange: onTrendLineWidthChange,
                onTrendLineStyleChange: onTrendLineStyleChange
            }

            infChart.structureManager.drawingTools.bindFibSettings(self.settingsPopup, callBackFnFibSettings);
        },
        bindFibGenericSettingsEvents: function (color, lineWidth, onFibLevelChange, onFibModeChange, onChangeSnapToHighLow, onTrendLineToggleShow) {
            var self = this,
                ann = self.annotation,
                options = ann.options,
                shape = self.shape,
                chartId = ann.chart.renderTo.id,
                stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chartId));
           
            /**
             * single option change event
             * @param {string} fillColor - hex fill color
             * @param {number} fillOpacity - fill opacity
             * @param {string} lineColor - hex line color
             * @param {number} lineWidth - line width
             * @param {object} prevOptions - prev options object
             * @param {boolean} isSingleColor - is single color or not
             * @param {boolean} isPropertyChange - is property change or not
             */
            function onSingleOptionChange(fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, isSingleColor, subType, isPropertyChange) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                self.onFibSingleOptionChange(fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, isSingleColor, prevOptions, subType, isPropertyChange);
            }

            /**
             * fib level line color change event
             * @param {object} rgb - color rgb
             * @param {string} value - hash color
             * @param {boolean} isPropertyChange - is property change
             * @param {object} fibLevelLineColors fib level line colors in settings panel
             */
            function onSingleLineColorChange(rgb, value, isSingleColor, fibLevelLineColors, subType, isPropertyChange) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                self.onFibSingleLineColorChange(rgb, value, isSingleColor, fibLevelLineColors, subType, isPropertyChange);
            }

            /**
             * change fibonacci drawing to single color or apply settings panle colors
             * @param {object} rgb color rgb
             * @param {string} value color hex
             * @param {number} opacity opacity
             * @param {boolean} isSingleColor is single color or not
             * @param {object} fibLevelColors fib level colors in settings panel
             */
            function onSingleFillColorChange(rgb, value, opacity, isSingleColor, fibLevelColors, subType) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                self.onFibSingleFillColorChange(rgb, value, opacity, isSingleColor, fibLevelColors, subType, isPropertyChange);
            }

            /**
             * change fibonacci single line width change
             * @param {number} strokeWidth - strock size
             * @param {boolean} isSingleColor - is single color or not
             * @param {object} fibLevelWidths - fib level widths in settings panel
             */
            function onSingleLineWidthChange(strokeWidth, isSingleColor, fibLevelWidths, subType) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                self.onFibSingleLineWidthChange(strokeWidth, isSingleColor, fibLevelWidths, subType, isPropertyChange);
            }

            function onSingleFontColorChange(rgb, value, isSingleColor, fibLevelFontColors, subType, isPropertyChange) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                self.onFibSingleFontColorChange(rgb, value, isSingleColor, fibLevelFontColors, subType, isPropertyChange);
            }

            function onSingleFontSizeChange(fontSize, isSingleColor, fibLevelFontSizes, subType) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                self.onFibSingleFontSizeChange(fontSize, isSingleColor, fibLevelFontSizes, subType, isPropertyChange);
            }

            /**
             * fib level line color change event
             * @param {object} rgb - color rgb
             * @param {string} value - hash color
             * @param {string} fibLevelId - fib level id
             * @param {boolean} isPropertyChange - is property change
             */
            function onFibLevelLineColorChange(rgb, value, fibLevelId, subType, isPropertyChange) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                self.onFibLevelLineColorChange(rgb, value, fibLevelId, false, subType, isPropertyChange);
            }

            /**
             * on fill color change event
             * @param {object} rgb - color rgb
             * @param {string} value - color hex
             * @param {number} opacity - opacity 0 - 1
             * @param {string} fibLevelId - fib level id
             * @param {boolean} isPropertyChange - is property change
             */
            function onFibLevelFillColorChange(rgb, value, opacity, fibLevelId, subType, isPropertyChange) {
                if (typeof isPropertyChange === "undefined" && self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                var fibLevels = self.annotation.options.fibLevels;
                var fibLevel = fibLevels.find(function (level) {
                    return level.id === fibLevelId;
                });
                self.annotation.options.enabledMyDefaultButton = true;
                self.onFibFillColorChange(rgb, value, opacity, fibLevel, false, subType, isPropertyChange);
            }

            /**
             * line width change event used for both single level and all level
             * @param {number} strokeWidth - stroke width
             * @param {string} fibLevelId - fib level id
             */
            function onFibLevelLineWidthChange(strokeWidth, fibLevelId, subType) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                self.onFibLineWidthChange(strokeWidth, fibLevelId, false, subType, isPropertyChange);
            }

            function onFibLevelFontColorChange(rgb, value, fibLevelId, subType, isPropertyChange) {
                if (typeof isPropertyChange === "undefined" && self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                var fibLevels = self.annotation.options.fibLevels;
                var fibLevel = fibLevels.find(function (level) {
                    return level.id === fibLevelId;
                });
                self.annotation.options.enabledMyDefaultButton = true;
                self.onFibLevelFontColorChange(rgb, value, fibLevel, false, subType, isPropertyChange);
            }

            function onFibLevelFontSizeChange(fontSize, fibLevelId, subType) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                self.onFibLevelFontSizeChange(fontSize, fibLevelId, false, subType, isPropertyChange);
            }

            function onFibLvlValueChange(currentLevel, value, subType) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                self.onFibLevelValueChange(currentLevel, value, subType, isPropertyChange);
            }

            function onToggleFibLevel(checked, currentLevel, subType) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.onFibLevelChange(currentLevel, checked, subType, isPropertyChange);
                self.annotation.options.enabledMyDefaultButton = true;
            }

            function onToggleFibMode(checked) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }

                if (onFibModeChange) {
                    onFibModeChange.call(self, checked, isPropertyChange);
                }
                self.annotation.options.enabledMyDefaultButton = true;
            }

            function onAlignStyleChange(linePosition, subType){
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.annotation.options.enabledMyDefaultButton = true;
                self.onAlignStyleChange(linePosition, subType, isPropertyChange);
            }

            function onToggleSnapToHighLow(checked) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }

                if (onChangeSnapToHighLow) {
                    onChangeSnapToHighLow.call(self, checked, isPropertyChange);
                }
                self.annotation.options.enabledMyDefaultButton = true;
            }

            function onSetAsMyDefaultSettings() {
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
                options.enabledMyDefaultButton = false;
            }

            function onResetToAppDefaultSettings() {
                self.updateSavedDrawingProperties(true);
                options.enabledMyDefaultButton  = false;
                
            }

            function onResetToMyDefaultSettings() {
                self.resetToUserDefaultDrawingProperties();
                options.enabledMyDefaultButton = false;
            }

            function onFibLevelFontWeightChange(fibLevelId, value, subType, isPropertyChange) {
                self.onFibLevelFontWeightChange(value, fibLevelId, false, subType, isPropertyChange);
                self.annotation.options.enabledMyDefaultButton = true;
            }

            function onFibSingleFontWeightChange(value, isSingleColor, fibLevelOptions, subType, isPropertyChange) {
                self.onFibSingleFontWeightChange(value, isSingleColor, fibLevelOptions, subType, isPropertyChange);
                self.annotation.options.enabledMyDefaultButton = true;
            }

            function onFibApplyAllButtonClick(fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, subType) {
                self.onFibApplyAllButtonClick(fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, subType, true);
                self.annotation.options.enabledMyDefaultButton= true;
            }

            function onSaveTemplate (templateName) {
                self.saveDrawingTemplate(templateName);
            }

            function onApplyTemplate (templateName) {
                self.applyDrawingTemplate(templateName);
                options.enabledMyDefaultButton = true;
            }

            function onDeleteTemplate (templateName) {
                self.deleteDrawingTemplate(templateName);
            }

            function resetEnabledMyDefaultButton(chartId, shape, drawingId, value){
                infChart.drawingsManager.resetEnabledMyDefaultButton.call(self, chartId, shape, drawingId, value);
            }

            function getEnabledMyDefaultButton(){
                return self.annotation && self.annotation.options && self.annotation.options.enabledMyDefaultButton;
            }

            function onTrendLineColorChange(rgb, color, opacity) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.onTrendLineColorChange.call(self, rgb, color,opacity, isPropertyChange);
            }

            function onTrendLineWidthChange(strokeWidth) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.onTrendLineWidthChange.call(self, strokeWidth, isPropertyChange);
            }

            function onTrendLineStyleChange(dashStyle) {
                var isPropertyChange = true;
                if (self.settingsPopup) {
                    isPropertyChange = self.isSettingsPropertyChange();
                }
                self.onTrendLineStyleChange.call(self, dashStyle, isPropertyChange);
            }

            var enabledMyDefaultButton = {};
            enabledMyDefaultButton.shape = shape;
            enabledMyDefaultButton.chartId = stockChart.id;
            enabledMyDefaultButton.drawingId = self.drawingId;
            enabledMyDefaultButton.resetEnabledMyDefaultButton = resetEnabledMyDefaultButton;
            enabledMyDefaultButton.getEnabledMyDefaultButton = getEnabledMyDefaultButton;

            var callBackFnFibGenSettings = {
                onSingleLineColorChange: onSingleLineColorChange,
                onSingleFillColorChange: onSingleFillColorChange,
                onSingleLineWidthChange: onSingleLineWidthChange,
                onSingleOptionChange: onSingleOptionChange,
                onFibLevelFillColorChange: onFibLevelFillColorChange,
                onFibLevelLineColorChange: onFibLevelLineColorChange,
                onFibLevelLineWidthChange: onFibLevelLineWidthChange,
                onToggleFibLevel: onToggleFibLevel,
                onFibLvlValueChange: onFibLvlValueChange,
                onToggleFibMode: onToggleFibMode,
                onSingleFontColorChange: onSingleFontColorChange,
                onFibLevelFontColorChange: onFibLevelFontColorChange,
                onSingleFontSizeChange: onSingleFontSizeChange,
                onFibLevelFontSizeChange: onFibLevelFontSizeChange,
                onFibLevelFontWeightChange: onFibLevelFontWeightChange,
                onFibSingleFontWeightChange: onFibSingleFontWeightChange,
                onAlignStyleChange: onAlignStyleChange,
                onToggleSnapToHighLow: onToggleSnapToHighLow,
                onSaveTemplate: onSaveTemplate,
                onApplyTemplate: onApplyTemplate,
                onDeleteTemplate: onDeleteTemplate,
                onFibApplyAllButtonClick: onFibApplyAllButtonClick,
                onSetAsMyDefaultSettings: onSetAsMyDefaultSettings,
                onResetToAppDefaultSettings: onResetToAppDefaultSettings,
                onResetToMyDefaultSettings: onResetToMyDefaultSettings,
                onTrendLineToggleShow: onTrendLineToggleShow,
                enabledMyDefaultButton: enabledMyDefaultButton,
                onTrendLineColorChange: onTrendLineColorChange,
                onTrendLineWidthChange: onTrendLineWidthChange,
                onTrendLineStyleChange: onTrendLineStyleChange
            }

            infChart.structureManager.drawingTools.bindFibGenericSettings(self.settingsPopup, callBackFnFibGenSettings);
        },
        setDeleteCursor: function () { //#CCA-2958
            if (infChart.drawingsManager.getIsActiveDeleteTool(this.stockChartId)) {
                var ann = this.annotation;
                if (ann.options.drawingType == 'shape') {
                    var url = infChart.drawingsManager.getDeleteCursor(this.stockChartId);
                    if (ann.title) {
                        ann.title.attr({ 'cursor': 'url("' + url + '"), default' });
                    }
                    $.each(this.dragSupporters, function (id, value) {
                        value.css({ 'cursor': 'url("' + url + '"), default' });
                    });
                }
            }
        },
        setDeleteModeCursor: function () {
            if (infChart.drawingsManager.getIsActiveEraseMode(this.stockChartId)) {
                var ann = this.annotation;
                if (ann.options.drawingType == 'shape') {
                    var url = infChart.drawingsManager.getEraseModeCursor(this.stockChartId);
                    if (ann.title) {
                        ann.title.attr({ 'cursor': 'url("' + url + '"), default' });
                    }
                    $.each(this.dragSupporters, function (id, value) {
                        value.css({ 'cursor': 'url("' + url + '"), default' });
                    });
                }
            }
        },
        symbol: {
            additionalDrawings: function () {
                var ann = this.annotation;

                ann.selectionMarker = [];
                infChart.drawingUtils.common.addSelectionMarker.call(this, ann, 0, 0);
            },
            step: function (e, isStartPoint) {
                var ann = this.annotation,
                    points = infChart.drawingUtils.common.calculateInitialPoints(e, ann, isStartPoint, 1, 1);

                var w = Math.round(points.dx),// + 1,
                    h = Math.round(points.dy),// + 1,
                    ret = {};

                ret.x = w < 0 ? w : 0;
                ret.width = Math.abs(w);
                ret.y = h < 0 ? h : 0;
                ret.height = Math.abs(h);
                ret.symbol = this.shape;
                ret.xValueEnd = isStartPoint ? ann.options.xValueEnd : points.xAxis.toValue(points.x);
                ret.yValueEnd = isStartPoint ? ann.options.yValueEnd : points.yAxis.toValue(points.y);

                ann.shape.attr({
                    symbol: this.shape,
                    x: ret.x,
                    y: ret.y,
                    width: ret.width,
                    height: ret.height
                });

                return ret;
            },
            stop: function (e, isStartPoint) {
                var ann = this.annotation,
                    chart = ann.chart;

                var symbol = this.stepFunction(e, isStartPoint);

                this.annotation.update({
                    xValueEnd: symbol.xValueEnd,
                    yValueEnd: symbol.yValueEnd,
                    shape: {
                        params: symbol
                    }
                });

                infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, symbol.yValueEnd);
                infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
                this.dragSupporters.push(chart.renderer.symbol(symbol.symbol, symbol.x, symbol.y, symbol.width, symbol.height, symbol).attr(infChart.drawingUtils.common.dragSupporterStyles).add(ann.group));
                infChart.drawingUtils.common.fixSelectionMarker.call(this, ann);
                infChart.drawingUtils.common.onPropertyChange.call(this);
            },
            scale: function () {
                var ann = this.annotation,
                    chart = ann.chart,
                    options = ann.options,
                    xAxis = chart.xAxis[options.xAxis],
                    yAxis = chart.yAxis[options.yAxis],
                    dx = xAxis.toPixels(options.xValueEnd) - xAxis.toPixels(options.xValue),
                    dy = yAxis.toPixels(options.yValueEnd) - yAxis.toPixels(options.yValue),
                    w = Math.round(dx),// + 1,
                    h = Math.round(dy),// + 1,
                    symbol = { symbol: options.shape.params.symbol };

                symbol.x = w < 0 ? w : 0;
                symbol.y = h < 0 ? h : 0;
                symbol.width = (!isNaN(w) && Math.abs(w)) || 0;
                symbol.height = (!isNaN(h) && Math.abs(h)) || 0;

                ann.update({
                    shape: {
                        params: symbol
                    }
                });

                infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
                this.dragSupporters.push(chart.renderer.symbol(symbol.symbol, symbol.x, symbol.y, symbol.width, symbol.height, symbol).attr(infChart.drawingUtils.common.dragSupporterStyles).add(ann.group));
                //#CCA-2958
                infChart.drawingUtils.common.setDeleteCursor.call(this);
                infChart.drawingUtils.common.setDeleteModeCursor.call(this);
            },
            selectAndBindResize: function () {
                var ann = this.annotation;
                var chart = ann.chart;
                var options = ann.options,
                    xAxis = chart.xAxis[options.xAxis],
                    yAxis = chart.yAxis[options.yAxis];

                ann.events.deselect.call(ann);
                ann.selectionMarker = [];
                chart.selectedAnnotation = ann;

                var startX = xAxis.toPixels(options.xValue),
                    startY = yAxis.toPixels(options.yValue);

                    if(startX < 0 && this.getShapeWidth) { 
                        var endX = this.getShapeWidth();                       
                    } else { 
                        var endX = Math.round(xAxis.toPixels(options.xValueEnd) - startX);
                    }
                var endY = Math.round(yAxis.toPixels(options.yValueEnd) - startY);

                if (!isNaN(startX) && !isNaN(startY) && !isNaN(endX) && !isNaN(endY)) {
                    infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, 0, 0, this.stepFunction, this.stop, true);
                    infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, endX, endY, this.stepFunction, this.stop, false);
                }
            },
            translateEnd: function () {
                infChart.drawingUtils.common.symbol.selectAndBindResize.call(this);
                infChart.drawingUtils.common.onPropertyChange.call(this);
            }
        },
        /***
         * Create an axis label and add to the group
         * @param {number} x x position
         * @param {number} y y position
         * @param {number} value actual value
         * @param {number} optionValue value that is set to the options (convered to  mode)
         * @param {boolean} isXAxis x or y
         * @returns {SVGElement} The generated label
         */
        getAxisLabel: function (x, y, value, optionValue, isXAxis, labelTheme) {
            var self = this,
                ann = self.annotation,
                options = ann.options,
                chart = ann.chart,
                height = 14,
                padding = 3,
                top,
                labelDefaultTheme = {
                    fill: labelTheme && labelTheme.fill || "#2f2e33",
                    stroke: labelTheme && labelTheme.stroke || "#858587",
                    opacity: labelTheme && labelTheme.opacity || 1,
                    fontColor: "#ffffff",
                    'zIndex': 20,
                    'padding': padding,
                    'r': 1,
                    'stroke-width': 0,
                    'stroke-linecap': 'butt',
                    'stroke-linejoin': 'miter',
                    'stroke-opacity': 1,
                    'hAlign': 'center',
                    'height': height,
                    'fontWeight': 100,
                    'fontSize': '10px'
                };
            top = isXAxis ? 0 : -(labelDefaultTheme.height / 2 + labelDefaultTheme.padding);

            if (!isXAxis) {
                ann.options.xLabelPadding = labelDefaultTheme.padding;
                ann.options.xLabelTop = top;
            }

            value = isXAxis ? self.getLabelFormattedXValue(optionValue, self.stockChart.chart.xAxis[options.xAxis]) :
                    self.getLabelFormattedYValue(value, optionValue);


            var lineLabel = chart.renderer.label(infChart.drawingUtils.common.getYValue.call(self, value), x, y + top).attr(labelDefaultTheme).add(ann.group);
            if (isXAxis) {
                lineLabel.attr({x: x - lineLabel.width / 2});
            } else {
                lineLabel.attr({x: x + 4});
            }
            lineLabel.css({ //to color text
                'fontWeight': labelDefaultTheme.fontWeight,
                'color': labelDefaultTheme.fontColor,
                'fontSize': labelDefaultTheme.fontSize
            });
            infChart.drawingUtils.common.getAxisLabelToFront.call(this, lineLabel);
            lineLabel.hide();
            return lineLabel;
        },
        getAxisLabelToFront: function (label, isParentOnly) {
            label.parentGroup.parentGroup.toFront();// get the label group to front from the axis labels
            if (!isParentOnly) {
                label.parentGroup.toFront();// get the label to front from the other vertical labels
            }
        },
        /**
         * Returns the andle of given two points in degrees
         * @param {object} point1 point with x,y
         * @param {object} point2 point with x,y
         * @returns {number} angle in degrees
         */
        getAngle: function (point1, point2) {
            var deltaX = point2.x - point1.x,
                deltaY = point2.y - point1.y,
                rad = Math.atan2(deltaY, deltaX),
                deg = rad * (180 / Math.PI);
            return deg;
        },
        settings: {
            /**
             * Change the stroke width of the annotation from the given width
             * IMPORTANT :: this method is uesd in commands.wrappers to set undo/redo actions
             * @param {number} strokeWidth new size
             * @param {boolean|undefined} isPropertyChange property change
             */
            onLineWidthChange: function (strokeWidth, isPropertyChange) {
                var self = this;
                self.annotation.update({
                    shape: {
                        params: {
                            'stroke-width': strokeWidth
                        }
                    }
                });

                if(self.additionalDrawings && self.additionalDrawings.lines){
                    $.each(self.additionalDrawings.lines, function (key, value) {
                        value.attr({
                            'stroke-width': strokeWidth
                        })
                    });
                }

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },
            /**
             * Change the stroke color of the annotation from the given color
             * IMPORTANT :: this method is uesd in commands.wrappers to set undo/redo actions
             * @param {object} rgb rgb value of the color
             * @param {string} color hash value of the color
             * @param {boolean|undefined} isPropertyChange property change
             */
            onLineColorChange: function (rgb, color, isPropertyChange) {
                var self = this;
                self.annotation.update({
                    shape: {
                        params: {
                            stroke: color
                        }
                    }
                });

                if(self.additionalDrawings['lineText']){
                    self.additionalDrawings['lineText'].css({
                        color: color
                    })
                }

                if(self.additionalDrawings && self.additionalDrawings.lines){
                    $.each(self.additionalDrawings.lines, function (key, value) {
                        value.attr({
                            stroke: color,
                            fillColor: color
                        })
                    });
                }

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },

            onLabelTextColorChange: function (rgb, color, isPropertyChange) {
                var self = this;
                var shape = this.shape;

                switch (shape) {
                    case 'abcdPattern':

                        if (self.additionalDrawings && self.additionalDrawings.labels) {

                            if (self.additionalDrawings.labels.ACFib) {
                                self.additionalDrawings.labels.ACFib.css({ color: color });
                            }

                            if (self.additionalDrawings.labels.BDFib) {
                                self.additionalDrawings.labels.BDFib.css({ color: color });
                            }

                            if (self.additionalDrawings.labels.aLabel) {
                                self.additionalDrawings.labels.aLabel.css({ color: color });
                            }

                            if (self.additionalDrawings.labels.bLabel) {
                                self.additionalDrawings.labels.bLabel.css({ color: color });
                            }

                            if (self.additionalDrawings.labels.cLabel) {
                                self.additionalDrawings.labels.cLabel.css({ color: color });
                            }

                            if (self.additionalDrawings.labels.dLabel) {
                                self.additionalDrawings.labels.dLabel.css({ color: color });
                            }

                            self.annotation.options.textColor = color;
                        }
                        break;
                    case 'harmonicPattern':

                        if (self.additionalDrawings && self.additionalDrawings.labels) {

                            if (self.additionalDrawings.labels.ACFib) {
                                self.additionalDrawings.labels.ACFib.css({ color: color });
                            }

                            if (self.additionalDrawings.labels.BDFib) {
                                self.additionalDrawings.labels.BDFib.css({ color: color });
                            }

                            if (self.additionalDrawings.labels.XBFib) {
                                self.additionalDrawings.labels.XBFib.css({ color: color });
                            }

                            if (self.additionalDrawings.labels.XDFib) {
                                self.additionalDrawings.labels.XDFib.css({ color: color });
                            }

                            if (self.additionalDrawings.labels.aLabel) {
                                self.additionalDrawings.labels.aLabel.css({ color: color });
                            }

                            if (self.additionalDrawings.labels.bLabel) {
                                self.additionalDrawings.labels.bLabel.css({ color: color });
                            }

                            if (self.additionalDrawings.labels.cLabel) {
                                self.additionalDrawings.labels.cLabel.css({ color: color });
                            }

                            if (self.additionalDrawings.labels.dLabel) {
                                self.additionalDrawings.labels.dLabel.css({ color: color });
                            }

                            if (self.additionalDrawings.labels.xLabel) {
                                self.additionalDrawings.labels.xLabel.css({ color: color });
                            }

                            self.annotation.options.textColor = color;
                        }
                        break;
                }

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },

            onLabelTextSizeChange: function (newFontSize, isPropertyChange) {
                var self = this;
                var isUpdate = false;
                var shape = self.shape;

                if (newFontSize === self.fontSize) {
                    return isUpdate;
                } else {
                    self.fontSize = newFontSize;
                    isUpdate = true;

                    switch (shape) {
                        case 'abcdPattern':
                            if (self.additionalDrawings.labels.ACFib) {
                                self.additionalDrawings.labels.ACFib.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.BDFib) {
                                self.additionalDrawings.labels.BDFib.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.aLabel) {
                                self.additionalDrawings.labels.aLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.bLabel) {
                                self.additionalDrawings.labels.bLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.cLabel) {
                                self.additionalDrawings.labels.cLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.dLabel) {
                                self.additionalDrawings.labels.dLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            self.annotation.options.textFontSize = newFontSize;

                            break;
                        case 'harmonicPattern':
                            if (self.additionalDrawings.labels.ACFib) {
                                self.additionalDrawings.labels.ACFib.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.BDFib) {
                                self.additionalDrawings.labels.BDFib.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.XBFib) {
                                self.additionalDrawings.labels.XBFib.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.XDFib) {
                                self.additionalDrawings.labels.XDFib.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.aLabel) {
                                self.additionalDrawings.labels.aLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.bLabel) {
                                self.additionalDrawings.labels.bLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.cLabel) {
                                self.additionalDrawings.labels.cLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.dLabel) {
                                self.additionalDrawings.labels.dLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.xLabel) {
                                self.additionalDrawings.labels.xLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            self.annotation.options.textFontSize = newFontSize;

                            break;
                        case 'longPositions':
                        case 'shortPositions':
                            if (self.additionalDrawings.stopLoss.label) {
                                self.additionalDrawings.stopLoss.label.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.pAndL.label) {
                                self.additionalDrawings.pAndL.label.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.takeProfit.label) {
                                self.additionalDrawings.takeProfit.label.css({ fontSize: newFontSize + 'px' });
                            }

                            self.updateLabels();
                            self.annotation.options.styles.textFontSize = newFontSize;

                            break;
                        case 'elliotTriangleWave':
                            if (self.additionalDrawings.labels.aLabel) {
                                self.additionalDrawings.labels.aLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.bLabel) {
                                self.additionalDrawings.labels.bLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.cLabel) {
                                self.additionalDrawings.labels.cLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.dLabel) {
                                self.additionalDrawings.labels.dLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.eLabel) {
                                self.additionalDrawings.labels.eLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.oLabel) {
                                self.additionalDrawings.labels.oLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            self.annotation.options.textFontSize = newFontSize;

                            break;
                        case 'elliotImpulseWave':
                            if (self.additionalDrawings.labels.no1Label) {
                                self.additionalDrawings.labels.no1Label.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.no2Label) {
                                self.additionalDrawings.labels.no2Label.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.no3Label) {
                                self.additionalDrawings.labels.no3Label.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.no4Label) {
                                self.additionalDrawings.labels.no4Label.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.no5Label) {
                                self.additionalDrawings.labels.no5Label.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.oLabel) {
                                self.additionalDrawings.labels.oLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            self.annotation.options.textFontSize = newFontSize;

                            break;
                        case 'elliotCorrectiveWave':
                            if (self.additionalDrawings.labels.aLabel) {
                                self.additionalDrawings.labels.aLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.bLabel) {
                                self.additionalDrawings.labels.bLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.cLabel) {
                                self.additionalDrawings.labels.cLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.oLabel) {
                                self.additionalDrawings.labels.oLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            self.annotation.options.textFontSize = newFontSize;

                            break;
                        case 'elliotCorrectiveDoubleWave':
                            if (self.additionalDrawings.labels.wLabel) {
                                self.additionalDrawings.labels.wLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.xLabel) {
                                self.additionalDrawings.labels.xLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.yLabel) {
                                self.additionalDrawings.labels.yLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.oLabel) {
                                self.additionalDrawings.labels.oLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            self.annotation.options.textFontSize = newFontSize;

                            break;
                        case 'correctiveTripleWave':
                            if (self.additionalDrawings.labels.wLabel) {
                                self.additionalDrawings.labels.wLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.xLabel) {
                                self.additionalDrawings.labels.xLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.xxLabel) {
                                self.additionalDrawings.labels.xxLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.yLabel) {
                                self.additionalDrawings.labels.yLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.zLabel) {
                                self.additionalDrawings.labels.zLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            if (self.additionalDrawings.labels.oLabel) {
                                self.additionalDrawings.labels.oLabel.css({ fontSize: newFontSize + 'px' });
                            }

                            self.annotation.options.textFontSize = newFontSize;

                            break;

                        default:
                            break;
                    }

                    isPropertyChange && self.onPropertyChange();
                    if (this.settingsPopup) {
                        this.settingsPopup.data("infUndoRedo", false);
                    }
                    infChart.drawingUtils.common.saveDrawingProperties.call(self);
                    return isUpdate;
                }
            },

            onTextColorChange: function (rgb, color, isPropertyChange) {
                var self = this;
                var shape = self.shape;

                switch (shape) {
                    case 'rectangle':
                        if (self.additionalDrawings.labels['rectText']) {
                            self.additionalDrawings.labels['rectText'].css({
                                color: color
                            });
                            self.annotation.options.textColor = color;
                        }
                        break;
                    case 'ellipse':
                        if (self.additionalDrawings.labels['ellipseText']) {
                            self.additionalDrawings.labels['ellipseText'].css({
                                color: color
                            });
                            self.annotation.options.textColor = color;
                        }
                        break;
                    case 'line':
                        if (self.additionalDrawings.labels['lineText']) {
                            self.additionalDrawings.labels['lineText'].css({
                                color: color
                            });
                            self.annotation.options.textColor = color;
                        }
                        break;
                }
                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },

            onTextSizeChange: function (newFontSize, isPropertyChange) {
                var self = this;
                var isUpdate = false;
                var shape = self.shape;

                switch (shape) {
                    case 'rectangle':
                        if (newFontSize !== self.fontSize) {
                            self.fontSize = newFontSize;
                            isUpdate = true;
                            self.additionalDrawings.labels['rectText'].css({
                                fontSize: newFontSize + 'px'
                            });
                            self.annotation.options.textFontSize = newFontSize;
                        }
                        break;
                    case 'ellipse':
                        if (newFontSize !== self.fontSize) {
                            self.fontSize = newFontSize;
                            isUpdate = true;
                            self.additionalDrawings.labels['ellipseText'].css({
                                fontSize: newFontSize + 'px'
                            });
                            self.annotation.options.textFontSize = newFontSize;
                        }
                        break;
                    case 'line':
                        if (newFontSize !== self.fontSize) {
                            self.fontSize = newFontSize;
                            isUpdate = true;
                            self.additionalDrawings.labels['lineText'].css({
                                fontSize: newFontSize + 'px'
                            });
                            self.annotation.options.textFontSize = newFontSize;
                        }
                        break;
                }

                self.calculateAndUpdateTextLabel();

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
                return isUpdate;
            },

            getStrokeDashArray: function (style, width){
                width = width.toString();
                var strokeDashArray;
                if (style === 'dash'){
                    switch (width){
                        case '1':
                            strokeDashArray = "4 3";
                            break;
                        case '2':
                            strokeDashArray = "8 6";
                            break;
                        case '3':
                            strokeDashArray = "12 9";
                            break;
                        default:
                            break;
                    }
                } else {
                        strokeDashArray = "none";
                }
                return  strokeDashArray; 
            },
            /**
             * Change the dashstyle of the annotation from the given type
             * IMPORTANT :: this method is uesd in commands.wrappers to set undo/redo actions
             * @param {string} dashStyle line type
             * @param {boolean|undefined} isPropertyChange property change
             */
            onLineStyleChange: function (dashStyle, isPropertyChange) {
                var self = this;
                self.annotation.update({
                    shape: {
                        params: {
                            dashstyle: dashStyle
                        }
                    }
                });
                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },

            onTextChange: function (text, isPropertyChange) {
                var self = this;
                var textLabelUpdate;
                var shape = this.shape;
                switch (shape) {
                    case 'rectangle':
                        textLabelUpdate = self.calculateAndUpdateTextLabel;
                        self.annotation.options.rectText = text;
                        break;
                    case 'ellipse':
                        textLabelUpdate = self.calculateAndUpdateTextLabel;
                        self.annotation.options.ellipseText = text;
                        break;
                    case 'line':
                        textLabelUpdate = self.calculateAndUpdateTextLabel;
                        self.annotation.options.lineText = text;
                        break;
                }

                textLabelUpdate.call(self);
                isPropertyChange && self.onPropertyChange();      
                    
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },

            onToggleText: function (checked, isPropertyChange) {
                var self = this;
                var shape = this.shape;
                switch (shape) {
                    case 'rectangle':
                        if(self.annotation.options ){
                            self.annotation.options.rectTextChecked = checked;
                        }
                        if(self.settingsPopup) {
                            if(checked) {
                                self.settingsPopup.find("textarea[inf-ctrl=rect-text]").removeAttr("disabled");
                                self.settingsPopup.find("div[inf-ctrl=verticalType]").find('button').prop('disabled', false);
                                self.settingsPopup.find("div[inf-ctrl=horizontalType]").find('button').prop('disabled', false);
                                self.settingsPopup.find("input[inf-ctrl=textColorPicker]").removeAttr("disabled");
                                $(self.settingsPopup.find("span[inf-ctrl=singleSelectedFontSize]")[0]).parent().removeAttr("disabled");
                                self.calculateAndUpdateTextLabel.call(self);
                            } else {
                                self.settingsPopup.find("textarea[inf-ctrl=rect-text]").attr("disabled","disabled");
                                self.settingsPopup.find("div[inf-ctrl=verticalType]").find('button').prop('disabled', true);
                                self.settingsPopup.find("div[inf-ctrl=horizontalType]").find('button').prop('disabled', true);
                                self.settingsPopup.find("input[inf-ctrl=textColorPicker]").attr("disabled","disabled");
                                $(self.settingsPopup.find("span[inf-ctrl=singleSelectedFontSize]")[0]).parent().attr("disabled","disabled");
                                self.additionalDrawings.labels.rectText.hide();
                            }
                        }
                        break;
                    case 'line':
                        if(self.annotation.options ){
                            self.annotation.options.lineTextChecked = checked;
                        }
                        if(self.settingsPopup) {
                            if(checked) {
                                self.settingsPopup.find("input[inf-ctrl=line-text]").removeAttr("disabled");
                                self.settingsPopup.find("input[inf-ctrl=textColorPicker]").removeAttr("disabled");
                                $(self.settingsPopup.find("span[inf-ctrl=singleSelectedFontSize]")[0]).parent().removeAttr("disabled");
                                self.calculateAndUpdateTextLabel.call(self);
                            } else {
                                self.settingsPopup.find("input[inf-ctrl=line-text]").attr("disabled","disabled");
                                self.settingsPopup.find("input[inf-ctrl=textColorPicker]").attr("disabled","disabled");
                                $(self.settingsPopup.find("span[inf-ctrl=singleSelectedFontSize]")[0]).parent().attr("disabled","disabled");
                                self.additionalDrawings.labels.lineText.hide();
                            }
                        }
                        break;
                    case 'ellipse':
                        if (self.annotation.options) {
                            self.annotation.options.ellipseTextChecked = checked;
                        }
                        if (self.settingsPopup) {
                            if (checked) {
                                self.settingsPopup.find("textarea[inf-ctrl=ellipse-text]").removeAttr("disabled");
                                self.settingsPopup.find("input[inf-ctrl=textColorPicker]").removeAttr("disabled");
                                $(self.settingsPopup.find("span[inf-ctrl=singleSelectedFontSize]")[0]).parent().removeAttr("disabled");
                                self.calculateAndUpdateTextLabel.call(self);
                            } else {
                                self.settingsPopup.find("textarea[inf-ctrl=ellipse-text]").attr("disabled", "disabled");
                                self.settingsPopup.find("input[inf-ctrl=textColorPicker]").attr("disabled","disabled");
                                $(self.settingsPopup.find("span[inf-ctrl=singleSelectedFontSize]")[0]).parent().attr("disabled","disabled");
                                self.additionalDrawings.labels.ellipseText.hide();
                            }
                        }
                        break;
                }
                
                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },

            

            onVerticalPositionSelect: function (position, isPropertyChange) {
                var self = this;
                self.annotation.options.verticalPosition = position;
                self.calculateAndUpdateTextLabel.call(self);
                isPropertyChange && self.onPropertyChange();            
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },

            onHorizontalPositionSelect: function (position, isPropertyChange) {
                var self = this;
                self.annotation.options.horizontalPosition = position;
                self.calculateAndUpdateTextLabel.call(self);
                isPropertyChange && self.onPropertyChange();            
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },

            /**
             * Change the stroke width of the annotation from the given width
             * IMPORTANT :: this method is uesd in commands.wrappers to set undo/redo actions
             * @param {number} strokeWidth new size
             * @param {boolean|undefined} isPropertyChange property change
             */
            onShortLongLineWidthChange: function (strokeWidth, isPropertyChange) {
                var self = this;
                self.annotation.update({
                    shape: {
                        params: {
                            'stroke-width': strokeWidth
                        }
                    }
                });
                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },

            /**
             * Change the dashstyle of the annotation from the given type
             * IMPORTANT :: this method is uesd in commands.wrappers to set undo/redo actions
             * @param {string} dashStyle line type
             * @param {boolean|undefined} isPropertyChange property change
             * @param {string} colorPickerRef filter to search for the specific color picker that change occured (used in wrappers)
             */
            onShortLongLineStyleChange: function (dashStyle, isPropertyChange, colorPickerRef) {
                var self = this;
                self.annotation.update({
                    shape: {
                        params: {
                            dashstyle: dashStyle
                        }
                    }
                });
                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },
            
            /**
             * Change the dashstyle of the annotation from the given type
             * IMPORTANT :: this method is uesd in commands.wrappers to set undo/redo actions
             * @param {string} value main line value
             * @param {boolean|undefined} isPropertyChange property change
             */
            onEntryValueChange: function (element, value, isPropertyChange) {
                var self = this;
                self.annotation.update({
                    yValue: value
                });
                self.annotation.options.yValue = value;
                self.yValue = value;
                self.scale();
                self.updateSettings(self.getConfig());
                
                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },

            onApplyLine: function (checked, lineType, isPropertyChange) {
                var self = this,
                    ann = self.annotation,
                    options = ann.options,
                    chart = ann.chart,
                    stockChart = this.stockChart,
                    line = ann.shape.d.split(' ');

                var isStopLoss = (lineType === 'sl1' || lineType === 'sl2' || lineType === 'sl3');
                var additionalDrawingList = isStopLoss ? options.stopLoss : options.takeProfit;
                var level = additionalDrawingList.find(function (level) {
                    if (level.id === lineType) {
                        return level;
                    }
                });
                var priceline = isStopLoss ? self.additionalDrawings.slPriceLines[level.id] : self.additionalDrawings.tpPriceLines[level.id];
                var lineLabel = isStopLoss ? self.additionalDrawings.slPriceLineLabels[level.id] : self.additionalDrawings.tpPriceLineLabels[level.id];
                var lineTagLabel = isStopLoss ? self.additionalDrawings.slPriceLineTagLabels[level.id] : self.additionalDrawings.tpPriceLineTagLabels[level.id];

                if(checked){
                    priceline.show();
                    lineLabel.show();
                    lineTagLabel.show();
                    level.enable = true;
                }else{
                    priceline.hide();
                    lineLabel.hide();
                    lineTagLabel.hide();
                    level.enable = false;
                    level.yValue = infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue) + infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue) * level.priceLineDiff;
                    if (self.settingsPopup) {
                        var settingPopUp = self.settingsPopup;
                        var ele = settingPopUp.find("input[inf-ctrl=priceLevelValue][inf-value='"+ level.id +"']");
                        ele.val(stockChart.formatValue(parseFloat(level.yValue).toFixed(3)));  
                    }
                    self.scale();
                }

                infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
                infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ["M", 0, 0, 'L', line[4], line[5]], self.dragSupporters);
                var tpPriceLines = self.additionalDrawings.tpPriceLines;
                $.each(tpPriceLines, function (key, value) {
                    if(value.visibility !== 'hidden'){
                        var line = value.d.split(' ');
                        var customAttributes = {
                            'level' : key,
                            'type': "additionalDrawing",
                            'stroke-width': 5
                        }            
                        var dragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', 'z-index': 20});
                        infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, dragSupporterStyles);
                    }
                });
                
                var slPriceLines = self.additionalDrawings.slPriceLines;
                $.each(slPriceLines, function (key, value) {
                    if(value.visibility !== 'hidden'){
                        var line = value.d.split(' ');
                        var customAttributes = {
                            'level' : key,
                            'type': "additionalDrawing",
                            'stroke-width': 5
                        }            
                        var dragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', 'z-index': 20});
                        infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, dragSupporterStyles);
                    }
                });

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },

            onPriceValueChange: function (element, priceValue, type, isPropertyChange) {
                var self = this,
                    ann = self.annotation,
                    options = ann.options,
                    chart = ann.chart,
                    xAxis = chart.xAxis[options.xAxis],
                    yAxis = chart.yAxis[options.yAxis];

                if (type == 'tp1' || type == 'tp2' || type == 'tp3') {
                    level = options.takeProfit.find(function (level) {
                        if (level.id == type) {
                            level.yValue = infChart.drawingUtils.common.getBaseYValues.call(self, priceValue);
                            return level;
                        }
                    });
                }
                if (type == 'sl1' || type == 'sl2' || type == 'sl3') {
                    level = options.stopLoss.find(function (level) {
                        if (level.id == type) {
                            level.yValue = infChart.drawingUtils.common.getBaseYValues.call(self, priceValue);
                            return level;
                        }
                    });
                }
                if (level.id == 'tp1' || level.id == 'tp2' || level.id == 'tp3') {
                    var priceline = self.additionalDrawings.tpPriceLines[level.id];
                    var lineLabel = self.additionalDrawings.tpPriceLineLabels[level.id];
                    var lineTagLabel = self.additionalDrawings.tpPriceLineTagLabels[level.id];
                }
                if (level.id == 'sl1' || level.id == 'sl2' || level.id == 'sl3') {
                    var priceline = self.additionalDrawings.slPriceLines[level.id];
                    var lineLabel = self.additionalDrawings.slPriceLineLabels[level.id];
                    var lineTagLabel = self.additionalDrawings.slPriceLineTagLabels[level.id];
                }

                var line = priceline.d.split(' ');
                var newY = yAxis.toPixels(priceValue) - yAxis.toPixels(options.yValue);
                priceline.attr({
                    d: ['M', line[1], newY, 'L', line[4], newY]
                }); 
                lineLabel.attr({
                    text: self.getPriceLineLabelFormattedValue(priceValue),
                    y: newY - lineTagLabel.height/2,
                });
                lineTagLabel.attr({
                    y: newY - lineTagLabel.height/2,
                }); 
                self.updateSettings(self.getConfig());

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);

            },

            onPriceLineWidthChange: function (type, strokeWidth, isPropertyChange) {
                var self = this,
                    ann = self.annotation,
                    options = ann.options;

                if (type == 'tp1' || type == 'tp2' || type == 'tp3') {
                    level = options.takeProfit.find(function (level) {
                        if (level.id == type) {
                            return level;
                        }
                    });
                }
                if (type == 'sl1' || type == 'sl2' || type == 'sl3') {
                    level = options.stopLoss.find(function (level) {
                        if (level.id == type) {
                            return level;
                        }
                    });
                }
                if (level.id == 'tp1' || level.id == 'tp2' || level.id == 'tp3') {
                    var priceline = self.additionalDrawings.tpPriceLines[level.id];
                }
                if (level.id == 'sl1' || level.id == 'sl2' || level.id == 'sl3') {
                    var priceline = self.additionalDrawings.slPriceLines[level.id];
                }

                priceline.attr({
                    'stroke-width': strokeWidth
                });
                level.lineWidth = strokeWidth;

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);

            },

            onPriceLineColorChange: function (color, type, isPropertyChange) {
                var self = this,
                    ann = self.annotation,
                    options = ann.options;

                if (type == 'tp1' || type == 'tp2' || type == 'tp3') {
                    level = options.takeProfit.find(function (level) {
                        if (level.id == type) {
                            return level;
                        }
                    });
                }
                if (type == 'sl1' || type == 'sl2' || type == 'sl3') {
                    level = options.stopLoss.find(function (level) {
                        if (level.id == type) {
                            return level;
                        }
                    });
                }
                if (level.id == 'tp1' || level.id == 'tp2' || level.id == 'tp3') {
                    var priceline = self.additionalDrawings.tpPriceLines[level.id];
                }
                if (level.id == 'sl1' || level.id == 'sl2' || level.id == 'sl3') {
                    var priceline = self.additionalDrawings.slPriceLines[level.id];
                }

                priceline.attr({
                    stroke: color
                }); 
                level.lineColor = color;

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }

                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },

            onPriceLineStyleChange: function (type, lineStyle, isPropertyChange) {
                var self = this,
                    ann = self.annotation,
                    options = ann.options;

                if (type == 'tp1' || type == 'tp2' || type == 'tp3') {
                    level = options.takeProfit.find(function (level) {
                        if (level.id == type) {
                            return level;
                        }
                    });
                }
                if (type == 'sl1' || type == 'sl2' || type == 'sl3') {
                    level = options.stopLoss.find(function (level) {
                        if (level.id == type) {
                            return level;
                        }
                    });
                }
                if (level.id == 'tp1' || level.id == 'tp2' || level.id == 'tp3') {
                    var priceline = self.additionalDrawings.tpPriceLines[level.id];
                }
                if (level.id == 'sl1' || level.id == 'sl2' || level.id == 'sl3') {
                    var priceline = self.additionalDrawings.slPriceLines[level.id];
                }

                priceline.attr({
                    dashstyle: lineStyle
                }); 
                level.lineStyle = lineStyle;

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },

            /**
             * Change the fill and opacity of the annotation from the given params
             * IMPORTANT :: this method is uesd in commands.wrappers to set undo/redo actions
             * @param {object} rgb rgb value of the color
             * @param {string} value hash value of the color
             * @param {float} opacity opacity to be set
             * @param {boolean|undefined} isPropertyChange property change
             * @param {string} colorPickerRef filter to search for the specific color picker that change occured (used in wrappers)
             */
            onFillColorChange: function (rgb, value, opacity, isPropertyChange, colorPickerRef) {
                var self = this;
                self.annotation.update({
                    shape: {
                        params: {
                            fill: value,
                            'fill-opacity': opacity
                        }
                    }
                });
                if(self.additionalDrawings && self.additionalDrawings.fill){
                    $.each(self.additionalDrawings.fill, function (key, fillDrawing) {
                        fillDrawing.attr({
                            fill: value,
                            'fill-opacity': opacity
                        })
                    });
                }

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },
            /**
             * Change the visibility of Fib levels
             * IMPORTANT :: this method is uesd in commands.wrappers to set undo/redo actions
             * @param {string} currentLevel level that is going to be changed
             * @param {boolean} checked visibility
             * @param {boolean|undefined} isPropertyChange property change
             * @param {boolean} ignoreSettingsSave - this is to indicate to this change does not affect to subsequent drawing
             */
            onFibLevelChange: function (currentLevel, checked, isPropertyChange, ignoreSettingsSave) {
                var self = this, drawing = self.additionalDrawings.lines[currentLevel];
                var label = self.fibonacciDrawings.lines[currentLevel];
                var hideFibLevelButton = self.additionalDrawings.hideFibLevelButton[currentLevel];
                var fill = self.fibonacciDrawings.fill[currentLevel],
                    options = self.annotation.options,
                    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels),
                    currentOrderIdx,
                    prevLine, prevFill, nextFill,
                    currentLinePoints,
                    nextLinePoints,
                    prvLinePoints,
                    i,
                    lineD,
                    next;
                if(isPropertyChange){
                    self.annotation.options.enabledMyDefaultButton = true;
                }
                fibLevels.some(function (fibLevel, i) {
                    if (fibLevel.id == currentLevel) {
                        currentOrderIdx = i;
                        return true;
                    }
                });
                fibLevels[currentOrderIdx].enable = checked;

                if (checked) {
                    drawing.show();
                    label.show();
                    if(hideFibLevelButton && self.annotation.chart.selectedAnnotation == self.annotation){
                        hideFibLevelButton.show();
                    }

                    for (i = currentOrderIdx + 1; i < fibLevels.length; i++) {
                        lineD = self.additionalDrawings.lines[fibLevels[i].id];
                        if (lineD && lineD.visibility != "hidden") {
                            prevLine = lineD;
                            prevFill = self.fibonacciDrawings.fill[fibLevels[i].id];
                            break;
                        }
                    }
                    for (i = currentOrderIdx - 1; i >= 0; i--) {
                        lineD = self.additionalDrawings.lines[fibLevels[i].id];
                        if (lineD && lineD.visibility != "hidden") {
                            next = lineD;
                            nextFill = self.fibonacciDrawings.fill[fibLevels[i].id];
                            break;
                        }
                    }

                    currentLinePoints = drawing.d.split(' ');

                    if (next && nextFill) {
                        nextFill.show();
                        nextLinePoints = next.d.split(' ');
                        nextFill.attr({
                            d: ['M', nextLinePoints[1], nextLinePoints[2], 'L', nextLinePoints[4], nextLinePoints[5], 'L', currentLinePoints[4], currentLinePoints[5], 'L', currentLinePoints[1], currentLinePoints[2], 'L', currentLinePoints[1], currentLinePoints[2]]
                        });

                    }

                    if (fill && prevLine) {
                        fill.show();
                        prvLinePoints = prevLine.d.split(' ');
                        fill.attr({
                            d: ['M', prvLinePoints[1], prvLinePoints[2], 'L', prvLinePoints[4], prvLinePoints[5], 'L', currentLinePoints[4], currentLinePoints[5], 'L', currentLinePoints[1], currentLinePoints[2], 'L', prvLinePoints[1], prvLinePoints[2]]
                        });
                    }

                } else {
                    drawing.hide();
                    label.hide();
                    fill.hide();
                    if(hideFibLevelButton){
                        hideFibLevelButton.hide();
                    }

                    for (i = currentOrderIdx + 1; i < fibLevels.length; i++) {
                        lineD = self.additionalDrawings.lines[fibLevels[i].id];
                        if (lineD && lineD.visibility != "hidden") {
                            prevLine = lineD;
                            prevFill = self.fibonacciDrawings.fill[fibLevels[i].id];
                            break;
                        }
                    }

                    for (i = currentOrderIdx - 1; i >= 0; i--) {
                        lineD = self.additionalDrawings.lines[fibLevels[i].id];
                        if (lineD && lineD.visibility != "hidden") {
                            next = lineD;
                            nextFill = self.fibonacciDrawings.fill[fibLevels[i].id];
                            break;
                        }
                    }
                    if (prevLine && next) {
                        prvLinePoints = prevLine.d.split(' ');
                        nextLinePoints = next.d.split(' ');
                        nextFill.attr({
                            d: ['M', nextLinePoints[1], nextLinePoints[2], 'L', nextLinePoints[4], nextLinePoints[5], 'L', prvLinePoints[4], prvLinePoints[5], prvLinePoints[1], prvLinePoints[2], 'L', nextLinePoints[1], nextLinePoints[2]]
                        })
                    } else if (!prevLine && nextFill) {
                        nextFill.hide();
                    }
                }

                if(self.resetDragSupporters){
                    self.resetDragSupporters();
                }

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
            },
            /**
             * change the fib level value and scale the fib drawing
             * IMPORTANT :: this method is uesd in commands.wrappers to set undo/redo actions
             * @param {string} currentLevel - fib level
             * @param {string} value - new value
             * @param {boolean|undefined} isPropertyChange property change
             */
            onFibLevelValueChange: function (currentLevel, value, isPropertyChange) {
                var self = this;
                var ann = self.annotation,
                    options = ann.options,
                    fibLevels = options.fibLevels;

                fibLevels.forEach(function (fibLevel) {
                    if (fibLevel.id === currentLevel) {
                        fibLevel.value = value;
                        return;
                    }
                });

                self.scale();
                self.updateSettings(self.getConfig());
                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
            },
            /**
             * Change the stroke of the annotation from the given params
             * IMPORTANT :: this method is uesd in commands.wrappers to set undo/redo actions
             * @param {object} rgb rgb value of the color
             * @param {string} value hash value of the color
             * @param {boolean|undefined} isPropertyChange property change
             */
            onFibSingleLineColorChange: function (rgb, value, isSingleColor, fibLevelColors, isPropertyChange) {
                var self = this;
                var fibLevels = self.annotation.options.fibLevels;
                self.isSingleColor = isSingleColor;
                if (isSingleColor) {
                    self.annotation.options.lineColor = value;

                    for (i = 0; i < fibLevels.length; i++) {
                        infChart.drawingUtils.common.settings.onFibLevelLineColorChange.call(self, rgb, value, fibLevels[i].id, true, false);
                    }
                } else {
                    for (i = 0; i < fibLevels.length; i++) {
                        var lineColor = fibLevelColors[fibLevels[i].id].lineColor;
                        infChart.drawingUtils.common.settings.onFibLevelLineColorChange.call(self, rgb, lineColor, fibLevels[i].id, false, false);
                    }
                }

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
            },
            /**
             * fib level color change event
             * @param {object} rgb - color rgb
             * @param {string} value - color hex
             * @param {string} fibLevelId - fib level id
             * @param {boolean} isPropertyChange - is property change
             */
            onFibLevelLineColorChange: function (rgb, value, fibLevelId, isAll, isPropertyChange) {
                var self = this;

                self.fibonacciDrawings.lines[fibLevelId].css({
                    fill: value
                });

                self.additionalDrawings.lines[fibLevelId].attr({
                    'stroke': value
                });

                if (!isAll) {
                    var fibLevels = self.annotation.options.fibLevels;
                    var fibLevel = fibLevels.find(function (level) {
                        return level.id === fibLevelId;
                    });
                    fibLevel.lineColor = value;
                }

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
            },
            /**
             * Change the fill and opacity of the annotation from the given params
             * IMPORTANT :: this method is uesd in commands.wrappers to set undo/redo actions
             * @param {object} rgb rgb value of the color
             * @param {string} value hash value of the color
             * @param {float} opacity opacity to be set
             * @param {string} fibLevel level that is going to be changed
             * @param {boolean|undefined} isPropertyChange property change
             */
            onFibFillColorChange: function (rgb, value, opacity, fibLevel, isAll, isPropertyChange) {
                var self = this;
                var fibonacciDrawingsFill = self.fibonacciDrawings.fill[fibLevel.id];

                if (fibonacciDrawingsFill) {
                    fibonacciDrawingsFill.attr({
                        'fill': value,
                        'fill-opacity': opacity
                    });
                    if (!isAll) {
                        fibLevel.fillColor = value;
                        fibLevel.fillOpacity = opacity;
                    }
                }
                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
            },
            /**
             * change fibonacci drawing to single color or apply settings panle colors
             * IMPORTANT :: this method is uesd in commands.wrappers to set undo/redo actions
             * @param {object} rgb color rgb
             * @param {string} value color hex
             * @param {number} opacity opacity
             * @param {boolean} isSingleColor is single color or not
             * @param {object} fibLevelColors fib level colors in settings panel
             * @param {boolean|undefined} isPropertyChange property change
             */
            onFibSingleFillColorChange: function (rgb, value, opacity, isSingleColor, fibLevelColors, isPropertyChange) {
                var self = this;
                var ann = self.annotation;
                var fibLevels = ann.options.fibLevels;
                var i;
                self.isSingleColor = isSingleColor;
                if (isSingleColor) {
                    ann.update({
                        shape: {
                            params: {
                                'fill': value,
                                'fill-opacity': opacity
                            }
                        }
                    });
                    ann.options.fillColor = value;
                    ann.options.fillOpacity = opacity;
                    for (i = 0; i < fibLevels.length; i++) {
                        infChart.drawingUtils.common.settings.onFibFillColorChange.call(self, rgb, value, opacity, fibLevels[i], true, false);
                    }
                } else {
                    for (i = 0; i < fibLevels.length; i++) {
                        var fibOption = fibLevelColors[fibLevels[i].id];
                        infChart.drawingUtils.common.settings.onFibFillColorChange.call(self, rgb, fibOption.fillColor, fibOption.fillOpacity, fibLevels[i], false, false);
                    }
                }
                isPropertyChange && self.onPropertyChange();
                if (self.settingsPopup) {
                    self.settingsPopup.data("infUndoRedo", false);
                }
            },
            onFibSingleFontColorChange: function (rgb, value, isSingleColor, fibLevelColors, isPropertyChange) {
                var self = this;
                var ann = self.annotation;
                var fibLevels = ann.options.fibLevels;
                var i;
                self.isSingleColor = isSingleColor;
                if (isSingleColor) {
                    ann.update({
                        shape: {
                            params: {
                                'font-color': value
                            }
                        }
                    });
                    ann.options.fontColor = value;
                    for (i = 0; i < fibLevels.length; i++) {
                        infChart.drawingUtils.common.settings.onFibLevelFontColorChange.call(self, rgb, value, fibLevels[i], true, false);
                    }
                } else {
                    for (i = 0; i < fibLevels.length; i++) {
                        var fibOption = fibLevelColors[fibLevels[i].id];
                        infChart.drawingUtils.common.settings.onFibLevelFontColorChange.call(self, rgb, fibOption.fontColor, fibLevels[i], false, false);
                    }
                }
                isPropertyChange && self.onPropertyChange();
                if (self.settingsPopup) {
                    self.settingsPopup.data("infUndoRedo", false);
                }
            },
            onFibLevelFontColorChange: function (rgb, value, fibLevel, isAll, isPropertyChange) {
                var self = this;
                var fibonacciDrawingsLabel = self.fibonacciDrawings.lines[fibLevel.id];
                if (fibonacciDrawingsLabel) {
                    fibonacciDrawingsLabel.attr({
                        'font-color': value
                    }).css({
                        'color': value
                    });
                }
                if (!isAll) {
                    fibLevel.fontColor = value;
                }
                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
            },

            /**
             * change font weight of given fib level
             * @param {string} value - font weight
             * @param {string} fibLevelId - fib level id
             * @param {boolean} isPropertyChange - is property chnage
             */
            onFibLevelFontWeightChange: function (value, fibLevelId, isAll, isPropertyChange) {
                var self = this;
                var fibonacciDrawingsLabel = self.fibonacciDrawings.lines[fibLevelId];
                if (fibonacciDrawingsLabel) {
                    fibonacciDrawingsLabel.attr({
                        'font-weight': value
                    }).css({
                        'font-weight': value
                    });
                }
                if (!isAll) {
                    var fibLevels = self.annotation.options.fibLevels;
                    var fibLevel = fibLevels.find(function (level) {
                        return level.id === fibLevelId;
                    });
                    fibLevel.fontWeight = value;
                }
                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
            },

            /**
             * fib single font weight change
             * @param {number} value - font weight
             * @param {boolean} isSingleColor - is single color
             * @param {object} fibLevelOptions - fib level options
             * @param {boolean} isPropertyChange - property change
             */
            onFibSingleFontWeightChange: function (value, isSingleColor, fibLevelOptions, isPropertyChange) {
                var self = this;
                var ann = self.annotation;
                var fibLevels = ann.options.fibLevels;
                var i;
                self.isSingleColor = isSingleColor;
                if (isSingleColor) {
                    ann.update({
                        shape: {
                            params: {
                                'font-weight': value
                            }
                        }
                    });
                    ann.options.fontWeight = value;
                    for (i = 0; i < fibLevels.length; i++) {
                        infChart.drawingUtils.common.settings.onFibLevelFontWeightChange.call(self, value, fibLevels[i].id, true, false);
                    }
                } else {
                    for (i = 0; i < fibLevels.length; i++) {
                        var fibOption = fibLevelOptions[fibLevels[i].id];
                        infChart.drawingUtils.common.settings.onFibLevelFontWeightChange.call(self, fibOption.fontWeight, fibLevels[i].id, false, false);
                    }
                }
                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
            },

            /**
             * fib single line width change
             * @param {number} strokeWidth - line width
             * @param {boolean} isSingleColor - is single color
             * @param {object} fibLevelWidths - fib level widths
             * @param {boolean} isPropertyChange - property change
             */
            onFibSingleLineWidthChange: function (strokeWidth, isSingleColor, fibLevelWidths, isPropertyChange) {
                var self = this;
                var fibLevels = self.annotation.options.fibLevels;
                self.isSingleColor = isSingleColor;
                if (isSingleColor) {
                    self.annotation.options.lineWidth = strokeWidth;

                    for (i = 0; i < fibLevels.length; i++) {
                        infChart.drawingUtils.common.settings.onFibLineWidthChange.call(self, strokeWidth, fibLevels[i].id, true, false);
                    }
                } else {
                    for (i = 0; i < fibLevels.length; i++) {
                        infChart.drawingUtils.common.settings.onFibLineWidthChange.call(self, fibLevelWidths[fibLevels[i].id].lineWidth, fibLevels[i].id, false, false);
                    }
                }

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
            },
            onFibSingleFontSizeChange: function (fontSize, isSingleColor, fibLevelFontSizes, isPropertyChange) {
                var self = this;
                var fibLevels = self.annotation.options.fibLevels;
                self.isSingleColor = isSingleColor;
                if (isSingleColor) {
                    self.annotation.update({
                        shape: {
                            params: {
                                'font-size': fontSize
                            }
                        }
                    });
                    self.annotation.options.fontSize = fontSize;

                    $.each(self.fibonacciDrawings.lines, function (key, val) {
                        val.attr({
                            'font-size': fontSize
                        });
                        val.css({
                            'fontSize': fontSize + 'px'
                        });
                    });
                    self.scale();
                } else {
                    for (var i = 0; i < fibLevels.length; i++) {
                        infChart.drawingUtils.common.settings.onFibLevelFontSizeChange.call(self, fibLevelFontSizes[fibLevels[i].id].fontSize, fibLevels[i].id, false, false);
                    }
                }

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
            },
            /**
             * fib single option change event
             * @param {stirng} fillColor - hex fill color
             * @param {number} fillOpacity - fill opacity
             * @param {string} lineColor - hex line color
             * @param {number} lineWidth - line width
             * @param {boolean} isSingleColor - is single option
             * @param {object} prevOptions - previous color, width options
             * @param {boolean} isPropertyChange -property change
             */
            onFibSingleOptionChange: function (fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, isSingleColor, prevOptions, isPropertyChange) {
                var self = this;
                var ann = self.annotation,
                    options = ann.options;

                options.isSingleColor = isSingleColor;
                infChart.drawingUtils.common.settings.onFibSingleFillColorChange.call(self, undefined, fillColor, fillOpacity, isSingleColor, prevOptions, false);
                infChart.drawingUtils.common.settings.onFibSingleLineColorChange.call(self, undefined, lineColor, isSingleColor, prevOptions, false);
                infChart.drawingUtils.common.settings.onFibSingleLineWidthChange.call(self, lineWidth, isSingleColor, prevOptions, false);
                infChart.drawingUtils.common.settings.onFibSingleFontColorChange.call(self, undefined, fontColor, isSingleColor, prevOptions, false);
                infChart.drawingUtils.common.settings.onFibSingleFontSizeChange.call(self, fontSize, isSingleColor, prevOptions, false);
                infChart.drawingUtils.common.settings.onFibSingleFontWeightChange.call(self, fontWeight, isSingleColor, prevOptions, false)

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
            },
            /**
             * Change the stroke width of the annotation from the given width
             * IMPORTANT :: this method is uesd in commands.wrappers to set undo/redo actions
             * @param {number} strokeWidth new size
             * @param {boolean|undefined} isPropertyChange property change
             */
            onFibLineWidthChange: function (strokeWidth, fibLevelId, isAll, isPropertyChange) {
                var self = this;
                self.additionalDrawings.lines[fibLevelId].attr({
                    'stroke-width': strokeWidth
                });
                if (!isAll) {
                    var fibLevels = self.annotation.options.fibLevels;
                    var fibLevel = fibLevels.find(function (level) {
                        return level.id === fibLevelId;
                    });
                    fibLevel.lineWidth = strokeWidth;
                }
                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
            },
            onFibLevelFontSizeChange: function (fontSize, fibLevelId, isAll, isPropertyChange) {
                var self= this;
                self.fibonacciDrawings.lines[fibLevelId].attr({
                    'font-size': fontSize
                }).css({
                    'fontSize': fontSize + 'px'
                });
                if (!isAll) {
                    var fibLevels = self.annotation.options.fibLevels;
                    var fibLevel = fibLevels.find(function (level) {
                        return level.id === fibLevelId;
                    });
                    fibLevel.fontSize = fontSize;
                }
                self.scale();
                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
            },
            onXabcdLineWidthChange: function (strokeWidth, isPropertyChange) {
                var self = this;

                self.annotation.update({
                    shape: {
                        params: {
                            'stroke-width': strokeWidth
                        }
                    }
                });

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },
            onXabcdLineColorChange: function (color, isPropertyChange) {
                var self = this;
                var pointArray = ["a", "b", "c", "d", "x"];
                var lineArray = ["AC", "BD", "XB", "XD"];
                self.annotation.update({
                    shape: {
                        params: {
                            stroke: color
                        }
                    }
                });

                if(self.additionalDrawings.lines["xbd"]){
                    self.additionalDrawings.lines["xbd"].attr({
                        stroke: color
                    });
                }
                
                self.additionalDrawings.lines["ac"].attr({
                    stroke: color
                });

                infChart.util.forEach(lineArray, function (index, value) {
                    if (self.additionalDrawings.labels[value + "Fib"]) {
                        self.additionalDrawings.labels[value + "Fib"].attr({
                            fill: color
                        });
                    }
                }); 

                infChart.util.forEach(pointArray, function (index, value) {
                    if (self.additionalDrawings.labels[value + "Label"]) {
                        self.additionalDrawings.labels[value + "Label"].attr({
                            fill: color
                        });
                    }
                }); 

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },
            onXabcdFillColorChange: function (value, opacity, isPropertyChange) {
                var self = this,
                    ann = self.annotation,
                    options = ann.options;

                var drawingsFillXab = self.additionalDrawings.fill["xabFill"];

               if(drawingsFillXab) {
                    drawingsFillXab.attr({
                        'fill': value,
                        'fill-opacity': opacity
                    });
                }

                var drawingsFillBc = self.additionalDrawings.fill["bcdFill"];
               if(drawingsFillBc){
                    drawingsFillBc.attr({
                            'fill': value,
                            'fill-opacity': opacity
                    });
                }
                self.annotation.options.fillColorValue = value;
                self.annotation.options.fillOpacityValue = opacity;

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);

            },
            onAbcdLineColorChange: function (color, isPropertyChange) {
                var self = this;
                var pointArray = ["a", "b", "c", "d"];
                var lineArray = ["AC", "BD"];
                self.annotation.update({
                    shape: {
                        params: {
                            stroke: color
                        }
                    }
                });

                self.additionalDrawings.lines["bd"].attr({
                    stroke: color
                });

                self.additionalDrawings.lines["ac"].attr({
                    stroke: color
                });

                infChart.util.forEach(lineArray, function (index, value) {
                    if (self.additionalDrawings.labels[value + "Fib"]) {
                        self.additionalDrawings.labels[value + "Fib"].attr({
                            fill: color
                        });
                    }
                }); 

                infChart.util.forEach(pointArray, function (index, value) {
                    if (self.additionalDrawings.labels[value + "Label"]) {
                        self.additionalDrawings.labels[value + "Label"].attr({
                            fill: color
                        });
                    }
                }); 
                
                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },
            onAbcdLineWidthChange: function (strokeWidth, isPropertyChange) {
                var self = this;

                self.annotation.update({
                    shape: {
                        params: {
                            'stroke-width': strokeWidth
                        }
                    }
                });
                self.additionalDrawings.lines["bd"].attr({
                    'stroke-width': strokeWidth
                });

                self.additionalDrawings.lines["ac"].attr({
                    'stroke-width': strokeWidth
                });

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },
            onPolylineColorChange: function (color, isPropertyChange) {
                var self = this;
                self.annotation.update({
                    shape: {
                        params: {
                            stroke: color
                        }
                    }
                });

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },
            onPolylineFillColorChange: function (rgb, value, opacity, isPropertyChange) {
                var self = this;
                if(self.annotation.options.drawingIsFullFilled){
                    self.annotation.update({
                        shape: {
                            params: {
                                fill: value,
                                'fill-opacity': opacity
                            }
                        }
                    });
                }
                self.annotation.update({
                    fillColorPicker: value,
                    fillOpacityPicker: opacity
                });

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },
            onPolylineStyleChange: function (lineStyle, isPropertyChange){
                var self = this;
                self.annotation.update({
                    shape: {
                        params: {
                            dashstyle: lineStyle
                        }
                    }
                });
                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },
            onPolylineWidthChange: function (strokeWidth, isPropertyChange) {
                var self = this;

                self.annotation.update({
                    shape: {
                        params: {
                            'stroke-width': strokeWidth
                        }
                    }
                });

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },
            onElliotWaveLineColorChange: function (color, isPropertyChange) {
                var self = this;
                self.annotation.update({
                    shape: {
                        params: {
                            stroke: color
                        }
                    }
                });

                self.labelValueNames.forEach(function(value, index){
                    if(self.additionalDrawings.labels[value]){
                        self.additionalDrawings.labels[value].attr({
                            'stroke': color,
                        }).css({
                            'color': color
                        });
                    }
                });


                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },
            onElliotWaveLineWidthChange: function (strokeWidth, isPropertyChange) {
                var self = this;

                self.annotation.update({
                    shape: {
                        params: {
                            'stroke-width': strokeWidth
                        }
                    }
                });

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }
                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },
            onElliotWaveDegreeChange: function (waveDegree, element, isPropertyChange) {
                var self = this,
                    ann = self.annotation,
                    options = ann.options;
                var selectedDegree;
                var xChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart);
                var listElement = element.find("li[inf-ctrl=waveDegree][inf-type="+ options.currentWaveDegree +"]");
                listElement.removeClass('active');

                self.waveDegrees.forEach(function (value, index) {
                    if(value.name == waveDegree){
                        selectedDegree = value;
                    }
                });
                
                
                self.annotation.update({
                    shape: {
                        params: {
                            'stroke': selectedDegree.color
                        }
                    },
                    currentWaveDegree: waveDegree
                });
                self.labelValueNames.forEach(function(value, index){
                    if(self.additionalDrawings.labels[value]){
                        self.additionalDrawings.labels[value].attr({
                            'stroke': selectedDegree.color,
                            text: selectedDegree.options[index]
                        }).css({
                            'color': selectedDegree.color
                        });
                    }
                });

                self.calculateAndUpdateInfoLabel();

                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var lineColorPickerElm = settingPanel.find("[inf-ctrl=lineColorPicker]");
                        lineColorPickerElm.mainColorPanel("value", {color: selectedDegree.color});
                }
                self.scale();
                if(isPropertyChange){
                    infChart.commandsManager.removeLastAction(xChartId);
                }

                isPropertyChange && self.onPropertyChange();
                if (this.settingsPopup) {
                    this.settingsPopup.data("infUndoRedo", false);
                }

                infChart.drawingUtils.common.saveDrawingProperties.call(self);
            },
            onFibApplyAllButtonClick: function (fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, isPropertyChange) {
                var self = this;
                var fibLevels = self.annotation.options.fibLevels;

                fibLevels.forEach(function (fibLevel) {
                    fibLevel.fillColor = fillColor;
                    fibLevel.fillOpacity = fillOpacity;
                    fibLevel.lineColor = lineColor;
                    fibLevel.lineWidth = lineWidth;
                    fibLevel.fontColor = fontColor;
                    fibLevel.fontSize = fontSize;
                    fibLevel.fontWeight = fontWeight;
                });
                self.fibLevels = fibLevels;

                self.updateSettings(self.getConfig());
                isPropertyChange && self.onPropertyChange();
            }
        },
        getContextMenuOptions : function (chartId, drawingId, options) {
            var drawingObject = infChart.drawingsManager.getDrawingObject(chartId, drawingId);
            var contextMenu =  {
                "eraseDrawing" : {
                    icon : options.eraseGroup.icon,
                    displayText : options.eraseGroup.displayText,
                    action : function () {
                        infChart.drawingsManager.removeDrawing(chartId, drawingId, undefined, true);
                        infChart.drawingsManager.updateIsGloballyLockInDelete(chartId);
                    }
                },
                "eraseAllDrawings" : {
                    icon : options.eraseAll.icon,
                    displayText : options.eraseAll.displayText,
                    action : function () {
                        var chartInstance = infChart.manager.getChart(chartId);
                        infChart.drawingsManager.removeAllDrawings(chartId, true);
                        infChart.drawingsManager.updateIsGloballyLockInDelete(chartId);
                        var leftPanel = $(chartInstance.container).find('div[inf-pnl=tb-drawing-nav-container]');
                        infChart.drawingsManager.setActiveDrawingToolOptions(chartId, leftPanel);
                    }
                },
                "showDrawingSettings" : {
                    icon : options.settings.icon,
                    displayText :options.settings.displayText,
                    action : function () {
                        var drawingObj = infChart.drawingsManager.getDrawingObject(chartId, drawingId);
                        if (drawingObj && !drawingObj.disableQuickSettingPanel) {
                            if (drawingObj.isQuickSetting) {
                                infChart.drawingUtils.common.toggleSettings.call(drawingObj);
                            } else {
                                infChart.drawingsManager.openSettings(drawingObj, false);
                            }
                        } else {
                            infChart.drawingsManager.openSettings(drawingObj, false);
                        }
                    }
                }
            };

            if (infChart.drawingsManager.getIsActiveEraseMode(chartId)) {
                var eraseModeOFF = {
                    icon: options.eraseModeOFF.icon,
                    displayText: options.eraseModeOFF.displayText,
                    disabled: !infChart.drawingsManager.isDrawnDrawingsAvailable(chartId),
                    action: function () {
                        infChart.drawingsManager.offDeleteMode(chartId);
                    }
                };
                contextMenu["eraseModeOFF"] = eraseModeOFF;
            } else {
                var eraseModeON = {
                    icon: options.eraseModeON.icon,
                    displayText: options.eraseModeON.displayText,
                    disabled: !infChart.drawingsManager.isDrawnDrawingsAvailable(chartId),
                    action: function () {
                        infChart.drawingsManager.setDeleteMode(chartId);
                    }
                };
                contextMenu["eraseModeON"] = eraseModeON;
            }

            if (drawingObject.annotation.options.isLocked) {
                var unlock = {
                    icon: options.lock.icon,
                    displayText: options.unlock.displayText,
                    disabled: !infChart.drawingsManager.isDrawnDrawingsAvailable(chartId),
                    action: function () {
                        var element = ($(drawingObject.settingsPopup[0]).find('a[inf-ctrl="quick-setting-lock"]'))
                        drawingObject.toggleLock(element);
                    }
                };
                contextMenu["unlock"] = unlock;
            } else {
                var lock = {
                    icon: options.unlock.icon,
                    displayText: options.lock.displayText,
                    disabled: !infChart.drawingsManager.isDrawnDrawingsAvailable(chartId),
                    action: function () {
                        var element = ($(drawingObject.settingsPopup[0]).find('a[inf-ctrl="quick-setting-lock"]'))
                        drawingObject.toggleLock(element);
                    }
                };
                contextMenu["lock"] = lock;
            }

            var newcontextMenu = infChart.drawingUtils.common.reorderContextMenu(contextMenu);
            return newcontextMenu;
        },
        reorderContextMenu: function(contextMenu){
            var newContextMenu = {};
            var contextMenuOrder = ["copyToClipboard", "eraseModeON", "eraseModeOFF", "eraseThis", "lock", "unlock", "eraseDrawing", "eraseAllDrawings", "showDrawingSettings"];
            $.each(contextMenuOrder, function (key, menuItem) {
                if(contextMenu[menuItem]){
                    newContextMenu[menuItem] = contextMenu[menuItem];
                }
            });
            return newContextMenu;
        },
        getTextDimensionsFromTempNode: function (textLabelData, textLabel) {
            let tempHtmlNode = document.createElement("span");
            document.body.appendChild(tempHtmlNode);
            
            tempHtmlNode.innerHTML = textLabelData;
            tempHtmlNode.style.fontWeight = textLabel.styles.fontWeight;
            tempHtmlNode.style.fontSize = textLabel.styles.fontSize;
            tempHtmlNode.style.fontStyle = textLabel.styles.fontStyle;
            tempHtmlNode.style.padding = textLabel.styles.padding;
            tempHtmlNode.style['line-height'] = 1;
            let width = tempHtmlNode.offsetWidth;
            let height = tempHtmlNode.offsetHeight;
            document.body.removeChild(tempHtmlNode);
            
            return {width :width, height : height};
        },

        globalLockToggle: function (element, isGloballyLocked) {
            if (isGloballyLocked) {
                $(element).addClass('active');
                $($(element)[0]).attr({ 'adv-chart-tooltip': infChart.manager.getLabel('label.globalUnlock') });
                $($(element).children()[0]).attr({ class: 'icom icom-lock' })
            } else {
                $(element).removeClass('active');
                $($(element)[0]).attr({ 'adv-chart-tooltip': infChart.manager.getLabel('label.globalLock') });
                $($(element).children()[0]).attr({ class: 'icom icom-unlock' })
            }
        },
        getExtendedLineCordinates: function (line, isExtendToRight, isExtendToLeft) {
            var self = this,
                ann = self.annotation,
                options = ann.options,
                chart = ann.chart,
                xAxis = chart.xAxis[options.xAxis],
                yAxis = chart.yAxis[options.yAxis];

            var lineFirstX = parseFloat(line[1]),
                lineFirstY = parseFloat(line[2]),
                lineSecondX = parseFloat(line[4]),
                lineSecondY = parseFloat(line[5]);
            //solving a linear equation of the  form y = mx + c
            var m = (lineSecondY - lineFirstY) / (lineSecondX - lineFirstX),
                c = lineFirstY - m * lineFirstX,
                plotLeft = chart.plotLeft,
                plotRight = plotLeft + chart.plotWidth,
                plotTop = chart.plotTop,
                plotBottom = plotTop + chart.plotHeight,
                rightX, rightY, leftX, leftY;

            if (isExtendToRight) {
                if (lineSecondX > lineFirstX) {
                    rightX = plotRight - xAxis.toPixels(options.xValue);
                    rightY = m * (rightX) + c;
                } else if (lineSecondX == lineFirstX) {
                    rightX = lineFirstX;
                    if (lineSecondY < lineFirstY) {
                        rightY = plotTop - yAxis.toPixels(options.yValue);
                    } else if (lineSecondY > lineFirstY){
                        rightY = plotBottom - yAxis.toPixels(options.yValue);
                    } else {
                        rightY = lineSecondY;
                    }
                } else {
                    rightX = plotLeft - xAxis.toPixels(options.xValue);
                    rightY = m * (rightX) + c;
                }
            }

            if (isExtendToLeft) {
                if (lineSecondX > lineFirstX) {
                    leftX = plotLeft - xAxis.toPixels(options.xValue);
                    leftY = m * (leftX) + c;
                } else if (lineSecondX == lineFirstX) {
                    leftX = lineFirstX;
                    if (lineSecondY > lineFirstY) {
                        leftY = plotTop - yAxis.toPixels(options.yValue);
                    } else if (lineSecondY < lineFirstY) {
                        leftY = plotBottom - yAxis.toPixels(options.yValue);
                    } else {
                        leftY = lineSecondY;
                    }
                } else {
                    leftX = plotRight - xAxis.toPixels(options.xValue);
                    leftY = m * (leftX) + c;
                }
            }

            return {lineRightX: rightX, lineRightY: rightY, lineLeftX: leftX, lineLeftY: leftY}
        },
        drawArrowHead : function (line, isStartPoint, isEndPoint){
            pathArray = line.split(' ');
            var k = Math.sqrt(2)
            var arrowHeadLength = 10*k 
            var startArrowHead, endArrowHead;
            if (isStartPoint){
                let x0, y0, x1, y1, x2, y2, x3, y3;
                x0 = pathArray[1],
                y0 = pathArray[2],
                x1 = pathArray[4],
                y1 = pathArray[5];
        
                if(parseFloat(x1) > parseFloat(x0) && parseFloat(y1) < parseFloat(y0)){
                    let tanTeta = (y1-y0)/(x1-x0);
                    let radAngle = Math.atan(tanTeta);
                    let pi = Math.PI;
                    let beta = 45 * (pi/180);
                    x2 = arrowHeadLength * Math.sin(beta - radAngle) + parseFloat(x0);
                    y2 = arrowHeadLength * Math.cos(beta - radAngle) + parseFloat(y0);
        
                    x3 = arrowHeadLength * Math.cos(beta - radAngle) + parseFloat(x0);
                    y3 = parseFloat(y0) - arrowHeadLength * Math.sin(beta - radAngle);
                } else if (parseFloat(x1) < parseFloat(x0) && parseFloat(y1) < parseFloat(y0)){
                    let tanTeta = (y1-y0)/(x1-x0);
                    let radAngle = Math.atan(tanTeta);
                    let pi = Math.PI;
                    let beta = 45 * (pi/180);
                    x2 = parseFloat(x0) - arrowHeadLength * Math.sin(beta - radAngle);
                    y2 = parseFloat(y0) - arrowHeadLength * Math.cos(beta - radAngle);
        
                    x3 = parseFloat(x0) - arrowHeadLength * Math.cos(beta - radAngle);
                    y3 = parseFloat(y0) + arrowHeadLength * Math.sin(beta - radAngle);
                } else if (parseFloat(x1) > parseFloat(x0) && parseFloat(y1) > parseFloat(y0)){
                    let tanTeta = (y1-y0)/(x1-x0);
                    let radAngle = Math.atan(tanTeta);
                    let pi = Math.PI;
                    let beta = 45 * (pi/180);
                    x2 = parseFloat(x0) + arrowHeadLength * Math.cos(beta - radAngle);
                    y2 = parseFloat(y0) - arrowHeadLength * Math.sin(beta - radAngle);
        
                    x3 = parseFloat(x0) + arrowHeadLength * Math.sin(beta - radAngle);
                    y3 = parseFloat(y0) + arrowHeadLength * Math.cos(beta - radAngle);
                } else if (parseFloat(x1) < parseFloat(x0) && parseFloat(y1) > parseFloat(y0)){
                    let tanTeta = (y1-y0)/(x1-x0);
                    let radAngle = Math.atan(tanTeta);
                    let pi = Math.PI;
                    let beta = 45 * (pi/180);
                    x2 = parseFloat(x0) - arrowHeadLength * Math.cos(beta - radAngle);
                    y2 = parseFloat(y0) + arrowHeadLength * Math.sin(beta - radAngle);
        
                    x3 = parseFloat(x0) - arrowHeadLength * Math.sin(beta - radAngle);
                    y3 = parseFloat(y0) - arrowHeadLength * Math.cos(beta - radAngle);
                } else if(parseFloat(x1) == parseFloat(x0) && parseFloat(y1) < parseFloat(y0)){
                    let pi = Math.PI;
                    let beta = 45 * (pi/180);
                    let lenArrow = Math.cos(beta)
                    x2 = parseFloat(x0) - arrowHeadLength * lenArrow;
                    y2 = parseFloat(y0) - arrowHeadLength * lenArrow;
        
                    x3 = parseFloat(x0) + arrowHeadLength * lenArrow;
                    y3 = parseFloat(y0) - arrowHeadLength * lenArrow;
                } else if(parseFloat(x1) == parseFloat(x0) && parseFloat(y1) > parseFloat(y0)){
                    let pi = Math.PI;
                    let beta = 45 * (pi/180);
                    let lenArrow = Math.cos(beta)
                    x2 = parseFloat(x0) - arrowHeadLength * lenArrow;
                    y2 = parseFloat(y0) + parseFloat(arrowHeadLength * lenArrow);
        
                    x3 = parseFloat(x0) + arrowHeadLength * lenArrow;
                    y3 = parseFloat(y0) + arrowHeadLength * lenArrow;
                }  else if(parseFloat(x1) < parseFloat(x0) && parseFloat(y1) == parseFloat(y0)){
                    let pi = Math.PI;
                    let beta = 45 * (pi/180);
                    let lenArrow = Math.cos(beta)
                    x2 = parseFloat(x0) - arrowHeadLength * lenArrow;
                    y2 = parseFloat(y0) + arrowHeadLength * lenArrow;
        
                    x3 = parseFloat(x0) - arrowHeadLength * lenArrow;
                    y3 = parseFloat(y0) - arrowHeadLength * lenArrow;
                }  else if(parseFloat(x1) > parseFloat(x0) && parseFloat(y1) == parseFloat(y0)){
                    let pi = Math.PI;
                    let beta = 45 * (pi/180);
                    let lenArrow = Math.cos(beta)
                    x2 = parseFloat(x0) + arrowHeadLength * lenArrow;
                    y2 = parseFloat(y0) + arrowHeadLength * lenArrow;
        
                    x3 = parseFloat(x0) + arrowHeadLength * lenArrow;
                    y3 = parseFloat(y0) - arrowHeadLength * lenArrow;
                } 
                startArrowHead = ['M', x2, y2, 'L', x0, y0, 'L', x3, y3];    
            } 
        
            if(isEndPoint) {
                let x0, y0, x1, y1, x2, y2, x3, y3;
                n = pathArray.length-1,
                x0 = pathArray[n-4],
                y0 = pathArray[n-3],
                x1 = pathArray[n-1],
                y1 = pathArray[n];
                        
                if (x0 === x1 && y0 === y1){
                    x0 = pathArray[n-7];
                    y0 = pathArray[n-6];
                }
        
                if(parseFloat(x1) < parseFloat(x0) && parseFloat(y1) < parseFloat(y0)){
                    let tanTeta = (y1-y0)/(x1-x0);
                    let radAngle = Math.atan(tanTeta);
                    let pi = Math.PI;
                    let beta = 45 * (pi/180);
                    x2 = arrowHeadLength * Math.sin(beta - radAngle) + parseFloat(x1);
                    y2 = arrowHeadLength * Math.cos(beta - radAngle) + parseFloat(y1);
        
                    x3 = arrowHeadLength * Math.cos(beta - radAngle) + parseFloat(x1);
                    y3 = parseFloat(y1) - arrowHeadLength * Math.sin(beta - radAngle);
                } else if (parseFloat(x1) > parseFloat(x0) && parseFloat(y1) < parseFloat(y0)){
                    let tanTeta = (y1-y0)/(x1-x0);
                    let radAngle = Math.atan(tanTeta);
                    let pi = Math.PI;
                    let beta = 45 * (pi/180);
                    x2 = parseFloat(x1) - arrowHeadLength * Math.sin(beta - radAngle);
                    y2 = parseFloat(y1) - arrowHeadLength * Math.cos(beta - radAngle);
        
                    x3 = parseFloat(x1) - arrowHeadLength * Math.cos(beta - radAngle);
                    y3 = parseFloat(y1) + arrowHeadLength * Math.sin(beta - radAngle);
                } else if (parseFloat(x1) < parseFloat(x0) && parseFloat(y1) > parseFloat(y0)){
                    let tanTeta = (y1-y0)/(x1-x0);
                    let radAngle = Math.atan(tanTeta);
                    let pi = Math.PI;
                    let beta = 45 * (pi/180);
                    x2 = parseFloat(x1) + arrowHeadLength * Math.cos(beta - radAngle);
                    y2 = parseFloat(y1) - arrowHeadLength * Math.sin(beta - radAngle);
        
                    x3 = parseFloat(x1) + arrowHeadLength * Math.sin(beta - radAngle);
                    y3 = parseFloat(y1) + arrowHeadLength * Math.cos(beta - radAngle);
                } else if (parseFloat(x1) > parseFloat(x0) && parseFloat(y1) > parseFloat(y0)){
                    let tanTeta = (y1-y0)/(x1-x0);
                    let radAngle = Math.atan(tanTeta);
                    let pi = Math.PI;
                    let beta = 45 * (pi/180);
                    x2 = parseFloat(x1) - arrowHeadLength * Math.cos(beta - radAngle);
                    y2 = parseFloat(y1) + arrowHeadLength * Math.sin(beta - radAngle);
        
                    x3 = parseFloat(x1) - arrowHeadLength * Math.sin(beta - radAngle);
                    y3 = parseFloat(y1) - arrowHeadLength * Math.cos(beta - radAngle);
                } else if(parseFloat(x1) == parseFloat(x0) && parseFloat(y1) > parseFloat(y0)){
                    let pi = Math.PI;
                    let beta = 45 * (pi/180);
                    let lenArrow = Math.cos(beta)
                    x2 = parseFloat(x1) - arrowHeadLength * lenArrow ;
                    y2 = parseFloat(y1) - arrowHeadLength * lenArrow;
        
                    x3 = parseFloat(x1) + arrowHeadLength * lenArrow;
                    y3 = parseFloat(y1) - arrowHeadLength * lenArrow;
                } else if(parseFloat(x1) == parseFloat(x0) && parseFloat(y1) < parseFloat(y0)){
                    let pi = Math.PI;
                    let beta = 45 * (pi/180);
                    let lenArrow = Math.cos(beta)
                    x2 = parseFloat(x1) - arrowHeadLength * lenArrow ;
                    y2 = parseFloat(y1) + arrowHeadLength * lenArrow;
        
                    x3 = parseFloat(x1) + arrowHeadLength * lenArrow;
                    y3 = parseFloat(y1) + arrowHeadLength * lenArrow;
                }  else if(parseFloat(x1) > parseFloat(x0) && parseFloat(y1) == parseFloat(y0)){
                    let pi = Math.PI;
                    let beta = 45 * (pi/180);
                    let lenArrow = Math.cos(beta)
                    x2 = parseFloat(x1) - arrowHeadLength * lenArrow ;
                    y2 = parseFloat(y1) + arrowHeadLength * lenArrow;
        
                    x3 = parseFloat(x1) - arrowHeadLength * lenArrow;
                    y3 = parseFloat(y1) - arrowHeadLength * lenArrow;
                }  else if(parseFloat(x1) < parseFloat(x0) && parseFloat(y1) == parseFloat(y0)){
                    let pi = Math.PI;
                    let beta = 45 * (pi/180);
                    let lenArrow = Math.cos(beta)
                    x2 = parseFloat(x1) + arrowHeadLength * lenArrow ;
                    y2 = parseFloat(y1) + arrowHeadLength * lenArrow;
        
                    x3 = parseFloat(x1) + arrowHeadLength * lenArrow;
                    y3 = parseFloat(y1) - arrowHeadLength * lenArrow;
                } 
                endArrowHead = ['M', x2, y2, 'L', x1, y1, 'L', x3, y3];
            }
        
            return {
                startArrowHead: startArrowHead,
                endArrowHead: endArrowHead
            }
        }
    };

    infChart.drawingUtils.common.setTheme();

    infChart.drawingUtils.highLowLabels = {
        checkOverlaps: function (annotation, nearestXDataPoint) {
            var overlappingDrawings = [];
            var allDrawings = infChart.drawingsManager.getAllDrawings(infChart.drawingsManager.getChartIdFromHighchartInstance(annotation.chart));

            if(allDrawings) {
                $.each(allDrawings, function (key, drawing) {
                    if (drawing.shape === "highLowLabels" && drawing.annotation.options.nearestXDataPoint === nearestXDataPoint) {
                        overlappingDrawings.push(drawing);
                    }
                });
            }

            return overlappingDrawings.length > 1;
        },
        updateLabels: function (annotation, stockChart) {
            var allDrawings = infChart.drawingsManager.getAllDrawings(infChart.drawingsManager.getChartIdFromHighchartInstance(annotation.chart));
            var highLowLabelDrawings = [];

            if(allDrawings) {
                $.each(allDrawings, function (key, drawing) {
                    if (drawing.shape === "highLowLabels") {
                        highLowLabelDrawings.push(drawing);
                    }
                });
            }

            highLowLabelDrawings.sort((a,b) => a.annotation.options.xValue - b.annotation.options.xValue);
            var labelValue,
                currentDrawing,
                previousDrawing,
                xAxis = annotation.chart.xAxis[annotation.options.xAxis],
                calculatedLabelData = {
                    change: 0,
                    percentageChange: 0,
                    bars: 0
                };

            for(var i = 0; i < highLowLabelDrawings.length; i++) {
                currentDrawing = highLowLabelDrawings[i];

                if(annotation.options.xValue <= currentDrawing.annotation.options.xValue) {
                    if (i === 0) {
                        calculatedLabelData.bars = 0;
                        calculatedLabelData.change = 0;
                        calculatedLabelData.percentageChange = 0;
                    } else {
                        previousDrawing = highLowLabelDrawings[i - 1];
                        calculatedLabelData.bars = currentDrawing.annotation.options.dataIndex - previousDrawing.annotation.options.dataIndex;
                        calculatedLabelData.change = currentDrawing.annotation.options.price - previousDrawing.annotation.options.price;
                        calculatedLabelData.percentageChange = ((calculatedLabelData.change/ previousDrawing.annotation.options.price) * 100);
                    }

                    currentDrawing.annotation.update({
                        title: {
                            text: infChart.drawingUtils.highLowLabels.getLabelData(currentDrawing.annotation, stockChart, calculatedLabelData)
                        },
                        calculatedLabelData: calculatedLabelData
                    });

                    currentDrawing.annotation.title.attr({
                        x: xAxis.toPixels(currentDrawing.annotation.options.nearestXDataPoint) - xAxis.toPixels(currentDrawing.annotation.options.xValue) - (currentDrawing.annotation.title.width / 2)
                    });

                    if(annotation.options.xValue < currentDrawing.annotation.options.xValue) {
                        break;
                    }
                }
            }
        },
        getLabelData: function (annotation, stockChart, calculatedLabelData) {
            var formattedLabels = [];

            $.each(annotation.options.labelDataItems, function (index, labelDataItem) {
                if(labelDataItem.enabled) {
                    switch (labelDataItem.id) {
                        case 'date':
                            formattedLabels.push(infChart.drawingUtils.highLowLabels.formatDate(annotation.options.nearestXDataPoint, stockChart.interval));
                            break;
                        case 'price':
                            formattedLabels.push(infChart.StockChart.prototype.formatValue.call(stockChart, annotation.options.price, undefined, undefined, undefined, undefined, NO_OF_SPECIFIC_DECIMAL_POINTS));
                            break;
                        case 'change':
                            var change = calculatedLabelData.change === 0 ? calculatedLabelData.change.toFixed(2) : infChart.StockChart.prototype.formatValue.call(stockChart, calculatedLabelData.change, undefined, undefined, undefined, undefined, NO_OF_SPECIFIC_DECIMAL_POINTS);
                            formattedLabels.push(change);
                            break;
                        case 'pChange':
                            formattedLabels.push(calculatedLabelData.percentageChange.toFixed(2) + '%');
                            break;
                        case 'bars':
                            formattedLabels.push(calculatedLabelData.bars + ' TB');
                            break;
                    }
                }
            });

            if(!annotation.options.isHighLabel) {
                formattedLabels = formattedLabels.reverse();
            }

            return formattedLabels.join('<br>');
        },
        formatDate: function (timeInMillis, chartInterval) {
            var _getMonth = function (val) {
                var shortFormat = "";
                switch (val) {
                    case 1:
                        shortFormat = "Ja";
                        break;
                    case 2:
                        shortFormat = "Fb";
                        break;
                    case 3:
                        shortFormat = "Ma";
                        break;
                    case 4:
                        shortFormat = "Ap";
                        break;
                    case 5:
                        shortFormat = "My";
                        break;
                    case 6:
                        shortFormat = "Jn";
                        break;
                    case 7:
                        shortFormat = "Jl";
                        break;
                    case 8:
                        shortFormat = "Au";
                        break;
                    case 9:
                        shortFormat = "Se";
                        break;
                    case 10:
                        shortFormat = "Oc";
                        break;
                    case 11:
                        shortFormat = "Nv";
                        break;
                    case 12:
                        shortFormat = "Dc";
                        break;
                }
                return shortFormat;
            };

            var _replaceMonth = function (val) {
                var parts = val.split(".");
                if (parts.length > 2) {
                    val = val.replace("." + parts[1] + ".", _getMonth(parseInt(parts[1], 10)));
                } else if (parts.length > 1) {
                    val = val.replace(parts[1] + ".", _getMonth(parseInt(parts[1], 10)));
                }
                return val;
            };

            var format;
            switch (chartInterval) {
                case 'T':
                    format = '%d.%m.%y %H:%M:%S';
                    break;
                case 'M':
                    format = '%b.%y';
                    break;
                case 'Y':
                    format = '%y';
                    break;
                case 'D':
                case 'W':
                    format = '%d.%m.%y';
                    break;
                default:
                    format = '%d.%m.%y %H:%M';
                    break;

            }
            return _replaceMonth(infChart.util.formatDate(timeInMillis, format));
        }
    }

})(infChart, jQuery);

window.infChart = window.infChart || {};

const UPPER_LIMIT_ANGLE = 67.5;
const LOWER_LIMIT_ANGLE = 22.5;
const RIGHT_ANGLE = 90;
const ANGLE_180 = 180;

infChart.lineDrawing = function () {
    this.borderColor = '#959595';
    this.labelDataItems = [
        {id: "priceRange", displayName: "Price Range", enabled: false},
        {id: "barsRange", displayName: "Bars Range", enabled: false},
        {id: "angle", displayName: "Angle", enabled: false},
        {id: "duration", displayName: "Duration", enabled: false}
    ];
    this.lineText = "";
    this.lineTextChecked = true;
    this.fontSize = "12px";
    this.fillColor = "#fff";
    this.StartArrowEnabled = true, 
    this.endArrowEnabled = true,
    this.showPriceDifferentIcon = '<img style = "width : 15px; height : 15px;" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI2LjUuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxMjAwIDEyMDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDEyMDAgMTIwMDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOiNGRkZGRkY7fQo8L3N0eWxlPgo8cGF0aCBjbGFzcz0ic3QwIiBkPSJNNzk5LjUsODU3LjJsLTU4LjgtNTguOEw2NDAsODkwLjVWMzA5LjNsMTAxLjYsOTIuOWw1OC44LTU4LjhMNjAyLjcsMTYyLjVoMjM5LjYKCUM4NTcuNSwyMTUuOSw5MDYuNywyNTUsOTY1LDI1NWM3MC40LDAsMTI3LjUtNTcuMSwxMjcuNS0xMjcuNVMxMDM1LjQsMCw5NjUsMGMtNTguMywwLTEwNy40LDM5LjEtMTIyLjYsOTIuNUgxMDcuNXY3MGg0ODkuOAoJTDM5OS42LDM0My40bDU4LjgsNTguOEw1NjAsMzA5LjN2NTgxLjJsLTEwMC44LTkyLjFsLTU4LjgsNTguOGwxOTcsMTgwLjNIMzU3LjdDMzQyLjUsOTg0LjEsMjkzLjMsOTQ1LDIzNSw5NDUKCWMtNzAuNCwwLTEyNy41LDU3LjEtMTI3LjUsMTI3LjVTMTY0LjYsMTIwMCwyMzUsMTIwMGM1OC4zLDAsMTA3LjQtMzkuMSwxMjIuNi05Mi41aDczNC44di03MEg2MDIuNUw3OTkuNSw4NTcuMnogTTk2NSw3Mi43CgljMzAuMywwLDU0LjgsMjQuNSw1NC44LDU0LjhjLTAuMSwzMC4zLTI0LjYsNTQuOC01NC44LDU0LjhjLTMwLjMsMC01NC44LTI0LjUtNTQuOC01NC44UzkzNC43LDcyLjcsOTY1LDcyLjd6IE0yMzUsMTEyNy4zCgljLTMwLjMsMC01NC44LTI0LjUtNTQuOC01NC44czI0LjUtNTQuOCw1NC44LTU0LjhzNTQuOCwyNC41LDU0LjgsNTQuOFMyNjUuMywxMTI3LjMsMjM1LDExMjcuM3oiLz4KPC9zdmc+Cg==" alt="Price Range" />';
    this.showTimeDifferenceIcon = '<img style = "width : 15px; height : 15px;" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI2LjUuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxMjAwIDEyMDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDEyMDAgMTIwMDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOiNGRkZGRkY7fQo8L3N0eWxlPgo8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMTY2LjEsNTk3LjVWMTExLjdIOTYuN3Y3MjguN0M0My44LDg1NS41LDUsOTA0LjEsNSw5NjJjMCw2OS44LDU2LjYsMTI2LjQsMTI2LjQsMTI2LjRzMTI2LjQtNTYuNiwxMjYuNC0xMjYuNAoJYzAtNTcuOC0zOC44LTEwNi42LTkxLjctMTIxLjdWNjAyLjVsMTc4LjgsMTk1LjRsNTguMy01OC4zbC05MS4zLTk5LjloNTc2LjRsLTkyLjEsMTAwLjhsNTguMyw1OC4zbDE3OS40LTE5NnY0ODUuN2g2OS40VjM1OS42CgljNTMtMTUuMSw5MS43LTYzLjgsOTEuNy0xMjEuNmMwLTY5LjgtNTYuNi0xMjYuNC0xMjYuNC0xMjYuNFM5NDIuMSwxNjguMiw5NDIuMSwyMzhjMCw1Ny44LDM4LjgsMTA2LjYsOTEuNywxMjEuN3YyMzcuNmwtMTc5LjQtMTk2CglsLTU4LjMsNTguM2w5Mi4xLDEwMC44SDMxMS45bDkxLjMtOTkuOWwtNTguMy01OC4zTDE2Ni4xLDU5Ny41eiBNMTA2OC42LDI5Mi40Yy0zMCwwLTU0LjMtMjQuMy01NC4zLTU0LjMKCWMwLTI5LjksMjQuMy01NC4yLDU0LjMtNTQuM2MzMCwwLDU0LjMsMjQuMyw1NC4zLDU0LjNTMTA5OC42LDI5Mi40LDEwNjguNiwyOTIuNHogTTEzMS40LDkwNy42YzMwLDAsNTQuMywyNC4zLDU0LjMsNTQuMwoJcy0yNC4zLDU0LjMtNTQuMyw1NC4zUzc3LjEsOTkyLDc3LjEsOTYyUzEwMS40LDkwNy42LDEzMS40LDkwNy42eiIvPgo8L3N2Zz4K" alt="Bars Range" />';
    this.showDegreesIcon = '<img style = "width : 15px; height : 15px;" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI2LjUuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxMjAwIDEyMDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDEyMDAgMTIwMDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOiNGRkZGRkY7fQo8L3N0eWxlPgo8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMTA2OS41LDkzMy42Yy01Ni4yLDAtMTAzLjgsMzctMTE5LjgsODhINjc3Yy00LjQtNzYuOS0yMS44LTE1MS42LTUxLjgtMjIyLjUKCWMtMzMuMi03OC40LTgwLjMtMTQ4LjktMTQwLjEtMjA5LjdsMjg3LjItMzMxLjhjMTQuNCw1LjcsMzAsOC45LDQ2LjQsOC45YzY5LjMsMCwxMjUuNS01Ni4yLDEyNS41LTEyNS41Uzg4OCwxNS41LDgxOC43LDE1LjUKCVM2OTMuMiw3MS43LDY5My4yLDE0MWMwLDI0LjEsNi44LDQ2LjYsMTguNiw2NS43TDQyNi41LDUzNi4ybC01MS44LDU5LjdMNi42LDEwMjEuNWwwLjEsMC4xSDV2NzloNTkyLjhINjc3aDI3NC4xCgljMTcuMSw0OC45LDYzLjcsODQsMTE4LjQsODRjNjkuMywwLDEyNS41LTU2LjIsMTI1LjUtMTI1LjVTMTEzOC44LDkzMy42LDEwNjkuNSw5MzMuNnogTTgxOC43LDg2LjljMjkuOSwwLDU0LjEsMjQuMiw1NC4xLDU0LjEKCXMtMjQuMyw1NC01NC4xLDU0cy01NC4xLTI0LjItNTQuMS01NC4xUzc4OC44LDg2LjksODE4LjcsODYuOXogTTExMS4xLDEwMjEuNmwzMjIuMS0zNzIuMkM0ODMuOSw3MDIsNTI0LDc2Mi42LDU1Mi40LDgyOS45CgljMjUuOSw2MS4xLDQxLDEyNS41LDQ1LjQsMTkxLjdMMTExLjEsMTAyMS42TDExMS4xLDEwMjEuNnogTTEwNjkuNSwxMTEzLjFjLTI5LjksMC01NC4xLTI0LjItNTQuMS01NC4xczI0LjItNTQuMSw1NC4xLTU0LjEKCXM1NC4xLDI0LjIsNTQuMSw1NC4xUzEwOTkuNCwxMTEzLjEsMTA2OS41LDExMTMuMXoiLz4KPC9zdmc+Cg==" alt="Angle" />';
    this.showDurationIcon = '<img style = "width : 15px; height : 15px;" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI3LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDEwMjQgMTAyNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOiNGRkZGRkY7fQo8L3N0eWxlPgo8ZyBpZD0iaWNvbW9vbi1pZ25vcmUiPgo8L2c+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik02MDguMSwyNjUuOXYzMjIuOWMwLDYuNy0yLjEsMTIuMy02LjUsMTYuNmMtNC4zLDQuMy05LjksNi41LTE2LjYsNi41SDM1NC40Yy02LjcsMC0xMi4zLTIuMS0xNi42LTYuNQoJYy00LjMtNC4zLTYuNS05LjktNi41LTE2LjZ2LTQ2LjFjMC02LjcsMi4xLTEyLjMsNi41LTE2LjZjNC4zLTQuMyw5LjktNi41LDE2LjYtNi41aDE2MS40VjI2NmMwLTYuNywyLjEtMTIuMyw2LjUtMTYuNgoJYzQuMy00LjMsOS45LTYuNSwxNi42LTYuNUg1ODVjNi43LDAsMTIuMywyLjEsMTYuNiw2LjVDNjA1LjksMjUzLjcsNjA4LjEsMjU5LjMsNjA4LjEsMjY1LjlMNjA4LjEsMjY1Ljl6IE04NzIuOCw3MjEuMQoJYzM3LjMtNjMuOSw1Ni0xMzMuNiw1Ni0yMDkuMXMtMTguNy0xNDUuMi01Ni0yMDkuMUM4MzUuNSwyMzksNzg1LDE4OC41LDcyMS4xLDE1MS4ycy0xMzMuNi01Ni0yMDkuMS01NgoJYy03NS41LDAtMTQ1LjIsMTguNy0yMDkuMSw1NlMxODguNSwyMzksMTUxLjIsMzAyLjljLTM3LjMsNjMuOS01NiwxMzMuNi01NiwyMDkuMXMxOC43LDE0NS4yLDU2LDIwOS4xUzIzOSw4MzUuNSwzMDIuOSw4NzIuOAoJczEzMy42LDU2LDIwOS4xLDU2czE0NS4yLTE4LjcsMjA5LjEtNTZDNzg1LDgzNS41LDgzNS41LDc4NSw4NzIuOCw3MjEuMXogTTk1MS42LDI1Ny41YzQ1LjQsNzcuNiw2OC4xLDE2Mi40LDY4LjEsMjU0LjUKCVM5OTcsNjg5LjIsOTUxLjYsNzY3LjFjLTQ1LjQsNzcuNi0xMDcuMSwxMzkuMS0xODUuMSwxODQuNUM2ODksOTk3LDYwNC4yLDEwMTkuNyw1MTIsMTAxOS43UzMzNC44LDk5NywyNTYuOSw5NTEuNgoJYy03Ny43LTQ1LjQtMTM5LjEtMTA2LjgtMTg0LjUtMTg0LjVDMjcsNjg5LjIsNC4zLDYwNC4xLDQuMyw1MTJTMjcsMzM1LDcyLjQsMjU3LjVjNDUuNC03OCwxMDYuOC0xMzkuNywxODQuNS0xODUuMQoJQzMzNC44LDI3LDQxOS45LDQuMyw1MTIsNC4zUzY4OSwyNyw3NjYuNSw3Mi40Qzg0NC41LDExNy44LDkwNi4yLDE3OS41LDk1MS42LDI1Ny41eiIvPgo8L3N2Zz4K" alt="Duration" />';
    infChart.drawingObject.apply(this, arguments);
};

infChart.lineDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.lineDrawing.prototype.additionalDrawingsFunction = function () {
    var ann = this.annotation;
    var options = ann.options;
    var chart = ann.chart;
    var additionalDrawingsArr = this.additionalDrawings;
    var xAxis = chart.xAxis[options.xAxis];
    var nearestXValue = infChart.math.findNearestXDataPoint(chart, options.xValue, undefined, true, true);
    var newX = xAxis.toPixels(nearestXValue) - xAxis.toPixels(options.xValue);
    var basicText = "";
    additionalDrawingsArr.labels = {};
    additionalDrawingsArr.lines = [];
    additionalDrawingsArr.lineArrow = [];

    $.each(this.labelDataItems, function (index, labelDataItem) {
        if (labelDataItem.enabled) {
            basicText += (basicText !== "" ? '<br>' : '') + "--";
        }
    });

    var dashArrayValues = infChart.drawingUtils.common.settings.getStrokeDashArray(options.shape.params.dashstyle, options.shape.params['stroke-width']);

    drawingLineAttr = {
        'stroke-width' : options.shape.params['stroke-width'],
        'dash-style': options.shape.params.dashstyle,
        'fill-color': options.shape.params.fill,
        'stroke' : options.shape.params.stroke,
        'fill-opacity': options.shape.params['stroke-opacity'],
        'stroke-dasharray': dashArrayValues,
        'stroke-opacity': options.shape.params['stroke-opacity'],
        'cursor': 'move'
    }

    var { 'dash-style': _, 'stroke-dasharray': __, ...newDrawingLineAttr } = drawingLineAttr;

    additionalDrawingsArr.labels["lineData"] = this.getLabel(basicText, 0, 0).hide();
    additionalDrawingsArr.labels["lineText"] = this.getTextLabel(this.lineText, 0, 0).hide();
    additionalDrawingsArr.lines["left"] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingLineAttr).add(ann.group);
    additionalDrawingsArr.lines["right"] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingLineAttr).add(ann.group);
    additionalDrawingsArr.lineArrow["startPointHead"]= chart.renderer.path(['M', 0, 0, 'L', 0, 0,'L', 0, 0]).attr(newDrawingLineAttr).add(ann.group);
    additionalDrawingsArr.lineArrow["endPointHead"]= chart.renderer.path(['M', 0, 0, 'L', 0, 0,'L', 0, 0]).attr(newDrawingLineAttr).add(ann.group);

    ann.selectionMarker = [];
    infChart.drawingUtils.common.addSelectionMarker.call(this, ann, newX, 0);
    $.each(ann.selectionMarker, function (index, selectionMarker) {
        if (selectionMarker) {
            selectionMarker.show();
        }
    });

    if(!options.settings.isStartPoint){
        additionalDrawingsArr.lineArrow["startPointHead"].hide();
    }
    if(!options.settings.isEndPoint){
        additionalDrawingsArr.lineArrow["endPointHead"].hide();
    }

    if(!options.settings.isExtendLeft){
        additionalDrawingsArr.lines["left"].hide();
    }
    if(!options.settings.isExtendRight){
        additionalDrawingsArr.lines["right"].hide();
    }
};


infChart.lineDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    return {
        shape: 'line',
        settings: {
            lineColor: annotation.options.shape.params.stroke ? infChart.themeManager.getDrawingsBorderColor(annotation.options.shape.params.stroke, 'line') : annotation.options.settings.lineColor,
            lineOpacity: annotation.options.settings.lineOpacity,
            lineWidth: annotation.options.shape.params['stroke-width'] ? annotation.options.shape.params['stroke-width'] : annotation.options.settings.lineWidth,
            lineStyle: annotation.options.shape.params.dashstyle ? annotation.options.shape.params.dashstyle : annotation.options.settings.linestyle,
            isExtendLeft: annotation.options.settings.isExtendLeft,
            isExtendRight: annotation.options.settings.isExtendRight,
            isStartPoint: annotation.options.settings.isStartPoint,
            isEndPoint: annotation.options.settings.isEndPoint,
            textColor: annotation.options.settings.textColor,
            textOpacity: annotation.options.settings.textOpacity,
            lineTextChecked: annotation.options.settings.lineTextChecked,
            textFontSize: annotation.options.settings.textFontSize,
            textFontWeight: annotation.options.settings.textFontWeight,
            textFontStyle: annotation.options.settings.textFontStyle,
            textDecoration: annotation.options.settings.textDecoration
        },
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        calculatedLabelData: annotation.options.calculatedLabelData,
        isLocked : annotation.options.isLocked,
        lineText: annotation.options.lineText,
        labelDataItems: annotation.options.labelDataItems
        };
};

infChart.lineDrawing.prototype.getConfigToCopy = function () {
    var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(this.annotation.chart);
    var chartInstance = infChart.manager.getChart(stockChartId);
    var xAxis = chartInstance.getMainXAxis();
    var yAxis = chartInstance.getMainYAxis();
    var shapeTheme = infChart.drawingUtils.common.theme["line"];
    var copyDistance = shapeTheme && shapeTheme.copyDistance;
    var defaultCopyDistance = infChart.drawingUtils.common.theme.defaultCopyDistance;
    var copyDistanceX = (copyDistance && (copyDistance.x || copyDistance.x == 0)) ? copyDistance.x : defaultCopyDistance;
    var copyDistanceY = (copyDistance && (copyDistance.y || copyDistance.y == 0)) ? copyDistance.y : defaultCopyDistance;
    var properties = this.getConfig();
    var angle = infChart.drawingUtils.common.getAngle({
        x: xAxis.toPixels(properties.xValue),
        y: yAxis.toPixels(properties.yValue)
    }, { x: xAxis.toPixels(properties.xValueEnd), y: yAxis.toPixels(properties.yValueEnd) });
    var near45 = Math.abs(angle - 45) < 5;

    properties.xValue = xAxis.toValue(xAxis.toPixels(properties.xValue) + copyDistanceX);
    properties.xValueEnd = xAxis.toValue(xAxis.toPixels(properties.xValueEnd) + copyDistanceX);

    if (!near45) {
        properties.yValue = yAxis.toValue(yAxis.toPixels(properties.yValue) + copyDistanceY);
        properties.yValueEnd = yAxis.toValue(yAxis.toPixels(properties.yValueEnd) + copyDistanceY);
    }
    return properties;
};

infChart.lineDrawing.prototype.getOptions = function (properties, chart) {
    var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, properties.xValue, undefined, true, true);
    var theme = infChart.drawingUtils.common.getTheme();
    var shapeTheme = theme["trendLine"];
    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        nearestXValue: nearestDataForXValue.xData,
        nearestXValueIndex: nearestDataForXValue.dataIndex,
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0],
                dashstyle: 'solid',
                'stroke-width': infChart.drawingUtils.common.baseLineWidth
            }
        },
        settings: {},
        labelDataItems: properties.labelDataItems ? properties.labelDataItems : this.labelDataItems,
    };
    if(properties.settings) {
        options.settings = properties.settings;

        if (properties.settings.lineColor) {
            options.shape.params.stroke = properties.settings.lineColor;
        }
        if (properties.settings.lineOpacity) {
            options.shape.params['stroke-opacity'] = properties.settings.lineOpacity;
        }

        if (properties.settings.lineWidth) {
            options.shape.params['stroke-width'] = properties.settings.lineWidth;
        }

        if (properties.settings.lineStyle) {
            options.shape.params.dashstyle = properties.settings.lineStyle;
        }
    } else {
        options.settings.lineColor = infChart.drawingUtils.common.baseBorderColor;
        options.settings.lineOpacity = infChart.drawingUtils.common.baseFillOpacity;
        options.settings.lineStyle = 'solid';
        options.settings.lineWidth = infChart.drawingUtils.common.baseLineWidth;
        options.settings.isExtendRight = false;
        options.settings.isExtendLeft = false;
        options.settings.isStartPoint = false;
        options.settings.isEndPoint = false;
        options.settings.textColor = shapeTheme.label.fontColor;
        options.settings.textOpacity = shapeTheme.label.fontOpacity;
        options.settings.lineTextChecked = this.lineTextChecked;
        options.settings.textFontSize = shapeTheme.label.fontSize;
        options.settings.textFontWeight = shapeTheme.label.fontWeight;
        options.settings.textFontStyle = shapeTheme.label.fontStyle;
        options.settings.textDecoration = shapeTheme.label.textDecoration;

    }

    if(properties.lineText){
        options.lineText = properties.lineText;
    } else {
        options.lineText = this.lineText;
    }

    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;

        var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, properties.xValueEnd, undefined, true, true);
        options.nearestXValueEnd = nearestDataForXValueEnd.xData;
        options.nearestXValueEndIndex = nearestDataForXValueEnd.dataIndex;
    }
    if(properties.calculatedLabelData) {
        options.calculatedLabelData = properties.calculatedLabelData;
    }

    options.validateTranslationFn = this.validateTranslation;
    options.isRealTimeTranslation = true;

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.lineDrawing.prototype.getQuickSettingsPopup = function () {
    return infChart.drawingUtils.common.getLineQuickSettings(infChart.drawingUtils.common.baseBorderColor, infChart.drawingUtils.common.baseFillOpacity);
};

infChart.lineDrawing.prototype.validateTranslation = function (newXValue) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        seriesData = chart.series[0].xData,
        dataMin = seriesData[0],
        xVal = options.xValue,
        xValEnd = options.xValueEnd,
        newXValueEnd = xValEnd - xVal + newXValue,
        totalPoints = infChart.drawingsManager.getTotalPoints(chart),
        dataMax = totalPoints[totalPoints.length - 1];

    return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax);
};

infChart.lineDrawing.prototype.scale = function (isCalculateNewValueForScale) {
    var ann = this.annotation,
        chart = ann.chart,
        additionalDrawingsArr = this.additionalDrawings,
        options = ann.options,
        line = ['M', 0, 0, 'L'],
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        nearestDataPointForXValue, nearestDataPointForXValueEnd;
        var newX, newXEnd;
        var yEnd = yAxis.toPixels(options.yValueEnd) - yAxis.toPixels(options.yValue);

    if (isCalculateNewValueForScale) {
        nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
        nearestDataPointForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);
        newX = xAxis.toPixels(nearestDataPointForXValue.xData) - xAxis.toPixels(ann.options.xValue);
        newXEnd = xAxis.toPixels(nearestDataPointForXValueEnd.xData) - xAxis.toPixels(ann.options.xValue);
    } else {
        newX = xAxis.toPixels(options.nearestXValue) - xAxis.toPixels(ann.options.xValue);
        newXEnd = xAxis.toPixels(options.nearestXValueEnd) - xAxis.toPixels(ann.options.xValue);
    }
    
    line[1] = newX;
    line[4] = newXEnd;
    line[5] = (!isNaN(yEnd) && yEnd) || 0;

    if (isCalculateNewValueForScale) {
        ann.update({
            nearestXValue: nearestDataPointForXValue.xData,
            nearestXValueIndex: nearestDataPointForXValue.dataIndex,
            nearestXValueEnd: nearestDataPointForXValueEnd.xData,
            nearestXValueEndIndex: nearestDataPointForXValueEnd.dataIndex,
            shape: {
                params: {
                    d: line
                }
            }
        });
        this.calculateAndUpdateLabel({
            nearestXValue: nearestDataPointForXValue.xData,
            nearestXValueIndex: nearestDataPointForXValue.dataIndex,
            nearestXValueEnd: nearestDataPointForXValueEnd.xData,
            nearestXValueEndIndex: nearestDataPointForXValueEnd.dataIndex,
            yValueEnd: options.yValueEnd
        });
    } else {
        ann.update({
            shape: {
                params: {
                    d: line
                }
            }
        });
        this.calculateAndUpdateLabel({
            nearestXValue: options.nearestXValue,
            nearestXValueIndex: options.nearestXValueIndex,
            nearestXValueEnd: options.nearestXValueEnd,
            nearestXValueEndIndex: options.nearestXValueEndIndex,
            yValueEnd: options.yValueEnd
        });
    }

    this.updateLineWithArrowHeadsAndPoints();
    this.calculateAndUpdateTextLabel();
    self.resetDragSUpporters();
};

infChart.lineDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation,
        chart = ann.chart,
         options = ann.options,
        width,
        height,
        pathDefinition,
        xAxis = chart.xAxis[options.xAxis],
        nearestXValue = infChart.math.findNearestXDataPoint(chart, options.xValue, undefined, true, true),
        nearestXValueEnd = infChart.math.findNearestXDataPoint(chart, options.xValueEnd, undefined, true, true),
        newX = xAxis.toPixels(nearestXValue) - xAxis.toPixels(ann.options.xValue),
        newXEnd = xAxis.toPixels(nearestXValueEnd) - xAxis.toPixels(ann.options.xValue);

    ann.events.deselect.call(ann);
    ann.selectionMarker = [];
    pathDefinition = ann.shape.d.split(' ');

    width = parseFloat(pathDefinition[4]);
    height = parseFloat(pathDefinition[5]);

    if (!isNaN(width) && !isNaN(height)) {
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, newX, 0, this.stepFunction, this.stop, true);
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, newXEnd, height, this.stepFunction, this.stop, false);
    }
    console.error("selectAndBindResize");
};

infChart.lineDrawing.prototype.step = function (e, isStartPoint) {
    var ann = this.annotation,
        points = infChart.drawingUtils.common.calculateInitialPoints(e, ann, isStartPoint, 0, 0),
        options = ann.options,
        chart = ann.chart,
        additionalDrawingsArr = this.additionalDrawings,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        xValueEnd = xAxis.toValue(xAxis.toPixels(options.xValue) + points.dx),
        yValueEnd = yAxis.toValue(yAxis.toPixels(options.yValue) + points.dy),
        nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true),
        nearestDataPointForXValueEnd = infChart.math.findNearestDataPoint(chart, xValueEnd, undefined, true, true),
        newX = xAxis.toPixels(nearestDataPointForXValue.xData) - xAxis.toPixels(ann.options.xValue),
        newXEnd = xAxis.toPixels(nearestDataPointForXValueEnd.xData) - xAxis.toPixels(ann.options.xValue),
        newYEnd = parseInt(points.dy, 10),
        newY = 0;

    if (infChart.manager.shiftKeyPressed) {
        var cordinateData = this.snapLine(ann, newX, newY, newXEnd, newYEnd, xValueEnd, yValueEnd, nearestDataPointForXValue, nearestDataPointForXValueEnd, points, isStartPoint);
        newX = cordinateData.newX;
        newY = cordinateData.newY;
        newXEnd = cordinateData.newXEnd;
        newYEnd = cordinateData.newYEnd;
        nearestDataPointForXValue = cordinateData.nearestDataPointForXValue;
        nearestDataPointForXValueEnd = cordinateData.nearestDataPointForXValueEnd;
        yValueEnd = cordinateData.yValueEnd;
    } 

    var line = ["M", newX, newY, 'L', parseInt(newXEnd, 10), newYEnd ];
    ann.shape.attr({
        d: line
    });


    this.calculateAndUpdateLabel({
        nearestXValue: nearestDataPointForXValue.xData,
        nearestXValueIndex: nearestDataPointForXValue.dataIndex,
        nearestXValueEnd: nearestDataPointForXValueEnd.xData,
        nearestXValueEndIndex: nearestDataPointForXValueEnd.dataIndex,
        yValueEnd: yValueEnd
    });

    this.updateLineWithArrowHeadsAndPoints(line, ann, additionalDrawingsArr);
    this.calculateAndUpdateTextLabel();

    return {line: line, nearestDataPointForXValue: nearestDataPointForXValue, nearestDataPointForXValueEnd: nearestDataPointForXValueEnd};
};

infChart.lineDrawing.prototype.snapLine = function (ann, newX, newY, newXEnd, newYEnd, xValueEnd, yValueEnd, nearestDataPointForXValue, nearestDataPointForXValueEnd,points, isStartPoint) {
    var xValue, yValue,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis];

    var angle = (-1) * infChart.drawingUtils.common.getAngle(
        {
            x: parseInt(newX, 10),
            y: yAxis.toPixels(ann.options.yValue)
        },
        {
            x: parseInt(parseInt(newXEnd, 10), 10),
            y: yAxis.toPixels(yValueEnd)
        });

    var convertedAngle = Math.abs(angle) > RIGHT_ANGLE ? ANGLE_180 - Math.abs(angle) : Math.abs(angle);
    
    if (convertedAngle < LOWER_LIMIT_ANGLE && convertedAngle > 0) {
        if (isStartPoint) {
            yValue = (yAxis.toValue(newYEnd + yAxis.toPixels(options.yValue)));
            ann.update({
                yValue: yValue
            }); 
        }
        newYEnd = 0;
        yValueEnd = ann.options.yValue;
    }

    if (convertedAngle > UPPER_LIMIT_ANGLE && convertedAngle < RIGHT_ANGLE) {
        if (isStartPoint) {
            newX = newXEnd;
            nearestDataPointForXValue = nearestDataPointForXValueEnd;
        } else {
            newXEnd = 0
            nearestDataPointForXValueEnd = nearestDataPointForXValue;
        }
    }

    if (convertedAngle < UPPER_LIMIT_ANGLE && convertedAngle > LOWER_LIMIT_ANGLE) {
        var radians = convertedAngle * Math.PI / ANGLE_180;
        var convertedLineXlength = (points.dx * Math.cos(45 - radians)) / (Math.cos(radians) * Math.sqrt(2)); //length of 45 degree line in x axis
        var newYLength = angle < 0 && angle > -ANGLE_180 ? (-1) * Math.abs(convertedLineXlength) : Math.abs(convertedLineXlength);
        if (isStartPoint) {
            xValue = xAxis.toValue(points.dx - convertedLineXlength + xAxis.toPixels(options.xValue));
            yValue = (yAxis.toValue((newYLength + points.dy) + yAxis.toPixels(options.yValue)));

            ann.update({
                xValue: xValue,
                yValue: yValue
            });
            nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, xValue, undefined, true, true);
            newX = xAxis.toPixels(nearestDataPointForXValue.xData) - xAxis.toPixels(xValue);
            newY = angle < 0 && angle > (-1) * RIGHT_ANGLE || angle < ANGLE_180 && angle > RIGHT_ANGLE ? newX : (-1) * newX;

        }
        xValueEnd = xAxis.toValue(convertedLineXlength + xAxis.toPixels(ann.options.xValue) );
        nearestDataPointForXValueEnd = infChart.math.findNearestDataPoint(chart, xValueEnd, undefined, true, true);            
        newXEnd = xAxis.toPixels(nearestDataPointForXValueEnd.xData) - xAxis.toPixels(ann.options.xValue);
        newYEnd = angle < 0 && angle > (-1) * RIGHT_ANGLE || angle < ANGLE_180 && angle > RIGHT_ANGLE ? parseInt(newXEnd, 10) : (-1) * parseInt(newXEnd, 10);
        yValueEnd = yAxis.toValue(newYEnd + yAxis.toPixels(ann.options.yValue));
    }
    return {
        newX: newX, 
        newY: newY,
        newXEnd: newXEnd, newYEnd: newYEnd,
        nearestDataPointForXValue: nearestDataPointForXValue,
        nearestDataPointForXValueEnd: nearestDataPointForXValueEnd,
        yValueEnd: yValueEnd
    };
}


infChart.lineDrawing.prototype.stop = function (e, isStartPoint) {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        additionalDrawingsArr = this.additionalDrawings,
        lineData = this.stepFunction(e, isStartPoint),
        line = lineData.line,
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        x = xAxis.toValue(line[4] + xAxis.toPixels(ann.options.xValue)),
        y = yAxis.toValue(line[5] + yAxis.toPixels(ann.options.yValue)),
        startY = yAxis.toValue(line[2] + yAxis.toPixels(ann.options.yValue));

    line[1] = 0;
    line[4] = xAxis.toPixels(lineData.nearestDataPointForXValueEnd.xData) - xAxis.toPixels(lineData.nearestDataPointForXValue.xData);
    line[5] = line[5] - line [2];
    line[2] = 0;

    ann.update({
        xValue: lineData.nearestDataPointForXValue.xData,
        xValueEnd: lineData.nearestDataPointForXValueEnd.xData,
        yValue: startY,
        yValueEnd: y,
        nearestXValue: lineData.nearestDataPointForXValue.xData,
        nearestXValueIndex: lineData.nearestDataPointForXValue.dataIndex,
        nearestXValueEnd: lineData.nearestDataPointForXValueEnd.xData,
        nearestXValueEndIndex: lineData.nearestDataPointForXValueEnd.dataIndex,
        shape: {
            params: {
                d: line
            }
        }
    });

    this.updateLineWithArrowHeadsAndPoints();
    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, y);
    self.resetDragSUpporters();

    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.lineDrawing.prototype.translate = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        additionalDrawingsArr = this.additionalDrawings,
        line = ann.shape.d.split(' '),
        xAxis = chart.xAxis[options.xAxis],
        nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true),
        nearestDataPointForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);

    var xValueDiff = xAxis.toPixels(nearestDataPointForXValueEnd.xData) - xAxis.toPixels(nearestDataPointForXValue.xData);
    var newLine = ["M", 0, 0, 'L', xValueDiff, line[5]];

    ann.update({
        xValue: nearestDataPointForXValue.xData,
        xValueEnd: nearestDataPointForXValueEnd.xData,
        nearestXValue: nearestDataPointForXValue.xData,
        nearestXValueIndex: nearestDataPointForXValue.dataIndex,
        nearestXValueEnd: nearestDataPointForXValueEnd.xData,
        nearestXValueEndIndex: nearestDataPointForXValueEnd.dataIndex,
        shape: {
            params: {
                d: newLine
            }
        }
    });

    this.calculateAndUpdateLabel({
        nearestXValue: nearestDataPointForXValue.xData,
        nearestXValueIndex: nearestDataPointForXValue.dataIndex,
        nearestXValueEnd: nearestDataPointForXValueEnd.xData,
        nearestXValueEndIndex: nearestDataPointForXValueEnd.dataIndex,
        yValueEnd: options.yValueEnd
    });

    this.calculateAndUpdateTextLabel();
    var newXEnd = xAxis.toPixels(options.xValueEnd) - xAxis.toPixels(options.xValue);
    // Update new position of the selection marker when scaling the chart while line is selected
    if (ann.selectionMarker && ann.selectionMarker.length > 1) {
        ann.selectionMarker[0].attr({
            x: 0
        });  
        ann.selectionMarker[1].attr({
            x: newXEnd
        });
    } 

    this.updateLineWithArrowHeadsAndPoints();
    self.selectAndBindResize();
    chart.selectedAnnotation = ann;  
    self.resetDragSUpporters();
}

infChart.lineDrawing.prototype.translateEnd = function () {
    var ann = this.annotation;
    this.selectAndBindResize();
    ann.chart.selectedAnnotation = ann; 
    infChart.drawingUtils.common.onPropertyChange.call(this);
};


infChart.lineDrawing.prototype.getSettingsPopup = function () {
    return infChart.drawingUtils.common.getLineSettings('Line', infChart.drawingUtils.common.baseBorderColor, this.labelDataItems, true, this.fontSize, this.fontColor, infChart.drawingUtils.common.baseFillOpacity, this.StartArrowEnabled, this.endArrowEnabled);
};


/**
 * Change the color of the annotation from the given params
 * IMPORTANT :: this method is used in commands.wrappers to set undo/redo actions
 * @param {object} labelItemId changed label item id
 * @param {string} value
 * @param {boolean|undefined} isPropertyChange property change
 */
 infChart.lineDrawing.prototype.onLabelItemsChange = function (labelItemId, value, isPropertyChange) {
    var self = this;
    var ann = self.annotation;
    var options = ann.options;

    for(var i = 0; i < options.labelDataItems.length; i++) {
        if(options.labelDataItems[i].id === labelItemId) {
            options.labelDataItems[i].enabled = value;
            break;
        }
    }

    self.scale.call(self);

    isPropertyChange && self.onPropertyChange();

    if (self.settingsPopup) {
        self.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.lineDrawing.prototype.bindSettingsEvents = function () {
    var self = this;

    var callBackFnLineSettingsEvents = {
        onLineColorChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.lineColor, {
            isUpdateAnnotationStyles: true,
            settingsItem: 'line',
            otherLineElements: [
                self.additionalDrawings.lines["left"],
                self.additionalDrawings.lines["right"],
                self.additionalDrawings.lineArrow["startPointHead"],
                self.additionalDrawings.lineArrow["endPointHead"]
            ]
        }),
        onLineWidthChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.lineWidth, {
            isUpdateAnnotationStyles: true,
            settingsItem: 'lineWidth',
            otherLineElements: [
                self.additionalDrawings.lines["left"],
                self.additionalDrawings.lines["right"],
                self.additionalDrawings.lineArrow["startPointHead"],
                self.additionalDrawings.lineArrow["endPointHead"]
            ],
            callBackFunction : function(settingsParams, isPropertyChange, strokeWidth){
                var dashArrayValues = infChart.drawingUtils.common.settings.getStrokeDashArray(self.annotation.options.shape.params.dashstyle, strokeWidth);
                if (settingsParams.otherLineElements) {
                    settingsParams.otherLineElements.forEach(function (element) {
                        if(element !== self.additionalDrawings.lineArrow["startPointHead"] && element !== self.additionalDrawings.lineArrow["endPointHead"]){
                        element.attr({
                            'stroke-dasharray': dashArrayValues
                        });
                    }
                    });
                }
            }
        }),
        onLineStyleChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.lineStyle, {
            isUpdateAnnotationStyles: true,
            settingsItem: 'lineStyle',
            otherLineElements: [
                self.additionalDrawings.lines["left"],
                self.additionalDrawings.lines["right"],
            ]
        }),
        onLineExtendToRight: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.checkBox, {
            isUpdateAnnotationStyles: false,
            settingsItem: 'isExtendRight',
            callBackFunction : function(settingsParams, isPropertyChange, value){
                self.onLineExtend.call(self, value, "right", isPropertyChange);
        },
            ctrlSelector: "[inf-ctrl=extendToRight]"
        }),

        onLineExtendToLeft: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.checkBox, {
            isUpdateAnnotationStyles: false,
            settingsItem: 'isExtendLeft',
            callBackFunction : function(settingsParams, isPropertyChange, value){
                self.onLineExtend.call(self, value, "left", isPropertyChange);
        },
            ctrlSelector: "[inf-ctrl=extendToLeft]"
        }),

        onStartArrowHeadTypeChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.value, {
            isUpdateAnnotationStyles: false,
            settingsItem: 'isStartPoint',
            callBackFunction : function(settingsParams, isPropertyChange, value){
                self.onChangeArrowHead.call(self, value, "startPointHead", isPropertyChange);
            },
            ctrlSelector: "[inf-ctrl= startArrowHeadType]"
        }),

        onEndArrowHeadTypeChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.value, {
            isUpdateAnnotationStyles: false,
            settingsItem: 'isEndPoint',
            callBackFunction : function(settingsParams, isPropertyChange, value){
                self.onChangeArrowHead.call(self, value, "endPointHead", isPropertyChange);
            },
            ctrlSelector: "[inf-ctrl= endArrowHeadType]"
        }),
        onTextColorChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.fontColor, {
            isUpdateAnnotationStyles: false,
            settingsItem: 'text',
            otherTextElements: [
                self.additionalDrawings.labels["lineText"]
            ],
            ctrlSelector: "[inf-ctrl= textColorPicker]"
        }),

        onToggleLineText: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.checkBox, {
            isUpdateAnnotationStyles: false,
            settingsItem: 'lineTextChecked',
            callBackFunction: function(settingsParams, isPropertyChange, value){
                self.onToggleLineText(value, isPropertyChange)
            },
            ctrlSelector: "[inf-ctrl=textToggle]"
        }),

        onLineTextChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.text, {
            isUpdateAnnotationStyles: false,
            settingsItem: 'lineText',
            callBackFunction: function(){
                self.calculateAndUpdateTextLabel()
            },
            ctrlSelector: "[inf-ctrl=line-text]"
        }),
        onTextSizeChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.fontSize, {
            isUpdateAnnotationStyles: false,
            settingsItem: 'textFontSize',
            otherTextElements: [
                self.additionalDrawings.labels["lineText"]
            ],
            callBackFunction: function(){
                self.calculateAndUpdateTextLabel()
            }
        }),
        onTextFontStyleChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.fontStyle, {
            isUpdateAnnotationStyles: false,
            settingsItem: 'textFontStyle',
            otherTextElements: [
                self.additionalDrawings.labels["lineText"]
            ],
            callBackFunction: function(){
                self.calculateAndUpdateTextLabel()
            }
        }),

        onTextFontWeightChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.fontStyle,{
            isUpdateAnnotationStyles: false,
            otherTextElements: [
                self.additionalDrawings.labels["lineText"]
            ],
            settingsItem: 'textFontWeight',
            callBackFunction: function(){
                self.calculateAndUpdateTextLabel()
            }
        }),

        onTextFontDecorationChange :infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.fontStyle, {
            isUpdateAnnotationStyles: false,
            settingsItem: 'textDecoration',
            otherTextElements: [
                self.additionalDrawings.labels["lineText"]
            ],
            callBackFunction: function(){
                self.calculateAndUpdateTextLabel()
            }
        }),

        onLabelItemsChange : function(labelItemId, value){
            var isPropertyChange = true;
            if (self.settingsPopup) {
                isPropertyChange = self.isSettingsPropertyChange();
            }
            self.onLabelItemsChange(labelItemId, value, isPropertyChange);
        },

        onResetToDefault : function(){
            self.updateSavedDrawingProperties(true)
        }
    }

    return infChart.structureManager.drawingTools.bindLineSettings(self.settingsPopup, callBackFnLineSettingsEvents);
};

infChart.lineDrawing.prototype.updateSettings = function (properties) {
    var styles = [];
    if (properties.settings.textFontWeight !== 'normal') {
        styles.push(properties.settings.textFontWeight);
    }
    if (properties.settings.textFontStyle !== 'normal') {
        styles.push(properties.settings.textFontStyle);
    }
    if (properties.settings.textDecoration !== 'inherit') {
        styles.push(properties.settings.textDecoration);
    }
    infChart.structureManager.drawingTools.updateLineSettings(this.settingsPopup, properties.settings, properties.labelDataItems, styles, properties.lineText);
};

/**
 * Create a label and add to the group
 * @param {String} name label text
 * @param {number} x x position
 * @param {number} y y position
 * @returns {SVGElement} the generated label
 */
 infChart.lineDrawing.prototype.getLabel = function (name, x, y) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        theme = infChart.drawingUtils.common.getTheme(),
        shapeTheme = theme["trendLine"];

    return chart.renderer.createElement('foreignObject').add(ann.group).attr({
        width: '150',
        height: '120'
    }).css(
            {
                color: shapeTheme && shapeTheme.label && shapeTheme.label.fontColor || "#ffffff !important",
                fontSize: '12px',
                cursor: 'move',
                fontWeight: '500',
                fontStyle: 'normal',
                textDecoration: 'inherit',
                backgroundColor: '#868688 !important',
                padding: '8px',
                borderRadius: '5px'
            });
};

infChart.lineDrawing.prototype.getTextLabel = function (lineText, x, y) {

    var self = this,
    ann = self.annotation,
    options = ann.options,
    chart = ann.chart,
    theme = infChart.drawingUtils.common.getTheme(),
    shapeTheme = theme["trendLine"];

    return chart.renderer.label(lineText, x, y,null, null, null, false).add(ann.group).attr({
        'zIndex': 20,
        'r': 3,
        'opacity': shapeTheme && shapeTheme.label && shapeTheme.label.opacity || 1,
        'stroke': shapeTheme && shapeTheme.label && shapeTheme.label.stroke || "#858587",
        'stroke-width': 0,
        'hAlign': 'center',
        'class': 'line-lbl',
        'padding': 5
    }).add(ann.group).css(
        {
            color: options.settings.textColor || shapeTheme && shapeTheme.label && shapeTheme.label.fontColor || '#fff',
            fontSize: options.settings.textFontSize || shapeTheme.fontSize || '12px',
            cursor: 'move',
            fontWeight: options.settings.textFontWeight ||'500',
            fontStyle: options.settings.textFontStyle ||'normal',
            textDecoration: options.settings.textDecoration || 'inherit'
        });
};

infChart.lineDrawing.prototype.beforeDestroy = function () {
    this.additionalDrawings.labels["lineData"].destroy();
    this.additionalDrawings.labels["lineText"].destroy();
};

infChart.lineDrawing.prototype.calculateAndUpdateLabel = function (newPositionData) {
    var ann = this.annotation,
        options = ann.options,
        line = ann.shape.d.split(' '),
        chart = ann.chart,
        additionalDrawingsArr = this.additionalDrawings,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis];

    var angle = infChart.drawingUtils.common.getAngle(
        {
            x: parseInt(line[1], 10),
            y: yAxis.toPixels(options.yValue) + parseInt(line[2], 10)
        },
        {
            x: parseInt(line[4], 10),
            y: yAxis.toPixels(newPositionData.yValueEnd)
        });

    var duration = this.calculateDuration(newPositionData);

    var calculatedLabelData = {
        yValue: options.yValue,
        priceRange: newPositionData.yValueEnd - options.yValue,
        barsRange:  newPositionData.nearestXValueEndIndex - newPositionData.nearestXValueIndex,
        angle:angle * -1,
        duration: duration,
        formattedPriceRange: (newPositionData.yValueEnd - options.yValue).toFixed(2),
        formatedPercentage: (((newPositionData.yValueEnd - options.yValue) / options.yValue) * 100).toFixed(2)
    };

    var labelData = this.getLabelData(ann, calculatedLabelData);
    var label = additionalDrawingsArr.labels["lineData"];
    var yLabelPosition = parseInt(line[5], 10);

    if(labelData){
        var labelHtml = "<div>" + labelData + "</div>";
        label.element.innerHTML = labelHtml;

        if (newPositionData.nearestXValueEnd > newPositionData.nearestXValue && newPositionData.yValueEnd > options.yValue) {
            yLabelPosition = yLabelPosition + 10;
        } else if (newPositionData.nearestXValueEnd > newPositionData.nearestXValue && newPositionData.yValueEnd < options.yValue) {
            yLabelPosition  = yLabelPosition - this.getLabelHeight() - 10;
        } else if (newPositionData.nearestXValueEnd < newPositionData.nearestXValue && newPositionData.yValueEnd > options.yValue) {
            yLabelPosition = yLabelPosition - this.getLabelHeight() - 10;
        } else {
            yLabelPosition = yLabelPosition + 10;
        }
        var labeWidth = this.getLabelWidth(calculatedLabelData);
        var labelHeight = this.getLabelHeight();
        
        label.attr({
            x: parseInt(line[4],10) + 10,
            y: yLabelPosition,
            width: labeWidth,
            height: labelHeight
        }).show();
    } else {
        label.attr({}).hide();
    }

    options.calculatedLabelData = calculatedLabelData;
};

infChart.lineDrawing.prototype.calculateAndUpdateTextLabel = function () {
    var ann = this.annotation,
        options = ann.options,
        line = ann.shape.d.split(' '),
        additionalDrawingsArr = this.additionalDrawings;

        var textLabelData = options.lineText.replace(/\n/g, "<br>");;
        var textLabel = additionalDrawingsArr.labels["lineText"];

    if(textLabelData && options.settings.lineTextChecked) {
        
        textLabel.attr({
            text: textLabelData
        }).hide();

        var angle = -options.calculatedLabelData.angle,
        radians = -angle * Math.PI/ANGLE_180,
        xCenterCorrection = Math.cos(radians) * textLabel.width/2,
        yCenterCorrection  = Math.sin(radians) * textLabel.width/2;

        if(!(angle > (-1) * RIGHT_ANGLE && angle < RIGHT_ANGLE)) {
            xCenterCorrection = xCenterCorrection - textLabel.width * Math.cos(radians);
            yCenterCorrection = yCenterCorrection - textLabel.width * Math.sin(radians);
        }
        var yLineCenter = (parseInt(line[5],10) +  parseInt(line[2]))/2;
        var xLineCenter = (parseInt(line[4],10) + parseInt(line[1],10))/2;

        textLabel.attr({
            x: xLineCenter - xCenterCorrection,
            y: yLineCenter + yCenterCorrection,
            rotation: angle > (-1) * RIGHT_ANGLE && angle < RIGHT_ANGLE ? angle :angle - ANGLE_180
        }).show();
    } else {
        textLabel.attr({}).hide();
    }
};

infChart.lineDrawing.prototype.getLabelWidth =  function (calculatedLabelData) {
    
    var tempHtmlNode = document.createElement("span");
    document.body.appendChild(tempHtmlNode);
    
    tempHtmlNode.innerHTML = calculatedLabelData.formattedPriceRange + ' ' + calculatedLabelData.formatedPercentage  + '%';
    var priceRangeElementWidth = tempHtmlNode.offsetWidth;
    
    tempHtmlNode.innerHTML = calculatedLabelData.duration;
    var durationElementWidth = tempHtmlNode.offsetWidth;
    
    document.body.removeChild(tempHtmlNode);
    
    return Math.max(priceRangeElementWidth, durationElementWidth) + 51;
};

infChart.lineDrawing.prototype.getLabelHeight =  function  () {
    return this.additionalDrawings.labels.lineData.element.querySelectorAll('[rel=lineToolInfoBox]')[0].clientHeight + 20;
};
infChart.lineDrawing.prototype.isRequiredProperty = function (propertyId, reset) {
    var isPositionProperty = false;

    switch (propertyId) {
        case "yValue":
        case "yValueEnd":
        case "xValue":
        case "xValueEnd":
            isPositionProperty = true;
            break
        case "lineText":
        case "isLocked":
            isPositionProperty = !reset
            break;
        default :
            break;
    }

    return isPositionProperty;
};

infChart.lineDrawing.prototype.calculateDuration = function (newPositionData) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart;

    var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart);
    var chartInstance = infChart.manager.getChart(stockChartId);
    var timeDuration = newPositionData.nearestXValueEnd - newPositionData.nearestXValue;

    var timeInMilliseconds, timeUnit;
    switch (chartInstance.interval) {
        case 'I_1':
        case 'I_3':
        case 'I_5':
        case 'I_15':
        case 'I_30':
            timeInMilliseconds = 60000;
            timeUnit = " minute";
            break;
        case 'I_60':
        case 'I_120':
        case 'I_240':
        case 'I_360':
        case 'I_480': 
        case 'I_720':
            timeInMilliseconds = 3600000;
            timeUnit = " hour";
            break;
        case 'W':
        case 'M':
        case 'Y':
            timeInMilliseconds = 604800000;
            timeUnit = " week";
            break;
        default: //default represents time intervals in days
            timeInMilliseconds = 86400000;
            timeUnit = " day";
            break;
    }

    timeDuration = Math.round(timeDuration / timeInMilliseconds);
    timeDuration = (timeDuration == 1 || timeDuration == -1) ? timeDuration + timeUnit : timeDuration + timeUnit + "s";

    return timeDuration;
};

infChart.lineDrawing.prototype.getLabelData = function (annotation, calculatedLabelData) {
    self = this;
    var labelHtml = '<div rel = "lineToolInfoBox" style = "display: grid; grid-row-gap: 10px; padding: 5px; background: #868688 !important; border-radius: 5px;">';
    var options = annotation.options;
    var islabelItemAvailable = false;
    
    $.each(options.labelDataItems, function (index, labelDataItem) {
        if (labelDataItem.enabled) {
            switch (labelDataItem.id) {
                case 'priceRange': {
                    labelHtml = labelHtml + '<span style = "display: grid; grid-column-gap: 10px; grid-template-columns: 15px 1fr;">' + self.showPriceDifferentIcon +
                        '<span class="drawing-lbl-box__label" style="color: #ffffff !important; font-weight: 500 !important">' + calculatedLabelData.formattedPriceRange + ' ' + calculatedLabelData.formatedPercentage  + '%' + '</span></span>';
                    islabelItemAvailable = true;
                }
                    break;
                case 'barsRange':{
                       labelHtml = labelHtml + '<span style = "display: grid; grid-column-gap: 10px; grid-template-columns: 15px 1fr;">' + self.showTimeDifferenceIcon +
                            '<span class="drawing-lbl-box__label" style="color: #ffffff !important; font-weight: 500 !important">' + calculatedLabelData.barsRange + ' bars' + '</span></span>';
                        islabelItemAvailable = true;
                    }
                    break;
                case 'angle': {
                    labelHtml = labelHtml + '<span style = "display: grid; grid-column-gap: 10px; grid-template-columns: 15px 1fr;">' + self.showDegreesIcon + 
                        '<span class="drawing-lbl-box__label" style="color: #ffffff !important; font-weight: 500 !important">' + calculatedLabelData.angle.toFixed(0) + '\u00B0' + '</span></span>';
                    islabelItemAvailable = true;
                }
                    break;
                case 'duration': {
                    labelHtml = labelHtml + '<span style = "display: grid; grid-column-gap: 10px; grid-template-columns: 15px 1fr;">' + self.showDurationIcon + 
                        '<span class="drawing-lbl-box__label" style="color: #ffffff !important; font-weight: 500 !important">' + calculatedLabelData.duration + '</span></span>';
                    islabelItemAvailable = true;
                }
                    break;
            }
        }
    });

    labelHtml = labelHtml + "</div>";

    if (!islabelItemAvailable) {
        labelHtml = null;
    }

    return labelHtml;
}

infChart.lineDrawing.prototype.onLineExtend = function (extended, direction, isPropertyChange) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        additionalDrawingsArr = this.additionalDrawings;

    if (additionalDrawingsArr) {
        if (extended) {
            additionalDrawingsArr.lines[direction].show();
        } else {
            additionalDrawingsArr.lines[direction].hide();
        }
    }

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.lineDrawing.prototype.onChangeArrowHead = function (extended, position, isPropertyChange) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        additionalDrawingsArr = this.additionalDrawings


    if (additionalDrawingsArr) {
        if (extended) {
            additionalDrawingsArr.lineArrow[position].show();
        } else {
            additionalDrawingsArr.lineArrow[position].hide();
        }
    }
    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.lineDrawing.prototype.onToggleLineText = function (checked, isPropertyChange) {
    var self = this;
    if (self.settingsPopup) {
        if (checked) {
            self.settingsPopup.find("input[inf-ctrl=line-text]").removeAttr("disabled");
            self.settingsPopup.find("input[inf-ctrl=textColorPicker]").removeAttr("disabled");
            $(self.settingsPopup.find("span[inf-ctrl=singleSelectedFontSize]")[0]).parent().removeAttr("disabled");
            self.calculateAndUpdateTextLabel.call(self);
        } else {
            self.settingsPopup.find("input[inf-ctrl=line-text]").attr("disabled", "disabled");
            self.settingsPopup.find("input[inf-ctrl=textColorPicker]").attr("disabled", "disabled");
            $(self.settingsPopup.find("span[inf-ctrl=singleSelectedFontSize]")[0]).parent().attr("disabled", "disabled");
            self.additionalDrawings.labels.lineText.hide();
        }
    }
};

infChart.lineDrawing.prototype.updateLineWithArrowHeadsAndPoints = function () {
    var self = this,
        ann = self.annotation,
        line = ann.shape.d.split(' '),
        additionalDrawingsArr = self.additionalDrawings;

    var ArrowHeadValues = infChart.drawingUtils.common.drawArrowHead.call(this, ann.shape.d, true, true);
    additionalDrawingsArr.lineArrow["endPointHead"].attr({ d: ArrowHeadValues.endArrowHead });
    additionalDrawingsArr.lineArrow["startPointHead"].attr({ d: ArrowHeadValues.startArrowHead });

    var pointsValues = infChart.drawingUtils.common.getExtendedLineCordinates.call(this, line, true, true);
    additionalDrawingsArr.lines["left"].attr({ d: ["M", line[1], line[2], "L", pointsValues.lineLeftX, pointsValues.lineLeftY] });
    additionalDrawingsArr.lines["right"].attr({ d: ["M", line[4], line[5], "L", pointsValues.lineRightX, pointsValues.lineRightY] });
};

infChart.lineDrawing.prototype.resetDragSUpporters = function (){
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        additionalDrawingsArr = self.additionalDrawings,
        line = ann.shape.d.split(' ');
    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, line, this.dragSupporters);
    if(additionalDrawingsArr.lines["left"]){
        infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, additionalDrawingsArr.lines["left"].d.split(' '), this.dragSupporters);
    }
    if(additionalDrawingsArr.lines["right"]){
        infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, additionalDrawingsArr.lines["right"].d.split(' '), this.dragSupporters);
    }
};
window.infChart = window.infChart || {};

infChart.mobilelineDrawing = function () {
    infChart.lineDrawing.apply(this, arguments);
};

infChart.mobilelineDrawing.prototype = Object.create(infChart.lineDrawing.prototype);

infChart.mobilelineDrawing.prototype.getOptions = function(properties, chart){
    var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, properties.xValue, undefined, true, true);
    var theme = infChart.drawingUtils.common.getTheme();
    var shapeTheme = theme["trendLine"];
    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        nearestXValue: nearestDataForXValue.xData,
        nearestXValueIndex: nearestDataForXValue.dataIndex,
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0],
                dashstyle: 'solid',
                'stroke-width': infChart.drawingUtils.common.baseLineWidth
            }
        },
        settings: {},
        labelDataItems: properties.labelDataItems ? properties.labelDataItems : this.labelDataItems,
    };
    if(properties.settings) {
        options.settings = properties.settings;

        if (properties.settings.lineColor) {
            options.shape.params.stroke = properties.settings.lineColor;
        }
        if (properties.settings.lineOpacity) {
            options.shape.params['stroke-opacity'] = properties.settings.lineOpacity;
        }

        if (properties.settings.lineWidth) {
            options.shape.params['stroke-width'] = properties.settings.lineWidth;
        }

        if (properties.settings.lineStyle) {
            options.shape.params.dashstyle = properties.settings.lineStyle;
        }
    } else {
        options.settings.lineColor = infChart.drawingUtils.common.baseBorderColor;
        options.settings.lineOpacity = infChart.drawingUtils.common.baseFillOpacity;
        options.settings.lineStyle = 'solid';
        options.settings.lineWidth = infChart.drawingUtils.common.baseLineWidth;
        options.settings.isExtendRight = false;
        options.settings.isExtendLeft = false;
        options.settings.isStartPoint = false;
        options.settings.isEndPoint = false;
        options.settings.textColor = shapeTheme.label.fontColor;
        options.settings.textOpacity = shapeTheme.label.fontOpacity;
        options.settings.lineTextChecked = this.lineTextChecked;
        options.settings.textFontSize = shapeTheme.label.fontSize;
        options.settings.textFontWeight = shapeTheme.label.fontWeight;
        options.settings.textFontStyle = shapeTheme.label.fontStyle;
        options.settings.textDecoration = shapeTheme.label.textDecoration;

    }

    if(properties.lineText){
        options.lineText = properties.lineText;
    } else {
        options.lineText = this.lineText;
    }

    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;

        var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, properties.xValueEnd, undefined, true, true);
        options.nearestXValueEnd = nearestDataForXValueEnd.xData;
        options.nearestXValueEndIndex = nearestDataForXValueEnd.dataIndex;
    }
    if(properties.calculatedLabelData) {
        options.calculatedLabelData = properties.calculatedLabelData;
    }

    options.validateTranslationFn = this.validateTranslation;

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.mobilelineDrawing.prototype.getQuickSettingsPopup = function () {
    //return infChart.drawingUtils.common.getLineQuickSettings(infChart.drawingUtils.common.baseBorderColor, infChart.drawingUtils.common.baseFillOpacity);
};

infChart.mobilelineDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation,
        chart = ann.chart,
         options = ann.options,
        width,
        height,
        pathDefinition,
        xAxis = chart.xAxis[options.xAxis],
        nearestXValue = infChart.math.findNearestXDataPoint(chart, options.xValue, undefined, true, true),
        nearestXValueEnd = infChart.math.findNearestXDataPoint(chart, options.xValueEnd, undefined, true, true),
        newX = xAxis.toPixels(nearestXValue) - xAxis.toPixels(ann.options.xValue),
        newXEnd = xAxis.toPixels(nearestXValueEnd) - xAxis.toPixels(ann.options.xValue);

    ann.events.deselect.call(ann);
    ann.selectionMarker = [];
    pathDefinition = ann.shape.d.split(' ');

    width = parseFloat(pathDefinition[4]);
    height = parseFloat(pathDefinition[5]);

    if (!isNaN(width) && !isNaN(height)) {
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, newX, 0, this.stepFunction, this.stop, true);
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, newXEnd, height, this.stepFunction, this.stop, false);
    }
    self.selectionMarkersBringToFront();
};

infChart.mobilelineDrawing.prototype.step = function (e, isStartPoint) {
    var ann = this.annotation,
        points = infChart.drawingUtils.common.calculateInitialPoints(e, ann, isStartPoint, 0, 0),
        options = ann.options,
        chart = ann.chart,
        additionalDrawingsArr = this.additionalDrawings,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        xValueEnd = xAxis.toValue(xAxis.toPixels(options.xValue) + points.dx),
        yValueEnd = yAxis.toValue(yAxis.toPixels(options.yValue) + points.dy),
        nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true),
        nearestDataPointForXValueEnd = infChart.math.findNearestDataPoint(chart, xValueEnd, undefined, true, true),
        newX = xAxis.toPixels(nearestDataPointForXValue.xData) - xAxis.toPixels(ann.options.xValue),
        newXEnd = xAxis.toPixels(nearestDataPointForXValueEnd.xData) - xAxis.toPixels(ann.options.xValue),
        newYEnd = parseInt(points.dy, 10),
        newY = 0;

    if (infChart.manager.shiftKeyPressed) {
        var cordinateData = this.snapLine(ann, newX, newY, newXEnd, newYEnd, xValueEnd, yValueEnd, nearestDataPointForXValue, nearestDataPointForXValueEnd, points, isStartPoint);
        newX = cordinateData.newX;
        newY = cordinateData.newY;
        newXEnd = cordinateData.newXEnd;
        newYEnd = cordinateData.newYEnd;
        nearestDataPointForXValue = cordinateData.nearestDataPointForXValue;
        nearestDataPointForXValueEnd = cordinateData.nearestDataPointForXValueEnd;
        yValueEnd = cordinateData.yValueEnd;
    } 

    var line = ["M", newX, newY, 'L', parseInt(newXEnd, 10), newYEnd ];
    ann.shape.attr({
        d: line
    });


    this.calculateAndUpdateLabel({
        nearestXValue: nearestDataPointForXValue.xData,
        nearestXValueIndex: nearestDataPointForXValue.dataIndex,
        nearestXValueEnd: nearestDataPointForXValueEnd.xData,
        nearestXValueEndIndex: nearestDataPointForXValueEnd.dataIndex,
        yValueEnd: yValueEnd
    });

    this.updateLineWithArrowHeadsAndPoints(line, ann, additionalDrawingsArr);
    this.calculateAndUpdateTextLabel();
    this.repositionSelectionMarkers();
    return {line: line, nearestDataPointForXValue: nearestDataPointForXValue, nearestDataPointForXValueEnd: nearestDataPointForXValueEnd};
};

infChart.mobilelineDrawing.prototype.stop = function (e, isStartPoint) {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        additionalDrawingsArr = this.additionalDrawings,
        lineData = this.stepFunction(e, isStartPoint),
        line = lineData.line,
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        x = xAxis.toValue(line[4] + xAxis.toPixels(ann.options.xValue)),
        y = yAxis.toValue(line[5] + yAxis.toPixels(ann.options.yValue)),
        startY = yAxis.toValue(line[2] + yAxis.toPixels(ann.options.yValue));

    line[1] = 0;
    line[4] = xAxis.toPixels(lineData.nearestDataPointForXValueEnd.xData) - xAxis.toPixels(lineData.nearestDataPointForXValue.xData);
    line[5] = line[5] - line [2];
    line[2] = 0;

    ann.update({
        xValue: lineData.nearestDataPointForXValue.xData,
        xValueEnd: lineData.nearestDataPointForXValueEnd.xData,
        yValue: startY,
        yValueEnd: y,
        nearestXValue: lineData.nearestDataPointForXValue.xData,
        nearestXValueIndex: lineData.nearestDataPointForXValue.dataIndex,
        nearestXValueEnd: lineData.nearestDataPointForXValueEnd.xData,
        nearestXValueEndIndex: lineData.nearestDataPointForXValueEnd.dataIndex,
        shape: {
            params: {
                d: line
            }
        }
    });

    this.updateLineWithArrowHeadsAndPoints();
    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, y);
    self.resetDragSUpporters();
    self.selectionMarkersBringToFront();
    self.selectAndBindResize();
    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.mobilelineDrawing.prototype.translate = function () {}

infChart.mobilelineDrawing.prototype.translateEnd = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        additionalDrawingsArr = this.additionalDrawings,
        line = ann.shape.d.split(' '),
        xAxis = chart.xAxis[options.xAxis],
        nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true),
        nearestDataPointForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);

    var xValueDiff = xAxis.toPixels(nearestDataPointForXValueEnd.xData) - xAxis.toPixels(nearestDataPointForXValue.xData);
    var newLine = ["M", 0, 0, 'L', xValueDiff, line[5]];

    ann.update({
        xValue: nearestDataPointForXValue.xData,
        xValueEnd: nearestDataPointForXValueEnd.xData,
        nearestXValue: nearestDataPointForXValue.xData,
        nearestXValueIndex: nearestDataPointForXValue.dataIndex,
        nearestXValueEnd: nearestDataPointForXValueEnd.xData,
        nearestXValueEndIndex: nearestDataPointForXValueEnd.dataIndex,
        shape: {
            params: {
                d: newLine
            }
        }
    });

    this.calculateAndUpdateLabel({
        nearestXValue: nearestDataPointForXValue.xData,
        nearestXValueIndex: nearestDataPointForXValue.dataIndex,
        nearestXValueEnd: nearestDataPointForXValueEnd.xData,
        nearestXValueEndIndex: nearestDataPointForXValueEnd.dataIndex,
        yValueEnd: options.yValueEnd
    });

    this.calculateAndUpdateTextLabel();
    var newXEnd = xAxis.toPixels(options.xValueEnd) - xAxis.toPixels(options.xValue);
    // Update new position of the selection marker when scaling the chart while line is selected
    if (ann.selectionMarker && ann.selectionMarker.length > 1) {
        ann.selectionMarker[0].attr({
            x: 0
        });  
        ann.selectionMarker[1].attr({
            x: newXEnd
        });
    } 

    this.updateLineWithArrowHeadsAndPoints();
    self.selectAndBindResize();
    chart.selectedAnnotation = ann;  
    self.resetDragSUpporters();
    self.selectionMarkersBringToFront();
}

infChart.mobilelineDrawing.prototype.repositionSelectionMarkers = function () {
    var self = this,
        ann = self.annotation,
        options = self.options,
        selectionMarker = ann.selectionMarker,
        line = ann.shape.d.split(' ');

        if(selectionMarker && selectionMarker[0]){
            selectionMarker[0].attr({
                x: line[1],
                y: line[2]
            });
        }

        if(selectionMarker && selectionMarker[1]){
            selectionMarker[1].attr({
                x: line[4],
                y: line[5]
            })
        }

};

infChart.mobilelineDrawing.prototype.selectionMarkersBringToFront = function (){
    if(this.annotation.selectionMarker && this.annotation.selectionMarker.length > 0){
        for (var i = 0; i < this.annotation.selectionMarker.length; i++) {
            this.annotation.selectionMarker[i].toFront();
        }
    }
}

infChart.mobilelineDrawing.prototype.updateConfigFromSettings = function (drawingObj, config){
    var properties = drawingObj.getConfig();
    infChart.util.forEach(config.options, function (index, option) {
        switch (option.name) {
            case 'lineColor':
                option.callBackMethod = "onLineColorChange";
                currentValue = {},
                currentValue.color = currentValue.lineColor;
                currentValue.opacity = currentValue.lineOpacity;
                break;
            case 'lineWidth':
                option.callBackMethod = "onLineWidthChange";
                option.currentValue = properties.settings.lineWidth;
                break;
            case 'lineStyle' :
                option.callBackMethod = "onLineStyleChange";
                option.currentValue = properties.settings.lineStyle;
                break;
            case 'isExtendLeft':
                option.callBackMethod = "onLineExtendToLeft";
                option.currentValue = properties.settings.isExtendLeft;
                break;
            case 'isExtendRight':
                option.callBackMethod = "onLineExtendToRight";
                option.currentValue = properties.settings.isExtendRight;
                break;
            case 'isStartPoint' :
                option.callBackMethod = "onStartArrowHeadTypeChange";
                option.currentValue = properties.settings.isStartPoint ? "arrowHead" : "normalHead";
                break;
            case 'isEndPoint':
                option.callBackMethod = "onEndArrowHeadTypeChange";
                option.currentValue = properties.settings.isEndPoint ? "arrowHead" : "normalHead";
                break;
            case 'lineText':
                option.callBackMethod = "onLineTextChange";
                option.currentValue = properties.settings.lineText;
                break;
            case 'lineTextChecked' :
                option.callBackMethod = "onToggleLineText";
                option.currentValue = properties.settings.lineTextChecked;
                break;
            case 'textColor':
                option.callBackMethod = "onTextColorChange";
                currentValue = {},
                currentValue.color = currentValue.textColor;
                currentValue.opacity = currentValue.textOpacity;
                break;
            case 'textFontSize':
                option.callBackMethod = "onTextSizeChange";
                option.currentValue = properties.settings.textFontSize;
                break;
            case 'textFontStyle' :
                option.callBackMethod = "onTextFontStyleChange";
                option.currentValue = properties.settings.textFontStyle;
                break;
            case 'textFontWeight':
                option.callBackMethod = "onTextFontWeightChange";
                option.currentValue = properties.settings.textFontWeight;
                break;
            case 'textDecoration':
                option.callBackMethod = "onTextFontDecorationChange";
                option.currentValue = properties.settings.textDecoration;
                break;
            case 'priceRange':
                option.callBackMethod = "onLabelItemsChangeValues";
                option.currentValue = properties.labelDataItems[0].enabled;
                break;
            case 'barsRange':
                option.callBackMethod = "onLabelItemsChangeValues";
                option.currentValue = properties.labelDataItems[1].enabled;
                break;
            case 'angle':
                option.callBackMethod = "onLabelItemsChangeValues";
                option.currentValue = properties.labelDataItems[2].enabled;
                break;
            case 'duration':
                option.callBackMethod = "onLabelItemsChangeValues";
                option.currentValue = properties.labelDataItems[3].enabled;
                break;      
        }
    });

    return config;
};

infChart.mobilelineDrawing.prototype.onLineColorChange = function (values){
    var self = this;
    infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.lineColor, {
        isUpdateAnnotationStyles: true,
        settingsItem: 'line',
        otherLineElements: [
            self.additionalDrawings.lines["left"],
            self.additionalDrawings.lines["right"],
            self.additionalDrawings.lineArrow["startPointHead"],
            self.additionalDrawings.lineArrow["endPointHead"]
        ]
    })(values.rgb, values.color, values.opacity);
};

infChart.mobilelineDrawing.prototype.onLineWidthChange = function (values){
    var self = this;
    infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.lineWidth, {
        isUpdateAnnotationStyles: true,
        settingsItem: 'lineWidth',
        otherLineElements: [
            self.additionalDrawings.lines["left"],
            self.additionalDrawings.lines["right"],
            self.additionalDrawings.lineArrow["startPointHead"],
            self.additionalDrawings.lineArrow["endPointHead"]
        ],
        callBackFunction : function(settingsParams, isPropertyChange, strokeWidth){
            var dashArrayValues = infChart.drawingUtils.common.settings.getStrokeDashArray(self.annotation.options.shape.params.dashstyle, strokeWidth);
            if (settingsParams.otherLineElements) {
                settingsParams.otherLineElements.forEach(function (element) {
                    if(element !== self.additionalDrawings.lineArrow["startPointHead"] && element !== self.additionalDrawings.lineArrow["endPointHead"]){
                    element.attr({
                        'stroke-dasharray': dashArrayValues
                    });
                }
                });
            }
        }
    })(values.lineWidth);
};

infChart.mobilelineDrawing.prototype.onLineStyleChange = function (values){
    var self = this;
    infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.lineStyle, {
        isUpdateAnnotationStyles: true,
        settingsItem: 'lineStyle',
        otherLineElements: [
            self.additionalDrawings.lines["left"],
            self.additionalDrawings.lines["right"],
        ]
    })(values.style);
};

infChart.mobilelineDrawing.prototype.onLineExtendToLeft = function (values){
    var self = this;
    infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.checkBox, {
        isUpdateAnnotationStyles: false,
        settingsItem: 'isExtendLeft',
        callBackFunction : function(settingsParams, isPropertyChange, value){
            self.onLineExtend.call(self, value, "left", isPropertyChange);
    },
        ctrlSelector: "[inf-ctrl=extendToLeft]"
    })(values.isExtendLeft);
};

infChart.mobilelineDrawing.prototype.onLineExtendToRight = function (values){
    var self = this;
    infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.checkBox, {
        isUpdateAnnotationStyles: false,
        settingsItem: 'isExtendRight',
        callBackFunction : function(settingsParams, isPropertyChange, value){
            self.onLineExtend.call(self, value, "right", isPropertyChange);
    },
        ctrlSelector: "[inf-ctrl=extendToRight]"
    })(values.isExtendRight);
};

infChart.mobilelineDrawing.prototype.onStartArrowHeadTypeChange = function (values){
    var self = this;
    var type = values.isStartPoint === 'arrowHead';
    infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.value, {
        isUpdateAnnotationStyles: false,
        settingsItem: 'isStartPoint',
        callBackFunction : function(settingsParams, isPropertyChange, value){
            self.onChangeArrowHead.call(self, value, "startPointHead", isPropertyChange);
        },
        ctrlSelector: "[inf-ctrl= startArrowHeadType]"
    })(type);
};

infChart.mobilelineDrawing.prototype.onEndArrowHeadTypeChange = function (values){
    var self = this;
    var type = values.isEndPoint === 'arrowHead';
    infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.value, {
        isUpdateAnnotationStyles: false,
        settingsItem: 'isEndPoint',
        callBackFunction : function(settingsParams, isPropertyChange, value){
            self.onChangeArrowHead.call(self, value, "endPointHead", isPropertyChange);
        },
        ctrlSelector: "[inf-ctrl= endArrowHeadType]"
    })(type);
};

infChart.mobilelineDrawing.prototype.onTextColorChange = function (values){
    var self = this;
    infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.fontColor, {
        isUpdateAnnotationStyles: false,
        settingsItem: 'text',
        otherTextElements: [
            self.additionalDrawings.labels["lineText"]
        ],
        ctrlSelector: "[inf-ctrl= textColorPicker]"
    })(values.rgb, values.color, values.opacity);
};

infChart.mobilelineDrawing.prototype.onToggleLineText = function (values){
    var self = this;
    infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.checkBox, {
        isUpdateAnnotationStyles: false,
        settingsItem: 'lineTextChecked',
        callBackFunction: function(settingsParams, isPropertyChange, value){
            self.onToggleLineText(value, isPropertyChange)
        },
        ctrlSelector: "[inf-ctrl=textToggle]"
    })(values.isChecked);
};

infChart.mobilelineDrawing.prototype.onLineTextChange = function (values){
    var self = this;
    infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.text, {
        isUpdateAnnotationStyles: false,
        settingsItem: 'lineText',
        callBackFunction: function(){
            self.calculateAndUpdateTextLabel()
        },
        ctrlSelector: "[inf-ctrl=line-text]"
    })(values.text);
};

infChart.mobilelineDrawing.prototype.onTextSizeChange = function (values){
    var self = this;
    infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.fontSize, {
        isUpdateAnnotationStyles: false,
        settingsItem: 'textFontSize',
        otherTextElements: [
            self.additionalDrawings.labels["lineText"]
        ],
        callBackFunction: function(){
            self.calculateAndUpdateTextLabel()
        }
    })(values.fontSize);
};

infChart.mobilelineDrawing.prototype.onTextFontStyleChange = function (values){
    var self = this;
    infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.fontStyle, {
        isUpdateAnnotationStyles: false,
        settingsItem: 'textFontStyle',
        otherTextElements: [
            self.additionalDrawings.labels["lineText"]
        ],
        callBackFunction: function(){
            self.calculateAndUpdateTextLabel()
        }
    })(values.fontStyle);
};

infChart.mobilelineDrawing.prototype.onTextFontWeightChange = function (values){
    var self = this;
    infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.fontStyle,{
        isUpdateAnnotationStyles: false,
        otherTextElements: [
            self.additionalDrawings.labels["lineText"]
        ],
        settingsItem: 'textFontWeight',
        callBackFunction: function(){
            self.calculateAndUpdateTextLabel()
        }
    })(values.fontWeight);
};

infChart.mobilelineDrawing.prototype.onTextFontDecorationChange = function (values){
    var self = this;
    infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.fontStyle, {
        isUpdateAnnotationStyles: false,
        settingsItem: 'textDecoration',
        otherTextElements: [
            self.additionalDrawings.labels["lineText"]
        ],
        callBackFunction: function(){
            self.calculateAndUpdateTextLabel()
        }
    })(values.textDecoration);
};

infChart.lineDrawing.prototype.onLabelItemsChangeValues = function(values){
    var self = this;
    var isPropertyChange = true;
    if (self.settingsPopup) {
        isPropertyChange = self.isSettingsPropertyChange();
    }
    if(values.priceRange){
        labelItemId = "priceRange";
        value = values.priceRange;
    }
    if(values.barsRange){
        labelItemId = "barsRange";
        value = values.priceRange;
    }
    if(values.angle){
        labelItemId = "angle";
        value = values.priceRange;
    }
    if(values.duration){
        labelItemId = "duration";
        value = values.priceRange;
    }

    self.onLabelItemsChange(labelItemId, values, isPropertyChange);
}
window.infChart = window.infChart || {};


infChart.extendedLineDrawing = function () {
    infChart.lineDrawing.apply(this, arguments);
};

infChart.extendedLineDrawing.prototype = Object.create(infChart.lineDrawing.prototype);

infChart.extendedLineDrawing.prototype.getOptions = function (properties, chart) {
    var options = infChart.lineDrawing.prototype.getOptions.call(this, properties, chart);

    if(properties && properties.settings && properties.settings.isExtendRight !== undefined){
        options.settings.isExtendRight = properties.settings.isExtendRight;
    } else {
        options.settings.isExtendRight = true;
    }

    if(properties && properties.settings && properties.settings.isExtendLeft !== undefined){
        options.settings.isExtendLeft = properties.settings.isExtendLeft;
    } else {
        options.settings.isExtendLeft = true;
    }
    return options;
};

infChart.extendedLineDrawing.prototype.getConfig = function () {
    var properties = infChart.lineDrawing.prototype.getConfig.call(this);
    properties.shape = 'extendedLine';
    return properties;
};


window.infChart = window.infChart || {};


infChart.lineArrowDrawing = function () {
    infChart.lineDrawing.apply(this, arguments);
};

infChart.lineArrowDrawing.prototype = Object.create(infChart.lineDrawing.prototype);

infChart.lineArrowDrawing.prototype.getOptions = function (properties, chart) {
    var options = infChart.lineDrawing.prototype.getOptions.call(this, properties, chart);

    if(properties && properties.settings && properties.settings.isEndPoint !== undefined){
        options.settings.isEndPoint = properties.settings.isEndPoint;
    } else {
        options.settings.isEndPoint = true;
    }

    return options;
};

infChart.lineArrowDrawing.prototype.getConfig = function () {
    var properties = infChart.lineDrawing.prototype.getConfig.call(this);
    properties.shape = 'lineArrow';
    return properties;
};


window.infChart = window.infChart || {};


infChart.rayDrawing = function () {
    infChart.lineDrawing.apply(this, arguments);
};

infChart.rayDrawing.prototype = Object.create(infChart.lineDrawing.prototype);

infChart.rayDrawing.prototype.getOptions = function (properties, chart) {
    var options = infChart.lineDrawing.prototype.getOptions.call(this, properties, chart);

    if(properties && properties.settings && properties.settings.isExtendRight !== undefined){
        options.settings.isExtendRight = properties.settings.isExtendRight;
    } else {
        options.settings.isExtendRight = true;
    }
    
    return options;
};

infChart.rayDrawing.prototype.getConfig = function () {
    var properties = infChart.lineDrawing.prototype.getConfig.call(this);
    properties.shape = 'ray';
    return properties;
};


window.infChart = window.infChart || {};

infChart.horizontalLineDrawing = function () {
    this.correctionFactor = 500;
    infChart.drawingObject.apply(this, arguments);
};

infChart.horizontalLineDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.horizontalLineDrawing.prototype.additionalDrawingsFunction = function () {
    var drawingObject = this,
        ann = drawingObject.annotation,
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        height = 14,
        padding = 6,
        top,
        theme = {
            fill: "#191919",
            stroke: "#2a2a2b",
            opacity: 1,
            fontColor: "#ffffff",
            'zIndex': 20,
            'padding': padding,
            'r': 1,
            'stroke-width': 1,
            'stroke-linecap': 'butt',
            'stroke-linejoin': 'miter',
            'stroke-opacity': 1,
            'hAlign': 'center',
            'height': height,
            'class': 'drawing-line-axis-lbl',
            'fontWeight': 100,
            'x': xAxis.width
        };

    if (infChart.drawingUtils.common.theme && infChart.drawingUtils.common.theme.axisLabel) {
        theme = infChart.util.merge(theme, infChart.drawingUtils.common.theme.axisLabel);
    }

    top = -(theme.height / 2 + theme.padding);
    ann.options.xLabelPadding = theme.padding;

    var value = this.getLabelFormattedValue();
    var lineLabel = chart.renderer.label(infChart.drawingUtils.common.getYValue.call(this, value), 0, top).attr(theme).add(ann.group);

    lineLabel.css({ //to color text
        'fontWeight': theme.fontWeight,
        'color': theme.fontColor
    });

    drawingObject.additionalDrawings['lineLabel'] = lineLabel;

    if(options.lineText){
        drawingObject.additionalDrawings.lineText = chart.renderer.label(options.lineText).css({
            color: options.shape.params.stroke,
            fontSize: infChart.drawingUtils.common.getTheme()['lineText'].fontSize
        }).add(ann.group);
    }
    
    var yAxis = chart.yAxis[ann.options.yAxis];
    if (chart.axisOffset[yAxis.side] < lineLabel.width) {
        yAxis.isDirty = true; // need to change the axis offset in the chart
        this.chartRedrawRequired = true;
    }
    ann.group.addClass("line-drawing");
    // bringing the label's group front to avoid overlapping with the axis labels
    infChart.drawingUtils.common.getAxisLabelToFront.call(this, lineLabel);
    if (!ann.selectionMarker) {
        ann.selectionMarker = [];
        infChart.drawingUtils.common.addSelectionMarker.call(this, ann, 0, 0);
    }
};

infChart.horizontalLineDrawing.prototype.beforeDestroy = function () {
    var drawingObject = this,
        ann = drawingObject.annotation,
        chart = ann.chart,
        yAxis = chart.yAxis[ann.options.yAxis];

    // need to reset the yAxis offset which is utilzed by this drawing
    yAxis.isDirty = true;
    this.chartRedrawRequired = true;
    if(drawingObject.additionalDrawings['lineText']){
        drawingObject.additionalDrawings['lineText'].destroy();
    }
};

infChart.horizontalLineDrawing.prototype.bindSettingsEvents = function () {
    var self = this;

    var callBackFnLineSettingsEvents = {
        onLineColorChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.lineColor, {
            isUpdateAnnotationStyles: true,
            settingsItem: 'line'
        }),
        onLineWidthChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.lineWidth, {
            isUpdateAnnotationStyles: true,
            settingsItem: 'lineWidth'

        }),
        onLineStyleChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.lineStyle, {
            isUpdateAnnotationStyles: true,
            settingsItem: 'lineStyle',
        }),
        
        onResetToDefault : function(){
            self.updateSavedDrawingProperties(true)
        }   
    }

    infChart.structureManager.drawingTools.bindLineSettings(self.settingsPopup, callBackFnLineSettingsEvents);
};

infChart.horizontalLineDrawing.prototype.getAxisOffset = function (axis) {
    var drawingObject = this,
        ann = drawingObject.annotation,
        options = ann.options,
        label = drawingObject.additionalDrawings['lineLabel'],
        padding = infChart.util.isDefined(ann.options.xLabelPadding) || 3;

    if (!axis.isXAxis && options.yAxis === axis.options.index) {

        var value = this.getLabelFormattedValue();
        label.attr({
            text: value
        });
        return label.width + padding;
    }
    return 0;
};

infChart.horizontalLineDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    return {
        shape: 'horizontalLine',
        settings: {
            lineColor: infChart.themeManager.getDrawingsBorderColor(annotation.options.shape.params.stroke, 'horizontalLine'),
            lineOpacity: annotation.options.settings.lineOpacity,
            lineWidth: annotation.options.shape.params['stroke-width'],
            lineStyle: annotation.options.shape.params.dashstyle
        },
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        clickCords: annotation.options.clickCords,
        width: annotation.chart.plotWidth,
        text: annotation.options.lineText,
        isLocked : annotation.options.isLocked
    };
};

/**
 * Returns the obj of properties to copy
 * @returns {object} properties
 */
infChart.horizontalLineDrawing.prototype.getConfigToCopy = function () {
    var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(this.annotation.chart);
    var chartInstance = infChart.manager.getChart(stockChartId);
    var yAxis = chartInstance.getMainYAxis();
    var properties = this.getConfig();
    var shapeTheme = infChart.drawingUtils.common.theme.horizontalLine;
    var copyDistance = shapeTheme && shapeTheme.copyDistance ? shapeTheme.copyDistance.y : infChart.drawingUtils.common.theme.defaultCopyDistance;

    properties.yValue = yAxis.toValue(yAxis.toPixels(properties.yValue) + copyDistance);
    return properties;
};

infChart.horizontalLineDrawing.prototype.getLabelFormattedValue = function () {
    var stockChart = this.stockChart;
    var value;
    if (stockChart.isPercent) {
        value = stockChart.getYLabel(this.annotation.options.yValue, true, false, false);
    } else {
        value = stockChart.formatValue(this.yValue, stockChart.getMainSeries().options.dp);
    }
    return value;
};

infChart.horizontalLineDrawing.prototype.getOptions = function (properties) {
    var options = {
        utilizeAxes: "y", // since label is drawn in the yAxis
        xValue: properties.xValue,
        yValue: properties.yValue,
        allowDragX: false,
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0],
                dashstyle: 'solid',
                'class': "horizontal-line",
                'stroke-width': infChart.drawingUtils.common.baseLineWidth
            }
        },
        settings: {}
    };

    if(properties.settings){
        options.settings = properties.settings;
        if (properties.settings.fillColor) {
            options.shape.params.fill = properties.settings.fillColor;
        }
        if (properties.settings.lineColor) {
            options.shape.params.stroke = properties.settings.lineColor;
        }
        if (properties.settings.lineOpacity) {
            options.shape.params.opacity = properties.settings.lineOpacity;
        }
        if (properties.settings.lineStyle) {
            options.shape.params.dashstyle = properties.settings.lineStyle;
        }
        if (properties.settings.lineWidth) {
            options.shape.params['stroke-width'] = properties.settings.lineWidth;
        }
    } else {
        options.settings.lineColor = infChart.drawingUtils.common.baseBorderColor;
        options.settings.lineOpacity = infChart.drawingUtils.common.baseFillOpacity;
        options.settings.lineStyle = 'solid';
        options.settings.lineWidth = infChart.drawingUtils.common.baseLineWidth;
    }

    if(properties.text){
        options.lineText = properties.text;
        options.allowDragY = properties.allowDragY || false;
        options.disableCopyPaste = true;
        this.disableQuickSettingPanel = true;
    }

    if (properties.width) {
        options.shape.params.d = ['M', 0, 0, 'L', properties.width * 1.5, 0];
    }
    if (properties.clickCords) {
        options.clickCords = properties.clickCords;
    }
    options.isRealTimeTranslation = true; // since label value is needed to be changed

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.horizontalLineDrawing.prototype.getQuickSettingsPopup = function () {
    return infChart.drawingUtils.common.getLineQuickSettings(infChart.drawingUtils.common.baseBorderColor, infChart.drawingUtils.common.baseFillOpacity);
};

infChart.horizontalLineDrawing.prototype.getSettingsPopup = function () {
    return infChart.drawingUtils.common.getLineSettings('Horizontal Line', infChart.drawingUtils.common.baseBorderColor, undefined, undefined, undefined, undefined, infChart.drawingUtils.common.baseFillOpacity, false, false);
};

infChart.horizontalLineDrawing.prototype.isRequiredProperty = function (propertyId) {
    var isPositionProperty = false;

    switch (propertyId) {
        case "yValue":
        case "yValueEnd":
        case "xValue":
        case "xValueEnd":
        case "text":
        case "isLocked":
            isPositionProperty = true;
            break;
        default :
            break;
    }

    return isPositionProperty;
};

infChart.horizontalLineDrawing.prototype.scale = function () {
    var ann = this.annotation,
        chart = ann.chart,
        options = ann.options,
        line = ann.shape.d.split(' '),
        xAxis = chart.xAxis[options.xAxis];
    var label = this.additionalDrawings['lineLabel'],
        lineText = this.additionalDrawings['lineText'];

    line[1] = - this.correctionFactor; 
    var firstCandle = xAxis.toPixels(chart.series[0].points[0].x); //distance to the first candle from chart start
    line[4] = xAxis.width - firstCandle; // line should be ended inside the plot area. Otherwise it will be shown in the yAxis some times
    
    ann.update({
        xValue: chart.series[0].points[0].x,
        shape: {
            params: {
                d: line
            }
        }
    });

    var value = this.getLabelFormattedValue();
    label.attr({
        text: value,
        x: xAxis.width - firstCandle,
        zIndex: 20
    });

    if(options.lineText){
        lineText.attr({
            x: xAxis.width - lineText.width - firstCandle - 50,
            y: - lineText.height
        });
    }

    infChart.drawingUtils.common.getAxisLabelToFront.call(this, label);
    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, ["M", 0, 0, 'L', line[4], line[5]], this.dragSupporters);
};

infChart.horizontalLineDrawing.prototype.select = function () {
    infChart.drawingUtils.common.getAxisLabelToFront.call(this, this.additionalDrawings['lineLabel']);
};

infChart.horizontalLineDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation;
    if (!ann.selectionMarker) {
        ann.selectionMarker = [];
        infChart.drawingUtils.common.addSelectionMarker.call(this, ann, 0, 0);
    }
};

infChart.horizontalLineDrawing.prototype.step = function () { };

infChart.horizontalLineDrawing.prototype.stop = function (e) {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        x = e.chartX,
        y = e.chartY,
        plotWidth = chart.plotWidth * 1.5,
        xAxis = chart.xAxis[options.xAxis],
        label = this.additionalDrawings['lineLabel'],
        lineText = this.additionalDrawings['lineText'],
        line = ["M", 0, 0, 'L', xAxis.width, 0];
        line[1] = - this.correctionFactor;
        var firstCandle = xAxis.toPixels(chart.series[0].points[0].x);
        line[4] = xAxis.width - firstCandle;

    ann.update({
        clickCords: { x: x, y: y },
        xValue: chart.series[0].points[0].x,
        shape: {
            params: {
                d: line
            }
        }
    });

    if(options.lineText){
        lineText.attr({
            x: xAxis.width - firstCandle - lineText.width - 50,
            y: - lineText.height
        });
    }

    label.attr({
        text: label.text.textStr, //https://www.highcharts.com/forum/viewtopic.php?t=39232
        x: xAxis.width - firstCandle,
        zIndex: 20
    });

    ann.group.addClass("line-drawing");

    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue);
    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, ["M", 0, 0, 'L', line[4], line[5]], this.dragSupporters);
    infChart.drawingUtils.common.onPropertyChange.call(this);
    return line;
};

infChart.horizontalLineDrawing.prototype.translate = function () {
    var value = this.getLabelFormattedValue(),
        lineLabel = this.additionalDrawings['lineLabel'];

    lineLabel.attr({
        text: value
    });
    infChart.drawingUtils.common.getAxisLabelToFront.call(this, lineLabel);
};

infChart.horizontalLineDrawing.prototype.translateEnd = function () {
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.horizontalLineDrawing.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updateLineSettings(this.settingsPopup, properties.settings);
};

window.infChart = window.infChart || {};

infChart.shortLineDrawing = function () {
    this.correctionFactor = 500;
    infChart.drawingObject.apply(this, arguments);

    this.linetheme = {
        fill: '#336699',
        stroke: '#ffffff',
        fontColor: "#ffffff"
    };

    this.labelProperties = {
        'stroke-linecap': 'butt',
        'stroke-linejoin': 'miter',
        'stroke-opacity': 1,
        'hAlign': 'center',
        'height': 14,
        'class': 'drawing-line-axis-lbl',
        'padding': 6,
    };

    this.mainIcon = "<img style = 'width : 12px; height : 12px;' src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI3LjEuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxMjAwIDEyMDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDEyMDAgMTIwMDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOiM2QUJBNUU7fQoJLnN0MXtmaWxsOiNGRjRENEQ7fQo8L3N0eWxlPgo8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMTAyMS45LDUzMS43djAuNVY1MzEuN3oiLz4KPHBvbHlnb24gY2xhc3M9InN0MSIgcG9pbnRzPSIxMTYuMSwxMTk1IDg5NC4xLDExOTUgODk0LjEsOTcyLjcgMzg0LjQsOTcyLjcgMTE5NSwxNjIuMiAxMDM3LjgsNSAyMjcuMyw4MTUuNiAyMjcuMywxOTQuNyA1LDE5NC43IAoJNSwxMDcxLjkgNSwxMDgzLjkgNSwxMTk1ICIvPgo8L3N2Zz4K'/>";
    this.slThemeNameLabel = {
        fill: '#e62051',
        stroke: '#ffffff',
        fontColor: "#ffffff"
    };
    
    this.takeProfit = [
        {
            id: 'tp1',
            type: 'tp',
            displayName: 'TP 1',
            priceLineDiff: -0.03,
            lineWidth: 1,
            lineStyle: 'solid',
            theme: this.tpTheme,
            enable: false,
            lineColor: "#336699"
            
        },
        {
            id: 'tp2',
            type: 'tp',
            displayName: 'TP 2',
            priceLineDiff: -0.06,
            lineWidth: 1,
            lineStyle: 'solid',
            theme: this.tpTheme,
            enable: false,
            lineColor: "#336699"
           
        },
        {
            id: 'tp3',
            type: 'tp',
            displayName: 'TP 3',
            priceLineDiff: -0.09,
            lineWidth: 1,
            lineStyle: 'solid',
            theme: this.tpTheme,
            enable: false,
            lineColor: "#336699"
            
        }
    ],
    this.stopLoss = [
        {
            id: 'sl1',
            type: 'sl',
            displayName: 'SL 1',
            priceLineDiff: 0.03,
            lineWidth: 1,
            lineStyle: 'solid',
            theme: this.slTheme,
            enable: false,
            lineColor: "#336699"
            
        },
        {
            id: 'sl2',
            type: 'sl',
            displayName: 'SL 2',
            priceLineDiff: 0.06,
            lineWidth: 1,
            lineStyle: 'solid',
            theme: this.slTheme,
            enable: false,
            lineColor: "#336699"
            
        },
        {
            id: 'sl3',
            type: 'sl',
            displayName: 'SL 3',
            priceLineDiff: 0.09,
            lineWidth: 1,
            lineStyle: 'solid',
            theme: this.slTheme,
            enable: false,
            lineColor: "#336699"
        }

    ];
    this.deselectAllDrawingsInAdditionalDrawingSelect = true;
};

infChart.shortLineDrawing.prototype = Object.create(infChart.drawingObject.prototype);
infChart.shortLineDrawing.prototype.additionalDrawingsFunction = function () {
    var drawingObject = this,
        ann = drawingObject.annotation,
        additionalDrawingsArr = drawingObject.additionalDrawings,
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        height = 14,
        padding = 6,
        top,
        theme = {
            'zIndex': 20,
            'padding': padding,
            'r': 1,
            'stroke-width': 1,
            'stroke-linecap': 'butt',
            'stroke-linejoin': 'miter',
            'stroke-opacity': 1,
            'hAlign': 'center',
            'height': height,
            'class': 'drawing-line-axis-lbl',
            'fontWeight': 100,
            'x': xAxis.width
        };

    if (infChart.drawingUtils.common.theme && infChart.drawingUtils.common.theme.shortLineAxisLabel) {
        theme = infChart.util.merge(theme, infChart.drawingUtils.common.theme.shortLineAxisLabel);
    }

    top = - (theme.height / 2 + theme.padding);
    ann.options.xLabelPadding = theme.padding;

    var drawingLineAttr = {
        'stroke-width': 1,
        'fill': 'none',
        'stroke': options.shape.params.stroke || theme && theme.stroke || infChart.drawingUtils.common.baseBorderColor,
    };

    var value = this.getPriceLineLabelFormattedValue(options.yValue);
    var lineLabel = chart.renderer.label(infChart.drawingUtils.common.getYValue.call(this, value), 0, top).attr(theme).css({color: theme.fontColor}).add(ann.group);
    var hiddenLevels = [];

    additionalDrawingsArr.tpPriceLines = {};
    additionalDrawingsArr.tpPriceLineLabels = {};
    additionalDrawingsArr.slPriceLines = {};
    additionalDrawingsArr.slPriceLineLabels = {};
    additionalDrawingsArr.tpPriceLineTagLabels = {};
    additionalDrawingsArr.slPriceLineTagLabels = {};
    additionalDrawingsArr.mainTypeLabel = {};
    additionalDrawingsArr.tpSelectionMarkers = {};
    additionalDrawingsArr.slSelectionMarkers = {};

    options.takeProfit.forEach(function(priceLineLevel) {
        if(!priceLineLevel.enable){
            hiddenLevels.push(priceLineLevel.id);
        }
        drawingLineAttr.stroke = priceLineLevel.lineColor;
        drawingLineAttr.dashstyle = priceLineLevel.lineStyle;
        //drawingLineAttr.lineColor = priceLineLevel.lineColor;
        drawingLineAttr["stroke-width"] = priceLineLevel.lineWidth;

        var line = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingLineAttr).add(ann.group);
        var selectionMarker = infChart.drawingUtils.common.addAdditionalDrawingSelectionMarker.call(drawingObject, ann, chart, 0, 0, {type:"additionalDrawing", level:priceLineLevel.id});
        additionalDrawingsArr.tpSelectionMarkers[priceLineLevel.id] = selectionMarker;
        line.priceLineDiff = priceLineLevel.priceLineDiff;
        
        var takeProfitTheme = infChart.util.merge({}, infChart.drawingUtils.common.theme.shortLineAxisLabel.takeProfit);
        var takeProfitLabelDrawingAttr = infChart.util.merge({}, drawingObject.labelProperties, {fill: takeProfitTheme.lineLabel.fill, 'stroke-width': takeProfitTheme.lineLabel['stroke-width'], stroke: takeProfitTheme.lineLabel.stroke });
        
        var lineLabel = chart.renderer.label(infChart.drawingUtils.common.getYValue.call(drawingObject, value), 0, top)
            .css({
                color: takeProfitTheme.lineLabel.color
            })    
            .attr(
                takeProfitLabelDrawingAttr
            )
            .add(ann.group);

        var takeProfitTagLabelDrawingAttr = infChart.util.merge({}, drawingObject.labelProperties, {fill: takeProfitTheme.lineTagLabel.fill, 'stroke-width': takeProfitTheme.lineTagLabel['stroke-width'], stroke: takeProfitTheme.lineTagLabel.stroke});
        var lineTagLabel = chart.renderer.label("TP", 0, top)
            .attr(
                takeProfitTagLabelDrawingAttr
            )
            .css({
                color: takeProfitTheme.lineTagLabel.color
            })
            .add(ann.group);
        lineLabel.priceLineDiff = priceLineLevel.priceLineDiff;
        lineLabel.id = priceLineLevel.id;
        line.attr({
            dashstyle: 'solid'
        });

        additionalDrawingsArr.tpPriceLines[priceLineLevel.id] = line;
        additionalDrawingsArr.tpPriceLineLabels[priceLineLevel.id] = lineLabel;
        additionalDrawingsArr.tpPriceLineTagLabels[priceLineLevel.id] = lineTagLabel;

        if(!priceLineLevel.enable){
            additionalDrawingsArr.tpPriceLines[priceLineLevel.id].hide();
            additionalDrawingsArr.tpPriceLineLabels[priceLineLevel.id].hide();
            additionalDrawingsArr.tpPriceLineTagLabels[priceLineLevel.id].hide();
            additionalDrawingsArr.tpSelectionMarkers[priceLineLevel.id].hide();
        }
    });

    options.stopLoss.forEach(function(priceLineLevel) {

        if(!priceLineLevel.enable){
            hiddenLevels.push(priceLineLevel.id);
        }
        drawingLineAttr.stroke = priceLineLevel.lineColor;
        drawingLineAttr.dashstyle = priceLineLevel.lineStyle;
        drawingLineAttr["stroke-width"] = priceLineLevel.lineWidth;

        var line = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingLineAttr).add(ann.group);
        var selectionMarker = infChart.drawingUtils.common.addAdditionalDrawingSelectionMarker.call(drawingObject, ann, chart, 0, 0, {type:"additionalDrawing", level:priceLineLevel.id});
        additionalDrawingsArr.slSelectionMarkers[priceLineLevel.id] = selectionMarker;
        line.priceLineDiff = priceLineLevel.priceLineDiff;

        var stopLossTheme = infChart.util.merge({}, infChart.drawingUtils.common.theme.shortLineAxisLabel.stoploss);
        var stopLossLabelDrawingAttr = infChart.util.merge({}, drawingObject.labelProperties, {fill: stopLossTheme.lineLabel.fill, 'stroke-width': stopLossTheme.lineLabel['stroke-width'], stroke: stopLossTheme.lineLabel.stroke});
        var lineLabel = chart.renderer.label(infChart.drawingUtils.common.getYValue.call(drawingObject, value), 0, top)
        .css({
            color: stopLossTheme.lineLabel.color
        })    
        .attr(
            stopLossLabelDrawingAttr
        )
        .add(ann.group);

        var stopLossTagLabelDrawingAttr = infChart.util.merge({}, drawingObject.labelProperties, {fill: stopLossTheme.lineTagLabel.fill, 'stroke-width': stopLossTheme.lineTagLabel['stroke-width'], stroke: stopLossTheme.lineTagLabel.stroke});
        var lineTagLabel = chart.renderer.label("SL", 0, top)
        .attr(           
            stopLossTagLabelDrawingAttr
        )
        .css({
            color: stopLossTheme.lineTagLabel.color
        })
        .add(ann.group);
        lineLabel.priceLineDiff = priceLineLevel.priceLineDiff;
        lineLabel.id = priceLineLevel.id;

        additionalDrawingsArr.slPriceLines[priceLineLevel.id] = line;
        additionalDrawingsArr.slPriceLineLabels[priceLineLevel.id] = lineLabel;
        additionalDrawingsArr.slPriceLineTagLabels[priceLineLevel.id] = lineTagLabel;

        if(!priceLineLevel.enable){
            additionalDrawingsArr.slPriceLines[priceLineLevel.id].hide();
            additionalDrawingsArr.slPriceLineLabels[priceLineLevel.id].hide();
            additionalDrawingsArr.slPriceLineTagLabels[priceLineLevel.id].hide();
            additionalDrawingsArr.slSelectionMarkers[priceLineLevel.id].hide();
        }
    });

    var mainTypeLabelTheme = infChart.util.merge({}, infChart.drawingUtils.common.theme.shortLineAxisLabel.mainTypeLabel);

    additionalDrawingsArr.mainTypeLabel = chart.renderer.createElement('foreignObject').add(ann.group)
    .css(
        mainTypeLabelTheme.foreignObject
    )
    .attr({
        width: '26',
        height: '26',
        rel: 'mainType'
    })
    .add(ann.group);
    var labelHtml = "<div style='display: flex; align-items: center; justify-content: center; border-color:" + mainTypeLabelTheme.insideIcon.stroke + "; border-width:" + mainTypeLabelTheme.insideIcon['stroke-width'] + "; border-style:" + mainTypeLabelTheme.insideIcon['border-style'] + "; height: 100%;'>" + drawingObject.mainIcon + "</div>";
    additionalDrawingsArr.mainTypeLabel.element.innerHTML = labelHtml;

    drawingObject.additionalDrawings['lineLabel'] = lineLabel;

    if (chart.axisOffset[yAxis.side] < lineLabel.width) {
        yAxis.isDirty = true; // need to change the axis offset in the chart
        this.chartRedrawRequired = true;
    }
    ann.group.addClass("line-drawing");
    // bringing the label's group front to avoid overlapping with the axis labels
    infChart.drawingUtils.common.getAxisLabelToFront.call(this, lineLabel);
    if (!ann.selectionMarker) {
        ann.selectionMarker = [];
        infChart.drawingUtils.common.addSelectionMarker.call(this, ann, (xAxis.width) *3/4 - xAxis.toPixels(options.xValue), 0);
    }
};

infChart.shortLineDrawing.prototype.deselect = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        additionalDrawings = self.additionalDrawings;
    self.annotation.selectionMarker = [];
    infChart.util.forEach(additionalDrawings.tpSelectionMarkers, function(index , value){
            additionalDrawings.tpSelectionMarkers[index].hide();
    });

    infChart.util.forEach(additionalDrawings.slSelectionMarkers, function(index , value){
                additionalDrawings.slSelectionMarkers[index].hide();
    });
    self.additionalLevelSelected = undefined;
};

infChart.shortLineDrawing.prototype.bindSettingsEvents = function () {
    return infChart.drawingUtils.common.bindShortLongLineSettingsEvents.call(this, infChart.drawingUtils.common.baseBorderColor);
};

infChart.shortLineDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    return {
        shape: 'shortLine',
        borderColor: infChart.themeManager.getDrawingsBorderColor(annotation.options.shape.params.stroke, 'shortLine'),
        fillColor: infChart.themeManager.getDrawingsFillColor(annotation.options.shape.params.fill, 'shortLine'),
        strokeWidth: annotation.options.shape.params['stroke-width'],
        dashStyle: annotation.options.shape.params.dashstyle,
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        clickCords: annotation.options.clickCords,
        width: annotation.chart.plotWidth,
        text: annotation.options.lineText,
        takeProfit: annotation.options.takeProfit,
        stopLoss: annotation.options.stopLoss,
        isLocked : annotation.options.isLocked

    };
};

/**
 * Returns the obj of properties to copy
 * @returns {object} properties
 */
infChart.shortLineDrawing.prototype.getConfigToCopy = function () {
    var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(this.annotation.chart);
    var chartInstance = infChart.manager.getChart(stockChartId);
    var yAxis = chartInstance.getMainYAxis();
    var properties = this.getConfig();
    var shapeTheme = infChart.drawingUtils.common.theme.horizontalLine;
    var copyDistance = shapeTheme && shapeTheme.copyDistance ? shapeTheme.copyDistance.y : infChart.drawingUtils.common.theme.defaultCopyDistance;

    properties.yValue = yAxis.toValue(yAxis.toPixels(properties.yValue) + copyDistance);
    return properties;
};

infChart.shortLineDrawing.prototype.getPriceLineLabelFormattedValue = function (yValue) {
    var stockChart = this.stockChart;
    var value;
    if (stockChart.isPercent) {
        value = stockChart.getYLabel(yValue, true, false, false);
    } else {
        value = stockChart.formatValue(yValue, stockChart.getMainSeries().options.dp);
    }
    return value;
};

infChart.shortLineDrawing.prototype.getOptions = function (properties) {
    var self = this;
    var options = {
        utilizeAxes: "y", // since label is drawn in the yAxis
        xValue: properties.xValue,
        yValue: parseFloat(properties.yValue),
        allowDragX: false,
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0],
                dashstyle: 'solid',
                stroke: '#FF4D4D',
                'class': "horizontal-line"
            }
        }
    };

    if (properties.takeProfit) {
        options.takeProfit = properties.takeProfit;
        infChart.util.forEach(options.takeProfit, function(index , value){
            value.yValue = infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue + options.yValue * value.priceLineDiff)
        });
    } else {
        options.takeProfit = [];
        infChart.util.forEach(this.takeProfit, function(index , value){
            options.takeProfit.push({
                id: value.id,
                yValue: infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue + options.yValue * value.priceLineDiff), //infChart.drawingUtils.common.getYValue.call(self, options.yValue + options.yValue * value.priceLineDiff),
                lineWidth: value.lineWidth,
                lineStyle: value.lineStyle,
                priceLineDiff: value.priceLineDiff,
                enable: value.enable,
                lineColor: value.lineColor
            });
        });
    }
    if (properties.stopLoss) {
        options.stopLoss = properties.stopLoss;
        infChart.util.forEach(options.stopLoss, function(index , value){
            value.yValue = infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue + options.yValue * value.priceLineDiff)
        });
    } else{
        options.stopLoss = [];
        infChart.util.forEach(this.stopLoss, function(index , value){
            options.stopLoss.push({
                id: value.id,
                yValue: infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue + options.yValue * value.priceLineDiff),//infChart.drawingUtils.common.getYValue.call(self, options.yValue + options.yValue * value.priceLineDiff),
                lineWidth: value.lineWidth,
                lineStyle: value.lineStyle,
                priceLineDiff: value.priceLineDiff,
                enable: value.enable,
                lineColor: value.lineColor
            });
        });
    }
    if(properties.text){
        options.lineText = properties.text;
        options.allowDragY = false;
        options.disableCopyPaste = true;
        this.disableQuickSettingPanel = true;
    }
    if (properties.width) {
        options.shape.params.d = ['M', 0, 0, 'L', properties.width * 1.5, 0];
    }
    if (properties.clickCords) {
        options.clickCords = properties.clickCords;
    }
    if (properties.fillColor) {
        options.shape.params.fill = properties.fillColor;
    }
    if (properties.borderColor) {
        options.shape.params.stroke = properties.borderColor;
    }
    if (properties.dashStyle) {
        options.shape.params.dashstyle = properties.dashStyle;
    }
    if (properties.strokeWidth) {
        options.shape.params['stroke-width'] = properties.strokeWidth;
    }
    options.isRealTimeTranslation = true; // since label value is needed to be changed

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.shortLineDrawing.prototype.getQuickSettingsPopup = function () {
    return infChart.drawingUtils.common.getPriceLineQuickSettings();
};

infChart.shortLineDrawing.prototype.getSettingsPopup = function () {
    return infChart.drawingUtils.common.getPriceLineSettings(this.annotation.options.takeProfit, this.annotation.options.stopLoss, this.annotation.options.yValue);
};

infChart.shortLineDrawing.prototype.isRequiredProperty = function (propertyId, reset) {
    var isPositionProperty = false;

    switch (propertyId) {
        case "yValue":
        case "yValueEnd":
        case "xValue":
        case "xValueEnd":
        case "text":
        case "isLocked":
            isPositionProperty = true;
            break;
        default :
            break;
    }

    return isPositionProperty;
};

infChart.shortLineDrawing.prototype.scale = function () {
    var drawingObject = this,
        ann = this.annotation,
        chart = ann.chart,
        options = ann.options,
        line = ann.shape.d.split(' '),
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        label = this.additionalDrawings['lineLabel'],
        tpPriceLines = this.additionalDrawings.tpPriceLines,
        tpPriceLineLabels = this.additionalDrawings.tpPriceLineLabels,
        tpPriceLineTagLabels = this.additionalDrawings.tpPriceLineTagLabels,
        slPriceLines = this.additionalDrawings.slPriceLines,
        slPriceLineLabels = this.additionalDrawings.slPriceLineLabels,
        slPriceLineTagLabels = this.additionalDrawings.slPriceLineTagLabels,
        tpSelectionMarkers = this.additionalDrawings.tpSelectionMarkers,
        slSelectionMarkers = this.additionalDrawings.slSelectionMarkers,
        stockChart = this.stockChart;

    line[1] = - this.correctionFactor; 
    var firstCandle = xAxis.toPixels(chart.series[0].points[0].x); //distance to the first candle from chart start
    line[4] = xAxis.width - firstCandle; // line should be ended inside the plot area. Otherwise it will be shown in the yAxis some times
    
    ann.update({
        xValue: chart.series[0].points[0].x,
        shape: {
            params: {
                d: line
            }
        }
    });

    drawingObject.additionalDrawings.mainTypeLabel.attr({
        x: chart.plotLeft - firstCandle,
        y: - drawingObject.additionalDrawings.mainTypeLabel.getBBox().height/2,// xAxis.width - firstCandle,
        zIndex: 20,
        'type': "mainDrawing"
    });

    label.attr({
        text: stockChart.formatValue(parseFloat(infChart.drawingUtils.common.getBaseYValues.call(drawingObject, options.yValue)).toFixed(3), stockChart.getMainSeries().options.dp),
        x: chart.plotLeft - firstCandle + drawingObject.additionalDrawings.mainTypeLabel.getBBox().width,
        zIndex: 20,
        'type': "mainDrawing"
    });

    $.each(tpPriceLines, function (id, priceLine) {

        var level = options.takeProfit.find(function(takeProfit) {
            return takeProfit.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        var newX = -drawingObject.correctionFactor;
        priceLine.attr({
            d: ['M', newX, newY, 'L', xAxis.width - firstCandle, newY]
        }); 
    });

    $.each(tpSelectionMarkers, function(id, selectionMarker){
        var level = options.takeProfit.find(function(takeProfit) {
            return takeProfit.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        var newX = (xAxis.width) * 3/4 - xAxis.toPixels(options.xValue);
        selectionMarker.attr({
            'cx': newX,
            'cy': newY
        });
    });

    $.each(tpPriceLineTagLabels, function (id, priceLineTagLabel) {

        var level = options.takeProfit.find(function(takeProfit) {
            return takeProfit.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        priceLineTagLabel.attr({
            text: infChart.manager.getLabel("label." + level.id + ""),
            x: chart.plotLeft - firstCandle,
            y: newY - priceLineTagLabel.height/2,
            zIndex: 20,
            'type': "additionalDrawing",
            'level': level.id
        });
    });

    var tagLabelWidth = Object.values(tpPriceLineTagLabels)[0].width;


    $.each(tpPriceLineLabels, function (id, priceLineLabel) {

        var level = options.takeProfit.find(function(takeProfit) {
            return takeProfit.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        priceLineLabel.attr({
            text: stockChart.formatValue((parseFloat(level.yValue)).toFixed(3), stockChart.getMainSeries().options.dp),
            x: (chart.plotLeft - firstCandle) + tagLabelWidth,
            y: newY - priceLineLabel.height/2,
            zIndex: 20,
            'type': "additionalDrawing",
            'level': level.id
        });
    });

    $.each(slPriceLines, function (id, priceLine) {
        
        var level = options.stopLoss.find(function(stopLoss) {
            return stopLoss.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        var newX = -drawingObject.correctionFactor;
        priceLine.attr({
            d: ['M', newX, newY, 'L', xAxis.width - firstCandle, newY]
        }); 
    });

    $.each(slSelectionMarkers, function(id, selectionMarker){
        var level = options.stopLoss.find(function(stopLoss) {
            return stopLoss.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        var newX = (xAxis.width) * 3/4 - xAxis.toPixels(options.xValue);
        selectionMarker.attr({
            'cx': newX,
            'cy': newY
        });
    });

    $.each(slPriceLineTagLabels, function (id, priceLineTagLabel) {

        var level = options.stopLoss.find(function(stopLoss) {
            return stopLoss.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        priceLineTagLabel.attr({
            text: infChart.manager.getLabel("label." + level.id + ""),
            x: chart.plotLeft - firstCandle,
            y: newY - priceLineTagLabel.height/2,
            zIndex: 20,
            'type': "additionalDrawing",
            'level': level.id
        });
    });

    var tagLabelWidth = Object.values(slPriceLineTagLabels)[0].width;

    $.each(slPriceLineLabels, function (id, priceLineLabel) {

        var level = options.stopLoss.find(function(stopLoss) {
            return stopLoss.id == id
        });

        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        priceLineLabel.attr({
            text: stockChart.formatValue((parseFloat(level.yValue)).toFixed(3), stockChart.getMainSeries().options.dp),
            x: (chart.plotLeft - firstCandle) + tagLabelWidth,
            y: newY - priceLineLabel.height/2,
            zIndex: 20,
            'type': "additionalDrawing",
            'level': level.id
        });
    });

    if(!drawingObject.additionalLevelSelected){
        if(ann.selectionMarker[0]){
            var newX = (xAxis.width) * 3/4 - xAxis.toPixels(options.xValue);
            ann.selectionMarker[0].attr({
                'cx': newX
            });
        }
    }

    infChart.drawingUtils.common.getAxisLabelToFront.call(this, label);
    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    var customAttributes = {
        'type': "mainDrawing",
        'stroke-width': 10
    } 
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, ["M", 0, 0, 'L', line[4], line[5]], this.dragSupporters, customAttributes);

    $.each(tpPriceLines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'type': "additionalDrawing",
                'stroke-width': 10
            }            
            var dragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', 'z-index': 20});
            infChart.drawingUtils.common.addDragSupporters.call(drawingObject, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], drawingObject.dragSupporters, customAttributes, dragSupporterStyles);
        }
    });

    $.each(slPriceLines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'type': "additionalDrawing",
                'stroke-width': 10
            }            
            var dragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', 'z-index': 20});
            infChart.drawingUtils.common.addDragSupporters.call(drawingObject, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], drawingObject.dragSupporters, customAttributes, dragSupporterStyles);
        }
    });

};

infChart.shortLineDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis];
    if (!ann.selectionMarker) {
        ann.selectionMarker = [];
        infChart.drawingUtils.common.addSelectionMarker.call(this, ann, (xAxis.width)*3/4 - xAxis.toPixels(options.xValue), 0);
    }
};

infChart.shortLineDrawing.prototype.step = function () { };

infChart.shortLineDrawing.prototype.stop = function (e) {
    var drawingObject = this,
        ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        x = e.chartX,
        y = e.chartY,
        plotWidth = chart.plotWidth * 1.5,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        label = this.additionalDrawings['lineLabel'],
        tpPriceLines = this.additionalDrawings.tpPriceLines,
        tpPriceLineLabels = this.additionalDrawings.tpPriceLineLabels,
        tpPriceLineTagLabels = this.additionalDrawings.tpPriceLineTagLabels,
        slPriceLines = this.additionalDrawings.slPriceLines,
        slPriceLineLabels = this.additionalDrawings.slPriceLineLabels,
        slPriceLineTagLabels = this.additionalDrawings.slPriceLineTagLabels,
        tpSelectionMarkers = this.additionalDrawings.tpSelectionMarkers,
        slSelectionMarkers = this.additionalDrawings.slSelectionMarkers,
        stockChart = this.stockChart,
        line = ["M", 0, 0, 'L', xAxis.width, 0];

        line[1] = - this.correctionFactor;
        var firstCandle = xAxis.toPixels(chart.series[0].points[0].x);
        line[4] = xAxis.width - firstCandle;
        
    ann.update({
        clickCords: { x: x, y: y },
        xValue: chart.series[0].points[0].x,
        shape: {
            params: {
                d: line
            }
        }
    });

    drawingObject.additionalDrawings.mainTypeLabel.attr({
        x: chart.plotLeft - firstCandle,
        y: - drawingObject.additionalDrawings.mainTypeLabel.getBBox().height/2,// xAxis.width - firstCandle,
        zIndex: 20,
        'type': "mainDrawing"
    });

    label.attr({
        text: stockChart.formatValue(parseFloat(infChart.drawingUtils.common.getBaseYValues.call(drawingObject, options.yValue)).toFixed(3), stockChart.getMainSeries().options.dp),
        x: chart.plotLeft - firstCandle + drawingObject.additionalDrawings.mainTypeLabel.getBBox().width,
        zIndex: 20,
        'type': "mainDrawing"
    });


    $.each(tpPriceLines, function (id, priceLine) {

        var level = options.takeProfit.find(function(takeProfit) {
            return takeProfit.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        var newX = -drawingObject.correctionFactor;
        priceLine.attr({
            d: ['M', newX, newY, 'L', xAxis.width - firstCandle, newY]
        }); 
    });

    $.each(tpSelectionMarkers, function(id, selectionMarker){
        var level = options.takeProfit.find(function(takeProfit) {
            return takeProfit.id == id
        });
        var newX = (xAxis.width) * 3/4 - xAxis.toPixels(options.xValue);
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        selectionMarker.attr({
            'cx': newX,
            'cy': newY
        });
    });

    $.each(tpPriceLineTagLabels, function (id, priceLineTagLabel) {

        var level = options.takeProfit.find(function(takeProfit) {         
            return takeProfit.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        priceLineTagLabel.attr({
            text: infChart.manager.getLabel("label." + level.id + "") ,
            x: chart.plotLeft - firstCandle,
            y: newY - priceLineTagLabel.height/2,
            zIndex:20,
            'type': "additionalDrawing",
            'level': level.id
        });
    });

    var tagLabelWidth = Object.values(tpPriceLineTagLabels)[0].width;

    $.each(tpPriceLineLabels, function (id, priceLineLabel) {

        var level = options.takeProfit.find(function(takeProfit) {
            return takeProfit.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        priceLineLabel.attr({
            text: stockChart.formatValue((parseFloat(level.yValue)).toFixed(3), stockChart.getMainSeries().options.dp),
            x: (chart.plotLeft - firstCandle) + tagLabelWidth,
            y: newY - priceLineLabel.height/2,
            zIndex: 20,
            'type': "additionalDrawing",
            'level': level.id
        });
    });

    $.each(slPriceLines, function (id, priceLine) {
        
        var level = options.stopLoss.find(function(stopLoss) {
            return stopLoss.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        var newX = -drawingObject.correctionFactor;
        priceLine.attr({
            d: ['M', newX, newY, 'L', xAxis.width - firstCandle, newY]
        }); 
    });

    $.each(slSelectionMarkers, function(id, selectionMarker){
        var level = options.stopLoss.find(function(stopLoss) {
            return stopLoss.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        var newX = (xAxis.width) * 3/4 - xAxis.toPixels(options.xValue);
        selectionMarker.attr({
            'cx': newX,
            'cy': newY
        });
    });

    $.each(slPriceLineTagLabels, function (id, priceLineTagLabel) {

        var level = options.stopLoss.find(function(stopLoss) {
            return stopLoss.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        priceLineTagLabel.attr({
            text: infChart.manager.getLabel("label." + level.id + ""),
            x: chart.plotLeft - firstCandle,
            y: newY - priceLineTagLabel.height/2,
            zIndex: 20,
            'type': "additionalDrawing",
            'level': level.id
        });
    });

    var tagLabelWidth = Object.values(slPriceLineTagLabels)[0].width;

    $.each(slPriceLineLabels, function (id, priceLineLabel) {

        var level = options.stopLoss.find(function(stopLoss) {
            return stopLoss.id == id
        });

        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        priceLineLabel.attr({
            text: stockChart.formatValue((parseFloat(level.yValue)).toFixed(3), stockChart.getMainSeries().options.dp),
            x: (chart.plotLeft - firstCandle) + tagLabelWidth,
            y: newY - priceLineLabel.height/2,
            zIndex: 20,
            'type': "additionalDrawing",
            'level': level.id
        });
    });

    ann.group.addClass("line-drawing");

    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue);
    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    var customAttributes = {
        'type': "mainDrawing",
        'stroke-width': 10
    } 
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, ["M", 0, 0, 'L', line[4], line[5]], this.dragSupporters, customAttributes);

    $.each(tpPriceLines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level': key,
                'type': "additionalDrawing",
                'stroke-width': 10
            }            
            var dragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', 'z-index': 20});
            infChart.drawingUtils.common.addDragSupporters.call(drawingObject, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], drawingObject.dragSupporters, customAttributes, dragSupporterStyles);
        }
    });

    $.each(slPriceLines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'type': "additionalDrawing",
                'stroke-width': 10
            }            
            var dragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', 'z-index': 20});
            infChart.drawingUtils.common.addDragSupporters.call(drawingObject, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], drawingObject.dragSupporters, customAttributes, dragSupporterStyles);
        }
    });

    if(ann.selectionMarker[0]){
        var newX = (xAxis.width) * 3/4 - xAxis.toPixels(options.xValue);
        ann.selectionMarker[0].attr({
            'cx': newX
        });
    }
    infChart.drawingUtils.common.onPropertyChange.call(this);
    if(infChart.drawingsManager.getIsActiveDrawingInprogress()){
        drawingObject.initialSettingPanelLoad = true;
    }
    return line;
};

infChart.shortLineDrawing.prototype.openSettingPanel = function () {
    var drawingObj = this;
    if (drawingObj.isQuickSetting) {
        infChart.drawingUtils.common.toggleSettings.call(drawingObj);
    }
};

infChart.shortLineDrawing.prototype.translate = function (event) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        line = ann.shape.d.split(' '),
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        tpPriceLines = this.additionalDrawings.tpPriceLines,
        slPriceLines = this.additionalDrawings.slPriceLines;

    if (options.selectedDrawing == "mainDrawing" || options.selectedDrawing == undefined) {
        infChart.util.forEach(options.takeProfit, function(index , value){
            if(!value.enable){
                value.yValue = infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue) + infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue) * value.priceLineDiff;
            }
        });
        infChart.util.forEach(options.stopLoss, function(index , value){
            if(!value.enable){
                value.yValue = infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue) + infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue) * value.priceLineDiff;
            }
        });
        this.scale();
    }
    if (options.selectedDrawing == 'tp1'||options.selectedDrawing == 'tp2'||options.selectedDrawing == 'tp3'|| options.selectedDrawing == 'sl1'||options.selectedDrawing == 'sl2'||options.selectedDrawing == 'sl3') {

        var yValue = yAxis.toValue(event.chartY);

        ann.update({
            yValue: options.yValueStore
        });

        self.updateAdditionalDrawing(options.selectedDrawing, yValue);
    }

    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    var customAttributes = {
        'type': "mainDrawing",
        'stroke-width': 10
    } 
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ["M", line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes);

    $.each(tpPriceLines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'type': "additionalDrawing",
                'stroke-width': 10
            }            
            var dragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', 'z-index': 20});
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, dragSupporterStyles);
        }
    });

    $.each(slPriceLines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'type': "additionalDrawing",
                'stroke-width': 10
            }            
            var dragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', 'z-index': 20});
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, dragSupporterStyles);
        }
    });
};

infChart.shortLineDrawing.prototype.updateAdditionalDrawing = function(selectedDrawing, yValue){
    var self = this,
        ann = self.annotation,
        options = ann.options
        chart = ann.chart,
        stockChart = this.stockChart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];
        if(selectedDrawing == 'tp1' || selectedDrawing == 'tp2' || selectedDrawing == 'tp3'){
            level = options.takeProfit.find( function(level) {
                if(level.id == selectedDrawing){
                    level.yValue = infChart.drawingUtils.common.getBaseYValues.call(self, yValue);//yValue;
                    return level;
                }
            });
        }
        if(selectedDrawing == 'sl1' || selectedDrawing == 'sl2' || selectedDrawing == 'sl3'){
            level = options.stopLoss.find( function(level) {
                if(level.id == selectedDrawing){
                    level.yValue = infChart.drawingUtils.common.getBaseYValues.call(self, yValue);
                    return level;
                }
            });
        }
        if(level.id == 'tp1' || level.id == 'tp2' || level.id == 'tp3'){
            var priceline = self.additionalDrawings.tpPriceLines[level.id];
            var lineLabel = self.additionalDrawings.tpPriceLineLabels[level.id];
            var lineTagLabel = self.additionalDrawings.tpPriceLineTagLabels[level.id];
            var selectionMarker = this.additionalDrawings.tpSelectionMarkers[level.id];
        }
        if(level.id == 'sl1' || level.id == 'sl2' || level.id == 'sl3'){
            var priceline = self.additionalDrawings.slPriceLines[level.id];
            var lineLabel = self.additionalDrawings.slPriceLineLabels[level.id];
            var lineTagLabel = self.additionalDrawings.slPriceLineTagLabels[level.id];
            var selectionMarker = this.additionalDrawings.slSelectionMarkers[level.id];
        }
    
        var line = priceline.d.split(' ');
        var newY = yAxis.toPixels(yValue) - yAxis.toPixels(options.yValue);
        priceline.attr({
            d: ['M', line[1], newY, 'L', line[4], newY]
        }); 
        lineLabel.attr({
            text: stockChart.formatValue((parseFloat(level.yValue)).toFixed(3), stockChart.getMainSeries().options.dp),
            y: newY - lineTagLabel.height/2,
        });
        lineTagLabel.attr({
            y: newY - lineTagLabel.height/2,
        }); 
        selectionMarker.attr({
            'cy': newY
        });
};

infChart.shortLineDrawing.prototype.translateEnd = function () {
    var self = this,
        ann = self.annotation
        options = ann.options;
    self.scale();
    self.annotation.options.selectedDrawing = undefined;
    infChart.drawingUtils.common.saveBaseYValues.call(self, options.yValue, options.yValueEnd);
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.shortLineDrawing.prototype.updateSettings = function (properties) {
    var self = this,
        ann = self.annotation,
        options = ann. options;
        // var takeProfitValues = [];
        // infChart.util.forEach(properties.takeProfit, function(index , value){
        //     takeProfitValues.push({
        //         id: value.id,
        //         yValue: infChart.drawingUtils.common.getYValue.call(self, value.yValue),
        //         lineWidth: value.lineWidth,
        //         lineStyle: value.lineStyle,
        //         enable: value.enable
        //     });
        // });

        // var stopLossValues = [];
        // infChart.util.forEach(properties.stopLoss, function(index , value){
        //     stopLossValues.push({
        //         id: value.id,
        //         yValue: infChart.drawingUtils.common.getYValue.call(self, value.yValue),
        //         lineWidth: value.lineWidth,
        //         lineStyle: value.lineStyle,
        //         enable: value.enable
        //     });
        // });
    infChart.structureManager.drawingTools.updatePriceLineSettings(this.settingsPopup, properties.takeProfit, properties.stopLoss, infChart.drawingUtils.common.getBaseYValues.call(self, properties.yValue));
};

infChart.shortLineDrawing.prototype.select = function (event) {
    var self = this,
        ann = self.annotation,
        options = ann.options;

    if (event && event.target) {
        var drawingtype = event.target.getAttribute('type');
        if (drawingtype && drawingtype == "additionalDrawing") {
            var level = event.target.getAttribute('level');
            if(level){
                options.selectedDrawing = level;
            }
        } else if(drawingtype && drawingtype == "mainDrawing") {
            options.selectedDrawing = "mainDrawing"; 
        }else{
            var type = event.target.parentElement.getAttribute('type');
            if(type == "additionalDrawing"){
                var level = event.target.parentElement.getAttribute('level'); 
                if(level){
                    options.selectedDrawing = level;
                }
            }else if (type == "mainDrawing"){
                options.selectedDrawing = "mainDrawing";
            }else{
                var type = event.target.parentElement.parentElement.getAttribute('type');
                if(type == "additionalDrawing"){
                    var level = event.target.parentElement.parentElement.getAttribute('level'); 
                    if(level){
                        options.selectedDrawing = level;
                    }
                }else{
                    options.selectedDrawing = undefined;
                }
            }
        }
    }
    if(options.selectedDrawing){
        self.showSelectionMarker(options.selectedDrawing);
        self.getLineToFront(options.selectedDrawing);
        infChart.drawingsManager.deselectDrawingTools(self.stockChart.id ,self.drawingId);
    }
};

infChart.shortLineDrawing.prototype.showSelectionMarker = function(level){
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        additionalDrawings = self.additionalDrawings;

    if (level == "tp1" || level == "tp2" || level == "tp3") {
        var newX = (xAxis.width) * 3/4 - xAxis.toPixels(options.xValue);
        additionalDrawings.tpSelectionMarkers[level].attr({
            'cx': newX
        });
        additionalDrawings.tpSelectionMarkers[level].show();
        self.additionalLevelSelected = true;
        if(ann.selectionMarker[0]){
            ann.selectionMarker[0].hide();
        }
    } else if (level == "sl1" || level == "sl2" || level == "sl3") {
        var newX = (xAxis.width) * 3/4 - xAxis.toPixels(options.xValue);
        additionalDrawings.slSelectionMarkers[level].attr({
            'cx': newX
        });
        additionalDrawings.slSelectionMarkers[level].show();
        self.additionalLevelSelected = true;
        if(ann.selectionMarker[0]){
            ann.selectionMarker[0].hide();
        }
    } else {
        self.additionalLevelSelected = false;
        if(ann.selectionMarker[0]){
            ann.selectionMarker[0].show();
        }
    }

    infChart.util.forEach(additionalDrawings.tpSelectionMarkers, function(index , value){
        if(level && level != index){
            if(additionalDrawings.tpSelectionMarkers[index]){
                additionalDrawings.tpSelectionMarkers[index].hide();
            }
        }
    });

    infChart.util.forEach(additionalDrawings.slSelectionMarkers, function(index , value){
        if(level && level != index){
            if(additionalDrawings.slSelectionMarkers[index]){
                additionalDrawings.slSelectionMarkers[index].hide();
            }
        }
    });
};

infChart.shortLineDrawing.prototype.getLineToFront = function(level){
    var self = this,
        ann = self.annotation,
        options = ann.options,
        additionalDrawings = self.additionalDrawings,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis];

    if (level == "tp1" || level == "tp2" || level == "tp3") {
        additionalDrawings.tpPriceLines[level].toFront();
        additionalDrawings.tpPriceLineTagLabels[level].toFront();
        additionalDrawings.tpPriceLineLabels[level].toFront();
        additionalDrawings.tpSelectionMarkers[level].toFront();
    } else if (level == "sl1" || level == "sl2" || level == "sl3") {
        additionalDrawings.slPriceLines[level].toFront();
        additionalDrawings.slPriceLineTagLabels[level].toFront();
        additionalDrawings.slPriceLineLabels[level].toFront();
        additionalDrawings.slSelectionMarkers[level].toFront();
    } else {
        ann.shape.toFront(); 
        if(ann.selectionMarker[0]){
            ann.selectionMarker[0].toFront();
        }else{
            ann.selectionMarker = [];
            infChart.drawingUtils.common.addSelectionMarker.call(this, ann, (xAxis.width)*3/4 - xAxis.toPixels(options.xValue), 0);
            ann.selectionMarker[0].toFront();
        }
        additionalDrawings.lineLabel.toFront();
        additionalDrawings.mainTypeLabel.toFront();
    }
};

// infChart.shortLineDrawing.prototype.select = function () {
//     infChart.drawingUtils.common.getAxisLabelToFront.call(this, this.additionalDrawings['lineLabel']);
// };

infChart.shortLineDrawing.prototype.updateOptions = function (options) {
    var ann = this.annotation;
    if (options.stopLoss) {
        ann.options.stopLoss = options.stopLoss;
    }
    if (options.takeProfit) {
        ann.options.takeProfit = options.takeProfit;
    }
    this.updateSettings(this.getConfig());
};

infChart.shortLineDrawing.prototype.isVisibleLastLevel = function(){
    return false;
};


window.infChart = window.infChart || {};

infChart.longLineDrawing = function () {
    this.correctionFactor = 500;
    infChart.drawingObject.apply(this, arguments);

    this.linetheme = {
        fill: '#FF4D4D',
        stroke: '#ffffff',
        fontColor: "#ffffff"
    };

    this.labelProperties = {
        'stroke-linecap': 'butt',
        'stroke-linejoin': 'miter',
        'stroke-opacity': 1,
        'hAlign': 'center',
        'height': 14,
        'class': 'drawing-line-axis-lbl',
        'padding': 6,
    };

    this.mainIcon = "<img style = 'width : 12px; height : 12px;' src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI3LjEuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxMjAwIDEyMDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDEyMDAgMTIwMDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOiM2QUJBNUU7fQoJLnN0MXtmaWxsOiMzMzY2OTk7fQo8L3N0eWxlPgo8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMTAyMS45LDUzMS43djAuNVY1MzEuN3oiLz4KPHBvbHlnb24gY2xhc3M9InN0MSIgcG9pbnRzPSIxMDgzLjksNSAzMDUuOSw1IDMwNS45LDIyNy4zIDgxNS42LDIyNy4zIDUsMTAzNy44IDE2Mi4yLDExOTUgOTcyLjcsMzg0LjQgOTcyLjcsMTAwNS4zIDExOTUsMTAwNS4zIAoJMTE5NSwxMjguMSAxMTk1LDExNi4xIDExOTUsNSAiLz4KPC9zdmc+Cg=='/>";
    this.takeProfit = [
        {
            id: 'tp1',
            type: 'tp',
            displayName: 'TP 1',
            priceLineDiff: 0.03,
            lineWidth: 1,
            lineStyle: 'solid',
            theme: this.tpTheme,
            enable: false,
            lineColor: "#FF4D4D"
            
        },
        {
            id: 'tp2',
            type: 'tp',
            displayName: 'TP 2',
            priceLineDiff: 0.06,
            lineWidth: 1,
            lineStyle: 'solid',
            theme: this.tpTheme,
            enable: false,
            lineColor: "#FF4D4D"
           
        },
        {
            id: 'tp3',
            type: 'tp',
            displayName: 'TP 3',
            priceLineDiff: 0.09,
            lineWidth: 1,
            lineStyle: 'solid',
            theme: this.tpTheme,
            enable: false,
            lineColor: "#FF4D4D"
            
        }
    ],
    this.stopLoss = [
        {
            id: 'sl1',
            type: 'sl',
            displayName: 'SL 1',
            priceLineDiff: -0.03,
            lineWidth: 1,
            lineStyle: 'solid',
            theme: this.slTheme,
            enable: false,
            lineColor: "#FF4D4D"
            
        },
        {
            id: 'sl2',
            type: 'sl',
            displayName: 'SL 2',
            priceLineDiff: -0.06,
            lineWidth: 1,
            lineStyle: 'solid',
            theme: this.slTheme,
            enable: false,
            lineColor: "#FF4D4D"
            
        },
        {
            id: 'sl3',
            type: 'sl',
            displayName: 'SL 3',
            priceLineDiff: -0.09,
            lineWidth: 1,
            lineStyle: 'solid',
            theme: this.slTheme,
            enable: false,
            lineColor: "#FF4D4D"
        }

    ];
    this.deselectAllDrawingsInAdditionalDrawingSelect = true;
};

infChart.longLineDrawing.prototype = Object.create(infChart.drawingObject.prototype);
infChart.longLineDrawing.prototype.additionalDrawingsFunction = function () {
    var drawingObject = this,
        ann = drawingObject.annotation,
        additionalDrawingsArr = drawingObject.additionalDrawings,
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        height = 14,
        padding = 6,
        top,
        theme = {
            opacity: 1,
            'zIndex': 20,
            'padding': padding,
            'r': 1,
            'stroke-width': 1,
            'stroke-linecap': 'butt',
            'stroke-linejoin': 'miter',
            'stroke-opacity': 1,
            'hAlign': 'center',
            'height': height,
            'class': 'drawing-line-axis-lbl',
            'fontWeight': 100,
            'x': xAxis.width
        };

    if (infChart.drawingUtils.common.theme && infChart.drawingUtils.common.theme.longLineAxisLabel) {
        theme = infChart.util.merge(theme, infChart.drawingUtils.common.theme.longLineAxisLabel);
    }

    top = -(theme.height / 2 + theme.padding);
    ann.options.xLabelPadding = theme.padding;

    var drawingLineAttr = {
        'stroke-width': 1,
        'fill': 'none',
        'stroke': options.shape.params.stroke || theme && theme.stroke || infChart.drawingUtils.common.baseBorderColor,
    };

    var value = this.getPriceLineLabelFormattedValue(options.yValue);
    var lineLabel = chart.renderer.label(infChart.drawingUtils.common.getYValue.call(this, value), 0, top).attr(theme).css({color: theme.fontColor}).add(ann.group);
    var hiddenLevels = [];

    additionalDrawingsArr.tpPriceLines = {};
    additionalDrawingsArr.tpPriceLineLabels = {};
    additionalDrawingsArr.slPriceLines = {};
    additionalDrawingsArr.slPriceLineLabels = {};
    additionalDrawingsArr.tpPriceLineTagLabels = {};
    additionalDrawingsArr.slPriceLineTagLabels = {};
    additionalDrawingsArr.mainTypeLabel = {};
    additionalDrawingsArr.tpSelectionMarkers = {};
    additionalDrawingsArr.slSelectionMarkers = {};

    options.takeProfit.forEach(function(priceLineLevel) {

        if(!priceLineLevel.enable){
            hiddenLevels.push(priceLineLevel.id);
        }
        //drawingLineAttr.stroke = drawingObject.linetheme.fill;
        drawingLineAttr.dashstyle = priceLineLevel.lineStyle;
        drawingLineAttr.stroke = priceLineLevel.lineColor;
        drawingLineAttr["stroke-width"] = priceLineLevel.lineWidth;

        var line = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingLineAttr).add(ann.group);
        var selectionMarker = infChart.drawingUtils.common.addAdditionalDrawingSelectionMarker.call(drawingObject, ann, chart, 0, 0, {type:"additionalDrawing", level:priceLineLevel.id});
        additionalDrawingsArr.tpSelectionMarkers[priceLineLevel.id] = selectionMarker;
        line.priceLineDiff = priceLineLevel.priceLineDiff;

        var takeProfitTheme = infChart.util.merge({}, infChart.drawingUtils.common.theme.longLineAxisLabel.takeProfit);
        var takeProfitLabelDrawingAttr = infChart.util.merge({}, drawingObject.labelProperties, {fill: takeProfitTheme.lineLabel.fill, 'stroke-width': takeProfitTheme.lineLabel['stroke-width'], stroke: takeProfitTheme.lineLabel.stroke });
        var lineLabel = chart.renderer.label(infChart.drawingUtils.common.getYValue.call(drawingObject, value), 0, top)
            .css({
                color: takeProfitTheme.lineLabel.color
            })    
            .attr(
                takeProfitLabelDrawingAttr
            )
            .add(ann.group);

        var takeProfitTagLabelDrawingAttr = infChart.util.merge({}, drawingObject.labelProperties, {fill: takeProfitTheme.lineTagLabel.fill, 'stroke-width': takeProfitTheme.lineTagLabel['stroke-width'], stroke: takeProfitTheme.lineTagLabel.stroke});
        var lineTagLabel = chart.renderer.label("TP", 0, top).attr(
                takeProfitTagLabelDrawingAttr
            )
            .css({
                color: takeProfitTheme.lineTagLabel.color
            })
            .add(ann.group);
        lineLabel.priceLineDiff = priceLineLevel.priceLineDiff;
        lineLabel.id = priceLineLevel.id;
        line.attr({
            dashstyle: 'solid'
        });

        additionalDrawingsArr.tpPriceLines[priceLineLevel.id] = line;
        additionalDrawingsArr.tpPriceLineLabels[priceLineLevel.id] = lineLabel;
        additionalDrawingsArr.tpPriceLineTagLabels[priceLineLevel.id] = lineTagLabel;

        if(!priceLineLevel.enable){
            additionalDrawingsArr.tpPriceLines[priceLineLevel.id].hide();
            additionalDrawingsArr.tpPriceLineLabels[priceLineLevel.id].hide();
            additionalDrawingsArr.tpPriceLineTagLabels[priceLineLevel.id].hide();
            additionalDrawingsArr.tpSelectionMarkers[priceLineLevel.id].hide();
        }
    });

    options.stopLoss.forEach(function(priceLineLevel) {

        if(!priceLineLevel.enable){
            hiddenLevels.push(priceLineLevel.id);
        }
        drawingLineAttr.stroke = priceLineLevel.lineColor;
        drawingLineAttr.dashstyle = priceLineLevel.lineStyle;
        drawingLineAttr["stroke-width"] = priceLineLevel.lineWidth;

        var line = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingLineAttr).add(ann.group);
        var selectionMarker = infChart.drawingUtils.common.addAdditionalDrawingSelectionMarker.call(drawingObject, ann, chart, 0, 0, {type:"additionalDrawing", level:priceLineLevel.id});
        additionalDrawingsArr.slSelectionMarkers[priceLineLevel.id] = selectionMarker;
        line.priceLineDiff = priceLineLevel.priceLineDiff;

        var stopLossTheme = infChart.util.merge({}, infChart.drawingUtils.common.theme.shortLineAxisLabel.stoploss);
        var stopLossLabelDrawingAttr = infChart.util.merge({}, drawingObject.labelProperties, {fill: stopLossTheme.lineLabel.fill, 'stroke-width': stopLossTheme.lineLabel['stroke-width'], stroke: stopLossTheme.lineLabel.stroke});
        var lineLabel = chart.renderer.label(infChart.drawingUtils.common.getYValue.call(drawingObject, value), 0, top)
        .css({
            color: stopLossTheme.lineLabel.color
        })    
        .attr(
            stopLossLabelDrawingAttr
        )
        .add(ann.group);

        var stopLossTagLabelDrawingAttr = infChart.util.merge({}, drawingObject.labelProperties, {fill: stopLossTheme.lineTagLabel.fill, 'stroke-width': stopLossTheme.lineTagLabel['stroke-width'], stroke: stopLossTheme.lineTagLabel.stroke});
        var lineTagLabel = chart.renderer.label("SL", 0, top)
        .attr(
            stopLossTagLabelDrawingAttr
        )
        .css({
            color: stopLossTheme.lineTagLabel.color
        })
        .add(ann.group);
        lineLabel.priceLineDiff = priceLineLevel.priceLineDiff;
        lineLabel.id = priceLineLevel.id;

        additionalDrawingsArr.slPriceLines[priceLineLevel.id] = line;
        additionalDrawingsArr.slPriceLineLabels[priceLineLevel.id] = lineLabel;
        additionalDrawingsArr.slPriceLineTagLabels[priceLineLevel.id] = lineTagLabel;

        if(!priceLineLevel.enable){
            additionalDrawingsArr.slPriceLines[priceLineLevel.id].hide();
            additionalDrawingsArr.slPriceLineLabels[priceLineLevel.id].hide();
            additionalDrawingsArr.slPriceLineTagLabels[priceLineLevel.id].hide();
            additionalDrawingsArr.slSelectionMarkers[priceLineLevel.id].hide();
        }
    });
    
    var mainTypeLabelTheme = infChart.util.merge({}, infChart.drawingUtils.common.theme.longLineAxisLabel.mainTypeLabel);
    additionalDrawingsArr.mainTypeLabel = chart.renderer.createElement('foreignObject').add(ann.group)
    .css(
        mainTypeLabelTheme.foreignObject
    )
    .attr({
        width: '26',
        height: '26',
        rel: 'mainType'
    })
    .add(ann.group);

    var labelHtml = "<div style='display: flex; align-items: center; justify-content: center; border-color:" + mainTypeLabelTheme.insideIcon.stroke + "; border-width:" + mainTypeLabelTheme.insideIcon['stroke-width'] + "; border-style:" + mainTypeLabelTheme.insideIcon['border-style'] + "; height: 100%;'>" + drawingObject.mainIcon + "</div>";
    additionalDrawingsArr.mainTypeLabel.element.innerHTML = labelHtml;

    drawingObject.additionalDrawings['lineLabel'] = lineLabel;

    if (chart.axisOffset[yAxis.side] < lineLabel.width) {
        yAxis.isDirty = true; // need to change the axis offset in the chart
        this.chartRedrawRequired = true;
    }
    ann.group.addClass("line-drawing");
    // bringing the label's group front to avoid overlapping with the axis labels
    infChart.drawingUtils.common.getAxisLabelToFront.call(this, lineLabel);
    if (!ann.selectionMarker) {
        ann.selectionMarker = [];
        infChart.drawingUtils.common.addSelectionMarker.call(this, ann, (xAxis.width) *3/4 - xAxis.toPixels(options.xValue), 0);
    }
};

infChart.longLineDrawing.prototype.deselect = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        additionalDrawings = self.additionalDrawings;
    self.annotation.selectionMarker = [];
    infChart.util.forEach(additionalDrawings.tpSelectionMarkers, function(index , value){
            additionalDrawings.tpSelectionMarkers[index].hide();
    });

    infChart.util.forEach(additionalDrawings.slSelectionMarkers, function(index , value){
                additionalDrawings.slSelectionMarkers[index].hide();
    });
    self.additionalLevelSelected = undefined;
};

infChart.longLineDrawing.prototype.bindSettingsEvents = function () {
    return infChart.drawingUtils.common.bindShortLongLineSettingsEvents.call(this, infChart.drawingUtils.common.baseBorderColor);
};

infChart.longLineDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    return {
        shape: 'longLine',
        borderColor: infChart.themeManager.getDrawingsBorderColor(annotation.options.shape.params.stroke, 'shortLine'),
        fillColor: infChart.themeManager.getDrawingsFillColor(annotation.options.shape.params.fill, 'shortLine'),
        strokeWidth: annotation.options.shape.params['stroke-width'],
        dashStyle: annotation.options.shape.params.dashstyle,
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        clickCords: annotation.options.clickCords,
        width: annotation.chart.plotWidth,
        text: annotation.options.lineText,
        takeProfit: annotation.options.takeProfit,
        stopLoss: annotation.options.stopLoss,
        isLocked : annotation.options.isLocked

    };
};

/**
 * Returns the obj of properties to copy
 * @returns {object} properties
 */
infChart.longLineDrawing.prototype.getConfigToCopy = function () {
    var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(this.annotation.chart);
    var chartInstance = infChart.manager.getChart(stockChartId);
    var yAxis = chartInstance.getMainYAxis();
    var properties = this.getConfig();
    var shapeTheme = infChart.drawingUtils.common.theme.horizontalLine;
    var copyDistance = shapeTheme && shapeTheme.copyDistance ? shapeTheme.copyDistance.y : infChart.drawingUtils.common.theme.defaultCopyDistance;

    properties.yValue = yAxis.toValue(yAxis.toPixels(properties.yValue) + copyDistance);
    return properties;
};

infChart.longLineDrawing.prototype.getPriceLineLabelFormattedValue = function (yValue) {
    var stockChart = this.stockChart;
    var value;
    if (stockChart.isPercent) {
        value = stockChart.getYLabel(yValue, true, false, false);
    } else {
        value = stockChart.formatValue(yValue, stockChart.getMainSeries().options.dp);
    }
    return value;
};

infChart.longLineDrawing.prototype.getOptions = function (properties) {
    var self = this;
    var options = {
        utilizeAxes: "y", // since label is drawn in the yAxis
        xValue: properties.xValue,
        yValue: parseFloat(properties.yValue),
        allowDragX: false,
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0],
                dashstyle: 'solid',
                stroke: '#336699',
                'class': "horizontal-line"
            }
        }
    };

    if (properties.takeProfit) {
        options.takeProfit = properties.takeProfit; 
        infChart.util.forEach(options.takeProfit, function(index , value){
            value.yValue = infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue + options.yValue * value.priceLineDiff)
        });
    } else {
        options.takeProfit = [];
        infChart.util.forEach(this.takeProfit, function(index , value){
            options.takeProfit.push({
                id: value.id,
                yValue: infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue + options.yValue * value.priceLineDiff),
                lineWidth: value.lineWidth,
                lineStyle: value.lineStyle,
                enable: value.enable,
                priceLineDiff: value.priceLineDiff,
                lineColor: value.lineColor
            });
        });
    }
    if (properties.stopLoss) {
        options.stopLoss = properties.stopLoss; 
        infChart.util.forEach(options.stopLoss, function(index , value){
            value.yValue = infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue + options.yValue * value.priceLineDiff)
        });
    } else{
        options.stopLoss = [];
        infChart.util.forEach(this.stopLoss, function(index , value){
            options.stopLoss.push({
                id: value.id,
                yValue: infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue + options.yValue * value.priceLineDiff),
                lineWidth: value.lineWidth,
                lineStyle: value.lineStyle,
                enable: value.enable,
                priceLineDiff: value.priceLineDiff,
                lineColor: value.lineColor
            });
        });
    }
    if(properties.text){
        options.lineText = properties.text;
        options.allowDragY = false;
        options.disableCopyPaste = true;
        this.disableQuickSettingPanel = true;
    }
    if (properties.width) {
        options.shape.params.d = ['M', 0, 0, 'L', properties.width * 1.5, 0];
    }
    if (properties.clickCords) {
        options.clickCords = properties.clickCords;
    }
    if (properties.fillColor) {
        options.shape.params.fill = properties.fillColor;
    }
    if (properties.borderColor) {
        options.shape.params.stroke = properties.borderColor;
    }
    if (properties.dashStyle) {
        options.shape.params.dashstyle = properties.dashStyle;
    }
    if (properties.strokeWidth) {
        options.shape.params['stroke-width'] = properties.strokeWidth;
    }
    options.isRealTimeTranslation = true; // since label value is needed to be changed

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.longLineDrawing.prototype.getQuickSettingsPopup = function () {
    return infChart.drawingUtils.common.getPriceLineQuickSettings();
};

infChart.longLineDrawing.prototype.getSettingsPopup = function () {
    return infChart.drawingUtils.common.getPriceLineSettings(this.annotation.options.takeProfit, this.annotation.options.stopLoss, this.annotation.options.yValue);
};

infChart.longLineDrawing.prototype.isRequiredProperty = function (propertyId, reset) {
    var isPositionProperty = false;

    switch (propertyId) {
        case "yValue":
        case "yValueEnd":
        case "xValue":
        case "xValueEnd":
        case "text":
        case "isLocked":
            isPositionProperty = true;
            break;
        default :
            break;
    }

    return isPositionProperty;
};

infChart.longLineDrawing.prototype.scale = function () {
    var drawingObject = this,
        ann = this.annotation,
        chart = ann.chart,
        options = ann.options,
        line = ann.shape.d.split(' '),
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        label = this.additionalDrawings['lineLabel'],
        tpPriceLines = this.additionalDrawings.tpPriceLines,
        tpPriceLineLabels = this.additionalDrawings.tpPriceLineLabels,
        tpPriceLineTagLabels = this.additionalDrawings.tpPriceLineTagLabels,
        slPriceLines = this.additionalDrawings.slPriceLines,
        slPriceLineLabels = this.additionalDrawings.slPriceLineLabels,
        slPriceLineTagLabels = this.additionalDrawings.slPriceLineTagLabels,
        tpSelectionMarkers = this.additionalDrawings.tpSelectionMarkers,
        slSelectionMarkers = this.additionalDrawings.slSelectionMarkers,
        stockChart = this.stockChart;

    line[1] = - this.correctionFactor; 
    var firstCandle = xAxis.toPixels(chart.series[0].points[0].x); //distance to the first candle from chart start
    line[4] = xAxis.width - firstCandle; // line should be ended inside the plot area. Otherwise it will be shown in the yAxis some times
    
    ann.update({
        xValue: chart.series[0].points[0].x,
        shape: {
            params: {
                d: line
            }
        }
    });

    drawingObject.additionalDrawings.mainTypeLabel.attr({
        x: chart.plotLeft - firstCandle,
        y: - drawingObject.additionalDrawings.mainTypeLabel.getBBox().height/2,// xAxis.width - firstCandle,
        zIndex: 20,
        'type': "mainDrawing"
    });

    label.attr({
        text: stockChart.formatValue(parseFloat(infChart.drawingUtils.common.getBaseYValues.call(drawingObject, options.yValue)).toFixed(3), stockChart.getMainSeries().options.dp),
        x: chart.plotLeft - firstCandle + drawingObject.additionalDrawings.mainTypeLabel.getBBox().width,
        zIndex: 20,
        'type': "mainDrawing"
    });

    $.each(tpPriceLines, function (id, priceLine) {

        var level = options.takeProfit.find(function(takeProfit) {
            return takeProfit.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        var newX = -drawingObject.correctionFactor;
        priceLine.attr({
            d: ['M', newX, newY, 'L', xAxis.width - firstCandle, newY]
        }); 
    });

    $.each(tpSelectionMarkers, function(id, selectionMarker){
        var level = options.takeProfit.find(function(takeProfit) {
            return takeProfit.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        var newX = (xAxis.width) * 3/4 - xAxis.toPixels(options.xValue);
        selectionMarker.attr({
            'cx': newX,
            'cy': newY
        });
    });

    $.each(tpPriceLineTagLabels, function (id, priceLineTagLabel) {

        var level = options.takeProfit.find(function(takeProfit) {
            return takeProfit.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        priceLineTagLabel.attr({
            text: infChart.manager.getLabel("label." + level.id + ""),
            x: chart.plotLeft - firstCandle,
            y: newY - priceLineTagLabel.height/2,
            zIndex: 20,
            'type': "additionalDrawing",
            'level': level.id

        });
    });

    var tagLabelWidth = Object.values(tpPriceLineTagLabels)[0].width;


    $.each(tpPriceLineLabels, function (id, priceLineLabel) {

        var level = options.takeProfit.find(function(takeProfit) {
            return takeProfit.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        priceLineLabel.attr({
            text: stockChart.formatValue((parseFloat(level.yValue)).toFixed(3), stockChart.getMainSeries().options.dp),
            x: (chart.plotLeft - firstCandle) + tagLabelWidth,
            y: newY - priceLineLabel.height/2,
            zIndex: 20,
            'type': "additionalDrawing",
            'level': level.id
        });
    });

    $.each(slPriceLines, function (id, priceLine) {
        
        var level = options.stopLoss.find(function(stopLoss) {
            return stopLoss.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        var newX = -drawingObject.correctionFactor;
        priceLine.attr({
            d: ['M', newX, newY, 'L', xAxis.width - firstCandle, newY]
        }); 
    });

    $.each(slSelectionMarkers, function(id, selectionMarker){
        var level = options.stopLoss.find(function(stopLoss) {
            return stopLoss.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        var newX = (xAxis.width) * 3/4 - xAxis.toPixels(options.xValue);
        selectionMarker.attr({
            'cx': newX,
            'cy': newY
        });
    });

    $.each(slPriceLineTagLabels, function (id, priceLineTagLabel) {

        var level = options.stopLoss.find(function(stopLoss) {
            return stopLoss.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        priceLineTagLabel.attr({
            text: infChart.manager.getLabel("label." + level.id + ""),
            x: chart.plotLeft - firstCandle,
            y: newY - priceLineTagLabel.height/2,
            zIndex: 20,
            'type': "additionalDrawing",
            'level': level.id
        });
    });

    var tagLabelWidth = Object.values(slPriceLineTagLabels)[0].width;

    $.each(slPriceLineLabels, function (id, priceLineLabel) {

        var level = options.stopLoss.find(function(stopLoss) {
            return stopLoss.id == id
        });

        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        priceLineLabel.attr({
            text: stockChart.formatValue((parseFloat(level.yValue)).toFixed(3), stockChart.getMainSeries().options.dp),
            x: (chart.plotLeft - firstCandle) + tagLabelWidth,
            y: newY - priceLineLabel.height/2,
            zIndex: 20,
            'type': "additionalDrawing",
            'level': level.id
        });
    });

    if(!drawingObject.additionalLevelSelected){
        if(ann.selectionMarker[0]){
            var newX = (xAxis.width) * 3/4 - xAxis.toPixels(options.xValue);
            ann.selectionMarker[0].attr({
                'cx': newX
            });
        }
    }
    infChart.drawingUtils.common.getAxisLabelToFront.call(this, label);
    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    var customAttributes = {
        'type': "mainDrawing",
        'stroke-width': 10
    } 
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, ["M", 0, 0, 'L', line[4], line[5]], this.dragSupporters, customAttributes);

    $.each(tpPriceLines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'type': "additionalDrawing",
                'stroke-width': 10
            }            
            var dragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', 'z-index': 20});
            infChart.drawingUtils.common.addDragSupporters.call(drawingObject, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], drawingObject.dragSupporters, customAttributes, dragSupporterStyles);
        }
    });

    $.each(slPriceLines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'type': "additionalDrawing",
                'stroke-width': 10
            }            
            var dragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', 'z-index': 20});
            infChart.drawingUtils.common.addDragSupporters.call(drawingObject, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], drawingObject.dragSupporters, customAttributes, dragSupporterStyles);
        }
    });

};

// infChart.longLineDrawing.prototype.select = function () {
//     infChart.drawingUtils.common.getAxisLabelToFront.call(this, this.additionalDrawings['lineLabel']);
// };

infChart.longLineDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis];
    if (!ann.selectionMarker) {
        ann.selectionMarker = [];
        infChart.drawingUtils.common.addSelectionMarker.call(this, ann, (xAxis.width) * 3/4 - xAxis.toPixels(options.xValue), 0);
    }
};

infChart.longLineDrawing.prototype.step = function () { };

infChart.longLineDrawing.prototype.stop = function (e) {
    var drawingObject = this,
        ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        x = e.chartX,
        y = e.chartY,
        plotWidth = chart.plotWidth * 1.5,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        label = this.additionalDrawings['lineLabel'],
        tpPriceLines = this.additionalDrawings.tpPriceLines,
        tpPriceLineLabels = this.additionalDrawings.tpPriceLineLabels,
        tpPriceLineTagLabels = this.additionalDrawings.tpPriceLineTagLabels,
        slPriceLines = this.additionalDrawings.slPriceLines,
        slPriceLineLabels = this.additionalDrawings.slPriceLineLabels,
        slPriceLineTagLabels = this.additionalDrawings.slPriceLineTagLabels,
        tpSelectionMarkers = this.additionalDrawings.tpSelectionMarkers,
        slSelectionMarkers = this.additionalDrawings.slSelectionMarkers,
        stockChart = this.stockChart,
       
        line = ["M", 0, 0, 'L', xAxis.width, 0];
        line[1] = - this.correctionFactor;
        var firstCandle = xAxis.toPixels(chart.series[0].points[0].x);
        line[4] = xAxis.width - firstCandle;
        
    ann.update({
        clickCords: { x: x, y: y },
        xValue: chart.series[0].points[0].x,
        shape: {
            params: {
                d: line
            }
        }
    });

    drawingObject.additionalDrawings.mainTypeLabel.attr({
        x: chart.plotLeft - firstCandle,
        y: - drawingObject.additionalDrawings.mainTypeLabel.getBBox().height/2,// xAxis.width - firstCandle,
        zIndex: 20,
        'type': "mainDrawing"
    });

    label.attr({
        text: stockChart.formatValue(parseFloat(infChart.drawingUtils.common.getBaseYValues.call(drawingObject, options.yValue)).toFixed(3), stockChart.getMainSeries().options.dp), //https://www.highcharts.com/forum/viewtopic.php?t=39232
        x: chart.plotLeft - firstCandle + drawingObject.additionalDrawings.mainTypeLabel.getBBox().width,
        zIndex: 20,
        'type': "mainDrawing"
    });


    $.each(tpPriceLines, function (id, priceLine) {

        var level = options.takeProfit.find(function(takeProfit) {
            return takeProfit.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        var newX = -drawingObject.correctionFactor;
        priceLine.attr({
            d: ['M', newX, newY, 'L', xAxis.width - firstCandle, newY]
        }); 
    });

    $.each(tpSelectionMarkers, function(id, selectionMarker){
        var level = options.takeProfit.find(function(takeProfit) {
            return takeProfit.id == id
        });
        var newX = (xAxis.width) * 3/4 - xAxis.toPixels(options.xValue);
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        selectionMarker.attr({
            'cx': newX,
            'cy': newY
        });
    });

    $.each(tpPriceLineTagLabels, function (id, priceLineTagLabel) {

        var level = options.takeProfit.find(function(takeProfit) {
            return takeProfit.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        priceLineTagLabel.attr({
            text: infChart.manager.getLabel("label." + level.id + "") ,
            x: chart.plotLeft - firstCandle,
            y: newY - priceLineTagLabel.height/2,
            zIndex:20,
            'type': "additionalDrawing",
            'level': level.id
        });
    });

    var tagLabelWidth = Object.values(tpPriceLineTagLabels)[0].width;


    $.each(tpPriceLineLabels, function (id, priceLineLabel) {

        var level = options.takeProfit.find(function(takeProfit) {
            return takeProfit.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        priceLineLabel.attr({
            text: stockChart.formatValue((parseFloat(level.yValue)).toFixed(3), stockChart.getMainSeries().options.dp),
            x: (chart.plotLeft - firstCandle) + tagLabelWidth,
            y: newY - priceLineLabel.height/2,
            zIndex: 20,
            'type': "additionalDrawing",
            'level': level.id
        });
    });

    $.each(slPriceLines, function (id, priceLine) {
        
        var level = options.stopLoss.find(function(stopLoss) {
            return stopLoss.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        var newX = -drawingObject.correctionFactor;
        priceLine.attr({
            d: ['M', newX, newY, 'L', xAxis.width - firstCandle, newY]
        }); 
    });

    $.each(slSelectionMarkers, function(id, selectionMarker){
        var level = options.stopLoss.find(function(stopLoss) {
            return stopLoss.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        var newX = (xAxis.width) * 3/4 - xAxis.toPixels(options.xValue);
        selectionMarker.attr({
            'cx': newX,
            'cy': newY
        });
    });

    $.each(slPriceLineTagLabels, function (id, priceLineTagLabel) {

        var level = options.stopLoss.find(function(stopLoss) {
            return stopLoss.id == id
        });
        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        priceLineTagLabel.attr({
            text: infChart.manager.getLabel("label." + level.id + ""),
            x: chart.plotLeft - firstCandle,
            y: newY - priceLineTagLabel.height/2,
            zIndex: 20,
            'type': "additionalDrawing",
            'level': level.id
        });
    });

    var tagLabelWidth = Object.values(slPriceLineTagLabels)[0].width;

    $.each(slPriceLineLabels, function (id, priceLineLabel) {

        var level = options.stopLoss.find(function(stopLoss) {
            return stopLoss.id == id
        });

        var newY = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(drawingObject, level.yValue)) - yAxis.toPixels(options.yValue);
        priceLineLabel.attr({
            text: stockChart.formatValue((parseFloat(level.yValue)).toFixed(3), stockChart.getMainSeries().options.dp),
            x: (chart.plotLeft - firstCandle) + tagLabelWidth,
            y: newY - priceLineLabel.height/2,
            zIndex: 20,
            'type': "additionalDrawing",
            'level': level.id
        });
    });

    ann.group.addClass("line-drawing");

    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue);
    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    var customAttributes = {
        'type': "mainDrawing",
        'stroke-width': 10
    } 
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, ["M", 0, 0, 'L', line[4], line[5]], this.dragSupporters, customAttributes);

    $.each(tpPriceLines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level': key,
                'type': "additionalDrawing",
                'stroke-width': 10
            }            
            var dragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', 'z-index': 20});
            infChart.drawingUtils.common.addDragSupporters.call(drawingObject, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], drawingObject.dragSupporters, customAttributes, dragSupporterStyles);
        }
    });

    $.each(slPriceLines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'type': "additionalDrawing",
                'stroke-width': 10
            }            
            var dragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', 'z-index': 20});
            infChart.drawingUtils.common.addDragSupporters.call(drawingObject, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], drawingObject.dragSupporters, customAttributes, dragSupporterStyles);
        }
    });

    if(ann.selectionMarker[0]){
        var newX = (xAxis.width) * 3/4 - xAxis.toPixels(options.xValue);
        ann.selectionMarker[0].attr({
            'cx': newX
        });
    }
    infChart.drawingUtils.common.onPropertyChange.call(this);
    if(infChart.drawingsManager.getIsActiveDrawingInprogress()){
        drawingObject.initialSettingPanelLoad = true;
    }
    return line;
};

infChart.longLineDrawing.prototype.openSettingPanel = function () {
    var drawingObj = this;
    if (drawingObj.isQuickSetting) {
        infChart.drawingUtils.common.toggleSettings.call(drawingObj);
    }
};

infChart.longLineDrawing.prototype.translate = function (event) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        line = ann.shape.d.split(' '),
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        tpPriceLines = this.additionalDrawings.tpPriceLines,
        slPriceLines = this.additionalDrawings.slPriceLines;

    if (options.selectedDrawing == "mainDrawing" || options.selectedDrawing == undefined) {
        infChart.util.forEach(options.takeProfit, function(index , value){
            if(!value.enable){
                value.yValue = infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue) + infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue) * value.priceLineDiff;
            }
        });
        infChart.util.forEach(options.stopLoss, function(index , value){
            if(!value.enable){
                value.yValue = infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue) + infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue) * value.priceLineDiff;
            }
        });
        this.scale();
    }
    if (options.selectedDrawing == 'tp1'||options.selectedDrawing == 'tp2'||options.selectedDrawing == 'tp3'|| options.selectedDrawing == 'sl1'||options.selectedDrawing == 'sl2'||options.selectedDrawing == 'sl3') {

        var yValue = yAxis.toValue(event.chartY);

        ann.update({
            yValue: options.yValueStore
        });

        self.updateAdditionalDrawing(options.selectedDrawing, yValue);
    }

    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    var customAttributes = {
        'type': "mainDrawing",
        'stroke-width': 10
    } 
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ["M", line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes);

    $.each(tpPriceLines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'type': "additionalDrawing",
                'stroke-width': 10
            }            
            var dragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', 'z-index': 20});
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, dragSupporterStyles);
        }
    });

    $.each(slPriceLines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'type': "additionalDrawing",
                'stroke-width': 10
            }            
            var dragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', 'z-index': 20});
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, dragSupporterStyles);
        }
    });
};

infChart.longLineDrawing.prototype.updateAdditionalDrawing = function(selectedDrawing, yValue){
    var self = this,
        ann = self.annotation,
        options = ann.options
        chart = ann.chart,
        stockChart = this.stockChart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];
        if(selectedDrawing == 'tp1' || selectedDrawing == 'tp2' || selectedDrawing == 'tp3'){
            level = options.takeProfit.find( function(level) {
                if(level.id == selectedDrawing){
                    level.yValue = infChart.drawingUtils.common.getBaseYValues.call(self, yValue);
                    return level;
                }
            });
        }
        if(selectedDrawing == 'sl1' || selectedDrawing == 'sl2' || selectedDrawing == 'sl3'){
            level = options.stopLoss.find( function(level) {
                if(level.id == selectedDrawing){
                    level.yValue = infChart.drawingUtils.common.getBaseYValues.call(self, yValue);
                    return level;
                }
            });
        }
        if(level.id == 'tp1' || level.id == 'tp2' || level.id == 'tp3'){
            var priceline = self.additionalDrawings.tpPriceLines[level.id];
            var lineLabel = self.additionalDrawings.tpPriceLineLabels[level.id];
            var lineTagLabel = self.additionalDrawings.tpPriceLineTagLabels[level.id];
            var selectionMarker = self.additionalDrawings.tpSelectionMarkers[level.id];
        }
        if(level.id == 'sl1' || level.id == 'sl2' || level.id == 'sl3'){
            var priceline = self.additionalDrawings.slPriceLines[level.id];
            var lineLabel = self.additionalDrawings.slPriceLineLabels[level.id];
            var lineTagLabel = self.additionalDrawings.slPriceLineTagLabels[level.id];
            var selectionMarker = self.additionalDrawings.slSelectionMarkers[level.id];
        }
    
        var line = priceline.d.split(' ');
        var newY = yAxis.toPixels(yValue) - yAxis.toPixels(options.yValue);
        priceline.attr({
            d: ['M', line[1], newY, 'L', line[4], newY]
        }); 
        lineLabel.attr({
            text: stockChart.formatValue(parseFloat((level.yValue)).toFixed(3), stockChart.getMainSeries().options.dp),
            y: newY - lineTagLabel.height/2,
        });
        lineTagLabel.attr({
            y: newY - lineTagLabel.height/2,
        }); 
        selectionMarker.attr({
            'cy': newY
        });
};

infChart.longLineDrawing.prototype.translateEnd = function () {
    var self = this,
        ann = self.annotation
        options = ann.options;
    self.scale();
    self.annotation.options.selectedDrawing = undefined;
    infChart.drawingUtils.common.saveBaseYValues.call(self, options.yValue, options.yValueEnd);
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.longLineDrawing.prototype.updateSettings = function (properties) {
    var self = this,
    ann = self.annotation,
    options = ann. options;
    // var takeProfitValues = [];
    // infChart.util.forEach(properties.takeProfit, function(index , value){
    //     takeProfitValues.push({
    //         id: value.id,
    //         yValue: infChart.drawingUtils.common.getYValue.call(self, value.yValue),
    //         lineWidth: value.lineWidth,
    //         lineStyle: value.lineStyle,
    //         enable: value.enable
    //     });
    // });

    // var stopLossValues = [];
    // infChart.util.forEach(properties.stopLoss, function(index , value){
    //     stopLossValues.push({
    //         id: value.id,
    //         yValue: infChart.drawingUtils.common.getYValue.call(self, value.yValue),
    //         lineWidth: value.lineWidth,
    //         lineStyle: value.lineStyle,
    //         enable: value.enable
    //     });
    // });
    infChart.structureManager.drawingTools.updatePriceLineSettings(this.settingsPopup, properties.takeProfit, properties.stopLoss, infChart.drawingUtils.common.getBaseYValues.call(self, properties.yValue));
};

infChart.longLineDrawing.prototype.select = function (event) {
    var self = this,
        ann = self.annotation,
        options = ann.options;

    if (event && event.target) {
        var drawingtype = event.target.getAttribute('type');
        if (drawingtype && drawingtype == "additionalDrawing") {
            var level = event.target.getAttribute('level');
            if(level){
                options.selectedDrawing = level;
            }
        } else if(drawingtype && drawingtype == "mainDrawing") {
            options.selectedDrawing = "mainDrawing"; 
        }else{
            var type = event.target.parentElement.getAttribute('type');
            if(type == "additionalDrawing"){
                var level = event.target.parentElement.getAttribute('level'); 
                if(level){
                    options.selectedDrawing = level;
                }
            }else if (type == "mainDrawing"){
                options.selectedDrawing = "mainDrawing";
            }else{
                var type = event.target.parentElement.parentElement.getAttribute('type');
                if(type == "additionalDrawing"){
                    var level = event.target.parentElement.parentElement.getAttribute('level'); 
                    if(level){
                        options.selectedDrawing = level;
                    }
                }else{
                    options.selectedDrawing = undefined;
                }
            }
        }
    }
    if(options.selectedDrawing){
        self.showSelectionMarker(options.selectedDrawing);
        self.getLineToFront(options.selectedDrawing);
        infChart.drawingsManager.deselectDrawingTools(self.stockChart.id ,self.drawingId);
    }
};

infChart.longLineDrawing.prototype.showSelectionMarker = function(level){
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        additionalDrawings = self.additionalDrawings;

    if (level == "tp1" || level == "tp2" || level == "tp3") {
        var newX = (xAxis.width) * 3/4 - xAxis.toPixels(options.xValue);
        additionalDrawings.tpSelectionMarkers[level].attr({
            'cx': newX
        });
        additionalDrawings.tpSelectionMarkers[level].show();
        self.additionalLevelSelected = true;
        if(ann.selectionMarker[0]){
            ann.selectionMarker[0].hide();
        }
    } else if (level == "sl1" || level == "sl2" || level == "sl3") {
        var newX = (xAxis.width) * 3/4 - xAxis.toPixels(options.xValue);
        additionalDrawings.slSelectionMarkers[level].attr({
            'cx': newX
        });
        additionalDrawings.slSelectionMarkers[level].show();
        self.additionalLevelSelected = true;
        if(ann.selectionMarker[0]){
            ann.selectionMarker[0].hide();
        }
    } else {
        self.additionalLevelSelected = false;
        if(ann.selectionMarker[0]){
            ann.selectionMarker[0].show();
        }
    }

    infChart.util.forEach(additionalDrawings.tpSelectionMarkers, function(index , value){
        if(level && level != index){
            if(additionalDrawings.tpSelectionMarkers[index]){
                additionalDrawings.tpSelectionMarkers[index].hide();
            }
        }
    });

    infChart.util.forEach(additionalDrawings.slSelectionMarkers, function(index , value){
        if(level && level != index){
            if(additionalDrawings.slSelectionMarkers[index]){
                additionalDrawings.slSelectionMarkers[index].hide();
            }
        }
    });
};

infChart.longLineDrawing.prototype.getLineToFront = function(level){
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        additionalDrawings = self.additionalDrawings;

    if (level == "tp1" || level == "tp2" || level == "tp3") {
        additionalDrawings.tpPriceLines[level].toFront();
        additionalDrawings.tpPriceLineTagLabels[level].toFront();
        additionalDrawings.tpPriceLineLabels[level].toFront();
        additionalDrawings.tpSelectionMarkers[level].toFront();
    } else if (level == "sl1" || level == "sl2" || level == "sl3") {
        additionalDrawings.slPriceLines[level].toFront();
        additionalDrawings.slPriceLineTagLabels[level].toFront();
        additionalDrawings.slPriceLineLabels[level].toFront();
        additionalDrawings.slSelectionMarkers[level].toFront();
    } else {
        ann.shape.toFront();
        if(ann.selectionMarker[0]){
            ann.selectionMarker[0].toFront();
        }else{
            ann.selectionMarker = [];
            infChart.drawingUtils.common.addSelectionMarker.call(this, ann, (xAxis.width)*3/4 - xAxis.toPixels(options.xValue), 0);
            ann.selectionMarker[0].toFront();
        }
        additionalDrawings.lineLabel.toFront();
        additionalDrawings.mainTypeLabel.toFront();
    }
};

infChart.longLineDrawing.prototype.updateOptions = function (options) {
    var ann = this.annotation;
    if (options.stopLoss) {
        ann.options.stopLoss = options.stopLoss;
    }
    if (options.takeProfit) {
        ann.options.takeProfit = options.takeProfit;
    }
    this.updateSettings(this.getConfig());
};

infChart.longLineDrawing.prototype.isVisibleLastLevel = function(){
    return false;
};


window.infChart = window.infChart || {};

infChart.horizontalRayDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
};

infChart.horizontalRayDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.horizontalRayDrawing.prototype.additionalDrawingsFunction = function () {
    var drawingObject = this,
        ann = drawingObject.annotation,
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        height = 14,
        padding = 6,
        top,
        theme = {
            fill: "#191919",
            stroke: "#2a2a2b",
            opacity: 1,
            fontColor: "#ffffff",
            'zIndex': 20,
            'padding': padding,
            'r': 1,
            'stroke-width': 1,
            'stroke-linecap': 'butt',
            'stroke-linejoin': 'miter',
            'stroke-opacity': 1,
            'hAlign': 'center',
            'height': height,
            'class': 'drawing-line-axis-lbl',
            'fontWeight': 100,
            'x': xAxis.width
        };

    if (infChart.drawingUtils.common.theme && infChart.drawingUtils.common.theme.horizontalRay) {
        theme = infChart.util.merge(theme, infChart.drawingUtils.common.theme.horizontalRay);
    }

    top = -(theme.height / 2 + theme.padding);
    ann.options.xLabelPadding = theme.padding;

    var value = this.getLabelFormattedValue();
    var lineLabel = chart.renderer.label(infChart.drawingUtils.common.getYValue.call(this, value), 0, top).attr(theme).add(ann.group);

    lineLabel.css({ //to color text
        'fontWeight': theme.fontWeight,
        'color': theme.fontColor
    });

    drawingObject.additionalDrawings['lineLabel'] = lineLabel;
    
    var yAxis = chart.yAxis[ann.options.yAxis];
    if (chart.axisOffset[yAxis.side] < lineLabel.width) {
        yAxis.isDirty = true; // need to change the axis offset in the chart
        this.chartRedrawRequired = true;
    }
    ann.group.addClass("line-drawing");
    // bringing the label's group front to avoid overlapping with the axis labels
    infChart.drawingUtils.common.getAxisLabelToFront.call(this, lineLabel);
    if (!ann.selectionMarker) {
        ann.selectionMarker = [];
        infChart.drawingUtils.common.addSelectionMarker.call(this, ann, 0, 0);
    }
};

infChart.horizontalRayDrawing.prototype.beforeDestroy = function () {
    var drawingObject = this,
        ann = drawingObject.annotation,
        chart = ann.chart,
        yAxis = chart.yAxis[ann.options.yAxis];

    // need to reset the yAxis offset which is utilzed by this drawing
    yAxis.isDirty = true;
    this.chartRedrawRequired = true;
};

infChart.horizontalRayDrawing.prototype.bindSettingsEvents = function () {
    var self = this;

    var callBackFnLineSettingsEvents = {
        onLineColorChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.lineColor, {
            isUpdateAnnotationStyles: true,
            settingsItem: 'line'
        }),
        onLineWidthChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.lineWidth, {
            isUpdateAnnotationStyles: true,
            settingsItem: 'lineWidth'

        }),
        onLineStyleChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.lineStyle, {
            isUpdateAnnotationStyles: true,
            settingsItem: 'lineStyle',
        }),
        
        onResetToDefault : function(){
            self.updateSavedDrawingProperties(true)
        }   
    }

    infChart.structureManager.drawingTools.bindLineSettings(self.settingsPopup, callBackFnLineSettingsEvents);
};

infChart.horizontalRayDrawing.prototype.getAxisOffset = function (axis) {
    var drawingObject = this,
        ann = drawingObject.annotation,
        options = ann.options,
        label = drawingObject.additionalDrawings['lineLabel'],
        padding = infChart.util.isDefined(ann.options.xLabelPadding) || 3;

    if (!axis.isXAxis && options.yAxis === axis.options.index) {

        var value = this.getLabelFormattedValue();
        label.attr({
            text: value
        });
        return label.width + padding;
    }
    return 0;
};

infChart.horizontalRayDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    return {
        shape: 'horizontalRay',
        settings: {
            lineColor: infChart.themeManager.getDrawingsBorderColor(annotation.options.shape.params.stroke, 'horizontalRay'),
            lineOpacity: annotation.options.shape.params.opacity,
            fillColor: infChart.themeManager.getDrawingsFillColor(annotation.options.shape.params.fill, 'horizontalRay'),
            lineWidth: annotation.options.shape.params['stroke-width'],
            lineStyle: annotation.options.shape.params.dashstyle,
        },
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        clickCords: annotation.options.clickCords,
        width: annotation.chart.plotWidth,
        isLocked : annotation.options.isLocked

    };
};

/**
 * Returns the obj of properties to copy
 * @returns {object} properties
 */
infChart.horizontalRayDrawing.prototype.getConfigToCopy = function () {
    var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(this.annotation.chart);
    var chartInstance = infChart.manager.getChart(stockChartId);
    var yAxis = chartInstance.getMainYAxis();
    var properties = this.getConfig();
    var shapeTheme = infChart.drawingUtils.common.theme.horizontalRay;
    var copyDistance = shapeTheme && shapeTheme.copyDistance ? shapeTheme.copyDistance.y : infChart.drawingUtils.common.theme.defaultCopyDistance;

    properties.yValue = yAxis.toValue(yAxis.toPixels(properties.yValue) + copyDistance);
    return properties;
};

infChart.horizontalRayDrawing.prototype.getLabelFormattedValue = function () {
    var stockChart = this.stockChart;
    var value;
    if (stockChart.isPercent) {
        value = stockChart.getYLabel(this.annotation.options.yValue, true, false, false);
    } else {
        value = stockChart.formatValue(this.yValue, stockChart.getMainSeries().options.dp);
    }
    return value;
};

infChart.horizontalRayDrawing.prototype.getOptions = function (properties) {
    var options = {
        utilizeAxes: "y", // since label is drawn in the yAxis
        xValue: properties.xValue,
        yValue: properties.yValue,
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0],
                dashstyle: 'solid',
                'class': "horizontal-line",
                'stroke-width': infChart.drawingUtils.common.baseLineWidth
            }
        },
        settings : {},
        isIndicator: properties.isIndicator
    };

    if(properties.settings){
        options.settings = properties.settings;
        if (properties.settings.fillColor) {
            options.shape.params.fill = properties.settings.fillColor;
        }
        if (properties.settings.lineColor) {
            options.shape.params.stroke = properties.settings.lineColor;
        }
        if (properties.settings.lineOpacity) {
            options.shape.params['stroke-opacity'] = properties.settings.lineOpacity;
        }
        if (properties.settings.lineStyle) {
            options.shape.params.dashstyle = properties.settings.lineStyle;
        }
        if (properties.settings.lineWidth) {
            options.shape.params['stroke-width'] = properties.settings.lineWidth;
        }
    } else {
        options.settings.lineColor = infChart.drawingUtils.common.baseBorderColor;
        options.settings.lineOpacity = infChart.drawingUtils.common.baseFillOpacity;
        options.settings.lineStyle = 'solid';
        options.settings.lineWidth = infChart.drawingUtils.common.baseLineWidth;
    }
    if (properties.width) {
        options.shape.params.d = ['M', 0, 0, 'L', properties.width * 1.5, 0];
    }
    if (properties.clickCords) {
        options.clickCords = properties.clickCords;
    }

    if (properties.allowDragX !== undefined) {
        options.allowDragX = properties.allowDragX;
    }

    if (properties.allowDragY !== undefined) {
        options.allowDragY = properties.allowDragY;
    }

    if (properties.drawingType !== undefined) {
        options.drawingType = properties.drawingType;
    }

    if (properties.indicatorId) {
        options.indicatorId = properties.indicatorId;
    }

    options.isRealTimeTranslation = true; // since label value is needed to be changed

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.horizontalRayDrawing.prototype.getQuickSettingsPopup = function () {
    return infChart.drawingUtils.common.getLineQuickSettings(infChart.drawingUtils.common.baseBorderColor, infChart.drawingUtils.common.baseFillOpacity);
};

infChart.horizontalRayDrawing.prototype.getSettingsPopup = function () {
    return infChart.drawingUtils.common.getLineSettings('Horizontal Ray', infChart.drawingUtils.common.baseBorderColor, undefined, undefined, undefined, undefined, infChart.drawingUtils.common.baseFillOpacity, false, false);
};

infChart.horizontalRayDrawing.prototype.scale = function () {
    var ann = this.annotation,
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis];
    var label = this.additionalDrawings['lineLabel'];

    var nearestXData = options.isIndicator ? options.xValue : infChart.math.findNearestXDataPoint(chart, (options.saveXValue) ? options.saveXValue: options.xValue, undefined, true, true);

    if(chart.series[0].xData[0] > options.saveXValue){
        options.saveXValue = options.xValue;
    }else{
        options.saveXValue = nearestXData;
    }
    var newX = xAxis.width - xAxis.toPixels(options.saveXValue);    
    var line = ['M', 0, 0, 'L', newX , 0];
    
    ann.update({
        xValue: (chart.series[0].xData[0] <= options.saveXValue) ? options.saveXValue: options.xValue,
        shape: {
            params: {
                d: line
            }
        }
    });
    var value = this.getLabelFormattedValue();
    label.attr({
        text: value,
        x: newX,
        zIndex: 20
    });
    
    infChart.drawingUtils.common.getAxisLabelToFront.call(this, label);
    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, ["M", 0, 0, 'L', line[4], line[5]], this.dragSupporters);
};

infChart.horizontalRayDrawing.prototype.select = function () {
    infChart.drawingUtils.common.getAxisLabelToFront.call(this, this.additionalDrawings['lineLabel']);
};

infChart.horizontalRayDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation;
    if (!ann.selectionMarker) {
        ann.selectionMarker = [];
        infChart.drawingUtils.common.addSelectionMarker.call(this, ann, 0, 0);
    }
};

infChart.horizontalRayDrawing.prototype.step = function () { };

infChart.horizontalRayDrawing.prototype.stop = function (e) {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        x = e.chartX,
        y = e.chartY,
        xAxis = chart.xAxis[options.xAxis],
        label = this.additionalDrawings['lineLabel'];

    if (!options.isIndicator) {
        options.xValue = infChart.math.findNearestXDataPoint(chart, options.xValue, undefined, true, true);
    }

    var newX  = xAxis.width - xAxis.toPixels(options.xValue);
    var line = ['M', 0, 0, 'L', newX , 0];
    options.saveXValue = options.xValue;

    ann.update({
        clickCords: { x: x, y: y },
        shape: {
            params: {
                d: line
            }
        }
    });
    
    label.attr({
        text: label.text.textStr,
        x: newX,
        zIndex: 20
    });

    ann.group.addClass("line-drawing");

    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue);
    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, ["M", 0, 0, 'L', line[4], line[5]], this.dragSupporters);
    infChart.drawingUtils.common.onPropertyChange.call(this);
    return line;
};

infChart.horizontalRayDrawing.prototype.translate = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        lineLabel = this.additionalDrawings['lineLabel'];

    var value = this.getLabelFormattedValue();

    options.xValue = options.isIndicator ? options.xValue : infChart.math.findNearestXDataPoint(chart, options.xValue, undefined, true, true);
    var newX  = xAxis.width - xAxis.toPixels(options.xValue);
    var line = ['M', 0, 0, 'L', newX , 0];
    options.saveXValue = options.xValue;

    ann.update({
        xValue: options.xValue,
        shape: {
            params: {
                d: line
            }
        }
    });

    lineLabel.attr({
        x: newX,
        text: value
    });
    infChart.drawingUtils.common.getAxisLabelToFront.call(this, lineLabel);
};

infChart.horizontalRayDrawing.prototype.translateEnd = function () {
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.horizontalRayDrawing.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updateLineSettings(this.settingsPopup, properties.settings);
};

window.infChart = window.infChart || {};

infChart.verticalLineDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
};

infChart.verticalLineDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.verticalLineDrawing.prototype.additionalDrawingsFunction = function () {
    var drawingObject = this,
        ann = drawingObject.annotation,
        options = ann.options,
        chart = ann.chart,
        height = ann.chart.xAxis.height,
        padding = 3,
        theme = infChart.drawingUtils.common.getTheme.call(this),
        nearestXDataPoint = infChart.math.findNearestXDataPoint(chart, ann.options.xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate),
        xAxis = chart.xAxis[options.xAxis],
        newX = xAxis.toPixels(nearestXDataPoint) - xAxis.toPixels(options.xValue);

    var lineLabel = chart.renderer.label(this.stockChart.getXAxisCrosshairLabel(nearestXDataPoint, this.stockChart.chart.xAxis[options.xAxis]), 0, 0).attr({
        'zIndex': 20,
        'padding': padding,
        'r': 1,
        'fill': theme.axisLabel.fill,
        'opacity': theme.axisLabel.opacity,
        'stroke': theme.axisLabel.stroke,
        'stroke-width': 1,
        'stroke-linecap': 'butt',
        'stroke-linejoin': 'miter',
        'stroke-opacity': 1,
        'hAlign': 'center',
        'height': height,
        'class': 'drawing-line-axis-lbl'
    }).add(ann.group);

    lineLabel.css({ //to color text
        'fontWeight': 700,
        'color': theme.axisLabel.fontColor
    });

    drawingObject.additionalDrawings['lineLabel'] = lineLabel;
    ann.group.addClass("line-drawing");
    // bringing the label's group front to avoid overlapping with the axis labels
    infChart.drawingUtils.common.getAxisLabelToFront.call(this, lineLabel);
    if (!ann.selectionMarker) {
        ann.selectionMarker = [];
        infChart.drawingUtils.common.addSelectionMarker.call(this, ann, newX, 0);
    }
};

infChart.verticalLineDrawing.prototype.afterRedrawXAxisWithoutSetExtremes = function () {
    infChart.drawingUtils.common.getAxisLabelToFront.call(this, this.additionalDrawings['lineLabel'], true);
};

infChart.verticalLineDrawing.prototype.bindSettingsEvents = function () {
    var self = this;

    var callBackFnLineSettingsEvents = {
        onLineColorChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.lineColor, {
            isUpdateAnnotationStyles: true,
            settingsItem: 'line'
        }),
        onLineWidthChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.lineWidth, {
            isUpdateAnnotationStyles: true,
            settingsItem: 'lineWidth'

        }),
        onLineStyleChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.lineStyle, {
            isUpdateAnnotationStyles: true,
            settingsItem: 'lineStyle',
        }),
        onResetToDefault : function(){
            self.updateSavedDrawingProperties(true)
        }   
    }

    infChart.structureManager.drawingTools.bindLineSettings(self.settingsPopup, callBackFnLineSettingsEvents);
};

infChart.verticalLineDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    return {
        shape: 'verticalLine',
        settings:{
            lineColor: infChart.themeManager.getDrawingsBorderColor(annotation.options.shape.params.stroke, 'verticalLine'),
            lineOpacity: annotation.options.shape.params.opacity,
            lineWidth: annotation.options.shape.params['stroke-width'],
            lineStyle: annotation.options.shape.params.dashstyle,
            fillColor: infChart.themeManager.getDrawingsFillColor(annotation.options.shape.params.fill, 'verticalLine')
        },
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        clickCords: annotation.options.clickCords,
        height: annotation.chart.plotHeight,
        isLocked : annotation.options.isLocked

    };
};

/**
 * Returns the obj of properties to copy
 * @returns {object} properties
 */
infChart.verticalLineDrawing.prototype.getConfigToCopy = function () {
    var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(this.annotation.chart);
    var chartInstance = infChart.manager.getChart(stockChartId);
    var xAxis = chartInstance.getMainXAxis();
    var properties = this.getConfig();
    var shapeTheme = infChart.drawingUtils.common.theme.verticalLine;
    var copyDistance = shapeTheme && shapeTheme.copyDistance ? shapeTheme.copyDistance.x : infChart.drawingUtils.common.theme.defaultCopyDistance;

    properties.xValue = xAxis.toValue(xAxis.toPixels(properties.xValue) + copyDistance);
    return properties;
};

infChart.verticalLineDrawing.prototype.getOptions = function (properties, chart) {
    var options = {
        utilizeAxes: "x",
        xValue: properties.xValue,
        yValue: properties.yValue,
        nearestXDataPoint: infChart.math.findNearestXDataPoint(chart, properties.xValue, undefined, true, true),
        allowDragY: false,
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0],
                dashstyle: 'solid',
                'class': 'vertical-line',
                'stroke-width': infChart.drawingUtils.common.baseLineWidth
            }
        },
        settings: {}
    };

    if(properties.settings){
        options.settings = properties.settings;
        if (properties.settings.fillColor) {
            options.shape.params.fill = properties.settings.fillColor;
        }
        if (properties.settings.lineColor) {
            options.shape.params.stroke = properties.settings.lineColor;
        }
        if (properties.settings.lineOpacity) {
            options.shape.params.opacity = properties.settings.lineOpacity;
        }
        if (properties.settings.lineStyle) {
            options.shape.params.dashstyle = properties.settings.lineStyle;
        }
        if (properties.settings.lineWidth) {
            options.shape.params['stroke-width'] = properties.settings.lineWidth;
        }
    } else {
        options.settings.lineColor = infChart.drawingUtils.common.baseBorderColor;
        options.settings.lineOpacity = infChart.drawingUtils.common.baseFillOpacity;
        options.settings.lineStyle = 'solid';
        options.settings.lineWidth = infChart.drawingUtils.common.baseLineWidth;
    }
    if (properties.height) {
        options.shape.params.d = ['M', 0, 0, 'L', 0, properties.height * 1.5];
    }
    if (properties.clickCords) {
        options.clickCords = properties.clickCords;
    }

    options.isRealTimeTranslation = true;
    options.useFutureDate = true;
    options.useAllXDataToFindNearestPoint = true;
    options.validateTranslationFn = this.validateTranslation;

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.verticalLineDrawing.prototype.validateTranslation = function (newXValue) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        seriesData = chart.series[0].xData,
        dataMin = seriesData[0],
        totalPoints = infChart.drawingsManager.getTotalPoints(chart),
        dataMax = totalPoints[totalPoints.length - 1];

    return (newXValue >= dataMin && newXValue <= dataMax);
};

infChart.verticalLineDrawing.prototype.getQuickSettingsPopup = function () {
    return infChart.drawingUtils.common.getLineQuickSettings(infChart.drawingUtils.common.baseBorderColor, infChart.drawingUtils.common.baseFillOpacity);
};

infChart.verticalLineDrawing.prototype.getSettingsPopup = function () {
    return infChart.drawingUtils.common.getLineSettings('Vertical Line', infChart.drawingUtils.common.baseBorderColor, undefined, undefined, undefined, undefined, infChart.drawingUtils.common.baseFillOpacity, false, false);
};

infChart.verticalLineDrawing.prototype.scale = function (isCalculateNewValueForScale) {
    var ann = this.annotation,
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        label = this.additionalDrawings['lineLabel'],
        nearestXDataPoint;

    if (isCalculateNewValueForScale) {
        nearestXDataPoint = infChart.math.findNearestXDataPoint(chart, options.xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
        ann.update({
            nearestXDataPoint: nearestXDataPoint,
        });
        options.nearestXDataPoint = nearestXDataPoint;
    }

    var newX = xAxis.toPixels(options.nearestXDataPoint) - xAxis.toPixels(ann.options.xValue),
        line = ["M", newX, 0, 'L', newX, yAxis.height];
    ann.update({
        yValue: yAxis.toValue(chart.plotTop),
        shape: {
            params: {
                d: line
            }
        }
    });
    label.attr({
        x: newX - (label.width / 2),
        y: chart.plotHeight,
        zIndex: 20,
        text: this.stockChart.getXAxisCrosshairLabel(options.nearestXDataPoint, this.stockChart.chart.xAxis[this.annotation.options.xAxis])
    });

    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, ["M", line[1], 0, 'L', line[4], line[5]], this.dragSupporters);

    // Update new position of the selection marker when scaling the chart while vertical line is selected
    if (ann.selectionMarker && ann.selectionMarker.length > 0) {
        ann.selectionMarker[0].attr({
            x: newX
        });
    }
};

infChart.verticalLineDrawing.prototype.select = function () {
    infChart.drawingUtils.common.getAxisLabelToFront.call(this, this.additionalDrawings['lineLabel']);
};

infChart.verticalLineDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        label = this.additionalDrawings['lineLabel'],
        xAxis = chart.xAxis[options.xAxis],
        newX = xAxis.toPixels(options.nearestXDataPoint) - xAxis.toPixels(options.xValue);

    if (!ann.selectionMarker) {
        ann.selectionMarker = [];
        infChart.drawingUtils.common.addSelectionMarker.call(this, ann, newX, ann.chart.yAxis[ann.options.yAxis].height / 2);
    }
    // infChart.drawingUtils.common.getAxisLabelToFront.call(this, label);
};

infChart.verticalLineDrawing.prototype.step = function () { };

infChart.verticalLineDrawing.prototype.stop = function (e) {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        label = this.additionalDrawings['lineLabel'],
        nearestXDataPoint = infChart.math.findNearestXDataPoint(chart, xAxis.toValue(e.chartX), undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate),
        newX = xAxis.toPixels(nearestXDataPoint) - xAxis.toPixels(ann.options.xValue),
        line = ["M", newX, 0, 'L', newX, yAxis.height];

    ann.update({
        nearestXDataPoint: nearestXDataPoint,
        shape: {
            params: {
                d: line
            }
        }
    });
    label.attr({
        x: newX - (label.width / 2),
        y: chart.plotHeight,
        zIndex: 20,
        text: this.stockChart.getXAxisCrosshairLabel(nearestXDataPoint, this.stockChart.chart.xAxis[this.annotation.options.xAxis])
    });

    if (ann.selectionMarker && ann.selectionMarker.length > 0) {
        ann.selectionMarker[0].attr({
            x: newX
        });
    }

    ann.group.addClass("line-drawing");
    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, ["M", line[1], 0, 'L', line[4], line[5]], this.dragSupporters);
    infChart.drawingUtils.common.onPropertyChange.call(this);
    return line;
};

infChart.verticalLineDrawing.prototype.translate = function (e) {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        label = this.additionalDrawings['lineLabel'],
        nearestXDataPoint = infChart.math.findNearestXDataPoint(chart, xAxis.toValue(e.chartX), undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate),
        newX = xAxis.toPixels(nearestXDataPoint) - xAxis.toPixels(ann.options.xValue),
        line = ["M", newX, 0, 'L', newX, yAxis.height];

    ann.update({
        nearestXDataPoint: nearestXDataPoint,
        shape: {
            params: {
                d: line
            }
        }
    });

    label.attr({
        x: newX - (label.width / 2),
        y: chart.plotHeight,
        text: this.stockChart.getXAxisCrosshairLabel(nearestXDataPoint, this.stockChart.chart.xAxis[this.annotation.options.xAxis])
    });
     // Update new position of the selection marker when scaling the chart while vertical line is selected
     if (ann.selectionMarker && ann.selectionMarker.length > 0) {
        ann.selectionMarker[0].attr({
            x: newX
        });
    }
    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, ["M", line[1], 0, 'L', line[4], line[5]], this.dragSupporters);
    infChart.drawingUtils.common.getAxisLabelToFront.call(this, label);
};

infChart.verticalLineDrawing.prototype.translateEnd = function () {
    var ann = this.annotation;
    this.selectAndBindResize();
    ann.chart.selectedAnnotation = ann;
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

/**
 * Update the annotations options specific to this tool from the given properties
 * @param options
 */
infChart.verticalLineDrawing.prototype.updateOptions = function (options) {
    var ann = this.annotation,
        options = ann.options;
    ann && ann.options && (ann.options.nearestXDataPoint = infChart.math.findNearestXDataPoint(ann.chart, options.xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate));
};

infChart.verticalLineDrawing.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updateLineSettings(this.settingsPopup, properties.settings);
};

window.infChart = window.infChart || {};

infChart.trendChannelDrawing = function () {
   infChart.drawingObject.apply(this, arguments);
};

infChart.trendChannelDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.trendChannelDrawing.prototype.additionalDrawingsFunction = function () {
   var self = this,
       ann = self.annotation,
       options = ann.options,
       chart = ann.chart,
       xAxis = chart.xAxis[options.xAxis],
       yAxis = chart.yAxis[options.yAxis],
       additionalDrawingsArr = self.additionalDrawings,
       theme = infChart.themeManager.getTheme(),
       shape = "trendChannel";

   additionalDrawingsArr.midLine = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr({
      'stroke-width': options.middleLineWidth? options.middleLineWidth : theme.drawing[shape] && theme.drawing[shape].middleLineWidth ? theme.drawing[shape].middleLineWidth : 1,
      stroke: options.middleLineColor? options.middleLineColor : theme.drawing[shape] && theme.drawing[shape].middleLineColor ? theme.drawing[shape].middleLineColor : theme.drawing.base.borderColor,
      'z-index': 2,
      cursor: 'default',
      dashstyle: options.middleLineStyle? options.middleLineStyle : theme.drawing[shape] && theme.drawing[shape].middleLineStyle ? theme.drawing[shape].middleLineStyle : 'dash'
   }).add(ann.group);

   additionalDrawingsArr.fill = chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0]).attr({
      'stroke-width': 0,
      fill: options.fillColor? options.fillColor : theme.drawing[shape] && theme.drawing[shape].fillColor ? theme.drawing[shape].fillColor : theme.drawing.base.fillColor,
      'fill-opacity': options.fillOpacity? options.fillOpacity : theme.drawing[shape] && theme.drawing[shape].fillOpacity ? theme.drawing[shape].fillOpacity : theme.drawing.base.fillOpacity,
      stroke: options.fillColor? options.fillColor : theme.drawing[shape] && theme.drawing[shape].fillColor ? theme.drawing[shape].fillColor : theme.drawing.base.fillColor,
      'z-index': 0,
      cursor: 'default',
      'pointer-events':'none'
   }).add(ann.group);

   ann.selectionMarker = [];
   infChart.drawingUtils.common.addSelectionMarker.call(this, ann, 0, 0);
};

infChart.trendChannelDrawing.prototype.bindSettingsEvents = function () {
   var self = this,
       ann = self.annotation;

   function onChannelLineColorChange(rgb, color) {
      var isPropertyChange = true;
      if (self.settingsPopup) {
         isPropertyChange = self.isSettingsPropertyChange();
      }
      infChart.drawingUtils.common.settings.onLineColorChange.call(self, rgb, color, isPropertyChange, "input[inf-ctrl=channelColorPicker]");
   }

   function onChannelLineWidthChange(channelLineWidth) {
      var isPropertyChange = true;
      if (self.settingsPopup) {
         isPropertyChange = self.isSettingsPropertyChange();
      }
      infChart.drawingUtils.common.settings.onLineWidthChange.call(self, channelLineWidth, isPropertyChange, self.settingsPopup.find(".channel-styles"));
   }

   function onChannelLineStyleChange(channelLineStyle) {
      var isPropertyChange = true;
      if (self.settingsPopup) {
         isPropertyChange = self.isSettingsPropertyChange();
      }
      infChart.drawingUtils.common.settings.onLineStyleChange.call(self, channelLineStyle, isPropertyChange, self.settingsPopup.find(".channel-styles"));
   }

   function onFillColorChange(rgb, value, opacity) {
      var isPropertyChange = true;
      if (self.settingsPopup) {
         isPropertyChange = self.isSettingsPropertyChange();
      }

      self.onFillColorChange.call(self, rgb, value, opacity, isPropertyChange);
   }

   function onMiddleLineColorChange(rgb, color) {
      var isPropertyChange = true;
      if (self.settingsPopup) {
         isPropertyChange = self.isSettingsPropertyChange();
      }
      self.onMiddleLineColorChange.call(self, rgb, color, isPropertyChange);
   }

   function onMiddleLineWidthChange(middleLineWidth) {
      var isPropertyChange = true;
      if (self.settingsPopup) {
         isPropertyChange = self.isSettingsPropertyChange();
      }
      self.onMiddleLineWidthChange.call(self, middleLineWidth, isPropertyChange);
   }

   function onMiddleLineStyleChange(middleLineStyle) {
      var isPropertyChange = true;
      if (self.settingsPopup) {
         isPropertyChange = self.isSettingsPropertyChange();
      }
      self.onMiddleLineStyleChange.call(self, middleLineStyle, isPropertyChange);
   }

   function onResetToDefault () {
      self.updateSavedDrawingProperties(true);
   }

   infChart.structureManager.drawingTools.bindTrendChannelSettings(self.settingsPopup, onChannelLineColorChange, onChannelLineWidthChange, onChannelLineStyleChange, onFillColorChange, onMiddleLineColorChange, onMiddleLineWidthChange, onMiddleLineStyleChange, onResetToDefault);
};

infChart.trendChannelDrawing.prototype.onFillColorChange = function (rgb, value, opacity, isPropertyChange) {
   var self = this;

   self.annotation.update({
      fillColor: value,
      fillOpacity: opacity,
   });

   if(self.additionalDrawings['fill']){
      self.additionalDrawings['fill'].attr({
         fill: value,
         'fill-opacity': opacity
      });
   }

   isPropertyChange && self.onPropertyChange();
   if (this.settingsPopup) {
      this.settingsPopup.data("infUndoRedo", false);
   }
   infChart.drawingUtils.common.saveDrawingProperties.call(self);
}

infChart.trendChannelDrawing.prototype.onMiddleLineColorChange = function (rgb, color, isPropertyChange) {
   var self = this;
   self.annotation.update({
      middleLineColor: color
   });

   if(self.additionalDrawings['midLine']){
      self.additionalDrawings['midLine'].attr({
         stroke: color
      });
   }

   isPropertyChange && self.onPropertyChange();
   if (this.settingsPopup) {
      this.settingsPopup.data("infUndoRedo", false);
   }
   infChart.drawingUtils.common.saveDrawingProperties.call(self);
}

infChart.trendChannelDrawing.prototype.onMiddleLineWidthChange = function (strokeWidth, isPropertyChange) {
   var self = this;

   self.annotation.update({
      middleLineWidth: strokeWidth
   });

   if(self.additionalDrawings['midLine']){
      self.additionalDrawings['midLine'].attr({
         'stroke-width': strokeWidth
      });
   }

   isPropertyChange && self.onPropertyChange();
   if (this.settingsPopup) {
      this.settingsPopup.data("infUndoRedo", false);
   }
   infChart.drawingUtils.common.saveDrawingProperties.call(self);
}

infChart.trendChannelDrawing.prototype.onMiddleLineStyleChange = function (dashStyle, isPropertyChange) {
   var self = this;

   self.annotation.update({
      middleLineStyle: dashStyle
   });

   if(self.additionalDrawings['midLine']){
      self.additionalDrawings['midLine'].attr({
         dashstyle: dashStyle
      });
   }
   isPropertyChange && self.onPropertyChange();
   if (this.settingsPopup) {
      this.settingsPopup.data("infUndoRedo", false);
   }
   infChart.drawingUtils.common.saveDrawingProperties.call(self);
}

infChart.trendChannelDrawing.prototype.getConfig = function () {
   var annotation = this.annotation;
   return {
      shape: 'trendChannel',
      channelLineColor: infChart.themeManager.getDrawingsBorderColor(annotation.options.shape.params.stroke, 'trendChannel'),
      channelLineWidth: annotation.options.shape.params['stroke-width'],
      channelLineStyle: annotation.options.shape.params.dashstyle,
      fillColor: annotation.options.fillColor,
      fillOpacity: annotation.options.fillOpacity,
      middleLineColor: annotation.options.middleLineColor,
      middleLineWidth: annotation.options.middleLineWidth,
      middleLineStyle: annotation.options.middleLineStyle,
      xValue: annotation.options.xValue,
      yValue: annotation.options.yValue,
      trendYValue: annotation.options.trendYValue,
      xValueEnd: annotation.options.xValueEnd,
      yValueEnd: annotation.options.yValueEnd,
      isLocked : annotation.options.isLocked

   };
};

infChart.trendChannelDrawing.prototype.getOptions = function (properties) {
   var options = {
      xValue: properties.xValue,
      yValue: properties.yValue,
      shape: {
         params: {
            d: ['M', 0, 0, 'L', 0, 0, 'M', 0, -60, 'L', 0, -60],
            dashstyle: 'solid'
         }
      },
      middleLineWidth: 1,
      middleLineStyle: 'dash'
   };
   if (properties.fillColor) {
      options.fillColor = properties.fillColor;
   }
   if (properties.fillOpacity) {
      options.fillOpacity = properties.fillOpacity;
   }
   if (properties.channelLineColor) {
      options.shape.params.stroke = properties.channelLineColor;
   }
   if (properties.channelLineWidth) {
      options.shape.params['stroke-width'] = properties.channelLineWidth;
   }
   if (properties.channelLineStyle) {
      options.shape.params.dashstyle = properties.channelLineStyle;
   }
   if (properties.middleLineColor) {
      options.middleLineColor = properties.middleLineColor;
   }
   if (properties.middleLineWidth) {
      options.middleLineWidth = properties.middleLineWidth;
   }
   if (properties.middleLineStyle) {
      options.middleLineStyle = properties.middleLineStyle;
   }
   if (properties.trendYValue) {
      options.trendYValue = properties.trendYValue;
   }
   if (properties.xValueEnd && properties.yValueEnd) {
      options.xValueEnd = properties.xValueEnd;
      options.yValueEnd = properties.yValueEnd;
   }
   options.validateTranslationFn = this.validateTranslation;

   options = infChart.Drawing.prototype.getOptions(properties,options);

   return options;
};

infChart.trendChannelDrawing.prototype.validateTranslation = function (newXValue) {
   var self = this,
       ann = self.annotation,
       options = ann.options,
       chart = ann.chart,
       seriesData = chart.series[0].xData,
       dataMin = seriesData[0],
       xVal = options.xValue,
       xValEnd = options.xValueEnd,
       newXValueEnd = xValEnd - xVal + newXValue,
       totalPoints = infChart.drawingsManager.getTotalPoints(chart),
       dataMax = totalPoints[totalPoints.length - 1];

   return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax);
};

/**
 * Returns the properties to set to the copy object
 * @returns {object} properties
 */
infChart.trendChannelDrawing.prototype.getConfigToCopy = function () {
   var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(this.annotation.chart);
   var chartInstance = infChart.manager.getChart(stockChartId);
   var xAxis = chartInstance.getMainXAxis();
   var yAxis = chartInstance.getMainYAxis();
   var shapeTheme = infChart.drawingUtils.common.theme["line"];
   var copyDistance = shapeTheme && shapeTheme.copyDistance;
   var defaultCopyDistance = infChart.drawingUtils.common.theme.defaultCopyDistance;
   var copyDistanceX = (copyDistance && (copyDistance.x || copyDistance.x == 0)) ? copyDistance.x : defaultCopyDistance;
   var copyDistanceY = (copyDistance && (copyDistance.y || copyDistance.y == 0)) ? copyDistance.y : defaultCopyDistance;
   var properties = this.getConfig();
   var angle = infChart.drawingUtils.common.getAngle({
      x: xAxis.toPixels(properties.xValue),
      y: yAxis.toPixels(properties.yValue)
   }, { x: xAxis.toPixels(properties.xValueEnd), y: yAxis.toPixels(properties.yValueEnd) });
   var near45 = Math.abs(angle - 45) < 5;

   properties.yValue = yAxis.toValue(yAxis.toPixels(properties.yValue) + copyDistanceY);
   properties.yValueEnd = yAxis.toValue(yAxis.toPixels(properties.yValueEnd) + copyDistanceY);
   properties.trendYValue = yAxis.toValue(yAxis.toPixels(properties.trendYValue) + copyDistanceY);
   if (!near45) {
      properties.xValue = xAxis.toValue(xAxis.toPixels(properties.xValue) + copyDistanceX);
      properties.xValueEnd = xAxis.toValue(xAxis.toPixels(properties.xValueEnd) + copyDistanceX);
   }
   return properties;
};

infChart.trendChannelDrawing.prototype.getMidpointResizeTrendChannel = function (e) {
   var ann = this.annotation,
       chart = ann.chart,
       pathDefinition = ann.shape.d.split(' '),
       width = parseFloat(pathDefinition[4]),
       height = parseFloat(pathDefinition[5]),
       //bbox = chart.container.getBoundingClientRect(),
       x = e.chartX,
       y = e.chartY,
       additionalDrawings = this.additionalDrawings;
   /* x = e.clientX - bbox.left,
   y = e.clientY - bbox.top;
   if (chart.infScaleX) {
   x = x / chart.infScaleX;
   }
   
   if (chart.infScaleY) {
   y = y / chart.infScaleY;
   }*/
   var yAxis = chart.yAxis[ann.options.yAxis],
      dy = y - yAxis.toPixels(ann.options.yValue),
      distance = (-1) * (height / 2 - dy), line;

   if (chart.isInsidePlot(x - chart.plotLeft, y - chart.plotTop)) {
      line = ["M", 0, 0, 'L', width, height, "M", 0, distance, 'L', width, height + distance];

      additionalDrawings.midLine.attr({
         d: ["M", 0, distance/2, 'L', width, (height + distance/2)]
      });

      additionalDrawings.fill.attr({
         d: ['M', 0, 0, 'L', width, height, 'L', width, height + distance, 'L', 0, distance]
      })
   } else {
      line = pathDefinition;
   }

   ann.shape.attr({
      d: line
   });

   return line;
};

infChart.trendChannelDrawing.prototype.getMidpointResizeTrendChannelAndUpdate = function (e) {
   var ann = this.annotation,
      chart = ann.chart,
      line = this.getMidpointResizeTrendChannel.call(this, e),
      xAxis = chart.xAxis[ann.options.xAxis],
      yAxis = chart.yAxis[ann.options.yAxis],
      x = xAxis.toValue(line[4] + xAxis.toPixels(ann.options.xValue)),
      y = yAxis.toValue(line[5] + yAxis.toPixels(ann.options.yValue)),
      trendY = yAxis.toValue(line[8] + yAxis.toPixels(ann.options.yValue));

   ann.update({
      xValueEnd: x,
      yValueEnd: y,
      trendYValue: trendY,
      shape: {
         params: {
            d: line
         }
      }
   });

   infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, y, trendY);
   infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
   infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, line, this.dragSupporters);
};

infChart.trendChannelDrawing.prototype.getQuickSettingsPopup = function () {
   var ann = this.annotation,
       options = ann.options,
       common = infChart.drawingUtils.common,
       theme = infChart.themeManager.getTheme(),
       shape = "trendChannel";
   var opacity = options.fillOpacity? options.fillOpacity : theme.drawing[shape] && theme.drawing[shape].fillOpacity ? theme.drawing[shape].fillOpacity : theme.drawing.base.fillOpacity;
   var fill = options.fillColor? options.fillColor : theme.drawing[shape] && theme.drawing[shape].fillColor ? theme.drawing[shape].fillColor : theme.drawing.base.fillColor;
   var channelLineColor = options.channelLineColor? options.channelLineColor : theme.drawing[shape] && theme.drawing[shape].channelLineColor ? theme.drawing[shape].channelLineColor : theme.drawing.base.borderColor;
   return infChart.structureManager.drawingTools.getTrendChannelQuickSettings(channelLineColor, fill, opacity);
};

infChart.trendChannelDrawing.prototype.getSettingsPopup = function () {
   var ann = this.annotation,
       options = ann.options,
       common = infChart.drawingUtils.common,
       theme = infChart.themeManager.getTheme(),
       shape = "trendChannel";
   var opacity = options.fillOpacity? options.fillOpacity : theme.drawing[shape] && theme.drawing[shape].fillOpacity ? theme.drawing[shape].fillOpacity : theme.drawing.base.fillOpacity;
   var fill = options.fillColor? options.fillColor : theme.drawing[shape] && theme.drawing[shape].fillColor ? theme.drawing[shape].fillColor : theme.drawing.base.fillColor;
   var channelLineColor = options.channelLineColor? options.channelLineColor : theme.drawing[shape] && theme.drawing[shape].channelLineColor ? theme.drawing[shape].channelLineColor : theme.drawing.base.borderColor;
   var middleLineColor = options.middleLineColor? options.middleLineColor : theme.drawing[shape] && theme.drawing[shape].middleLineColor ? theme.drawing[shape].middleLineColor : theme.drawing.base.borderColor;
   return infChart.structureManager.drawingTools.getTrendChannelSettings(channelLineColor, middleLineColor, fill, opacity);
};

infChart.trendChannelDrawing.prototype.scale = function () {
   var ann = this.annotation,
       chart = ann.chart,
       options = ann.options,
       line = ann.shape.d.split(' '),
       xAxis = chart.xAxis[options.xAxis],
       yAxis = chart.yAxis[options.yAxis],
       additionalDrawings = this.additionalDrawings;

   line[4] = xAxis.toPixels(options.xValueEnd) - xAxis.toPixels(options.xValue);
   line[5] = yAxis.toPixels(options.yValueEnd) - yAxis.toPixels(options.yValue);
   line[7] = line[1];
   line[8] = yAxis.toPixels(options.trendYValue) - yAxis.toPixels(ann.options.yValue);
   line[10] = line[4];
   line[11] = line[5] + line[8];

   ann.update({
      shape: {
         params: {
            d: line
         }
      }
   });

   additionalDrawings.midLine.attr({
      d: ["M", 0, (line[8]/2), 'L', line[4], (line[5] + line[8]/2)]
   });

   additionalDrawings.fill.attr({
      d: ['M', 0, 0, 'L', line[4], line[5], 'L', line[4], line[11], 'L', 0, line[8]]
   })

   infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
   infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, line, this.dragSupporters);
   infChart.drawingUtils.common.fixSelectionMarker.call(this, ann);
};

infChart.trendChannelDrawing.prototype.selectAndBindResize = function () {
   var ann = this.annotation,
      width, height, distance, startPoint, endPoint, midPoint, pathDefinition;

   ann.events.deselect.call(ann);
   ann.selectionMarker = [];
   pathDefinition = ann.shape.d.split(' ');
   width = parseFloat(pathDefinition[4]);
   height = parseFloat(pathDefinition[5]);
   distance = parseFloat(pathDefinition[8]);
   infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, 0, 0, this.stepFunction, this.stop, true);
   infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, width, height, this.stepFunction, this.stop, false);
   infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, width / 2, height / 2 + distance, this.getMidpointResizeTrendChannel, this.getMidpointResizeTrendChannelAndUpdate, false);
};

infChart.trendChannelDrawing.prototype.step = function (e, isStartPoint) {
   var ann = this.annotation,
       pathDefinition = ann.shape.d.split(' '),
       distance = parseFloat(pathDefinition[8]),
       points = infChart.drawingUtils.common.calculateInitialPoints(e, ann, isStartPoint, 0, 0),
       additionalDrawings = this.additionalDrawings;

   var line = ["M", 0, 0, 'L', parseInt(points.dx, 10), parseInt(points.dy, 10), "M", 0, distance, 'L', parseInt(points.dx, 10), parseInt(points.dy, 10) + distance];
   ann.shape.attr({
      d: line
   });

   additionalDrawings.midLine.attr({
      d: ["M", 0, distance/2, 'L', parseInt(points.dx, 10), parseInt(points.dy, 10) + distance/2]
   });

   additionalDrawings.fill.attr({
      d: ['M', 0, 0, 'L', parseInt(points.dx, 10), parseInt(points.dy, 10), 'L', parseInt(points.dx, 10), parseInt(points.dy, 10) + distance, 'L', 0, distance]
   })

   return line;
};

infChart.trendChannelDrawing.prototype.stop = function (e, isStartPoint) {
   var ann = this.annotation,
      chart = ann.chart,
      line = this.stepFunction(e, isStartPoint),
      xAxis = chart.xAxis[ann.options.xAxis],
      yAxis = chart.yAxis[ann.options.yAxis],
      x = xAxis.toValue(line[4] + xAxis.toPixels(ann.options.xValue)),
      y = yAxis.toValue(line[5] + yAxis.toPixels(ann.options.yValue)),
      trendY = yAxis.toValue(line[8] + yAxis.toPixels(ann.options.yValue));

   ann.update({
      xValueEnd: x,
      yValueEnd: y,
      trendYValue: trendY,
      shape: {
         params: {
            d: line
         }
      }
   });

   infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, y, trendY);
   infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
   infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, line, this.dragSupporters);
   infChart.drawingUtils.common.fixSelectionMarker.call(this, ann);
   infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.trendChannelDrawing.prototype.translateEnd = function () {
   infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.trendChannelDrawing.prototype.updateSettings = function (properties) {
   infChart.structureManager.drawingTools.updateTrendChannelSettings($(this.settingsPopup), properties.channelLineColor, properties.channelLineWidth, properties.channelLineStyle, properties.fillColor, properties.fillOpacity,
       properties.middleLineColor, properties.middleLineWidth, properties.middleLineStyle);
};


window.infChart = window.infChart || {};

infChart.rectangleDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
    this.rectText = "";
    this.rectTextChecked = true;
    this.verticalPosition = "Top";
    this.horizontalPosition = "Left";
    this.fontSize = "12px";
    this.fillColor = "#fff";
};

infChart.rectangleDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.rectangleDrawing.prototype.additionalDrawingsFunction = function () {
    infChart.drawingUtils.common.symbol.additionalDrawings.call(this);
    var additionalDrawingsArr = this.additionalDrawings;
    var ann = this.annotation;
    var options = ann.options;
    var chart = ann.chart;

    drawingFillAttr = {
        'stroke-width': 0,
        fill: options.shape.params.fill ? options.shape.params.fill : '#959595',
        'fill-opacity': options.shape.params['fill-opacity'] ? options.shape.params['fill-opacity'] : 0.5,
        stroke: options.shape.params.stroke ? options.shape.params.stroke: '#959595',
        'z-index': 2,
        cursor: 'move'
    };
    drawingAttr = {
        'stroke-width': options.shape.params['stroke-width'] ? options.shape.params['stroke-width'] : 1,
        fill: options.shape.params.fill ? options.shape.params.fill : '#959595',
        stroke: options.shape.params.stroke ? options.shape.params.stroke: '#959595',
        'z-index': 2,
        cursor: 'move'
    };

    additionalDrawingsArr.labels = {};
    additionalDrawingsArr.lines = {};
    additionalDrawingsArr.fill = {};

    additionalDrawingsArr.labels["rectText"] = this.getTextLabel(this.rectText, 0, 0);
    additionalDrawingsArr.lines[0] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingAttr).add(ann.group);
    additionalDrawingsArr.lines[1] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingAttr).add(ann.group);
    additionalDrawingsArr.lines[2] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingAttr).add(ann.group);
    additionalDrawingsArr.lines[3] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingAttr).add(ann.group);

    additionalDrawingsArr.fill[0] = chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0]).attr(drawingFillAttr).add(ann.group);
    additionalDrawingsArr.fill[1] = chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0]).attr(drawingFillAttr).add(ann.group);

    if(!options.isExtendToLeft){
        additionalDrawingsArr.lines[2].hide();
        additionalDrawingsArr.lines[3].hide();
        additionalDrawingsArr.fill[1].hide();
    }
    if(!options.isExtendToRight){
        additionalDrawingsArr.lines[0].hide();
        additionalDrawingsArr.lines[1].hide();
        additionalDrawingsArr.fill[0].hide();
    }
};

infChart.rectangleDrawing.prototype.getTextLabel = function (rectText, x, y) {

    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        theme = infChart.drawingUtils.common.getTheme(),
        shapeTheme = theme["trendLine"];

    return chart.renderer.createElement('foreignObject').add(ann.group).attr({
        width: '150',
        height: '120'
    
    }).css(
            {
                color: options.textColor ||shapeTheme && shapeTheme.label && shapeTheme.label.fontColor || "#ffffff !important",
                fontSize: options.textFontSize + 'px' || shapeTheme.fontSize || '12px',
                cursor: 'move',
                fontWeight: '500',
                fontStyle: 'normal',
                textDecoration: 'inherit',
                padding: '5px',
                borderRadius: '5px'
            });
};


infChart.rectangleDrawing.prototype.calculateAndUpdateTextLabel  = function () {

    var ann = this.annotation,
        options = ann.options,
        
        additionalDrawingsArr = this.additionalDrawings;

    var textLabelData = options.rectText.replace(/\n/g, "<br>");
    var textLabel = additionalDrawingsArr.labels["rectText"];
    if (textLabelData && options.rectTextChecked && options.shape) {

        var rectangle = ann.shape.d.split(' ');
        var xStart = parseInt(rectangle[1], 10);
        var xEnd = parseInt(rectangle[4], 10);
        var yStart = parseInt(rectangle[2], 10);
        var yEnd = parseInt(rectangle[11], 10);
        var rectHeight = Math.abs(yStart - yEnd);
        var rectWidth = Math.abs(xEnd - xStart);
        var alignStyleClass = 'left';
        var yLabelPosition, xLabelPosition, labelHeight, labelWidth;


        var textDimensionsFromTempNode = this.getTextDimensionsFromTempNode(textLabelData, textLabel);
        var tempNodeTextWidth = labelWidth = textDimensionsFromTempNode.width;
        var tempNodeTextHeight = textDimensionsFromTempNode.height;
        textLabel.attr({ width: labelWidth, height: tempNodeTextHeight });


        var labelHtml = "<div rel = 'rectangleText'>" + textLabelData + "</div>";
        textLabel.element.innerHTML = labelHtml;
        labelHeight = this.getLabelHeight(textLabel);

        switch (options.verticalPosition) {
            case "Top":
                yLabelPosition = yStart - labelHeight;
                break;
            case "Inside":
                labelWidth = (rectWidth < tempNodeTextWidth) ? rectWidth : tempNodeTextWidth;
                textLabel.attr({width: labelWidth, height: rectHeight}).css({'word-break' : 'break-all'});    
                labelHeight = (rectHeight < this.getLabelHeight(textLabel)) ? rectHeight : this.getLabelHeight(textLabel);
                yLabelPosition = (yStart === 0 ? yStart + yEnd / 2 : yEnd + yStart / 2) - labelHeight / 2;
                break;
            case "Bottom":
                yLabelPosition = yEnd;
                break;
        }

        switch (options.horizontalPosition) {
            case "Left":
                xLabelPosition = (xStart > xEnd) ? xEnd : xStart;
                break;
            case "Center":
                xLabelPosition = (xStart === 0 ? xEnd / 2 : xStart / 2) - labelWidth/2 ;
                alignStyleClass = 'center';

                break;
            case "Right":
                xLabelPosition = ((xStart > xEnd) ? xStart : xEnd) - labelWidth;
                var alignStyleClass = 'right';
                break;
        }

        textLabel.attr({
            x: xLabelPosition,
            y: yLabelPosition,
            width: labelWidth
        }).css({ 'text-align': alignStyleClass }).show();
    } else {
        textLabel.attr({
        }).hide();
    }
};

infChart.rectangleDrawing.prototype.getLabelHeight  =  function  (textLabel) {
    padding = Number(textLabel.styles.padding.substring(0, textLabel.styles.padding.length - 2));
    return this.additionalDrawings.labels.rectText.element.querySelectorAll('[rel=rectangleText]')[0].clientHeight + padding * 2;
}

infChart.rectangleDrawing.prototype.getTextDimensionsFromTempNode =  function (textLabelData, textLabel) {
    var tempHtmlNode = document.createElement("span");
    document.body.appendChild(tempHtmlNode);
    
    tempHtmlNode.innerHTML = textLabelData;
    tempHtmlNode.style.fontWeight = textLabel.styles.fontWeight;
    tempHtmlNode.style.fontSize = textLabel.styles.fontSize;
    tempHtmlNode.style.fontStyle = textLabel.styles.fontStyle;
    tempHtmlNode.style.padding = textLabel.styles.padding;
    var width = tempHtmlNode.offsetWidth + 20;
    var height = tempHtmlNode.offsetHeight + (parseInt(textLabel.styles.fontSize) * 2);
    document.body.removeChild(tempHtmlNode);
    
    return {width :width, height : height};
};


infChart.rectangleDrawing.prototype.bindSettingsEvents  = function () {
    var self = this;
    var common = infChart.drawingUtils.common;

    function onExtendToLeft(value) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onExtendToLeft(value, isPropertyChange);
    }

    function onExtendToRight(value) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onExtendToRight(value, isPropertyChange);
    }

    infChart.drawingUtils.common.bindBasicDrawingSettingsEvents.call(this, common.baseBorderColor, common.baseFillColor, onExtendToLeft, onExtendToRight);
};

infChart.rectangleDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    return {
        shape: 'rectangle',
        borderColor: infChart.themeManager.getDrawingsBorderColor(annotation.options.shape.params.stroke, 'rectangle'),
        fillColor: infChart.themeManager.getDrawingsFillColor(annotation.options.shape.params.fill, 'rectangle'),
        fillOpacity: annotation.options.shape.params['fill-opacity'],
        strokeWidth: annotation.options.shape.params['stroke-width'],
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        rectText: annotation.options.rectText,
        rectTextChecked: annotation.options.rectTextChecked,
        verticalPosition: annotation.options.verticalPosition,
        horizontalPosition: annotation.options.horizontalPosition,
        isExtendToLeft: annotation.options.isExtendToLeft,
        isExtendToRight: annotation.options.isExtendToRight,
        textFontSize: annotation.options.textFontSize,
        textColor: annotation.options.textColor,
        isLocked : annotation.options.isLocked
    };
};

infChart.rectangleDrawing.prototype.getOptions = function (properties) {
    var theme = infChart.drawingUtils.common.getTheme();
    var shapeTheme = theme["trendLine"];
    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        shape: {
            type: 'symbol',
            params: {
                width: 0,
                height: 0,
                symbol: 'rectangle'
            }
        },
        isIndicator: properties.isIndicator,
        isDisplayOnly: properties.isDisplayOnly,
        rectText: properties.rectText ? properties.rectText : this.rectText,
        rectTextChecked: (properties.rectTextChecked !== undefined) ? properties.rectTextChecked : this.rectTextChecked,
        verticalPosition: properties.verticalPosition ? properties.verticalPosition : this.verticalPosition,
        horizontalPosition: properties.horizontalPosition ? properties.horizontalPosition : this.horizontalPosition
    };
    if (properties.borderColor) {
        options.shape.params.stroke = properties.borderColor;
    }
    if (properties.fillColor) {
        options.shape.params.fill = properties.fillColor;
    }
    if (properties.fillOpacity) {
        options.shape.params['fill-opacity'] = properties.fillOpacity;
    }
    if (properties.strokeWidth) {
        options.shape.params['stroke-width'] = properties.strokeWidth;
    }
    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
    }

    if (properties.allowDragX !== undefined) {
        options.allowDragX = properties.allowDragX;
    }

    if (properties.allowDragY !== undefined) {
        options.allowDragY = properties.allowDragY;
    }

    if (properties.drawingType !== undefined) {
        options.drawingType = properties.drawingType;
    }

    if (properties.indicatorId) {
        options.indicatorId = properties.indicatorId;
    }

    if(properties.textColor) {
        options.textColor = properties.textColor;
    } else {
        options.textColor = shapeTheme.label.fontColor;
    }
    if(properties.textFontSize) {
        options.textFontSize = properties.textFontSize;
    } else {
        options.textFontSize = shapeTheme.label.fontSize;
    }

    if(properties.isExtendToRight !== "undefined"){
        options.isExtendToRight = properties.isExtendToRight;
    } else {
        options.isExtendToRight = false;
    }

    if(properties.isExtendToLeft !== "undefined"){
        options.isExtendToLeft = properties.isExtendToLeft;
    } else {
        options.isExtendToLeft = false;
    }

    options.validateTranslationFn = this.validateTranslation;

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.rectangleDrawing.prototype.validateTranslation = function (newXValue) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        seriesData = chart.series[0].xData,
        dataMin = seriesData[0],
        xVal = options.xValue,
        xValEnd = options.xValueEnd,
        newXValueEnd = xValEnd - xVal + newXValue,
        totalPoints = infChart.drawingsManager.getTotalPoints(chart),
        dataMax = totalPoints[totalPoints.length - 1];

    return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax);
};

infChart.rectangleDrawing.prototype.getQuickSettingsPopup = function () {
    var common = infChart.drawingUtils.common;
    return common.getRectangleQuickSettings(common.baseBorderColor, common.baseFillColor, common.baseFillOpacity);
};

infChart.rectangleDrawing.prototype.getSettingsPopup = function () {
    var common = infChart.drawingUtils.common;
    return common.getBasicDrawingSettings(infChart.manager.getLabel('label.rectangle'), common.baseBorderColor, common.baseFillColor, common.baseFillOpacity, this.shape, this.fontSize, this.fontColor);
};

infChart.rectangleDrawing.prototype.scale = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        isIndicator = options.isIndicator;
    infChart.drawingUtils.common.symbol.scale.call(self);
    if(!isIndicator){
        self.calculateAndUpdateTextLabel();
        self.calculateAndUpdateExtendLine();
    }
};

infChart.rectangleDrawing.prototype.selectAndBindResize = function () {
    infChart.drawingUtils.common.symbol.selectAndBindResize.call(this);
};

infChart.rectangleDrawing.prototype.step = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        isIndicator = options.isIndicator;
    var rect = infChart.drawingUtils.common.symbol.step.call(self, e, isStartPoint);
    if (!isIndicator) {
        self.calculateAndUpdateTextLabel();
        self.calculateAndUpdateExtendLine();
    }
    return rect;
};

infChart.rectangleDrawing.prototype.calculateAndUpdateExtendLine = function(){
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        additionalDrawings = self.additionalDrawings,
        lineDrawings = additionalDrawings.lines,
        fillDrawings = additionalDrawings.fill,
        firstCandle = chart.series[0].xData[0];

        if(ann.shape.d) {
            var box = ann.shape.d.split(' ');
            var distanceToFirstCandle = xAxis.toPixels(firstCandle) - xAxis.toPixels(options.xValue);
            var totalPoints = infChart.manager.getTotalPoints(chart);
            var distanceToLastCandle = xAxis.toPixels(totalPoints[totalPoints.length - 1]) - xAxis.toPixels(options.xValue);
            if(parseFloat(box[4]) > parseFloat(box[1])){
                rightLineStart = box[4];
                leftLineStart = box[1];
            } else {
                rightLineStart = box[1];
                leftLineStart = box[4];
            }
    
            if(parseFloat(box[2]) > parseFloat(box[8])){
                bottom = box[2];
                topValue = box[8];
            } else {
                bottom = box[8];
                topValue = box[2];
            }
            if(lineDrawings){
                $.each(lineDrawings, function (key, value) {
                    if(key == 0){
                        value.attr({
                            d: ["M", rightLineStart, topValue, "L", distanceToLastCandle + 500, topValue]
                        });
                    }
                    if(key == 1){
                        value.attr({
                            d: ["M", rightLineStart, bottom, "L", distanceToLastCandle + 500, bottom]
                        });
                    }
                    if(key == 2){
                        value.attr({
                            d: ["M", leftLineStart, topValue, "L", distanceToFirstCandle - 500, topValue]
                        });
                    }
                    if(key == 3){
                        value.attr({
                            d: ["M", leftLineStart, bottom, "L", distanceToFirstCandle - 500, bottom]
                        });
                    }
                });
            }

            if(fillDrawings){
                $.each(fillDrawings, function (key, value) {
                    if(key == 0){
                        value.attr({
                            d: ["M", rightLineStart, topValue, "L", distanceToLastCandle + 500, topValue, "L", distanceToLastCandle + 500, bottom, "L",  rightLineStart, bottom, "L", rightLineStart, topValue]
                        });
                    }
                    if(key == 1){
                        value.attr({
                            d: ["M", leftLineStart, topValue, "L", distanceToFirstCandle - 500, topValue, "L", distanceToFirstCandle - 500, bottom, "L", leftLineStart, bottom, "L", leftLineStart, topValue]
                        });
                    }
                });
            }
        }

};

infChart.rectangleDrawing.prototype.stop = function (e, isStartPoint) {
    infChart.drawingUtils.common.symbol.stop.call(this, e, isStartPoint);
};

infChart.rectangleDrawing.prototype.getShapeWidth = function () {
    var self = this,
        ann = self.annotation;

    return ann.options.shape.params.width;
};

infChart.rectangleDrawing.prototype.translateEnd = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        isIndicator = options.isIndicator,
        xAxis = chart.xAxis[options.xAxis];
    var futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];
    if (futureValue < options.xValue || futureValue < options.xValueEnd || (futureValue < options.xValueStore) || (futureValue < options.xValueEndStore)) {
        var line = ann.shape.d.split(' ');
        var value = (line[1] === '0') ? line[4] : line[1];
        var xValueEnd = xAxis.toValue(parseFloat(value) + xAxis.toPixels(options.xValue));
        ann.update({
            xValueEnd: xValueEnd
        });
    } else {
        width = Math.abs(xAxis.toPixels(options.xValueEnd) - xAxis.toPixels(options.xValue));
        var symbol = options.shape.params;
        symbol.width = width;
        ann.update({
            shape: {
                params: symbol
            }
        });
    }
    
    infChart.drawingUtils.common.symbol.translateEnd.call(this);
    if(isIndicator){
        this.calculateAndUpdateTextLabel();
        this.calculateAndUpdateExtendLine();
    }
};

infChart.rectangleDrawing.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updateBasicDrawingSettings(this.settingsPopup, properties.borderColor, properties.strokeWidth, properties.fillColor, properties.fillOpacity, 
        properties.rectText, properties.rectTextChecked, properties.verticalPosition, properties.horizontalPosition, this.shape, undefined, properties.isExtendToRight, properties.isExtendToLeft, properties.textColor, properties.textFontSize);
};

infChart.rectangleDrawing.prototype.isRequiredProperty = function (propertyId, reset) {
    var isPositionProperty = false;

    switch (propertyId) {
        case "yValue":
        case "yValueEnd":
        case "xValue":
        case "xValueEnd":
            isPositionProperty = true;
            break
        case "rectText":
        case "isLocked":
            isPositionProperty = !reset
            break;
        default:
            break;
    }

    return isPositionProperty;
};

/*
* @param {boolean} extended property ti extend the lines to left
* @param {boolean|undefined} isPropertyChange property change
*/
infChart.rectangleDrawing.prototype.onExtendToRight = function (extended, isPropertyChange) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        additionalDrawings = self.additionalDrawings,
        lineDrawings = additionalDrawings.lines,
        fillDrawings = additionalDrawings.fill;

    if(lineDrawings){
        if(extended){
            lineDrawings[0].show();
            lineDrawings[1].show();
        } else {
            lineDrawings[0].hide();
            lineDrawings[1].hide();
        }
    }

    if(fillDrawings){
        if(extended){
            fillDrawings[0].show();
        } else {
            fillDrawings[0].hide();
        }
    }
    this.annotation.options.isExtendToRight = extended;
    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

/*
* @param {boolean} extended property ti extend the lines to right
* @param {boolean|undefined} isPropertyChange property change
*/
infChart.rectangleDrawing.prototype.onExtendToLeft = function (extended, isPropertyChange) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        additionalDrawings = self.additionalDrawings,
        lineDrawings = additionalDrawings.lines,
        fillDrawings = additionalDrawings.fill;
    if(lineDrawings){
        if(extended){
            lineDrawings[2].show();
            lineDrawings[3].show();
        } else {
            lineDrawings[2].hide();
            lineDrawings[3].hide();
        }
    }

    if(fillDrawings){
        if(extended){
            fillDrawings[1].show();
        } else {
            fillDrawings[1].hide();
        }
    }
    this.annotation.options.isExtendToLeft = extended;
    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.rectangleDrawing.prototype.specificCursorChange = function(url){
    var self = this,
        ann = self.annotation,
        options = ann.options,
        additionalDrawings = self.additionalDrawings;

        $.each(additionalDrawings.lines, function (key, value) {
                if(url){
                    value.css({'cursor': 'url("' + url + '"), default'});
                } else {
                    infChart.util.setCursor(value, 'move');
                    value.css({'cursor': 'move'});
                }
        });

        $.each(additionalDrawings.fill, function (key, value) {
            if(url){
                value.css({'cursor': 'url("' + url + '"), default'});
            } else {
                infChart.util.setCursor(value, 'move');
                value.css({'cursor': 'move'});
            }
        });
};
window.infChart = window.infChart || {};

infChart.ellipseDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
    this.ellipseText = "";
    this.ellipseTextChecked = true;
    this.fontSize = "12px";
    this.fillColor = "#fff";
};

infChart.ellipseDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.ellipseDrawing.prototype.additionalDrawingsFunction = function () {
    infChart.drawingUtils.common.symbol.additionalDrawings.call(this);
    var additionalDrawingsArr = this.additionalDrawings;
    additionalDrawingsArr.labels = {};
    additionalDrawingsArr.labels["ellipseText"] = this.getTextLabel("", 0, 0);
    
    
};

infChart.ellipseDrawing.prototype.calculateAndUpdateTextLabel = function () {
    var ann = this.annotation,
        options = ann.options,
        textData = options.ellipseText,
        additionalDrawingsArr = this.additionalDrawings;
        var textLabel = additionalDrawingsArr.labels["ellipseText"];
    
    if (textData && options.ellipseTextChecked && ann.shape) {
        
        ellipse = ann.shape.d.split(' ');
        textData = options.ellipseText.replace(/\n/g, "<br>");
        var labelHtml = "<div rel = 'ellipseText' style='display: flex; justify-content: center; align-items: center;' >" + textData + "</div>";
        textLabel.hide();
        textLabel.element.innerHTML = labelHtml;

        x = parseInt (ellipse[1]);
        y = parseInt(ellipse[2]);
        horizontalRadius = ellipse[4];
        verticalRadius = ellipse[5];
        
        xLabelPosition = horizontalRadius - (horizontalRadius * 1 / Math.sqrt(2));
        yLabelPosition = verticalRadius - verticalRadius * 1 / Math.sqrt(2);

        if (x < 0) {
            xLabelPosition = -2 * horizontalRadius + xLabelPosition;
        } 

        if (y < 0) {
            yLabelPosition = -2 * verticalRadius + yLabelPosition;
        } 
        
        var width = horizontalRadius * Math.sqrt(2);
        var height = verticalRadius * Math.sqrt(2);
        padding = Number(textLabel.styles.padding.substring(0, textLabel.styles.padding.length - 2));
        this.additionalDrawings.labels.ellipseText.element.querySelectorAll('[rel=ellipseText]')[0].style.height = height - padding + "px";

        textLabel.attr({ x: xLabelPosition, y: yLabelPosition, width : width, height : height }).css({ 'text-align': 'center', 'word-break' : 'break-all' }).show();
    } else {
        textLabel.hide();
    }

        

}

infChart.ellipseDrawing.prototype.getLabelHeight =  function  () {
    return this.additionalDrawings.labels.ellipseText.element.querySelectorAll('[rel=ellipseText]')[0].clientHeight;
}

infChart.ellipseDrawing.prototype.getTextLabel = function (lineText, x, y) {

    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        theme = infChart.drawingUtils.common.getTheme(),
        shapeTheme = theme["trendLine"];

    return chart.renderer.createElement('foreignObject').add(ann.group).attr({
        width: '150',
        height: '120'
    
    }).css(
            {
                color: options.textColor ||shapeTheme && shapeTheme.label && shapeTheme.label.fontColor || "#ffffff !important",
                fontSize: options.textFontSize || shapeTheme.fontSize || '12px',
                cursor: 'move',
                fontWeight: '500',
                fontStyle: 'normal',
                textDecoration: 'inherit',
                padding: '5px',
                borderRadius: '5px'
            });
};

infChart.ellipseDrawing.prototype.bindSettingsEvents = function () {
    var common = infChart.drawingUtils.common;
    common.bindBasicDrawingSettingsEvents.call(this, common.baseBorderColor, common.baseFillColor);
};

infChart.ellipseDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    return {
        shape: 'ellipse',
        borderColor: infChart.themeManager.getDrawingsBorderColor(annotation.options.shape.params.stroke, 'ellipse'),
        fillColor: infChart.themeManager.getDrawingsFillColor(annotation.options.shape.params.fill, 'ellipse'),
        fillOpacity: annotation.options.shape.params['fill-opacity'],
        strokeWidth: annotation.options.shape.params['stroke-width'],
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        ellipseText: annotation.options.ellipseText,
        ellipseTextChecked: annotation.options.ellipseTextChecked,
        textFontSize: annotation.options.textFontSize,
        textColor: annotation.options.textColor,
        isLocked : annotation.options.isLocked
    };
};

infChart.ellipseDrawing.prototype.getOptions = function (properties) {
    var theme = infChart.drawingUtils.common.getTheme();
    var shapeTheme = theme["trendLine"];
    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        shape: {
            type: 'symbol',
            params: {
                w: 0,
                h: 0,
                symbol: 'ellipse'
            }
        },
        ellipseText: properties.ellipseText ? properties.ellipseText : this.ellipseText,
        ellipseTextChecked: (properties.ellipseTextChecked !== undefined) ? properties.ellipseTextChecked : this.ellipseTextChecked,
    };
    if (properties.borderColor) {
        options.shape.params.stroke = properties.borderColor;
    }
    if (properties.fillColor) {
        options.shape.params.fill = properties.fillColor;
    }
    if (properties.fillOpacity) {
        options.shape.params['fill-opacity'] = properties.fillOpacity;
    }
    if (properties.strokeWidth) {
        options.shape.params['stroke-width'] = properties.strokeWidth;
    }
    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
    }
    if(properties.textColor) {
        options.textColor = properties.textColor;
    } else {
        options.textColor = shapeTheme.label.fontColor;
    }
    if(properties.textFontSize) {
        options.textFontSize = properties.textFontSize;
    } else {
        options.textFontSize = shapeTheme.label.fontSize;
    }
    //options.isRealTimeTranslation = true;
    options.validateTranslationFn = this.validateTranslation;

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.ellipseDrawing.prototype.validateTranslation = function (newXValue) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        seriesData = chart.series[0].xData,
        dataMin = seriesData[0],
        xVal = options.xValue,
        xValEnd = options.xValueEnd,
        newXValueEnd = xValEnd - xVal + newXValue,
        totalPoints = infChart.drawingsManager.getTotalPoints(chart),
        dataMax = totalPoints[totalPoints.length - 1];

    return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax);
};

infChart.ellipseDrawing.prototype.getQuickSettingsPopup = function () {
    var common = infChart.drawingUtils.common;
    return common.getRectangleQuickSettings(common.baseBorderColor, common.baseFillColor, common.baseFillOpacity);
};

infChart.ellipseDrawing.prototype.getSettingsPopup = function () {
    var common = infChart.drawingUtils.common;
    return common.getBasicDrawingSettings(infChart.manager.getLabel('label.ellipse'), common.baseBorderColor, common.baseFillColor, common.baseFillOpacity, this.shape, this.fontSize, this.fontColor);
};

infChart.ellipseDrawing.prototype.scale = function () {
    infChart.drawingUtils.common.symbol.scale.call(this);
    this.calculateAndUpdateTextLabel();
};

infChart.ellipseDrawing.prototype.selectAndBindResize = function () {
    infChart.drawingUtils.common.symbol.selectAndBindResize.call(this);
};

infChart.ellipseDrawing.prototype.step = function (e, isStartPoint) {
    this.calculateAndUpdateTextLabel();
    return infChart.drawingUtils.common.symbol.step.call(this, e, isStartPoint);
};

infChart.ellipseDrawing.prototype.stop = function (e, isStartPoint) {
    infChart.drawingUtils.common.symbol.stop.call(this, e, isStartPoint);
};

infChart.ellipseDrawing.prototype.getShapeWidth = function(){
    var self = this,
        ann = self.annotation;
    
    return ann.shape.width;
};

infChart.ellipseDrawing.prototype.translateEnd = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis];
    var futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];
    if(futureValue < options.xValue || futureValue < options.xValueEnd || (futureValue < options.xValueStore) || (futureValue < options.xValueEndStore)){
        var ellipse = self.annotation.shape.d.split(' ');
        var value = ellipse[1] > 0 ? ellipse[4] * 2: ellipse[4] * 2 * (-1);
        var xValueEnd = xAxis.toValue(parseFloat(value) + xAxis.toPixels(options.xValue));
        ann.update({
            xValueEnd: xValueEnd
        });
    } else {  
        width = Math.abs(xAxis.toPixels(options.xValueEnd) - xAxis.toPixels(options.xValue));
        var symbol = options.shape.params;
        symbol.width = width;
        ann.update({
            shape: {
                params: symbol
            }
        });
    }
    infChart.drawingUtils.common.symbol.translateEnd.call(this);
};

infChart.ellipseDrawing.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updateBasicDrawingSettings(this.settingsPopup, properties.borderColor, properties.strokeWidth, properties.fillColor, properties.fillOpacity,  properties.ellipseText, properties.ellipseTextChecked, undefined, undefined, this.shape, undefined, undefined,undefined,properties.textColor, properties.textFontSize);
};


infChart.ellipseDrawing.prototype.isRequiredProperty = function (propertyId, reset) {
    var isPositionProperty = false;

    switch (propertyId) {
        case "yValue":
        case "yValueEnd":
        case "xValue":
        case "xValueEnd":
            isPositionProperty = true;
            break
        case "ellipseText":
        case "isLocked":
            isPositionProperty = !reset
            break;
        default:
            break;
    }

    return isPositionProperty;
};
window.infChart = window.infChart || {};

infChart.polylineDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
};

infChart.polylineDrawing.prototype = Object.create(infChart.drawingObject.prototype);

/**
* set additional drawings of the tool
*/
infChart.polylineDrawing.prototype.additionalDrawingsFunction = function () {
    var self = this,
        additionalDrawingsArr = self.additionalDrawings,
        ann = self.annotation;
    additionalDrawingsArr.circles = {};
    ann.selectionMarker = [];
    self.setSelectionMarkers();
    
};

/**
* Get xAxis labels to front when there is an real-time update which is to redraw the chart without extrem changes
*/
infChart.polylineDrawing.prototype.afterRedrawXAxisWithoutSetExtremes = function () { };

infChart.polylineDrawing.prototype.bindSettingsEvents = function () {
    infChart.drawingUtils.common.bindPolylineSettingsEvents.call(this);
};

infChart.polylineDrawing.prototype.deselect = function () {
    this.annotation.selectionMarker = [];
    this.additionalDrawings.circles = {};
};

/**
* Returns the maximum offset of the axis labels
* @param {Highstock.Axis} axis axis object
* @returns {number} max width
*/
infChart.polylineDrawing.prototype.getAxisOffset = function (axis) {
    return 0;
};

/**
* Returns the base line's path
* @returns Array path to draw base line
*/
infChart.polylineDrawing.prototype.getBasePatternLine = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        x = xAxis.toPixels(options.xValue),
        y = yAxis.toPixels(options.yValue),
        nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate),
        newX = xAxis.toPixels(nearestDataForXValue.xData) - x,
        line = ['M', newX, 0];

    infChart.util.forEach(options.intermediatePoints, function (index, value) {
        nearestDataForIntermediateXValue = infChart.math.findNearestDataPoint(chart, value.xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate),
        newIntermediateX = xAxis.toPixels(nearestDataForIntermediateXValue.xData) - x,
        line.push('L');
        line.push(newIntermediateX);
        line.push(yAxis.toPixels(value.yValue) - y);
    });

    if (options.xValueEnd) {
        var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
        var newXEnd = xAxis.toPixels(nearestDataForXValueEnd.xData) - x;
        line.push('L');
        line.push(newXEnd);
        line.push(yAxis.toPixels(options.yValueEnd) - y);
    }
    return line;
};

infChart.polylineDrawing.prototype.getClickValues = function (clickX, clickY) {
    var ann = this.annotation;
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];
    var coordinates = {
        xValue: options.xValue,
        yValue: options.yValue,
        intermediatePoints: options.intermediatePoints
    };

    if(coordinates.intermediatePoints[ann.options.completedSteps - 1]){
        coordinates.intermediatePoints[ann.options.completedSteps - 1].xValue = xAxis.toValue(clickX);
        coordinates.intermediatePoints[ann.options.completedSteps - 1].yValue = yAxis.toValue(clickY);
    }else{
        coordinates.intermediatePoints[ann.options.completedSteps - 1] = {};
        coordinates.intermediatePoints[ann.options.completedSteps - 1].xValue = xAxis.toValue(clickX);
        coordinates.intermediatePoints[ann.options.completedSteps - 1].yValue = yAxis.toValue(clickY);
    }
    return coordinates;
};

/**
* Returns the config to save
* @returns {{shape: string, borderColor: *, strokeWidth: *, xValue: *, yValue: *, xValueEnd: *, yValueEnd: *, intermediatePoints: Array}} config object
*/
infChart.polylineDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    var intermediatePoints = [];

    infChart.util.forEach(annotation.options.intermediatePoints, function(index , value){
        intermediatePoints.push({
            xValue: value.xValue,
            yValue: value.yValue
        });
    });

    return {
        shape: 'polyline',
        borderColor: annotation.options.shape.params.stroke,
        fillColor: annotation.options.shape.params.fill,
        fillOpacity: annotation.options.shape.params['fill-opacity'],
        strokeWidth: annotation.options.shape.params['stroke-width'],
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        intermediatePoints: intermediatePoints,
        fillColorPicker: annotation.options.fillColorPicker,
        fillOpacityPicker: annotation.options.fillOpacityPicker,
        finalCompletedSteps: annotation.options.finalCompletedSteps,
        drawingIsFullFilled: annotation.options.drawingIsFullFilled,
        lineStyle: annotation.options.shape.params.dashstyle,
        isLocked : annotation.options.isLocked

    };
};

/**
* Returns the the drawing options from saved|initial properties
* @param {object} properties drawing properties
* @returns {{name: *, indicatorId: *, utilizeAxes: string, xValue: *, yValue: *, xValueEnd: *, yValueEnd: *, intermediatePoints: Array, allowDragY: boolean, shape: {params: {fill: string, d: *[]}}, isIndicator: boolean, drawingType: string, allowDragX: boolean}} options to set
*/
infChart.polylineDrawing.prototype.getOptions = function (properties) {
    var options = {
        name: properties.name,
        xValue: properties.xValue,
        yValue: properties.yValue,
        xValueEnd: properties.xValueEnd,
        yValueEnd: properties.yValueEnd,
        intermediatePoints: [],
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0]
            }
        }
    };

    if(properties.fillOpacity){
        options.shape.params["fill-opacity"] = properties.fillOpacity;
    }else{
        options.shape.params["fill-opacity"] = 0;
    }

    if (properties.fillColor) {
        options.shape.params.fill = properties.fillColor;
    }

    if(properties.fillOpacityPicker){
        options.fillOpacityPicker = properties.fillOpacityPicker;
    }else{
        options.fillOpacityPicker = 0.5;
    }

    if (properties.fillColorPicker) {
        options.fillColorPicker = properties.fillColorPicker;
    }

    if (properties.borderColor) {
        options.shape.params.stroke = properties.color || properties.borderColor;
    }

    if (properties.lineStyle) {
        options.shape.params.dashstyle = properties.lineStyle;
    } else {
        options.shape.params.dashstyle = 'solid';
    }

    if (properties.strokeWidth) {
        options.shape.params['stroke-width'] = properties.strokeWidth;
    }

    if (properties.intermediatePoints) {
        infChart.util.forEach(properties.intermediatePoints, function(index , value){
            options.intermediatePoints.push({
                xValue: value.xValue,
                yValue: value.yValue
            });
        });
    }
    if (properties.completedSteps) {
        options.completedSteps = properties.completedSteps;
    }

    if(properties.drawingIsFullFilled){
        options.drawingIsFullFilled = properties.drawingIsFullFilled;
    }else{
        options.drawingIsFullFilled = false
    }

    if (properties.finalCompletedSteps) {
        options.finalCompletedSteps = properties.finalCompletedSteps;
    }
    options.useAllXDataToFindNearestPoint = true;
    options.useFutureDate = true;
    // options.isRealTimeTranslation = true; // since label value is needed to be changed
    options.validateTranslationFn = this.validateTranslation;

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.polylineDrawing.prototype.validateTranslation = function (newXValue) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        seriesData = chart.series[0].xData,
        dataMin = seriesData[0],
        xVal = options.xValue,
        xValEnd = options.xValueEnd,
        newXValueEnd = xValEnd - xVal + newXValue,
        totalPoints = infChart.drawingsManager.getTotalPoints(chart),
        dataMax = totalPoints[totalPoints.length - 1];

        for (intermediate of options.intermediatePoints){
            var intermediateXVal = intermediate.xValue;
            var newIntermediateVal = intermediateXVal - xVal + newXValue;
            if(newIntermediateVal < dataMin || newIntermediateVal > dataMax){
                return false;
            }
        }
  
    return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax);
}; 

/**
* Returns the paths, values and positions of the shapes under this drawing
* @returns {object} pattern shapes
*/
infChart.polylineDrawing.prototype.getPatternShapes = function () {
    var nameAdditionalY = 25;
    var patternPaths = {};

    var ann = this.annotation;
    var chart = ann.chart;
    var options = ann.options;
    var intermediatePoints = options.intermediatePoints;
    var intermediatePointsRaw = this.intermediatePoints;
    var xAxis = chart.xAxis[options.xAxis];
    var yAxis = chart.yAxis[options.yAxis];

    var x = xAxis.toPixels(options.xValue);
    var y = yAxis.toPixels(options.yValue);
    var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
    var newX = xAxis.toPixels(nearestDataForXValue.xData) - x;
    
    var points = {
        circles :  [
            { x: newX, y: 0 }
        ]
    }

    infChart.util.forEach(intermediatePoints, function (index, value) {
        var nearestDataForIntermediateXValue = infChart.math.findNearestDataPoint(chart, intermediatePoints[index].xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
        var newX = xAxis.toPixels(nearestDataForIntermediateXValue.xData) - x;
        points.circles[index+1] = {x: newX, y: yAxis.toPixels(intermediatePoints[index].yValue) - y};
    });
    if(!options.drawingIsFullFilled){
        if(options.xValueEnd && options.yValueEnd){
            var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
            var newXEnd = xAxis.toPixels(nearestDataForXValueEnd.xData) - x;
            points.circles[intermediatePoints.length+1] = {x: newXEnd, y: yAxis.toPixels(options.yValueEnd) - y}
        };
    }

    patternPaths.positions =  points;
    return patternPaths;
};

infChart.polylineDrawing.prototype.getQuickSettingsPopup = function () {
    var common = infChart.drawingUtils.common;
    return infChart.structureManager.drawingTools.getPolylineQuickSettings(common.baseBorderColor, common.baseFillColor, common.baseFillOpacity);
};

infChart.polylineDrawing.prototype.getSettingsPopup = function () {
    var common = infChart.drawingUtils.common;
    return infChart.structureManager.drawingTools.getPolylineSettings(common.baseBorderColor, common.baseFillColor, common.baseFillOpacity);
};

/**
* Scale function of the tool
*/
infChart.polylineDrawing.prototype.scale = function () {
    var self = this,
        ann = self.annotation,
        line,
        additionalDrawingsArr = self.additionalDrawings;

    line = self.getBasePatternLine();

    ann.update({
        shape: {
            params: {
                d: line
            }
        }
    });

    var lineShapes = self.getPatternShapes();

    infChart.util.forEach(lineShapes.positions["circles"], function (index, value) {
        if (additionalDrawingsArr.circles[index]) {
            var circlePositions = lineShapes.positions["circles"][index];
            additionalDrawingsArr.circles[index].attr({ x: circlePositions.x, y: circlePositions.y });
        }
    });
};

infChart.polylineDrawing.prototype.scaleSelectionMarkers = function (lineShapes) {
    var self = this;
    var additionalDrawingsArr = self.additionalDrawings;
    additionalDrawingsArr.rect.x && additionalDrawingsArr.rect.x.attr({
        x: clipPosX.x,
        y: clipPosX.y,
        width: clipPosX.w,
        height: clipPosX.h
    });
    additionalDrawingsArr.rect.y && additionalDrawingsArr.rect.y.attr({
        x: clipPosY.x,
        y: clipPosY.y,
        width: clipPosY.w,
        height: clipPosY.h
    });
};

infChart.polylineDrawing.prototype.select = function () { };

infChart.polylineDrawing.prototype.selectAndBindResize = function () {
    this.setSelectionMarkers();
};

infChart.polylineDrawing.prototype.setSelectionMarkers = function () {
    var self = this;
    var ann = self.annotation;
    var options = ann.options;
    var lineShapes = self.getPatternShapes();
    var additionalDrawingsArr = self.additionalDrawings;

    if (!ann.selectionMarker.length) {
        infChart.util.forEach(lineShapes.positions["circles"], function (index, value) {
            var circlePosition = lineShapes.positions["circles"][index];
            if (circlePosition && circlePosition.x != undefined && circlePosition.y != undefined) {
                if(index == 0){
                    additionalDrawingsArr.circles[index] = infChart.drawingUtils.common.addAndBindSelectionMarker.call(self, ann, circlePosition.x, circlePosition.y, self.stepFunction, self.stop, true, {name: index, drawingId: self.drawingId}, { name: index });
                }else if(index == options.finalCompletedSteps) {
                    additionalDrawingsArr.circles[index] = infChart.drawingUtils.common.addAndBindSelectionMarker.call(self, ann, circlePosition.x, circlePosition.y, self.stepFunction, self.stop, true, {name: index, drawingId: self.drawingId}, { name: index });
                } else {
                    additionalDrawingsArr.circles[index] = infChart.drawingUtils.common.addAndBindSelectionMarker.call(self, ann, circlePosition.x, circlePosition.y, self.stepFunction, self.stop, true, undefined, { name: index });
                }
            }
        });
    }
};

/**
* Step function
* @param {Event} e event
* @param {boolean} isStartPoint indicate whether the start or not
*/
infChart.polylineDrawing.prototype.step = function (e, isStartPoint, itemProperties) {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        pointx = xAxis.toValue(e.chartX),
        pointy = yAxis.toValue(e.chartY),
        completedSteps = ann.options.completedSteps,
        intermediatePoints = options.intermediatePoints,
        newOtions = {};
    if(infChart.drawingsManager.getIsActiveDrawingInprogress()){
        if (completedSteps == 0) {
            newOtions.xValue = pointx;
            newOtions.yValue = pointy;
        } else if(completedSteps == options.finalCompletedSteps) {
            newOtions.xValueEnd = pointx;
            newOtions.yValueEnd = pointy;
        } else {
            if (!intermediatePoints[completedSteps - 1]) {
                intermediatePoints[completedSteps - 1] = {};
            }
            intermediatePoints[completedSteps - 1].xValue = pointx;
            intermediatePoints[completedSteps - 1].yValue = pointy;
        }
    } else {
        if (itemProperties.name == 0) {
            newOtions.xValue = pointx;
            newOtions.yValue = pointy;
            if(options.drawingIsFullFilled){
                newOtions.xValueEnd = pointx;
                newOtions.yValueEnd = pointy;
            }
        } else if(itemProperties.name == options.finalCompletedSteps) {
            newOtions.xValueEnd = pointx;
            newOtions.yValueEnd = pointy;
            if(options.drawingIsFullFilled){
                newOtions.xValue = pointx;
                newOtions.yValue = pointy;
            }
        } else {
            if (!intermediatePoints[itemProperties.name - 1]) {
                intermediatePoints[itemProperties.name - 1] = {};
            }
            intermediatePoints[itemProperties.name - 1].xValue = pointx;
            intermediatePoints[itemProperties.name - 1].yValue = pointy;
        }
    }
    newOtions.intermediatePoints = intermediatePoints;
    ann.update(newOtions);
    this.scale();
};

infChart.polylineDrawing.prototype.getNextPointOptions = function () {
    var ann = this.annotation;
    var completedSteps = ann.options.completedSteps;
    var pointOptions = { name: "1" };
    if(completedSteps > 0){
        pointOptions.name = completedSteps;
    }
    return pointOptions;
};

infChart.polylineDrawing.prototype.showSelectionMarkers = function (itemProperties) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        additionalDrawingsArr = self.additionalDrawings;
        var lineShapes = self.getPatternShapes();

    if(!options.drawingIsFullFilled){
        if(itemProperties.name == '0'){
            var circlePosition = lineShapes.positions["circles"][options.finalCompletedSteps];
            additionalDrawingsArr.circles[options.finalCompletedSteps] = infChart.drawingUtils.common.addAndBindSelectionMarker.call(self, ann, circlePosition.x, circlePosition.y, self.stepFunction, self.stop, true, {name: options.finalCompletedSteps, drawingId: self.drawingId}, { name: options.finalCompletedSteps });
        } else if (itemProperties.name == options.finalCompletedSteps) {
            var circlePosition = lineShapes.positions["circles"][0];
            additionalDrawingsArr.circles[0] = infChart.drawingUtils.common.addAndBindSelectionMarker.call(self, ann, circlePosition.x, circlePosition.y, self.stepFunction, self.stop, true, {name: '0', drawingId: self.drawingId}, { name: '0' });
        }
    }
};

/**
 * Stop function
 * @param {Event} e event
 * @param {boolean} isStartPoint indicate whether the start or not
 */
infChart.polylineDrawing.prototype.stop = function (e, isStartPoint, itemProperties, abortDrawing) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        intermediatePoints = options.intermediatePoints,
        lineShapes = self.getPatternShapes(),
        additionalDrawingsArr = self.additionalDrawings,
        stopPropagation = false;
    if (infChart.drawingsManager.getIsActiveDrawingInprogress()) {
        if (options.drawingIsFullFilled) {
            intermediatePoints.pop();
            ann.update({
                xValueEnd: options.xValue,
                yValueEnd: options.yValue
            });
            self.intermediatePoints = intermediatePoints;
            self.yValueEnd = options.yValueEnd;
            ann.update({
                shape: {
                    params: {
                        fill: options.fillColorPicker,
                        'fill-opacity': options.fillOpacityPicker
                    }
                }
            });
        } else {
            if(abortDrawing) {
                if(intermediatePoints.length > 1) {
                    options.xValueEnd = intermediatePoints[intermediatePoints.length - 2].xValue;
                    options.yValueEnd = intermediatePoints[intermediatePoints.length - 2].yValue;
                    intermediatePoints.pop();
                    intermediatePoints.pop();
                } else {
                    stopPropagation = true;
                }
            } else {
                options.xValueEnd = intermediatePoints[intermediatePoints.length - 1].xValue;
                options.yValueEnd = intermediatePoints[intermediatePoints.length - 1].yValue;
                intermediatePoints.pop();
            }

            ann.update({
                xValueEnd: options.xValueEnd,
                yValueEnd: options.yValueEnd
            });
            self.intermediatePoints = intermediatePoints;
            self.yValueEnd = options.yValueEnd;
        }
    } else {
        if (!options.drawingIsFullFilled) {
            var name = e.target.getAttribute('name');
            var drawingId = e.target.getAttribute('drawingId');
            if (name == '0' && drawingId == self.drawingId) {
                ann.update({
                    xValueEnd: options.xValue,
                    yValueEnd: options.yValue,
                });
                self.annotation.options.drawingIsFullFilled = true;
                self.intermediatePoints = intermediatePoints;
                self.yValueEnd = options.yValueEnd;
                ann.update({
                    shape: {
                        params: {
                            fill: options.fillColorPicker,
                            'fill-opacity': options.fillOpacityPicker
                        }
                    }
                });
                self.annotation.options.drawingIsFullFilled = true;
            }
            if (name == options.finalCompletedSteps && drawingId == self.drawingId) {
                ann.update({
                    xValue: options.xValueEnd,
                    yValue: options.yValueEnd,
                });
                self.annotation.options.drawingIsFullFilled = true;
                self.intermediatePoints = intermediatePoints;
                self.yValue = options.yValue;
                ann.update({
                    shape: {
                        params: {
                            fill: options.fillColorPicker,
                            'fill-opacity': options.fillOpacityPicker
                        }
                    }
                });
                self.annotation.options.drawingIsFullFilled = true;
            }
        }
    }
    
    for (var i = 0; i < ann.selectionMarker.length; i++) {
        ann.selectionMarker[i].destroy();
    }
    ann.selectionMarker = [];
    self.setSelectionMarkers();
    self.setPoints();
    infChart.drawingUtils.common.saveBaseYValues.call(self, ann.options.yValue, ann.options.yValueEnd, undefined, ann.options.intermediatePoints);
    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
    return {stopPropagation: stopPropagation};
};

infChart.polylineDrawing.prototype.setPoints = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        intermediatePoints = options.intermediatePoints,
        chart = ann.chart;
    var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
    var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
    var intermediatePoints = options.intermediatePoints;
    var intermediate = [];
    infChart.util.forEach(intermediatePoints, function (index, value) {
        var nearestDataForIntermediateXValue = infChart.math.findNearestDataPoint(chart, intermediatePoints[index].xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
        intermediate.push({xValue: nearestDataForIntermediateXValue.xData, yValue: intermediatePoints[index].yValue});
    });

    ann.update({
        xValue: nearestDataForXValue.xData,
        xValueEnd: nearestDataForXValueEnd.xData,
        intermediatePoints:  intermediate
    });
    self.scale();
};

infChart.polylineDrawing.prototype.translateEnd = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        line = ann.shape.d.split(' '),
        intermediatePoints = options.intermediatePoints,
        xAxis = chart.xAxis[options.xAxis];

        var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
        var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
        var intermediate = [];
        infChart.util.forEach(intermediatePoints, function (index, value) {
            var nearestDataForIntermediateXValue = infChart.math.findNearestDataPoint(chart, intermediatePoints[index].xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
            intermediate.push({xValue: nearestDataForIntermediateXValue.xData, yValue: intermediatePoints[index].yValue});
        });

        ann.update({
            xValue: nearestDataForXValue.xData,
            xValueEnd: nearestDataForXValueEnd.xData,
            intermediatePoints:  intermediate
        });
        self.scale();
};

infChart.polylineDrawing.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updatePolylineSettings(this.settingsPopup, properties.borderColor, properties.strokeWidth, properties.fillColorPicker, properties.fillOpacityPicker, properties.lineStyle);
};

infChart.polylineDrawing.prototype.isRequiredProperty = function (propertyId) {
    var isPositionProperty = false;

    switch (propertyId) {
        case "yValue":
        case "yValueEnd":
        case "xValue":
        case "xValueEnd":
        case "intermediatePoints":
        case "fillOpacity":
        case "drawingIsFullFilled":
        case "finalCompletedSteps":
        case "isLocked":
            isPositionProperty = true;
            break;
        default :
            break;
    }

    return isPositionProperty;
};

infChart.polylineDrawing.prototype.beforeUpdateOptions = function(properties) {
    var options = this.annotation.options;
    var isRemoveFill = false;

    if(properties.xValue != properties.xValueEnd && properties.yValue != properties.yValueEnd && options.xValue == options.xValueEnd && options.yValue == options.yValueEnd){
        isRemoveFill = true;
        properties.isRemoveFill = isRemoveFill;
    }
    if(properties.xValue == properties.xValueEnd && properties.yValue == properties.yValueEnd && options.xValue != options.xValueEnd && options.yValue != options.yValueEnd && !isRemoveFill){
        isRemoveFill = false;
        properties.isRemoveFill = isRemoveFill;
    }
};

infChart.polylineDrawing.prototype.updateOptions = function(properties){
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart;
    if(properties.isRemoveFill){
        ann.update({
            shape: {
                params: {
                    fill: 'none',
                    'fill-opacity': 0
                }
            },
            drawingIsFullFilled: false
        });
        options.drawingIsFullFilled = false;
        self.drawingIsFullFilled = false;
        for (var i = 0; i < ann.selectionMarker.length; i++) {
            ann.selectionMarker[i].destroy();
        }
        ann.selectionMarker = [];
        self.setSelectionMarkers();
    }

    if(properties.isRemoveFill == false){
        ann.update({
            shape: {
                params: {
                    fill: options.fillColorPicker,
                    'fill-opacity': options.fillOpacityPicker
                }
            },
            drawingIsFullFilled: true
        });
        options.drawingIsFullFilled = true;
        self.drawingIsFullFilled = true;
        for (var i = 0; i < ann.selectionMarker.length; i++) {
            ann.selectionMarker[i].destroy();
        }
        ann.selectionMarker = [];
        self.setSelectionMarkers();
    }
};
window.infChart = window.infChart || {};

infChart.brushDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
};

infChart.brushDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.brushDrawing.prototype.additionalDrawingsFunction = function () {
    var ann = this.annotation;

    ann.selectionMarker = [];
    infChart.drawingUtils.common.addSelectionMarker.call(this, ann, 0, 0);
};

infChart.brushDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    var linePointValues = [];

    annotation.options.linePointValues.forEach(function (pointValue) {
        linePointValues.push({
            xValue: pointValue.xValue,
            yValue: pointValue.yValue,
            dx: pointValue.dx,
            dy: pointValue.dy
        })
    });

    return {
        shape: 'brush',
        settings: {
            lineColor: infChart.themeManager.getDrawingsBorderColor(annotation.options.shape.params.stroke, 'brush'),
            lineOpacity: annotation.options.shape.params['stroke-opacity'],
            fillColor: infChart.themeManager.getDrawingsFillColor(annotation.options.shape.params.fill, 'brush'),
            lineWidth: annotation.options.shape.params['stroke-width'],
        },
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        linePointValues: linePointValues,
        isLocked : annotation.options.isLocked
    };
};

/**
* Return the properties to set for copy object
* @returns {object} properties
*/
infChart.brushDrawing.prototype.getConfigToCopy = function () {
    var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(this.annotation.chart);
    var chartInstance = infChart.manager.getChart(stockChartId);
    var xAxis = chartInstance.getMainXAxis();
    var yAxis = chartInstance.getMainYAxis();
    var shapeTheme = infChart.drawingUtils.common.theme["line"];
    var copyDistance = shapeTheme && shapeTheme.copyDistance;
    var defaultCopyDistance = infChart.drawingUtils.common.theme.defaultCopyDistance;
    var copyDistanceX = (copyDistance && (copyDistance.x || copyDistance.x == 0)) ? copyDistance.x : defaultCopyDistance;
    var copyDistanceY = (copyDistance && (copyDistance.y || copyDistance.y == 0)) ? copyDistance.y : defaultCopyDistance;
    var properties = this.getConfig();
    var angle = infChart.drawingUtils.common.getAngle({
        x: xAxis.toPixels(properties.xValue),
        y: yAxis.toPixels(properties.yValue)
    }, { x: xAxis.toPixels(properties.xValueEnd), y: yAxis.toPixels(properties.yValueEnd) });
    var near45 = Math.abs(angle - 45) < 5;
    // var newlinePointValues = [], point;

    properties.xValue = xAxis.toValue(xAxis.toPixels(properties.xValue) + copyDistanceX);
    properties.xValueEnd = xAxis.toValue(xAxis.toPixels(properties.xValueEnd) + copyDistanceX);

    if (!near45) {
        properties.yValue = yAxis.toValue(yAxis.toPixels(properties.yValue) + copyDistanceY);
        properties.yValueEnd = yAxis.toValue(yAxis.toPixels(properties.yValueEnd) + copyDistanceY);
    }

    properties.linePointValues.forEach(function (pointValues) {
        pointValues.xValue = xAxis.toValue(xAxis.toPixels(pointValues.xValue) + copyDistanceX);

        if (!near45) {
            pointValues.yValue = yAxis.toValue(yAxis.toPixels(pointValues.yValue) + copyDistanceY);
        }
    });

    return properties;
};

infChart.brushDrawing.prototype.getOptions = function (properties) {
    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        shape: {
            params: {
                d: ['M' + 0, 0 + 'L' + 0, 0],
                dashstyle: 'solid',
                fill: 'none'
            }
        },
        linePointValues: [],
        intermediateLine: 'M0 0L0 0',
        settings: {}
    };
    if(properties.settings){
        options.settings = properties.settings;
        if (properties.settings.fillColor) {
            options.shape.params.fill = properties.settings.fillColor;
        }
        if (properties.settings.lineColor) {
            options.shape.params.stroke = properties.settings.lineColor;
        }
        if (properties.settings.lineOpacity) {
            options.shape.params['stroke-opacity'] = properties.settings.lineOpacity;
        }
        if (properties.settings.strokeWidth) {
            options.shape.params['stroke-width'] = properties.settings.lineWidth;
        }
    } else {
        options.settings.fillColor = infChart.drawingUtils.common.baseBorderColor;
        options.settings.lineColor = infChart.drawingUtils.common.baseBorderColor;
        options.settings.lineOpacity = infChart.drawingUtils.common.baseFillOpacity;
        options.settings.lineWidth = infChart.drawingUtils.common.baseLineWidth;
    }
    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
    }
    if (properties.linePointValues) {
        properties.linePointValues.forEach(function (point) {
            options.linePointValues.push({
                xValue: point.xValue,
                yValue: point.yValue,
                dx: point.dx,
                dy: point.dy
            });
        })
    }
    options.validateTranslationFn = this.validateTranslation;
    //options.isRealTimeTranslation = true;

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.brushDrawing.prototype.validateTranslation = function (newXValue) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        seriesData = chart.series[0].xData,
        dataMin = seriesData[0],
        xVal = options.xValue,
        xValEnd = options.xValueEnd,
        newXValueEnd = xValEnd - xVal + newXValue,
        totalPoints = infChart.drawingsManager.getTotalPoints(chart),
        dataMax = totalPoints[totalPoints.length - 1];

        for (pointValues of options.linePointValues){
            var pointVal = pointValues.xValue;
            var newPointVal = pointVal - xVal + newXValue;
            if(newPointVal < dataMin || newPointVal > dataMax){
                return false;
            }
        }
  
    return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax);
};

infChart.brushDrawing.prototype.getQuickSettingsPopup = function () {
    return infChart.structureManager.drawingTools.getBrushQuickSettings(infChart.drawingUtils.common.baseBorderColor, infChart.drawingUtils.common.baseFillOpacity);
};

infChart.brushDrawing.prototype.getSettingsPopup = function () {
    return infChart.structureManager.drawingTools.getBrushSettings(infChart.drawingUtils.common.baseBorderColor, infChart.drawingUtils.common.baseFillOpacity);
};

infChart.brushDrawing.prototype.bindSettingsEvents = function () {
    var self = this;
    
    var callBackFnLineSettingsEvents = {
        onLineColorChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.lineColor, {
            isUpdateAnnotationStyles: true,
            settingsItem: 'line',
        }),
        onLineWidthChange: infChart.drawingSettings.getEventHandler(this, infChart.drawingSettings.eventTypes.lineWidth, {
            isUpdateAnnotationStyles: true,
            settingsItem: 'lineWidth'
        }),

        onResetToDefault : function(){
            self.updateSavedDrawingProperties(true)
        }   
    }

    return infChart.structureManager.drawingTools.bindLineSettings(self.settingsPopup, callBackFnLineSettingsEvents);
};

infChart.brushDrawing.prototype.scale = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        line = ['M' + 0, 0 + 'L' + 0, 0],
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];

    options.linePointValues.forEach(function (pointValues) {
        pointValues.dx = xAxis.toPixels(pointValues.xValue) - xAxis.toPixels(options.xValue);
        pointValues.dy = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(self, pointValues.yValue)) - yAxis.toPixels(options.yValue);
        line.push(parseInt(pointValues.dx, 10));
        line.push(parseInt(pointValues.dy, 10));
    });

    ann.update({
        shape: {
            params: {
                d: line
            }
        }
    });

    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, line, self.dragSupporters);
};

infChart.brushDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation,
        chart = ann.chart,
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        startX = xAxis.toPixels(ann.options.xValue);
        if(startX < 0){
            endX = this.getShapeWidth();
        }else{
            endX = xAxis.toPixels(ann.options.xValueEnd) - startX;
        }
        var endY = yAxis.toPixels(ann.options.yValueEnd) - yAxis.toPixels(ann.options.yValue);
    ann.events.deselect.call(ann);
    ann.selectionMarker = [];
    chart.selectedAnnotation = ann;

    if (!isNaN(endX) && !isNaN(endY)) {
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, 0, 0, function () { }, function () { }, true);
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, endX, endY, function () { }, function () { }, false);
    }
};

infChart.brushDrawing.prototype.step = function (e, isStartPoint) {
    var ann = this.annotation,
        chart = ann.chart,
        points = infChart.drawingUtils.common.calculateInitialPoints.call(this, e, ann, isStartPoint, 0, 0),
        line = [ann.options.intermediateLine + ' ' + parseInt(points.dx, 10), parseInt(points.dy, 10)],
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis];

    ann.shape.attr({
        d: line
    });

    ann.options.intermediateLine = ann.shape.d;
    ann.options.linePointValues.push({ xValue: xAxis.toValue(e.chartX), yValue: infChart.drawingUtils.common.getBaseYValues.call(this, yAxis.toValue(e.chartY)), dx: points.dx, dy: points.dy });

    return { line: line, points: points };
};

infChart.brushDrawing.prototype.stop = function (e, isStartPoint) {
    var ann = this.annotation,
        chart = ann.chart,
        lineData = this.stepFunction(e, isStartPoint),
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        x = xAxis.toValue(lineData.points.dx + xAxis.toPixels(ann.options.xValue)),
        y = yAxis.toValue(lineData.points.dy + yAxis.toPixels(ann.options.yValue));

    ann.update({
        xValueEnd: x,
        yValueEnd: y,
        shape: {
            params: {
                d: lineData.line
            }
        }
    });

    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, y);
    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, lineData.line, this.dragSupporters);
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.brushDrawing.prototype.getShapeWidth = function(){
    var self = this,
        ann = self.annotation,
        shape = ann.shape.d.split(' ');
    
    return shape[shape.length - 2];
};

infChart.brushDrawing.prototype.translate = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];

    // options.linePointValues.forEach(function (pointValues) {
    //     pointValues.xValue = xAxis.toValue(xAxis.toPixels(options.xValue) + pointValues.dx);
    //     pointValues.yValue = infChart.drawingUtils.common.getBaseYValues.call(self, yAxis.toValue(yAxis.toPixels(options.yValue) + pointValues.dy))
    // });
};

infChart.brushDrawing.prototype.translateEnd = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis];
    var futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];

    if(futureValue < options.xValue || futureValue < options.xValueEnd || (futureValue < options.xValueStore) || (futureValue < options.xValueEndStore)){
        var line = self.annotation.shape.d.split(' ');
        var value = line[line.length - 2];
        var xValueEnd = xAxis.toValue(parseFloat(value) + xAxis.toPixels(options.xValue));
        ann.update({
            xValueEnd: xValueEnd
        });
    }
    this.selectAndBindResize();
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.brushDrawing.prototype.updateOptions = function (options) {
    var ann = this.annotation;
    ann && ann.options && (ann.options.linePointValues = options.linePointValues);
};

infChart.brushDrawing.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updateBrushSettings(this.settingsPopup, properties.settings);
};
window.infChart = window.infChart || {};

infChart.upArrowDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
    this.fillColor = '#336699';
};

infChart.upArrowDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.upArrowDrawing.prototype.additionalDrawingsFunction = function () {
    infChart.drawingUtils.common.symbol.additionalDrawings.call(this);
};

infChart.upArrowDrawing.prototype.bindSettingsEvents = function () {
    var theme = infChart.drawingUtils.common.getTheme.call(this);
    var fillColor = theme.upArrow && theme.upArrow.fillColor ? theme.upArrow.fillColor : this.fillColor;
    infChart.drawingUtils.common.bindArrowSettingsEvents.call(this, fillColor);
};

infChart.upArrowDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    return {
        shape: 'upArrow',
        fillColor: infChart.themeManager.getDrawingsFillColor(annotation.options.shape.params.fill, 'upArrow'),
        strokeWidth: annotation.options.shape.params['stroke-width'],
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        isLocked : annotation.options.isLocked

    };
};

infChart.upArrowDrawing.prototype.getOptions = function (properties) {
    var theme = infChart.drawingUtils.common.getTheme.call(this);
    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        shape: {
            type: 'symbol',
            params: {
                width: 0,
                height: 0,
                symbol: 'upArrow',
                fill: theme.upArrow && theme.upArrow.fillColor ? theme.upArrow.fillColor : this.fillColor,
                stroke: 'none'
            }
        }
    };
    if (properties.fillColor) {
        options.shape.params.fill = properties.fillColor;
    }
    if (properties.strokeWidth) {
        options.shape.params['stroke-width'] = properties.strokeWidth;
    }
    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
    }
    options.validateTranslationFn = this.validateTranslation;

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.upArrowDrawing.prototype.validateTranslation = function (newXValue) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        seriesData = chart.series[0].xData,
        dataMin = seriesData[0],
        xVal = options.xValue,
        xValEnd = options.xValueEnd,
        newXValueEnd = xValEnd - xVal + newXValue,
        totalPoints = infChart.drawingsManager.getTotalPoints(chart),
        dataMax = totalPoints[totalPoints.length - 1];

    return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax);
};

infChart.upArrowDrawing.prototype.getQuickSettingsPopup = function () {
    var theme = infChart.drawingUtils.common.getTheme.call(this);
    var fillColor = theme.upArrow && theme.upArrow.fillColor ? theme.upArrow.fillColor : this.fillColor;
    return infChart.structureManager.drawingTools.getArrowQuickSettings(fillColor);
};

infChart.upArrowDrawing.prototype.getSettingsPopup = function () {
    var theme = infChart.drawingUtils.common.getTheme.call(this);
    var fillColor = theme.upArrow && theme.upArrow.fillColor ? theme.upArrow.fillColor : this.fillColor;
    return infChart.drawingUtils.common.getArrowSettings('Arrow Up', fillColor);
};

infChart.upArrowDrawing.prototype.selectAndBindResize = function () {
    infChart.drawingUtils.common.symbol.selectAndBindResize.call(this);
};

infChart.upArrowDrawing.prototype.scale = function () {
    infChart.drawingUtils.common.symbol.scale.call(this);
};

infChart.upArrowDrawing.prototype.step = function (e, isStartPoint) {
    return infChart.drawingUtils.common.symbol.step.call(this, e, isStartPoint);
};

infChart.upArrowDrawing.prototype.stop = function (e, isStartPoint) {
    infChart.drawingUtils.common.symbol.stop.call(this, e, isStartPoint);
};

infChart.upArrowDrawing.prototype.getShapeWidth = function(){
    var self = this,
        ann = self.annotation;
    
    return ann.options.shape.params.width;
};

infChart.upArrowDrawing.prototype.translateEnd = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis];

    var futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];
    if(futureValue < options.xValue || futureValue < options.xValueEnd || (futureValue < options.xValueStore) || (futureValue < options.xValueEndStore)){
        var upArrow = self.annotation.shape.d.split(' ');
        var value;
        if (options.xValue <= options.xValueEnd) {
            value = upArrow[4];
        } else {
            value = upArrow[19];
        }
        var xValueEnd = xAxis.toValue(parseFloat(value) + xAxis.toPixels(options.xValue));
            ann.update({
                xValueEnd: xValueEnd
            });
    } else {
        width = Math.abs(xAxis.toPixels(options.xValueEnd) - xAxis.toPixels(options.xValue));
        var symbol = options.shape.params;
        symbol.width = width;
        ann.update({
            shape: {
                params: symbol
            }
        });
    }
    infChart.drawingUtils.common.symbol.translateEnd.call(this);
};

infChart.upArrowDrawing.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updateArrowSettings(this.settingsPopup, properties.fillColor);
};
window.infChart = window.infChart || {};

infChart.downArrowDrawing = function () {
    this.fillColor = '#FF4D4D';
    infChart.drawingObject.apply(this, arguments);
};

infChart.downArrowDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.downArrowDrawing.prototype.additionalDrawings = function () {
    infChart.drawingUtils.common.symbol.additionalDrawings.call(this);
};

infChart.downArrowDrawing.prototype.bindSettingsEvents = function () {
    var theme = infChart.drawingUtils.common.getTheme.call(this);
    var fillColor = theme.downArrow && theme.downArrow.fillColor ? theme.downArrow.fillColor : this.fillColor;
    infChart.drawingUtils.common.bindArrowSettingsEvents.call(this, fillColor);
};

infChart.downArrowDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    return {
        shape: 'downArrow',
        fillColor: infChart.themeManager.getDrawingsFillColor(annotation.options.shape.params.fill, 'downArrow'),
        strokeWidth: annotation.options.shape.params['stroke-width'],
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        isLocked : annotation.options.isLocked

    };
};

infChart.downArrowDrawing.prototype.getOptions = function (properties) {
    var theme = infChart.drawingUtils.common.getTheme.call(this);
    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        shape: {
            type: 'symbol',
            params: {
                width: 0,
                height: 0,
                symbol: 'downArrow',
                fill: theme.downArrow && theme.downArrow.fillColor ? theme.downArrow.fillColor : this.fillColor,
                stroke: 'none'
            }
        }
    };
    if (properties.fillColor) {
        options.shape.params.fill = properties.fillColor;
    }
    if (properties.strokeWidth) {
        options.shape.params['stroke-width'] = properties.strokeWidth;
    }
    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
    }
    options.validateTranslationFn = this.validateTranslation;

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.downArrowDrawing.prototype.validateTranslation = function (newXValue) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        seriesData = chart.series[0].xData,
        dataMin = seriesData[0],
        xVal = options.xValue,
        xValEnd = options.xValueEnd,
        newXValueEnd = xValEnd - xVal + newXValue,
        totalPoints = infChart.drawingsManager.getTotalPoints(chart),
        dataMax = totalPoints[totalPoints.length - 1];

    return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax);
};

infChart.downArrowDrawing.prototype.getQuickSettingsPopup = function () {
    var theme = infChart.drawingUtils.common.getTheme.call(this);
    var fillColor = theme.downArrow && theme.downArrow.fillColor ? theme.downArrow.fillColor : this.fillColor;
    return infChart.structureManager.drawingTools.getArrowQuickSettings(fillColor);
};

infChart.downArrowDrawing.prototype.getSettingsPopup = function () {
    var theme = infChart.drawingUtils.common.getTheme.call(this);
    var fillColor = theme.downArrow && theme.downArrow.fillColor ? theme.downArrow.fillColor : this.fillColor;
    return infChart.drawingUtils.common.getArrowSettings('Arrow Down', fillColor);
};

infChart.downArrowDrawing.prototype.scale = function () {
    infChart.drawingUtils.common.symbol.scale.call(this);
};

infChart.downArrowDrawing.prototype.selectAndBindResize = function () {
    infChart.drawingUtils.common.symbol.selectAndBindResize.call(this);
};

infChart.downArrowDrawing.prototype.step = function (e, isStartPoint) {
    return infChart.drawingUtils.common.symbol.step.call(this, e, isStartPoint);
};

infChart.downArrowDrawing.prototype.stop = function (e, isStartPoint) {
    infChart.drawingUtils.common.symbol.stop.call(this, e, isStartPoint);
};

infChart.downArrowDrawing.prototype.getShapeWidth = function(){
    var self = this,
        ann = self.annotation;
    
    return ann.shape.params.width;
};

infChart.downArrowDrawing.prototype.translateEnd = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis];

    var futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];
    if(futureValue < options.xValue || futureValue < options.xValueEnd || (futureValue < options.xValueStore) || (futureValue < options.xValueEndStore)){
        var downArrow = self.annotation.shape.d.split(' ');
        var value;
        if (options.xValue <= options.xValueEnd) {
            value = downArrow[4];
        } else {
            value = downArrow[19];
        }
        var xValueEnd = xAxis.toValue(parseFloat(value) + xAxis.toPixels(options.xValue));
            ann.update({
                xValueEnd: xValueEnd
            });
    } else {
        width = Math.abs(xAxis.toPixels(options.xValueEnd) - xAxis.toPixels(options.xValue));
        var symbol = options.shape.params;
        symbol.width = width;
        ann.update({
            shape: {
                params: symbol
            }
        });
    }
    infChart.drawingUtils.common.symbol.translateEnd.call(this);
};

infChart.downArrowDrawing.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updateArrowSettings(this.settingsPopup, properties.fillColor);
};

window.infChart = window.infChart || {};

infChart.regressionLineDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
};

infChart.regressionLineDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.regressionLineDrawing.prototype.additionalDrawingsFunction = function () {
    var ann = this.annotation;

    ann.selectionMarker = [];

    infChart.drawingUtils.common.addSelectionMarker.call(this, ann, 0, 0);
};

infChart.regressionLineDrawing.prototype.bindSettingsEvents = function () {
    infChart.drawingUtils.common.bindBasicDrawingSettingsEvents.call(this, infChart.drawingUtils.common.baseBorderColor);
};

infChart.regressionLineDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    return {
        shape: 'regressionLine',
        borderColor: annotation.options.shape.params.stroke,
        fillColor: annotation.options.shape.params.fill,
        strokeWidth: annotation.options.shape.params['stroke-width'],
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        isLocked : annotation.options.isLocked

    };
};

infChart.regressionLineDrawing.prototype.getOptions = function (properties) {
    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        allowDragY: false,
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0]
            }
        }
    };
    if (properties.fillColor) {
        options.shape.params.fill = properties.fillColor;
    }
    if (properties.borderColor) {
        options.shape.params.stroke = properties.borderColor;
    }
    if (properties.strokeWidth) {
        options.shape.params['stroke-width'] = properties.strokeWidth;
    }
    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
    }
    options.validateTranslationFn = this.validateTranslation;

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.regressionLineDrawing.prototype.validateTranslation = function (newXValue) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        seriesData = chart.series[0].xData,
        dataMin = seriesData[0],
        xVal = options.xValue,
        xValEnd = options.xValueEnd,
        newXValueEnd = xValEnd - xVal + newXValue,
        dataMax = seriesData[seriesData.length - 1];

    return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax);
};

infChart.regressionLineDrawing.prototype.getQuickSettingsPopup = function () {
    return infChart.drawingUtils.common.getRectangleQuickSettings(infChart.drawingUtils.common.baseBorderColor);
};

infChart.regressionLineDrawing.prototype.getSettingsPopup = function () {
    return infChart.drawingUtils.common.getBasicDrawingSettings(infChart.manager.getLabel('label.regressionLine'), infChart.drawingUtils.common.baseBorderColor);
};

infChart.regressionLineDrawing.prototype.scale = function () {
    var ann = this.annotation,
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        //yAxis = chart.yAxis[options.yAxis],
        //x = ann.transX,
        //y = ann.transY,
        xVal = options.xValue,
        //yVal = options.yValue,
        periodStartXValue = options.xValueEnd > xVal ? xVal : options.xValueEnd,
        periodEndXValue = options.xValueEnd < xVal ? xVal : options.xValueEnd,
        dx = xAxis.toPixels(options.xValueEnd) - xAxis.toPixels(xVal),
        regressionLinePoints = infChart.math.calculateLinearRegression(chart, ann.options.yValue, periodStartXValue, periodEndXValue);

    var line = ["M", 0, regressionLinePoints.startPointY, 'L', parseInt(dx, 10), regressionLinePoints.endPointY];

    ann.update({
        shape: {
            params: {
                d: line
            }
        }
    });

    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, ["M", 0, line[2], 'L', line[4], line[5]], this.dragSupporters);
};

infChart.regressionLineDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation,
        width, height, pathDefinition, startX, startY;

    ann.events.deselect.call(ann);
    ann.selectionMarker = [];
    pathDefinition = ann.shape.d.split(' ');
    startX = parseFloat(pathDefinition[1]);
    startY = parseFloat(pathDefinition[2]);
    width = parseFloat(pathDefinition[4]);
    height = parseFloat(pathDefinition[5]);
    infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, startX, startY, this.stepFunction, this.stop, true);
    infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, width, height, this.stepFunction, this.stop, false);
};

infChart.regressionLineDrawing.prototype.step = function (e, isStartPoint) {
    var ann = this.annotation,
        chart = ann.chart,
        points = infChart.drawingUtils.common.calculateInitialPoints(e, ann, isStartPoint, 0, 0),
        xValueEnd = isStartPoint ? ann.options.xValueEnd : points.xAxis.toValue(points.x),
        periodStartXValue = xValueEnd > ann.options.xValue ? ann.options.xValue : xValueEnd,
        periodEndXValue = xValueEnd < ann.options.xValue ? ann.options.xValue : xValueEnd,
        regressionLinePoints = infChart.math.calculateLinearRegression(chart, ann.options.yValue, periodStartXValue, periodEndXValue);

    var line = ["M", 0, regressionLinePoints.startPointY, 'L', parseInt(points.dx, 10), regressionLinePoints.endPointY];
    ann.shape.attr({
        d: line
    });

    return line;
};

infChart.regressionLineDrawing.prototype.stop = function (e, isStartPoint) {
    var ann = this.annotation,
        chart = ann.chart,
        line = this.stepFunction(e, isStartPoint),
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        x = xAxis.toValue(line[4] + xAxis.toPixels(ann.options.xValue)),
        y = yAxis.toValue(line[5] + yAxis.toPixels(ann.options.yValue));

    ann.update({
        xValueEnd: x,
        yValueEnd: y,
        shape: {
            params: {
                d: line
            }
        }
    });

    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, y);
    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, ["M", 0, line[2], 'L', line[4], line[5]], this.dragSupporters);
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.regressionLineDrawing.prototype.translate = function () {
    var ann = this.annotation,
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        xVal = options.xValue,
        periodStartXValue = options.xValueEnd > xVal ? xVal : options.xValueEnd,
        periodEndXValue = options.xValueEnd < xVal ? xVal : options.xValueEnd,
        dx = xAxis.toPixels(options.xValueEnd) - xAxis.toPixels(xVal),
        regressionLinePoints = infChart.math.calculateLinearRegression(chart, ann.options.yValue, periodStartXValue, periodEndXValue);
    ann.events.deselect.call(ann);

    var line = ["M", 0, regressionLinePoints.startPointY, 'L', parseInt(dx, 10), regressionLinePoints.endPointY];

    ann.update({
        shape: {
            params: {
                d: line
            }
        }
    });

    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, ["M", 0, line[2], 'L', line[4], line[5]], this.dragSupporters);
    // this.openDrawingSettings.call(this);
    this.selectAndBindResize();
    ann.chart.selectedAnnotation = ann;
};

infChart.regressionLineDrawing.prototype.translateEnd = function () {
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.regressionLineDrawing.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updateBasicDrawingSettings(this.settingsPopup, properties.borderColor, properties.strokeWidth);
};

window.infChart = window.infChart || {};

infChart.regressionChannelDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
    this.levels = {
        upper: { id: "upper", fillColor: '#726a6f', fillOpacity: 0.5, label: "label.upperFillColor" },
        lower: { id: "lower", fillColor: '#835974', fillOpacity: 0.5, label: "label.lowerFillColor" }
    };
};

infChart.regressionChannelDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.regressionChannelDrawing.prototype.additionalDrawingsFunction = function () {
    var ann = this.annotation,
        chart = ann.chart,
        options = ann.options,
        additionalDrawingsArr = this.additionalDrawings,
        levels = this.levels,
        theme = infChart.drawingUtils.common.getTheme.call(this),
        drawingFillAttr;

    additionalDrawingsArr.lines = {};
    additionalDrawingsArr.fill = {};

    var regOptions, themeFillColor,
        common = infChart.drawingUtils.common;

    $.each(levels, function (indx, value) {
        regOptions = options.levels && options.levels[indx];
        themeFillColor = theme.regressionChannel && theme.regressionChannel.fillColors && theme.regressionChannel.fillColors[value.id];
        drawingFillAttr = {
            'stroke-width': 0,
            fill: regOptions && regOptions.fillColor ? regOptions.fillColor : themeFillColor ? themeFillColor : value && value.fillColor ? value.fillColor : common.baseFillColor,
            'fill-opacity': regOptions && regOptions.fillOpacity ? regOptions.fillOpacity : value.fillOpacity != undefined ? value.fillOpacity : common.baseFillOpacity,
            stroke: ann.options.shape.params.stroke,
            'z-index': 2,
            cursor: 'move'
        };
        additionalDrawingsArr.fill[value.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0]).attr(drawingFillAttr).add(ann.group);
    });


    ann.selectionMarker = [];
    infChart.drawingUtils.common.addSelectionMarker.call(this, ann, 0, 0);
};

infChart.regressionChannelDrawing.prototype.bindSettingsEvents = function () {
    var self = this;

    function onLineColorChange(rgb, color) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        infChart.drawingUtils.common.settings.onLineColorChange.call(self, rgb, color, isPropertyChange);
    }

    function onFillColorChange(rgb, value, opacity, level) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onFillColorChange(rgb, value, opacity, level, isPropertyChange)
    }

    function onLineWidthChange(strokeWidth) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        infChart.drawingUtils.common.settings.onLineWidthChange.call(self, strokeWidth, isPropertyChange);
    }

    function onResetToDefault () {
        self.updateSavedDrawingProperties(true);
    }

    infChart.structureManager.drawingTools.bindRegressionChannelSettings(self.settingsPopup, onLineColorChange, onFillColorChange, onLineWidthChange, onResetToDefault);
};

infChart.regressionChannelDrawing.prototype.getConfig = function () {
    var self = this,
        annotation = self.annotation,
        levels = {};

    $.each(self.additionalDrawings.fill, function (id, val) {
        levels[id] = {
            fillColor: val.attr('fill'),
            fillOpacity: val.attr('fill-opacity')
        }
    });
    return {
        shape: 'regressionChannel',
        levels: levels,
        borderColor: annotation.options.shape.params.stroke,
        fillColor: annotation.options.shape.params.fill,
        strokeWidth: annotation.options.shape.params['stroke-width'],
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        isLocked : annotation.options.isLocked

    };
};

infChart.regressionChannelDrawing.prototype.getOptions = function (properties) {
    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        allowDragY: false,
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0]
            }
        }
    };
    if (properties.fillColor) {
        options.shape.params.fill = properties.fillColor;
    }
    if (properties.borderColor) {
        options.shape.params.stroke = properties.borderColor;
    }
    if (properties.strokeWidth) {
        options.shape.params['stroke-width'] = properties.strokeWidth;
    }
    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
    }
    if (properties.levels) {
        options.levels = properties.levels;
    }
    options.validateTranslationFn = this.validateTranslation;

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.regressionChannelDrawing.prototype.validateTranslation = function (newXValue) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        seriesData = chart.series[0].xData,
        dataMin = seriesData[0],
        xVal = options.xValue,
        xValEnd = options.xValueEnd,
        newXValueEnd = xValEnd - xVal + newXValue,
        dataMax = seriesData[seriesData.length - 1];

    return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax);
};

infChart.regressionChannelDrawing.prototype.getQuickSettingsPopup = function () {
    return infChart.structureManager.drawingTools.getRegressionChannelQuickSettings(this.levels);
};

infChart.regressionChannelDrawing.prototype.getSettingsPopup = function () {
    return infChart.structureManager.drawingTools.getRegressionChannelSettings(this.levels);
    //var title = infChart.manager.getLabel('label.regressionChannel'),
    //    lineColor = infChart.drawingUtils.common.baseBorderColor,
    //    levels = this.levels,
    //    fillColor,
    //    baseOpacity = infChart.drawingUtils.common.baseFillOpacity,
    //    baseFillColor = infChart.drawingUtils.common.baseFillColor,
    //    fillOpacity,
    //    label;
    //
    //var regSettings =
    //    //'<div class="drawing_popup">' +
    //    //'<div class="drawing_popup_header"><div class="text-ellipsis"> <span inf-container="popupHeader">' + title + '</span></div><ul><li class="header_ctrl" inf-ctrl="closeSettings"> <span class="icon ico-close"></span> </li><li class="icon ico-trashcan header_ctrl" inf-ctrl="deleteDrawing"> </li></ul></div>' +
    //    '<div class="drawing_popup_row">' +
    //    '<table width="100%" border="0" cellspacing="0" cellpadding="0">' +
    //    '<tr>' +
    //    '<td width="30%"> <input type="hidden" inf-ctrl="lineColorPicker" value="' + lineColor + '">' +
    //    '<br>' +
    //    '<div class="label_colorPicker" data-localize="label.lineColor">' + infChart.manager.getLabel("label.lineColor") + '</div>' + '</td>';
    //
    //$.each(levels, function (id, value) {
    //
    //    fillColor = value.fillColor ? value.fillColor : baseFillColor;
    //    fillOpacity = value.fillOpacity ? value.fillOpacity : baseOpacity;
    //    label = levels[id].label;
    //
    //    regSettings += '<td width="30%"> <input type="hidden" inf-ctrl="fillColorPicker" value="' + fillColor + '" data-opacity="' + fillOpacity + '" inf-ctrl-val="' + value.id + '">' +
    //        '<div class="label_colorPicker"  data-localize="' + label + '">' + infChart.manager.getLabel(label) + '</div>' + '</td>';
    //
    //});
    //
    //regSettings +=
    //    '</tr> ' +
    //    '</table> ' +
    //    '</div>' +
    //    '<div class="drawing_popup_row">' +
    //    '<table width="100%" border="0" cellspacing="0" cellpadding="0">' +
    //    '<tr>' +
    //    '<td width="30%">' + '<div type="text" class="settings_btn selected" inf-ctrl="lineWidth" inf-size="1"><span style="font-weight: 100;">/</span></div>' + '</td>' +
    //    '<td  width="66%" colspan="2"> ' + '<div type="text" class="settings_btn" inf-ctrl="lineWidth" inf-size="2"><span style="font-weight: 400;">/</span></div>' +
    //    '<div type="text" class="settings_btn" inf-ctrl="lineWidth" inf-size="3"><span style="font-weight: 900;">/</span></div>' + '</td>' +
    //    '</tr>' +
    //    '<tr>' +
    //    '<td colspan="3" align="center">' + '<div class="label_colorPicker" data-localize="label.lineWeight">' + infChart.manager.getLabel("label.lineWeight") + '</div>' + '</td>' +
    //    '</tr>' +
    //    '</table> ' +
    //    '</div>' ;// +
    //    //'</div>';
    //
    //return regSettings;
};

/**
 * Change the fill, opacity and level of the annotation from the given params
 * IMPORTANT :: this method is uesed in commands.wrappers to set undo/redo actions
 * @param {object} rgb rgb value of the color
 * @param {string} value hash value of the color
 * @param {float} opacity opacity to be set
 * @param {number} level fib level
 * @param {boolean|undefined} isPropertyChange property change
 */
infChart.regressionChannelDrawing.prototype.onFillColorChange = function (rgb, value, opacity, level, isPropertyChange) {
    var self = this;
    self.annotation.update({
        shape: {
            params: {
                fill: value,
                'fill-opacity': opacity
            }
        }
    });

    var drawingsFill = self.additionalDrawings.fill[level];
    drawingsFill.attr({
        'fill': value,
        'fill-opacity': opacity
    });
    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.regressionChannelDrawing.prototype.scale = function () {
    var self = this,
        ann = this.annotation,
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        xVal = options.xValue,
        periodStartXValue = options.xValueEnd > xVal ? xVal : options.xValueEnd,
        periodEndXValue = options.xValueEnd < xVal ? xVal : options.xValueEnd,
        dx = xAxis.toPixels(options.xValueEnd) - xAxis.toPixels(xVal),
        regressionLinePoints = infChart.math.calculateLinearRegression(chart, ann.options.yValue, periodStartXValue, periodEndXValue),
        regressionChannelPoints = infChart.math.calculateRegressionChannel(regressionLinePoints.calcData.points, regressionLinePoints.startPointY, regressionLinePoints.endPointY),
        regLevels = this.levels,
        fillDrawings = self.additionalDrawings.fill,
        fill,
        currentLine;

    var line = [
        "M", 0, regressionLinePoints.startPointY, 'L', parseInt(dx, 10), regressionLinePoints.endPointY,
        "M", 0, regressionChannelPoints.upper.startPointY, 'L', parseInt(dx, 10), regressionChannelPoints.upper.endPointY,
        "M", 0, regressionChannelPoints.lower.startPointY, 'L', parseInt(dx, 10), regressionChannelPoints.lower.endPointY
    ];

    ann.update({
        shape: {
            params: {
                d: line
            }
        }
    });

    $.each(regLevels, (function (index) {
        fill = fillDrawings && fillDrawings[index];
        currentLine = regressionChannelPoints[index];

        if (index == "upper") {
            fill.attr({
                d: ['M', line[1], line[2], 'L', line[4], line[5], 'L', line[10], line[11], 'L', line[7], line[8], 'L', line[1], line[2]]
            });
        } else {
            fill.attr({
                d: ['M', line[1], line[2], 'L', line[4], line[5], 'L', line[16], line[17], 'L', line[13], line[14], 'L', line[1], line[2]]
            });
        }
    }));

    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, line, this.dragSupporters);
};

infChart.regressionChannelDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation,
        width, height, pathDefinition, startX, startY;

    ann.events.deselect.call(ann);
    ann.selectionMarker = [];
    pathDefinition = ann.shape.d.split(' ');
    startX = parseFloat(pathDefinition[1]);
    startY = parseFloat(pathDefinition[2]);
    width = parseFloat(pathDefinition[4]);
    height = parseFloat(pathDefinition[5]);
    infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, startX, startY, this.stepFunction, this.stop, true);
    infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, width, height, this.stepFunction, this.stop, false);
};

infChart.regressionChannelDrawing.prototype.step = function (e, isStartPoint) {
    var self = this,
        ann = this.annotation,
        chart = ann.chart,
        points = infChart.drawingUtils.common.calculateInitialPoints(e, ann, isStartPoint, 0, 0),
        xValueEnd = isStartPoint ? ann.options.xValueEnd : points.xAxis.toValue(points.x),
        periodStartXValue = xValueEnd > ann.options.xValue ? ann.options.xValue : xValueEnd,
        periodEndXValue = xValueEnd < ann.options.xValue ? ann.options.xValue : xValueEnd,
        regressionLinePoints = infChart.math.calculateLinearRegression(chart, ann.options.yValue, periodStartXValue, periodEndXValue),
        regressionChannelPoints = infChart.math.calculateRegressionChannel(regressionLinePoints.calcData.points, regressionLinePoints.startPointY, regressionLinePoints.endPointY),
        regLevels = this.levels,
        fillDrawings = self.additionalDrawings.fill,
        fill,
        currentLine;

    var line = [
        "M", 0, regressionLinePoints.startPointY, 'L', parseInt(points.dx, 10), regressionLinePoints.endPointY,
        "M", 0, regressionChannelPoints.upper.startPointY, 'L', parseInt(points.dx, 10), regressionChannelPoints.upper.endPointY,
        "M", 0, regressionChannelPoints.lower.startPointY, 'L', parseInt(points.dx, 10), regressionChannelPoints.lower.endPointY
    ];
    ann.shape.attr({
        d: line
    });
    $.each(regLevels, (function (index) {
        fill = fillDrawings && fillDrawings[index];
        currentLine = regressionChannelPoints[index];

        if (index == "upper") {
            fill.attr({
                d: ['M', line[1], line[2], 'L', line[4], line[5], 'L', line[10], line[11], 'L', line[7], line[8], 'L', line[1], line[2]]
            });
        } else {
            fill.attr({
                d: ['M', line[1], line[2], 'L', line[4], line[5], 'L', line[16], line[17], 'L', line[13], line[14], 'L', line[1], line[2]]
            });
        }
    }));
    return line;
};

infChart.regressionChannelDrawing.prototype.stop = function (e, isStartPoint) {
    var ann = this.annotation,
        chart = ann.chart,
        line = this.stepFunction(e, isStartPoint),
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        x = xAxis.toValue(line[4] + xAxis.toPixels(ann.options.xValue)),
        y = yAxis.toValue(line[5] + yAxis.toPixels(ann.options.yValue));

    ann.update({
        xValueEnd: x,
        yValueEnd: y,
        shape: {
            params: {
                d: line
            }
        }
    });

    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, y);
    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, line, this.dragSupporters);
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.regressionChannelDrawing.prototype.translate = function () {
    var ann = this.annotation,
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        xVal = options.xValue,
        periodStartXValue = options.xValueEnd > xVal ? xVal : options.xValueEnd,
        periodEndXValue = options.xValueEnd < xVal ? xVal : options.xValueEnd,
        dx = xAxis.toPixels(options.xValueEnd) - xAxis.toPixels(xVal),
        regressionLinePoints = infChart.math.calculateLinearRegression(chart, ann.options.yValue, periodStartXValue, periodEndXValue),
        regressionChannelPoints = infChart.math.calculateRegressionChannel(regressionLinePoints.calcData.points, regressionLinePoints.startPointY, regressionLinePoints.endPointY),
        regLevels = this.levels,
        fillDrawings = this.additionalDrawings.fill,
        fill,
        currentLine;

    ann.events.deselect.call(ann);

    var line = [
        "M", 0, regressionLinePoints.startPointY, 'L', parseInt(dx, 10), regressionLinePoints.endPointY,
        "M", 0, regressionChannelPoints.upper.startPointY, 'L', parseInt(dx, 10), regressionChannelPoints.upper.endPointY,
        "M", 0, regressionChannelPoints.lower.startPointY, 'L', parseInt(dx, 10), regressionChannelPoints.lower.endPointY
    ];

    ann.update({
        shape: {
            params: {
                d: line
            }
        }
    });

    $.each(regLevels, (function (index) {
        fill = fillDrawings && fillDrawings[index];
        currentLine = regressionChannelPoints[index];

        if (index == "upper") {
            fill.attr({
                d: ['M', line[1], line[2], 'L', line[4], line[5], 'L', line[10], line[11], 'L', line[7], line[8], 'L', line[1], line[2]]
            });
        } else {
            fill.attr({
                d: ['M', line[1], line[2], 'L', line[4], line[5], 'L', line[16], line[17], 'L', line[13], line[14], 'L', line[1], line[2]]
            });
        }
    }));


    infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, line, this.dragSupporters);
    // this.openDrawingSettings.call(this);
    this.selectAndBindResize();
    ann.chart.selectedAnnotation = ann;
};

infChart.regressionChannelDrawing.prototype.translateEnd = function () {
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.regressionChannelDrawing.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updateRegressionChannelSettings(this.settingsPopup, properties.borderColor, properties.strokeWidth, properties.levels);
};
window.infChart = window.infChart || {};

infChart.andrewsPitchforkDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
    this.fibLevels = [{
            id: 'level_0',
            value: 25,
            enable: false,
            fillColor: '#726a6f',
            lineColor: '#959595',
            lineWidth: 1
        },
        {
            id: 'level_1',
            value: 38.2,
            enable: false,
            fillColor: '#835974',
            lineColor: '#959595',
            lineWidth: 1
        },
        {
            id: 'level_2',
            value: 50,
            enable: false,
            fillColor: '#7b6171',
            lineColor: '#959595',
            lineWidth: 1
        },
        {
            id: 'level_3',
            value: 100,
            enable: true,
            fillColor: '#f8bce2',
            lineColor: '#959595',
            lineWidth: 1
        },
        {
            id: 'level_4',
            value: 100,
            enable: false,
            fillColor: '#f075c3',
            lineColor: '#959595',
            lineWidth: 1
        },
        {
            id: 'level_5',
            value: 150,
            enable: false,
            fillColor: '#eb40ab',
            lineColor: '#959595',
            lineWidth: 1
        },
        {
            id: 'level_6',
            value: 175,
            enable: false,
            fillColor: '#c71585',
            lineColor: '#959595',
            lineWidth: 1
        },
        {
            id: 'level_7',
            value: 200,
            enable: false,
            fillColor: '#800e56',
            lineColor: '#959595',
            lineWidth: 1
        }
    ];
    this.fibLevelDragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', type:'additionalDrawing'});
};

infChart.andrewsPitchforkDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.andrewsPitchforkDrawing.prototype.additionalDrawingsFunction = function () {
    var self = this;
    var ann = self.annotation;
    var chart = ann.chart;
    var options = ann.options;
    var additionalDrawingsObj = self.additionalDrawings;
    var fibonacciDrawings = self.fibonacciDrawings;
    var fibLevels = options.fibLevels ? options.fibLevels : self.fibLevels;
    var theme = infChart.drawingUtils.common.getTheme.call(self);
    var hiddenLevels = [];

    ann.selectionMarker = [];
    additionalDrawingsObj.fill = {};
    additionalDrawingsObj.lines = {};
    fibonacciDrawings.fill = {};
    fibonacciDrawings.lines = {};

    //if base point don't add fork, but add selection pointer
    if (ann.options.trendXValue !== Number.MIN_SAFE_INTEGER && ann.options.trendYValue !== Number.MIN_SAFE_INTEGER) {
        var shapeParams = ann.options.shape.params;
        var drawingAttr = {
            'stroke-width': shapeParams['stroke-width'],
            stroke: shapeParams.stroke,
            'z-index': 4,
            cursor: 'move'
        };

        fibLevels.forEach(function (fibLevel) {
            var themeFillColor = theme.fibRetracements && theme.fibRetracements.fibLevelFillColors && theme.fibRetracements.fibLevelFillColors[fibLevel.id];
            var baseFillOpacity = (theme.andrewsPitchfork && typeof theme.andrewsPitchfork.fillOpacity !== "undefined") ? theme.andrewsPitchfork.fillOpacity : infChart.drawingUtils.common.baseFillOpacity;
            if (!fibLevel.enable) {
                hiddenLevels.push(fibLevel);
            }
            var drawingFillAttr = {
                'fill': options.isSingleColor && options.fillColor ? options.fillColor : fibLevel && fibLevel.fillColor ? fibLevel.fillColor : themeFillColor,
                'fill-opacity': options.isSingleColor && options.fillOpacity ? options.fillOpacity : fibLevel && fibLevel.fillOpacity ? fibLevel.fillOpacity : baseFillOpacity,
                'z-index': 2,
                'cursor': 'default',
                'level': fibLevel.id,
                'pointer-events': 'none'
            };
            var drawingAttr = {
                'stroke-width': options.isSingleColor && options.lineWidth ? options.lineWidth : fibLevel && fibLevel.lineWidth ? fibLevel.lineWidth : ann.options.shape.params['stroke-width'],
                'stroke': options.isSingleColor && options.lineColor ? options.lineColor : fibLevel && fibLevel.lineColor ? fibLevel.lineColor : ann.options.shape.params.stroke,
                'z-index': 3,
                'cursor': 'default',
                'level': fibLevel.id
            };

            var linePath = chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'M', 0, 0, 'L', 0, 0]);
            var fillPath0 = chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0]);
            var fillPath1 = chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0]);

            fibonacciDrawings.lines[fibLevel.id] = linePath.attr(drawingAttr).add(ann.group);
            fibonacciDrawings.fill[fibLevel.id + '-0'] = fillPath0.attr(drawingFillAttr).add(ann.group);
            fibonacciDrawings.fill[fibLevel.id + '-1'] = fillPath1.attr(drawingFillAttr).add(ann.group);
        });

        hiddenLevels.forEach(function (fibLevel) {
            self.onFibLevelChange(fibLevel.id, false, false);
        });

        additionalDrawingsObj["lines"] = chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'M', 0, 0, 'L', 0, 0, 'M', 0, 0, 'L', 0, 0]).attr(drawingAttr).add(ann.group);

        var xAxis = chart.xAxis[ann.options.xAxis],
            yAxis = chart.yAxis[ann.options.yAxis];
        var x = xAxis.toPixels(ann.options.trendXValue) - xAxis.toPixels(ann.options.xValue);
        var y = yAxis.toPixels(ann.options.trendYValue) - yAxis.toPixels(ann.options.yValue);
        if (!isNaN(x) && !isNaN(y)) {
            infChart.drawingUtils.common.addSelectionMarker.call(this, ann, x, y);
        }
    }

    infChart.drawingUtils.common.addSelectionMarker.call(this, ann, 0, 0);
};

infChart.andrewsPitchforkDrawing.prototype.bindSettingsEvents = function () {
    let self = this;
    let isPropertyChange = function () {
        let isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = this.isSettingsPropertyChange();
        }
        return isPropertyChange;
    };
    let getFibLevelById = function (fibLevelId) {
        return self.annotation.options.fibLevels.find(function (fibLevel) {
            return fibLevel.id === fibLevelId;
        });
    };
    let bindingOptions = {
        onLineWidthChange: function (strokeWidth) {
            let isPropertyChange = true;
            if (self.settingsPopup) {
                isPropertyChange = self.isSettingsPropertyChange();
            }
            self.onLineWidthChange.call(self, strokeWidth, isPropertyChange);
        },
        onColorChange: function (rgb, color) {
            let isPropertyChange = true;
            if (self.settingsPopup) {
                isPropertyChange = self.isSettingsPropertyChange();
            }
            self.onLineColorChange.call(self, rgb, color, isPropertyChange);
        },
        onSingleOptionChange: function (fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, isSingleColor) {
            self.applyAllToFibLines(isSingleColor, fillColor, fillOpacity, lineColor, lineWidth, prevOptions, isPropertyChange.call(self));
        },
        onSingleLineColorChange: function (rgb, lineColor) {
            self.onChangeAllFibLines('lineColor', lineColor, isPropertyChange.call(self));
        },
        onSingleFillColorChange: function (rgb, value, opacity) {
            self.onChangeAllFibLines('fillColor', {
                fill: value,
                opacity: opacity
            }, isPropertyChange.call(self));
        },
        onSingleLineWidthChange: function (strokeWidth) {
            self.onChangeAllFibLines('lineWidth', parseInt(strokeWidth, 10), isPropertyChange.call(self));
        },
        onFibLevelFillColorChange: function (rgb, value, opacity, fibLevelId) {
            self.onChangeFibLines(getFibLevelById(fibLevelId), 'fillColor', {
                fill: value,
                opacity: opacity
            }, isPropertyChange.call(self));
        },
        onFibLevelLineColorChange: function (rgb, value, fibLevelId) {
            self.onChangeFibLines(getFibLevelById(fibLevelId), 'lineColor', value, isPropertyChange.call(self));
        },
        onFibLevelLineWidthChange: function (strokeWidth, fibLevelId) {
            self.onChangeFibLines(getFibLevelById(fibLevelId), 'lineWidth', parseInt(strokeWidth, 10), isPropertyChange.call(self));
        },
        onToggleFibLevel: function (checked, fibLevelId) {
            self.onChangeFibLines(getFibLevelById(fibLevelId), 'enable', checked, isPropertyChange.call(self));
        },
        onFibLvlValueChange: function (fibLevelId, value) {
            self.onChangeFibLines(getFibLevelById(fibLevelId), 'value', value, isPropertyChange.call(self));
        },
        onResetToDefault: function () {
            self.updateSavedDrawingProperties(true);
        },
        onFibApplyAllButtonClick: function (fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions) {
            infChart.drawingUtils.common.settings.onFibApplyAllButtonClick.call(self, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, true);
        }
    };

    // infChart.structureManager.drawingTools.bindRectangleSettings(self.settingsPopup, onColorChange, onLineWidthChange, onFillColorChange, onResetToDefault);
    infChart.structureManager.drawingTools.bindAndrewsPitchForkSettings(self.settingsPopup, bindingOptions);
};

infChart.andrewsPitchforkDrawing.prototype.drawFork = function (drawingObj, isMoveStartPoint) {
    let self = this;
    let ann = self.annotation;
    let chart = ann.chart;
    let options = ann.options;
    let line = ann.shape.d.split(' ');
    let startPointX = parseInt(line[1], 10);
    let startPointY = parseInt(line[2], 10);
    let endPointX = parseInt(line[4], 10);
    let endPointY = parseInt(line[5], 10);
    let plotWidth = chart.plotWidth * infChart.drawingUtils.common.correctionFactor;
    let plotHeight = chart.plotHeight * infChart.drawingUtils.common.correctionFactor;
    let xAxis = chart.xAxis[ann.options.xAxis];
    let yAxis = chart.yAxis[ann.options.yAxis];
    let fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels ? options.fibLevels : self.fibLevels);
    let xS, yS;

    if (!isMoveStartPoint) {
        xS = xAxis.toPixels(ann.options.xValue) | 0;
        yS = yAxis.toPixels(ann.options.yValue) | 0;
    } else {
        xS = startPointX + (xAxis.toPixels(ann.options.xValue));
        yS = startPointY + (yAxis.toPixels(ann.options.yValue));
    }

    let dx = endPointX + startPointX;
    let dy = endPointY + startPointY;
    let xB = xAxis.toPixels(ann.options.trendXValue) | 0;
    let yB = yAxis.toPixels(ann.options.trendYValue) | 0;
    let lineD = drawingObj.additionalDrawings.lines
    let xC = xS + dx / 2;
    let yC = yS + dy / 2;
    var srLine;

    if (Object.getOwnPropertyNames(lineD).length > 0) {
        let m, c;

        if (xC < xB) {
            plotWidth = -1 * plotWidth;
        }

        if (!isMoveStartPoint) {
            xC = xS + dx / 2;
            yC = yS + dy / 2;
            m = (yC - yB) / (xC - xB);
            c = yB - (m * xB);
            srLine = ['M', xB - xS, yB - yS, 'L', plotWidth, plotWidth * m + c,
                'M', endPointX, endPointY, 'L', startPointX, startPointY
            ];
        } else {
            let xE = xAxis.toPixels(ann.options.xValueEnd);
            let yE = yAxis.toPixels(ann.options.yValueEnd);
            xC = (xS + xE) / 2;
            yC = (yS + yE) / 2;
            m = (yC - yB) / (xC - xB);
            c = yB - (m * xB);
            let adLine = lineD.d.split(' ');
            srLine = ['M', adLine[1], adLine[2], 'L', plotWidth, plotWidth * m + c,
                'M', endPointX, endPointY, 'L', startPointX, startPointY
            ]
        }

        lineD.attr({
            d: srLine
        });

        let lastEnableLevel;
        fibLevels.forEach(function (fibLevel) {
            let fibValue = fibLevel.value / 100;
            let fibLine = self.fibonacciDrawings.lines[fibLevel.id];
            let fibFill0 = self.fibonacciDrawings.fill[fibLevel.id + '-0'];
            let fibFill1 = self.fibonacciDrawings.fill[fibLevel.id + '-1'];
            let endX, endY, startX, startY, line, pfC1, pfC2, dfx, dfy;
            let fibFillD0, fibFillD1;
            let xm = (endPointX + startPointX) / 2;
            let ym = (startPointY + endPointY) / 2;

            dfx = (xS - xC) * fibValue;
            dfy = (yS - yC) * fibValue;

            if (!isMoveStartPoint) {
                endX = xC - dfx - xS;
                endY = yC - dfy - yS;
                startX = xC + dfx - xS;
                startY = yC + dfy - yS;
            } else {
                endX = xC - dfx - xAxis.toPixels(ann.options.xValue);
                endY = yC - dfy - yAxis.toPixels(ann.options.yValue);
                startX = xC + dfx - xAxis.toPixels(ann.options.xValue);
                startY = yC + dfy - yAxis.toPixels(ann.options.yValue);
            }
            pfC1 = (yC - dfy) - (m * (xC - dfx));
            pfC2 = (yC + dfy) - (m * (xC + dfx));

            line = ['M', startX, startY, 'L', plotWidth, plotWidth * m + pfC2, 'M', endX, endY, 'L', plotWidth, plotWidth * m + pfC1];

            if (lastEnableLevel) {
                let lastEnableLine = self.fibonacciDrawings.lines[lastEnableLevel.id].d.split(' ');

                fibFillD0 = ['M', endX, endY, 'L', plotWidth, plotWidth * m + pfC1, 'L', plotWidth, lastEnableLine[11],
                    'L', lastEnableLine[7], lastEnableLine[8], 'L', endX, endY
                ];
                fibFillD1 = ['M', startX, startY, 'L', plotWidth, plotWidth * m + pfC2, 'L', plotWidth, lastEnableLine[5],
                    'L', lastEnableLine[1], lastEnableLine[2], 'L', startX, startY
                ]
            } else {
                fibFillD0 = ['M', endX, endY, 'L', plotWidth, plotWidth * m + pfC1, 'L', plotWidth, plotWidth * m + c,
                    'L', xm, ym, 'L', endX, endY
                ];
                fibFillD1 = ['M', startX, startY, 'L', plotWidth, plotWidth * m + pfC2, 'L', plotWidth, plotWidth * m + c,
                    'L', xm, ym, 'L', startX, startY
                ]
            }

            if (fibLevel.enable) {
                lastEnableLevel = fibLevel;
            }

            fibFill1.attr({
                d: fibFillD1
            });

            fibFill0.attr({
                d: fibFillD0
            });

            fibLine.attr({
                d: line
            });

        });

    }
};

infChart.andrewsPitchforkDrawing.prototype.getConfig = function () {
    var self = this;
    var annotation = this.annotation;
    var options = annotation.options;
    var fibLevels = options.fibLevels ? infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels) : self.fibLevels;
    return {
        shape: 'andrewsPitchfork',
        fibLevels: fibLevels,
        borderColor: options.lineColor,
        fillColor: options.fillColor,
        fillOpacity: options.fillOpacity,
        medianLineColor: options.medianLineColor,
        medianLineWidth: options.medianLineWidth,
        strokeWidth: options.lineWidth,
        trendXValue: options.trendXValue,
        trendYValue: options.trendYValue,
        xValue: options.xValue,
        yValue: options.yValue,
        xValueEnd: options.xValueEnd,
        yValueEnd: options.yValueEnd,
        isSingleColor: options.isSingleColor,
        isLocked : annotation.options.isLocked

    };
}

/**
 * Returns the obj of properties to copy
 * @returns {object} properties
 */
infChart.andrewsPitchforkDrawing.prototype.getConfigToCopy = function () {
    var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(this.annotation.chart);
    var chartInstance = infChart.manager.getChart(stockChartId);
    var xAxis = chartInstance.getMainXAxis();
    var yAxis = chartInstance.getMainYAxis();
    var properties = this.getConfig();
    var shapeTheme = infChart.drawingUtils.common.theme.andrewsPitchfork;
    var copyDistance = shapeTheme && shapeTheme.copyDistance;
    var defaultCopyDistance = infChart.drawingUtils.common.theme.defaultCopyDistance;
    var copyDistanceX = (copyDistance && (copyDistance.x || copyDistance.x == 0)) ? copyDistance.x : defaultCopyDistance;
    var copyDistanceY = (copyDistance && (copyDistance.y || copyDistance.y == 0)) ? copyDistance.y : defaultCopyDistance;

    properties.xValue = xAxis.toValue(xAxis.toPixels(properties.xValue) + copyDistanceX);
    properties.yValue = yAxis.toValue(yAxis.toPixels(properties.yValue) + copyDistanceY);
    properties.trendXValue = xAxis.toValue(xAxis.toPixels(properties.trendXValue) + copyDistanceX);
    properties.trendYValue = yAxis.toValue(yAxis.toPixels(properties.trendYValue) + copyDistanceY);
    if (properties.xValueEnd) {
        properties.xValueEnd = xAxis.toValue(xAxis.toPixels(properties.xValueEnd) + copyDistanceX);
    }
    if (properties.yValueEnd) {
        properties.yValueEnd = yAxis.toValue(yAxis.toPixels(properties.yValueEnd) + copyDistanceY);
    }
    return properties;
};

infChart.andrewsPitchforkDrawing.prototype.getOptions = function (properties) {
    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        trendXValue: Number.MIN_SAFE_INTEGER,
        trendYValue: Number.MIN_SAFE_INTEGER,
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0]
            }
        }
    };

    var theme = infChart.drawingUtils.common.getTheme.call(this);
    var baseFillColor = (theme.andrewsPitchfork && theme.andrewsPitchfork.singleFillColor) ? theme.andrewsPitchfork.singleFillColor : infChart.drawingUtils.common.baseFillColor;
    var baseFillOpacity = (theme.andrewsPitchfork && typeof theme.andrewsPitchfork.fillOpacity !== "undefined") ? theme.andrewsPitchfork.fillOpacity : infChart.drawingUtils.common.baseFillOpacity;
    var baseBorderColor = (theme.andrewsPitchfork && theme.andrewsPitchfork.borderColor) ? theme.fibRetracements.borderColor : infChart.drawingUtils.common.baseBorderColor;
    var baseLineWidth = (theme.andrewsPitchfork && typeof theme.andrewsPitchfork.lineWidth !== "undefined") ? theme.fibRetracements.lineWidth : infChart.drawingUtils.common.baseLineWidth;

    options.fillColor = properties.fillColor ? properties.fillColor : baseFillColor;
    options.fillOpacity = properties.fillOpacity ? properties.fillOpacity : baseFillOpacity;
    options.lineColor = properties.borderColor ? properties.borderColor : baseBorderColor;
    options.lineWidth = properties.strokeWidth ? properties.strokeWidth : baseLineWidth;
    options.medianLineColor = properties.medianLineColor ? properties.medianLineColor : baseBorderColor;
    options.medianLineWidth = properties.medianLineWidth ? properties.medianLineWidth : baseLineWidth;
    options.shape.params['fill'] = options.fillColor;
    options.shape.params['fill-opacity'] = options.fillOpacity;
    options.shape.params['stroke'] = options.medianLineColor;
    options.shape.params['stroke-width'] = options.medianLineWidth;

    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
    }
    if (properties.trendXValue && properties.trendYValue) {
        options.trendXValue = properties.trendXValue;
        options.trendYValue = properties.trendYValue;
    } else {
        options.events = null;
    }
    options.disableIntermediateScale = true;
    options.validateTranslationFn = this.validateTranslation;

    options.isSingleColor = typeof properties.isSingleColor !== "undefined" ? properties.isSingleColor : false;
    var fibLevels = properties.fibLevels ? properties.fibLevels : this.fibLevels;
    options.fibLevels = infChart.drawingUtils.common.getFibLevelsWithOpacity(infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels), baseFillOpacity);

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
}

infChart.andrewsPitchforkDrawing.prototype.validateTranslation = function (newXValue) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        seriesData = chart.series[0].xData,
        dataMin = seriesData[0],
        xVal = options.xValue,
        xValEnd = options.xValueEnd,
        trendXVal = options.trendXValue,
        newXValueEnd = xValEnd - xVal + newXValue,
        newTrendXValue = trendXVal - xVal + newXValue,
        totalPoints = infChart.drawingsManager.getTotalPoints(chart),
        dataMax = totalPoints[totalPoints.length - 1];

    return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax) && (newTrendXValue >= dataMin && newTrendXValue <= dataMax);
};

infChart.andrewsPitchforkDrawing.prototype.getQuickSettingsPopup = function () {
    var common = infChart.drawingUtils.common;
    return common.getRectangleQuickSettings(common.baseBorderColor);
};

infChart.andrewsPitchforkDrawing.prototype.getSettingsPopup = function () {
    let self = this;
    let options = self.annotation.options;
    let andrewsPitchforkOptions = {};
    andrewsPitchforkOptions['fibLevels'] = options.fibLevels ? options.fibLevels : self.fibLevels;
    andrewsPitchforkOptions['medianLineColor'] = options.medianLineColor;
    andrewsPitchforkOptions['medianLineWidth'] = options.medianLineWidth;
    andrewsPitchforkOptions['fillColor'] = options.fillColor;
    andrewsPitchforkOptions['fillOpacity'] = options.fillOpacity;
    andrewsPitchforkOptions['lineColor'] = options.lineColor;
    andrewsPitchforkOptions['lineWidth'] = options.lineWidth;
    return infChart.drawingUtils.common.getAndrewsPitchForkSettings(andrewsPitchforkOptions);
};

infChart.andrewsPitchforkDrawing.prototype.moveCenterPoint = function (e) {
    var ann = this.annotation,
        chart = ann.chart,
        //bbox = chart.container.getBoundingClientRect(),
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        x = e.chartX,
        y = e.chartY;
    /* x = e.clientX - bbox.left,
     y = e.clientY - bbox.top;
     if (chart.infScaleX) {
     x = x / chart.infScaleX;
     }
     if (chart.infScaleY) {
     y = y / chart.infScaleY;
     }*/
    //this.basePoint = {xValue : xAxis.toValue(x), yValue : yAxis.toValue(y)};
    ann.update({
        trendXValue: xAxis.toValue(x),
        trendYValue: yAxis.toValue(y)
    });

    this.drawFork(this);

    return ann.shape.d.split(' ');
};

infChart.andrewsPitchforkDrawing.prototype.moveStartPoint = function (e) {
    var ann = this.annotation,
        chart = ann.chart,
        pathDefinition = ann.shape.d.split(' '),
        x = e.chartX,
        y = e.chartY;
    var xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        xS = xAxis.toPixels(ann.options.xValue) | 0,
        yS = yAxis.toPixels(ann.options.yValue) | 0,
        dx = x - xS,
        dy = y - yS;

    var line = ["M", parseInt(dx, 10), parseInt(dy, 10), 'L', parseInt(pathDefinition[4], 10), parseInt(pathDefinition[5], 10)];
    ann.shape.attr({
        d: line
    });

    this.drawFork(this, true);

    return line;
};

/**
 * change the fillColor of annotation by given params
 * IMPORTANT :: this method is uesed in commands.wrappers to set undo/redo actions
 * @param {object} rgb rgb value of the color
 * @param {string} value hash value of the color
 * @param {string} opacity
 * @param {boolean|undefined} isPropertyChange property change 
 */
infChart.andrewsPitchforkDrawing.prototype.onFillColorChange = function (rgb, value, opacity, isPropertyChange) {
    var self = this;
    var fillD = self.additionalDrawings.fill;
    if (fillD && fillD.length > 0) {
        fillD.forEach(function (val) {
            val.attr({
                fill: value,
                'fill-opacity': opacity
            })
        });
    }
    self.annotation.update({
        shape: {
            params: {
                fill: value,
                'fill-opacity': opacity
            }
        }
    });

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

/**
 * Change the line color of the annotation from the given params
 * IMPORTANT :: this method is uesed in commands.wrappers to set undo/redo actions
 * @param {object} rgb rgb value of the color
 * @param {string} value hash value of the color
 * @param {boolean|undefined} isPropertyChange property change
 */
infChart.andrewsPitchforkDrawing.prototype.onLineColorChange = function (rgb, value, isPropertyChange) {
    let self = this;
    let ann = self.annotation;
    let options = ann.options;

    options.medianLineColor = value;

    if (self.additionalDrawings.lines) {
        self.additionalDrawings.lines.attr({
            stroke: value
        });
    }
    ann.update({
        shape: {
            params: {
                stroke: value
            }
        }
    });

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

/**
 * change the line width of annotation by given params
 * IMPORTANT :: this method is uesed in commands.wrappers to set undo/redo actions
 * @param {string} strokeWidth 
 */
infChart.andrewsPitchforkDrawing.prototype.onLineWidthChange = function (strokeWidth, isPropertyChange) {
    let self = this;
    let ann = self.annotation;
    let options = ann.options;

    options.medianLineWidth = strokeWidth;

    if (self.additionalDrawings.lines) {
        self.additionalDrawings.lines.attr({
            'stroke-width': strokeWidth
        });
    }

    self.annotation.update({
        shape: {
            params: {
                'stroke-width': strokeWidth
            }
        }
    });
    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.andrewsPitchforkDrawing.prototype.scale = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        line = ann.shape.d.split(' '),
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        x = xAxis.toPixels(options.xValueEnd) | 0,
        y = yAxis.toPixels(options.yValueEnd) | 0,
        xS = xAxis.toPixels(options.xValue) | 0,
        yS = yAxis.toPixels(options.yValue) | 0;

    line[4] = x - xS;
    line[5] = y - yS;

    ann.update({
        shape: {
            params: {
                d: line
            }
        }
    });

    var additionalDrawings = self.additionalDrawings;
    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', 0, 0, 'L', line[4], line[5]], self.dragSupporters);
    self.drawFork(self);
    if(additionalDrawings.lines && additionalDrawings.lines.d){
        var additionalLine = additionalDrawings.lines.d.split(' ');
        infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', additionalLine[1], additionalLine[2], 'L', additionalLine[4], additionalLine[5]], self.dragSupporters);
        self.addFibLevlDragSupporters();
    }
};

infChart.andrewsPitchforkDrawing.prototype.addFibLevlDragSupporters = function(){
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        fibonacciDrawings = self.fibonacciDrawings;

    if(fibonacciDrawings.lines){
        $.each(fibonacciDrawings.lines, function (key, value) {
            if(value.visibility !== "hidden"){
                var line = value.d.split(' ');
                var customAttributes = {
                    'level' : key,
                    'stroke-width': 15
                }   
                infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
                infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[7], line[8], 'L', line[10], line[11]], self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
            }
        });
    }    
};

infChart.andrewsPitchforkDrawing.prototype.selectAndBindResize = function () {
    var self = this,
        ann = self.annotation,
        pathDefinition;

    ann.events.deselect.call(ann);
    ann.selectionMarker = [];

    var value = self.additionalDrawings.lines;
    if(value && value.d){
        pathDefinition = value.d.split(' ');

        infChart.drawingUtils.common.addAndBindSelectionMarker.call(self, ann, pathDefinition[7], pathDefinition[8], self.stepFunction, self.stop);
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(self, ann, pathDefinition[10], pathDefinition[11], self.moveStartPoint, self.updateMoveStartPoint);
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(self, ann, pathDefinition[1], pathDefinition[2], self.moveCenterPoint, self.updateMoveCenterPoint);
    }

};

infChart.andrewsPitchforkDrawing.prototype.step = function (e) {
    var ann = this.annotation,
        points = infChart.drawingUtils.common.calculateInitialPoints(e, ann, false, 4, 4);

    var line = ["M", 0, 0, 'L', parseInt(points.dx, 10), parseInt(points.dy, 10)];

    ann.shape.attr({
        d: line
    });

    this.drawFork(this);

    return line;
};

infChart.andrewsPitchforkDrawing.prototype.stop = function (e) {
    var ann = this.annotation,
        chart = ann.chart,
        line = this.stepFunction(e),
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        x = xAxis.toValue(line[4] + xAxis.toPixels(ann.options.xValue)),
        y = yAxis.toValue(line[5] + yAxis.toPixels(ann.options.yValue)),
        self = this;

    ann.update({
        xValueEnd: x,
        yValueEnd: y,
        shape: {
            params: {
                d: line
            }
        }
    });

    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, y, ann.options.trendYValue);
    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, line, self.dragSupporters);

    //$.each(self.additionalDrawings, function (key, value) {

    var value = self.additionalDrawings.lines,
        lineD = value.d.split(' ');

    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, [
        'M', lineD[1], lineD[2], 'L', lineD[4], lineD[5],
        'M', lineD[7], lineD[8], 'L', lineD[10], lineD[11]
        //'M', lineD[10], lineD[11], 'L', lineD[16], lineD[17]
    ], self.dragSupporters);
    //  });

    var additionalDrawings = self.additionalDrawings;
    if(additionalDrawings.lines && additionalDrawings.lines.d){
        var additionalLine = additionalDrawings.lines.d.split(' ');
        infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', additionalLine[1], additionalLine[2], 'L', additionalLine[4], additionalLine[5]], self.dragSupporters);
        this.addFibLevlDragSupporters();
    }

    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.andrewsPitchforkDrawing.prototype.translateEnd = function () {
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.andrewsPitchforkDrawing.prototype.updateMoveCenterPoint = function (e) {
    var ann = this.annotation,
        chart = ann.chart,
        line = this.moveCenterPoint(e),
        self = this;

    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, line, self.dragSupporters);

    // $.each(self.additionalDrawings, function (key, value) {

    var value = self.additionalDrawings.lines,
        lineD = value.d.split(' ');

    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, [
        'M', lineD[1], lineD[2], 'L', lineD[4], lineD[5],
        'M', lineD[7], lineD[8], 'L', lineD[10], lineD[11]
        //'M', lineD[10], lineD[11], 'L', lineD[16], lineD[17]
    ], self.dragSupporters);
    // });
    this.addFibLevlDragSupporters();

    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
};

infChart.andrewsPitchforkDrawing.prototype.updateMoveStartPoint = function (e) {
    var ann = this.annotation,
        chart = ann.chart,
        line = this.moveStartPoint(e),
        dx = parseInt(line[4], 0) - parseInt(line[1], 10),
        dy = parseInt(line[5], 0) - parseInt(line[2], 10),
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        x = xAxis.toValue(line[1] + xAxis.toPixels(ann.options.xValue)),
        y = yAxis.toValue(line[2] + yAxis.toPixels(ann.options.yValue)),
        self = this;

    var srLine = ["M", 0, 0, 'L', dx, dy];

    x = (!isNaN(x) && x) || 0;
    y = (!isNaN(y) && y) || 0;

    ann.update({
        xValue: x,
        yValue: y,
        shape: {
            params: {
                d: srLine
            }
        }
    });

    self.drawFork(self);
    ann.events.deselect.call(ann, e);
    self.selectAndBindResize();
    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, line, self.dragSupporters);

    // $.each(self.additionalDrawings, function (key, value) {
    var value = self.additionalDrawings.lines,
        lineD = value.d.split(' ');

    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, [
        'M', lineD[1], lineD[2], 'L', lineD[4], lineD[5],
        'M', lineD[7], lineD[8], 'L', lineD[10], lineD[11],
        'M', lineD[13], lineD[14], 'L', lineD[16], lineD[17]
    ], self.dragSupporters);
    //});
    this.addFibLevlDragSupporters();

    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
};

infChart.andrewsPitchforkDrawing.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updateAndrewsPitchForkSettings(this.settingsPopup, properties);
    // infChart.structureManager.drawingTools.updateRectangleSettings(this.settingsPopup, properties.borderColor, properties.strokeWidth, properties.fillColor, properties.fillOpacity);
};

infChart.andrewsPitchforkDrawing.prototype.onFibLevelChange = function (currentLevel, checked, isPropertyChange) {
    var self = this;
    var ann = self.annotation;
    var chart = ann.chart;
    var line = ann.shape.d.split(' ');
    var options = self.annotation.options;
    var fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels);
    var currentOrderIdx;
    var currentFibLevel;

    fibLevels.some(function (fibLevel, i) {
        if (fibLevel.id === currentLevel) {
            currentOrderIdx = i;
            currentFibLevel = fibLevel;
            return true;
        }
    });
    fibLevels[currentOrderIdx].enable = checked;

    if (checked) {
        self.fibonacciDrawings.lines[currentFibLevel.id].show();
        self.fibonacciDrawings.fill[currentFibLevel.id + '-0'].show();
        self.fibonacciDrawings.fill[currentFibLevel.id + '-1'].show();
    } else {
        self.fibonacciDrawings.lines[currentFibLevel.id].hide();
        self.fibonacciDrawings.fill[currentFibLevel.id + '-0'].hide();
        self.fibonacciDrawings.fill[currentFibLevel.id + '-1'].hide();
    }
    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, line, self.dragSupporters);
    if(self.additionalDrawings.lines && self.additionalDrawings.lines.d){
        var additionalLine = self.additionalDrawings.lines.d.split(' ');
        infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', additionalLine[1], additionalLine[2], 'L', additionalLine[4], additionalLine[5]], self.dragSupporters);
        this.addFibLevlDragSupporters();
    }
    isPropertyChange && self.onPropertyChange();
    
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.andrewsPitchforkDrawing.prototype.onChangeAllFibLines = function (property, propertyValue, isPropertyChange) {
    let self = this;
    let options = self.annotation.options;
    let fibLevels = options.fibLevels;

    if (isPropertyChange) {
        options.isSingleColor = true;
    }
    switch (property) {
        case 'fillColor':
            options.fillColor = propertyValue.fill;
            options.fillOpacity = propertyValue.opacity;
            break;
        case 'lineColor':
            options.lineColor = propertyValue;
            break;
        case 'lineWidth':
            options.lineWidth = propertyValue;
            break;
        default:
            break;
    }

    fibLevels.forEach(function (fibLevel) {
        self.onChangeFibLines(fibLevel, property, propertyValue, false);
    });

    if (isPropertyChange) {
        self.onPropertyChange();
    }
};

infChart.andrewsPitchforkDrawing.prototype.onChangeFibLines = function (fibLevel, property, propertyValue, isPropertyChange) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        line = ann.shape.d.split(' '),
        isSingleColor = options.isSingleColor;

    switch (property) {
        case 'enable':
            fibLevel.enable = propertyValue;
            if (propertyValue) {
                self.fibonacciDrawings.lines[fibLevel.id].show();
                self.fibonacciDrawings.fill[fibLevel.id + '-0'].show();
                self.fibonacciDrawings.fill[fibLevel.id + '-1'].show();
            } else {
                self.fibonacciDrawings.lines[fibLevel.id].hide();
                self.fibonacciDrawings.fill[fibLevel.id + '-0'].hide();
                self.fibonacciDrawings.fill[fibLevel.id + '-1'].hide();
            }
            self.drawFork(self);
            infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, line, self.dragSupporters);
            if(self.additionalDrawings.lines && self.additionalDrawings.lines.d){
                var additionalLine = self.additionalDrawings.lines.d.split(' ');
                infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', additionalLine[1], additionalLine[2], 'L', additionalLine[4], additionalLine[5]], self.dragSupporters);
                this.addFibLevlDragSupporters();
            }
            break;
        case 'value':
            fibLevel.value = propertyValue;
            self.drawFork(self);
            infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, line, self.dragSupporters);
            if(self.additionalDrawings.lines && self.additionalDrawings.lines.d){
                var additionalLine = self.additionalDrawings.lines.d.split(' ');
                infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', additionalLine[1], additionalLine[2], 'L', additionalLine[4], additionalLine[5]], self.dragSupporters);
                this.addFibLevlDragSupporters();
            }
            break;
        case 'lineColor':
            if(!isSingleColor){
                fibLevel.lineColor = propertyValue;
            }
            self.fibonacciDrawings.lines[fibLevel.id].attr({
                'stroke': propertyValue
            });
            break;
        case 'fillColor':
            if(!isSingleColor){
                fibLevel.fillColor = propertyValue.fill;
                fibLevel.fillOpacity = propertyValue.opacity;
            }
            self.fibonacciDrawings.fill[fibLevel.id + '-0'].attr({
                'fill': propertyValue.fill,
                'fill-opacity': propertyValue.opacity
            });
            self.fibonacciDrawings.fill[fibLevel.id + '-1'].attr({
                'fill': propertyValue.fill,
                'fill-opacity': propertyValue.opacity
            });
            break;
        case 'lineWidth':
            if(!isSingleColor){
                fibLevel.lineWidth = propertyValue;
            }    
            self.fibonacciDrawings.lines[fibLevel.id].attr({
                'stroke-width': propertyValue
            });
            break;
        default:
            break;
    }
    if (isPropertyChange) {
        if (this.settingsPopup) {
            this.settingsPopup.data("infUndoRedo", false);
        }
        self.onPropertyChange();
    }
};

infChart.andrewsPitchforkDrawing.prototype.applyAllToFibLines = function (enabled, fillColor, fillOpacity, lineColor, lineWidth, prevOptions, isPropertyChange) {
    let self = this;
    let options = self.annotation.options;
    options.isSingleColor = enabled;
    if (enabled) {
        self.onChangeAllFibLines('lineColor', lineColor, false);
        self.onChangeAllFibLines('lineWidth', parseInt(lineWidth, 10), false);
        self.onChangeAllFibLines('fillColor', {
            fill: fillColor,
            opacity: fillOpacity
        }, false);
    } else {
        options.fibLevels.forEach(fibLevel => {
            let prevFibOption = prevOptions[fibLevel.id];
            self.onChangeFibLines(fibLevel, 'lineColor', prevFibOption.lineColor, false);
            self.onChangeFibLines(fibLevel, 'lineWidth', prevFibOption.lineWidth, false);
            self.onChangeFibLines(fibLevel, 'fillColor', {
                fill: prevFibOption.fillColor,
                opacity: prevFibOption.fillOpacity
            }, false);
        });
    }
    if (isPropertyChange) {
        if (this.settingsPopup) {
            this.settingsPopup.data("infUndoRedo", false);
        }
        self.onPropertyChange();
    }
};

infChart.andrewsPitchforkDrawing.prototype.getContextMenuOptions = function (chartId, drawingId, options, event) {
    var self = this;
    var selectedLevel;
    var contextMenu = {};

    selectedLevel = event.target.getAttribute('level');
    if(!selectedLevel && event.target.parentElement){
        selectedLevel = event.target.parentElement.getAttribute('level');
        if(!selectedLevel && event.target.parentElement.parentElement){
            selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
        }
    }
    if(selectedLevel){
        var levelSelected = self.annotation.options.fibLevels.find(function (fibLevel) {
            if(fibLevel.id === selectedLevel){
                return fibLevel;
            }
        });
    }

    if (!self.isVisibleLastLevel()) {
        var eraseThis = {
            icon: options.erase.icon,
            displayText: options.erase.displayText,
            action: function () {
                if (levelSelected) {
                    self.onChangeFibLines(levelSelected, 'enable', false, true);
                }
            }
        }
        contextMenu["eraseThis"] = eraseThis;
    }
    if (selectedLevel) {
        return Object.assign(contextMenu, infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options));
     } else {
        return infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options);
     }
};

infChart.andrewsPitchforkDrawing.prototype.isVisibleLastLevel = function () {
    return false;
}

infChart.andrewsPitchforkDrawing.prototype.getFibLevelById = function (fibLevelId) {
    var self = this,
        ann = self.annotation,
        options = ann.options;

        var fibLevelDetails = self.annotation.options.fibLevels.find(function (fibLevel) {
            if(fibLevel.id === fibLevelId){
                return fibLevelId;
            }
        });

    return fibLevelDetails;
};

window.infChart = window.infChart || {};

infChart.labelDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
    this.borderColor = '#000000';
    this.backgroundColor = '#FFFFFF';
};

infChart.labelDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.labelDrawing.prototype.additionalDrawingsFunction = function (isOnSelect) {
    if (!isOnSelect) {
        return;
    }

    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        index = chart.annotationInputIndex = chart.annotationInputIndex ? chart.annotationInputIndex : 1,
        input = document.createElement('span'),
        text = options.textValue || '',
        $input = $(input),
        container = infChart.structureManager.getContainer(this.stockChart.getContainer(), "drawing"),
        inputBox;

    input.innerHTML = '<textarea type="text" wrap="off" maxlength="100" rows="3" x-enable-drawing-copy class="form-control is-label annotation-' + index + '" placeholder="Add text"></textarea>';
    input.style.position = 'absolute';
    container.appendChild(input);
    input.xAddClass("label-input-container");

    inputBox = input.querySelectorAll("textarea")[0];
    inputBox.focus();
    inputBox.value = text;

    inputBox.onkeypress = function (event) {
        if (event.keyCode === 13) {
            self.onTextChange(this);
        }
    };
    self.additionalDrawings[0] = $input;
    $input.hide();
    self.positionInput();
    chart.annotationInputIndex++;
};

infChart.labelDrawing.prototype.bindSettingsEvents = function () {
    var self = this;

    function onColorChange(rgb, value) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onColorChange.call(self, rgb, value, isPropertyChange);
    }

    function onBorderColorChange(rgb, value, opacity, checked) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onBorderColorChange.call(self, rgb, value, opacity, checked, isPropertyChange);
    }

    function onBackgroundColorChange(rgb, value, opacity, checked) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onBackgroundColorChange.call(self, rgb, value, opacity, checked, isPropertyChange);
    }

    function onApplyBackgroundColor(propertyValue, color) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();

        }
        self.onApplyBackgroundColor.call(self, propertyValue, color, isPropertyChange);
    }

    function onApplyBorderColor(propertyValue, color) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();

        }
        self.onApplyBorderColor.call(self, propertyValue, color, isPropertyChange);
    }

    function onFontSizeChange(newFontSize) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();

        }
        self.onFontSizeChange.call(self, newFontSize, isPropertyChange);
    }

    function onFontStyleChange(style, isSelected) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onFontStyleChange.call(self, style, isSelected, isPropertyChange);
    }

    function onTextChange(text) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        return self.onSettingsTextChange.call(self, text, isPropertyChange);
    }

    function onResetToDefault () {
        self.updateSavedDrawingProperties(true);
    }

    infChart.structureManager.drawingTools.bindLabelSettings(self.settingsPopup, onColorChange, onFontSizeChange, onFontStyleChange, onTextChange, onBorderColorChange, onBackgroundColorChange, onApplyBorderColor, onApplyBackgroundColor, onResetToDefault);
};

/**
 * actions to take on deselecting the drawing tool
 */
infChart.labelDrawing.prototype.deselect = function () {
    var $input = this.additionalDrawings[0];
    if ($input) {
        this.onTextChange($input.find("input")[0]);
    }
};

infChart.labelDrawing.prototype.destroyDrawing = function () {
    var $input = this.additionalDrawings[0];

    if ($input) {
        $input.remove();
        delete this.additionalDrawings[0];
    }
};

infChart.labelDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    return {
        shape: 'label',
        text: annotation.options.title.text,
        textValue: annotation.options.textValue,
        color: annotation.options.title.style.color,
        fontSize: this.fontSize,
        fontWeight: annotation.options.title.style.fontWeight,
        fontStyle: annotation.options.title.style.fontStyle,
        textDecoration: annotation.options.title.style.textDecoration,
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        stroke: annotation.options.title.borderAttributes.stroke,
        backgroundColor: annotation.options.title.borderAttributes.fill,
        strokeWidth: annotation.options.title.borderAttributes['stroke-width'],
        isBackgroundEnabled: annotation.options.isBackgroundEnabled,
        isBorderEnabled: annotation.options.isBorderEnabled,
        borderColorPicker: annotation.options.borderColorPicker,
        backgroundColorPicker: annotation.options.backgroundColorPicker,
        isLocked : annotation.options.isLocked

    };
};

infChart.labelDrawing.prototype.getOptions = function (properties) {
    var theme = {
        style: {
            color: this.borderColor,
            fontSize: '12',
            cursor: 'move',
            fontWeight: 'normal',
            fontStyle: 'normal',
            textDecoration: 'inherit'
        },
        borderAttributes: {
            stroke: this.backgroundColor,
            'stroke-width': 1,
            padding: 4,
            r: 0,
            fill: this.backgroundColor
        }
    };

    if (infChart.drawingUtils.common.theme && infChart.drawingUtils.common.theme.label) {
        theme = infChart.util.merge(theme, infChart.drawingUtils.common.theme.label);
    }

    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        title: {
            text: 'Label',
            style: theme.style,
            borderAttributes: theme.borderAttributes
        },
        shape: {
            type: null,
            params: null
        }
    };
    if (properties.text) {
        options.title.text = properties.text;
    }
    if (properties.textValue) {
        options.textValue = properties.textValue;
    }else{
        options.textValue = '';
    }
    if (properties.color) {
        options.title.style.color = properties.color;
    }
    if (properties.fontSize) {
        options.title.style.fontSize = properties.fontSize + 'px'
        this.fontSize = properties.fontSize;
    }
    if (properties.fontWeight) {
        options.title.style.fontWeight = properties.fontWeight;
    }
    if (properties.fontStyle) {
        options.title.style.fontStyle = properties.fontStyle;
    }
    if (properties.textDecoration) {
        options.title.style.textDecoration = properties.textDecoration;
    }
    if (properties.backgroundColor) {
        options.title.borderAttributes.fill = properties.backgroundColor;
    }
    if (properties.stroke) {
        options.title.borderAttributes.stroke = properties.stroke;
    }
    if(typeof properties.strokeWidth !== "undefined"){
        options.title.borderAttributes['stroke-width'] = properties.strokeWidth;
    }
    if(properties.borderColorPicker){
        options.borderColorPicker = properties.borderColorPicker;
    }else{
        options.borderColorPicker = this.backgroundColor;
    }
    if(properties.backgroundColorPicker){
        options.backgroundColorPicker = properties.backgroundColorPicker;
    }else{
        options.backgroundColorPicker = this.backgroundColor;
    }
    if(typeof properties.isBackgroundEnabled !== "undefined"){
        options.isBackgroundEnabled = properties.isBackgroundEnabled;
    } else {
        options.isBackgroundEnabled = true;
    }
    if(typeof properties.isBorderEnabled !== "undefined"){
        options.isBorderEnabled = properties.isBorderEnabled;
    } else {
        options.isBorderEnabled = true;
    }
    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
    }
    options.validateTranslationFn = this.validateTranslation;
    options.isRealTimeTranslation = true;

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.labelDrawing.prototype.validateTranslation = function (newXValue) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        seriesData = chart.series[0].xData,
        dataMin = seriesData[0],
        totalPoints = infChart.drawingsManager.getTotalPoints(chart),
        dataMax = totalPoints[totalPoints.length - 1],
        xValue = xAxis.toValue(xAxis.toPixels(newXValue) + ann.title.width);

    return (newXValue >= dataMin && xValue <= dataMax);
};

infChart.labelDrawing.prototype.getQuickSettingsPopup = function () {
    return infChart.structureManager.drawingTools.getLabelQuickSettings(this.fontSize);
};

infChart.labelDrawing.prototype.getSettingsPopup = function () {
    return infChart.structureManager.drawingTools.getLabelSettings(this.fontSize);
};

infChart.labelDrawing.prototype.isRequiredProperty = function (propertyId, reset) {
    var isPositionProperty = false;

    switch (propertyId) {
        case "yValue":
        case "yValueEnd":
        case "xValue":
        case "xValueEnd":
        case "trendYValue":
        case "trendXValue":
        case "intermediatePoints":
        case "linePointValues":
        case "clickCords" :
            isPositionProperty = true;
            break;
        case "text":
        case "textValue":
        case "isLocked":
            if(reset){
                isPositionProperty = false;
            }else{
                isPositionProperty = true;
            }
        default :
            break;
    }

    return isPositionProperty;
};

// infChart.labelDrawing.prototype.onClick = function (e) {
//     this.showInput();
// };

infChart.labelDrawing.prototype.openSettingPanel = function () {
    var drawingObj = this;
    if (drawingObj.isQuickSetting) {
        infChart.drawingUtils.common.toggleSettings.call(drawingObj);
        drawingObj.settingsPopup.find("textarea[inf-ctrl=text]").focus().select();
    }
};

infChart.labelDrawing.prototype.focusAndSelectInput  = function () {
    this.settingsPopup.find("textarea[inf-ctrl=text]").focus().select();
}

/**
 * Change the color of the annotation from the given params
 * IMPORTANT :: this method is uesed in commands.wrappers to set undo/redo actions
 * @param {object} rgb rgb value of the color 
 * @param {string} value 
 * @param {boolean|undefined} isPropertyChange property change 
 */
infChart.labelDrawing.prototype.onColorChange = function (rgb, value, isPropertyChange) {
    var self = this;
    self.annotation.update({
        title: {
            style: {
                color: value
            }
        }
    });
    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.labelDrawing.prototype.onApplyBackgroundColor = function(propertyValue, color, isPropertyChange){
    var self = this,
        ann = self.annotation,
        options = ann.options;
    var theme = infChart.drawingUtils.common.getTheme(),
        shapeTheme = theme[self.shape];

        options.isBackgroundEnabled = propertyValue;
        if(propertyValue){
            self.annotation.update({
                title: {
                    borderAttributes: {
                        fill: color
                    }
                }
            });
        }else{
            self.annotation.update({
                title: {
                    borderAttributes: {
                        fill: 'transparent'
                    }
                }
            });
        }

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.labelDrawing.prototype.onApplyBorderColor = function(propertyValue, color, isPropertyChange){
    var self = this,
        ann = self.annotation,
        options = ann.options;
    var theme = infChart.drawingUtils.common.getTheme(),
        shapeTheme = theme[self.shape];

    options.isBorderEnabled = propertyValue;
    if(propertyValue){
        self.annotation.update({
            title: {
                borderAttributes: {
                    stroke: color,
                    'stroke-width': 1
                }
            }
        });
    }else{
        self.annotation.update({
            title: {
                borderAttributes: {
                    // stroke: shapeTheme.borderAttributes.stroke,
                    'stroke-width': 0
                }
            }
        });
    }

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.labelDrawing.prototype.onBorderColorChange = function(rgb, value, opacity, checked, isPropertyChange){
    var self = this;
        ann = self.annotation,
        options = ann.options;
        options.borderColorPicker = value;
    if(checked){
        self.annotation.options.isBorderEnabled = true;
        self.annotation.update({
            title: {
                borderAttributes: {
                    stroke: value
                }
            }
        });
        isPropertyChange && self.onPropertyChange();
        if (this.settingsPopup) {
            this.settingsPopup.data("infUndoRedo", false);
        }
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.labelDrawing.prototype.onBackgroundColorChange = function(rgb, value, opacity, checked, isPropertyChange){
    var self = this;
        ann = self.annotation,
        options = ann.options;
        options.backgroundColorPicker = value;
    if(checked){
        self.annotation.options.isBackgroundEnabled = true;
        self.annotation.update({
            title: {
                borderAttributes: {
                    fill: value
                }
            }
        });
        isPropertyChange && self.onPropertyChange();
        if (this.settingsPopup) {
            this.settingsPopup.data("infUndoRedo", false);
        }
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

/**
 * Change the font size change of the annotation from the given params
 * IMPORTANT :: this method is uesed in commands.wrappers to set undo/redo actions
 * @param {boolean} isIncrease 
 * @param {boolean|undefined} isPropertyChange property change 
 * @returns 
 */
infChart.labelDrawing.prototype.onFontSizeChange = function(newFontSize, isPropertyChange){
    var self = this;
    var isUpdate = false;

    if (newFontSize !== self.fontSize) {
        self.fontSize = newFontSize;
        isUpdate = true;
        self.annotation.update({
            title: {
                style: {
                    fontSize: newFontSize + 'px'
                }
            }
        });

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);

    self.annotation.update({});
    }
    
    return isUpdate;
};

/**
 * Change the font style change of the annotation from the given params
 * IMPORTANT :: this method is uesed in commands.wrappers to set undo/redo actions
 * @param {object} style 
 * @param {boolean} isSelected 
 * @param {boolean|undefined} isPropertyChange property change 
 */
infChart.labelDrawing.prototype.onFontStyleChange = function (style, isSelected, isPropertyChange) {
    var self = this;
    switch (style) {
        case 'bold':
            var fontWeight;
            if (isSelected) {
                fontWeight = 'normal';
            } else {
                fontWeight = 'bold';
            }
            self.annotation.update({
                title: {
                    style: {
                        fontWeight: fontWeight
                    }
                }
            });
            self.onPropertyChange();
            break;
        case 'italic':
            var fontStyle;
            if (isSelected) {
                fontStyle = 'normal';
            } else {
                fontStyle = 'italic';
            }
            self.annotation.update({
                title: {
                    style: {
                        fontStyle: fontStyle
                    }
                }
            });
            self.onPropertyChange();
            break;
        case 'underline':
            var textDecoration;
            if (isSelected) {
                textDecoration = 'inherit';
            } else {
                textDecoration = 'underline';
            }
            self.annotation.update({
                title: {
                    style: {
                        textDecoration: textDecoration
                    }
                }
            });
            self.onPropertyChange();
            break;
    }
    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

/**
 * Change the text change of the annotation from the given params
 * IMPORTANT :: this method is uesed in commands.wrappers to set undo/redo actions
 * @param {string} text 
 * @param {boolean|undefined} isPropertyChange property change 
 * @returns 
 */
infChart.labelDrawing.prototype.onSettingsTextChange = function (text, isPropertyChange) {
    var self = this,
        newText;
        self.annotation.options.textValue = text;
    if(text == ""){
        newText = "Label";
    }else{
        newText = text.replace("/n", "<br>");
        var textArray = [];
        textArray = text.match(/.{1,1000}/g);
        var newText = "";
        for (var i = 0; i < textArray.length; i++) {
            if (i == 0) {
                newText = newText + "" + textArray[i];
            } else {
                newText = newText + "<br>" + textArray[i];
            }
        }
    }

    self.annotation.update({
        title: {
            text: newText
        }
    });

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
    return true;
};

infChart.labelDrawing.prototype.onTextChange = function (input) {
    var self = this,
        ann = self.annotation,
        parent = input.parentNode,
        value = input.value.trim() === "" ? "" : input.value;

    var isPropertyChange = value !== ann.options.title.text;

    self.onSettingsTextChange.call(self, value, isPropertyChange);

    infChart.structureManager.drawingTools.updateLabelSettings(self.settingsPopup, undefined, value || input.value, undefined, true);
    $(parent).remove();
    delete self.additionalDrawings[0];
};

infChart.labelDrawing.prototype.positionInput = function () {
    var ann = this.annotation,
        chart = ann.chart,
        options = ann.options,
        yAxis = chart.yAxis[options.yAxis],
        xAxis = chart.xAxis[options.xAxis],
        y = yAxis.toPixels(options.yValue),
        x = xAxis.toPixels(options.xValue),
        input = this.additionalDrawings[0];

    input && input.css({
        left: x,
        top: y,
        zIndex: 1
    });
};

infChart.labelDrawing.prototype.scale = function () {
    var self = this,
        ann = self.annotation;
    var yValue = infChart.drawingUtils.common.getYValue.call(self, self.yValue);
    ann.update(yValue);
    this.positionInput();
    infChart.drawingUtils.common.setDeleteCursor.call(this); //#CCA-2958
    infChart.drawingUtils.common.setDeleteModeCursor.call(this);
};

infChart.labelDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation;

    if (ann.selectionMarker) {

    } else {
        ann.selectionMarker = [];
        infChart.drawingUtils.common.addSelectionMarker.call(this, ann, 0, 0);
    }
    infChart.drawingUtils.common.fixSelectionMarker.call(this, ann);
};

infChart.labelDrawing.prototype.showInput = function () {
    var self = this,
        ann = self.annotation,
        $input;

    //deselecting selection markerkers to fix https://xinfiit.atlassian.net/projects/CCA/issues/CCA-4010
    ann.events.deselect.call(ann);
    self.additionalDrawingsFunction(true);

    $input = self.additionalDrawings[0];
    $input && $input.show();
    $input.find("textarea").focus();

    //'blur' event is not used since it doesn't get fired when click on the chart
    $input && $input.xOutside('click', function (event) {

        if (ann && ann.title && ann.title.element && !$(ann.title.element).xIsInside(event.target, ".highcharts-label")) {
            self.onTextChange($input.find("textarea")[0]);
            return true;
        }
    });
};

infChart.labelDrawing.prototype.step = function () { };

infChart.labelDrawing.prototype.stop = function () {
    this.selectAndBindResize();
    //https://xinfiit.atlassian.net/browse/CCA-3735
    // saveBaseYValues should be exceute before openDrawingSettings since scaleDrawings get executed and a wrong yValue gets stored
    infChart.drawingUtils.common.saveBaseYValues.call(this, this.annotation.options.yValue);
    infChart.drawingsManager.openSettings(this, !!infChart.settings.config.disableDrawingSettingsPanel);
    if(infChart.drawingsManager.getIsActiveDrawingInprogress()){
        this.initialSettingPanelLoad = true;
    }
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.labelDrawing.prototype.translateEnd = function () {
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.labelDrawing.prototype.updateSettings = function (properties) {
    var styles = [];
    if (properties.fontWeight !== 'normal') {
        styles.push(properties.fontWeight);
    }
    if (properties.textDecoration !== 'inherit') {
        styles.push(properties.textDecoration);
    }
    if (properties.fontStyle !== 'normal') {
        styles.push(properties.fontStyle);
    }
    infChart.structureManager.drawingTools.updateLabelSettings(this.settingsPopup, properties.color, properties.textValue, properties.backgroundColorPicker, properties.borderColorPicker, properties.isBorderEnabled, properties.isBackgroundEnabled, styles);
};

window.infChart = window.infChart || {};

infChart.fibFansDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
    this.fibLevels = [
        {
            id: 'level_0',
            value: 38.2,
            enable: true,
            drawingPosX: -20,
            drawingPosY: 7,
            fillColor: "#FFB6C1",
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_1',
            value: 50,
            enable: true,
            drawingPosX: -20,
            drawingPosY: 7,
            fillColor: "#ADD8E6",
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_2',
            value: 61.8,
            enable: true,
            drawingPosX: -20,
            drawingPosY: 7,
            fillColor: "#D3D3D3",
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        }
    ];
};

infChart.fibFansDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.fibFansDrawing.prototype.additionalDrawingsFunction = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        drawingAttr = {
            'stroke-width': ann.options.shape.params['stroke-width'],
            fill: ann.options.shape.params.fill,
            stroke: ann.options.shape.params.stroke,
            'z-index': 2,
            cursor: 'move'
        },
        drawingFillAttr = {
            'stroke-width': 0,
            fill: ann.options.shape.params.fill,
            stroke: ann.options.shape.params.stroke,
            'z-index': 2,
            cursor: 'move'
        },
        labelAttr,
        fibLevels = options.fibLevels ? options.fibLevels : this.fibLevels,
        additionalDrawingsArr = self.additionalDrawings,
        fibonacciDrawingsArr = self.fibonacciDrawings,
        theme = infChart.drawingUtils.common.getTheme.call(self),
        baseFillOpacity = (theme.fibFans && typeof theme.fibFans.fillOpacity !== "undefined") ? theme.fibFans.fillOpacity : infChart.drawingUtils.common.baseFillOpacity,
        baseFontColor = (theme.fibFans && typeof theme.fibFans.fontColor !== "undefined") ? theme.fibFans.fontColor : infChart.drawingUtils.common.baseFontColor,
        baseFontSize = (theme.fibFans && typeof theme.fibFans.fontSize !== "undefined") ? theme.fibFans.fontSize : infChart.drawingUtils.common.baseFontSize,
        baseFontWeight = (theme.fibFans && typeof theme.fibFans.fontWeight !== "undefined") ? theme.fibFans.fontWeight : infChart.drawingUtils.common.baseFontWeight,
        labelStyles = {
            'color': baseFontColor,
            fontSize: baseFontSize + 'px',
            'font-weight' : baseFontWeight
        };

    additionalDrawingsArr.lines = {};
    fibonacciDrawingsArr.lines = {};
    fibonacciDrawingsArr.fill = {};

    var hiddenLevels = [];

    // add fill objects first to avoid overlapping lines with and texts with them
    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);
    fibLevels.forEach(function (fibLevel) {
        var themeFillColor = theme.fibFans && theme.fibFans.fibLevelFillColors && theme.fibFans.fibLevelFillColors[fibLevel.id];
        if (!fibLevel.enable) {
            hiddenLevels.push(fibLevel.id);
        }
        drawingFillAttr = {
            'stroke-width': 0,
            fill: options.isSingleColor && options.fillColor ? options.fillColor : fibLevel && fibLevel.fillColor ? fibLevel.fillColor : themeFillColor,
            'fill-opacity': options.isSingleColor && options.fillOpacity ? options.fillOpacity : fibLevel && fibLevel.fillOpacity ? fibLevel.fillOpacity : baseFillOpacity,
            stroke: ann.options.shape.params.stroke,
            'z-index': 2,
            cursor: 'default',
            'level': fibLevel.id,
            'pointer-events':'none'
        };
        drawingAttr = {
            'stroke-width': options.isSingleColor && options.lineWidth ? options.lineWidth : fibLevel && fibLevel.lineWidth ? fibLevel.lineWidth : ann.options.shape.params['stroke-width'],
            fill: ann.options.shape.params.fill,
            stroke: options.isSingleColor && options.lineColor ? options.lineColor :  fibLevel && fibLevel.lineColor ? fibLevel.lineColor : ann.options.shape.params.stroke,
            'z-index': 2,
            cursor: 'move',
            'level': fibLevel.id
        };

        var fontColor = options.isSingleColor && options.fontColor ? options.fontColor : fibLevel && fibLevel.fontColor ? fibLevel.fontColor : baseFontColor;
        var fontSize = options.isSingleColor && options.fontSize ? options.fontSize : fibLevel && fibLevel.fontSize ? fibLevel.fontSize : baseFontSize;
        var fontWeight = options.isSingleColor && options.fontWeight ? options.fontWeight : fibLevel && fibLevel.fontWeight ? fibLevel.fontWeight : baseFontWeight;

        labelStyles = {
            'color': fontColor,
            fontSize: fontSize + 'px',
            'font-weight' : fontWeight
        };
        labelAttr ={
            'level': fibLevel.id,
            'font-color': fontColor,
            'font-size': fontSize,
            'font-weight' : fontWeight
        };
        fibonacciDrawingsArr.fill[fibLevel.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0]).attr(drawingFillAttr).add(ann.group);
        // adding lines and texts after fill objects
        additionalDrawingsArr.lines[fibLevel.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingAttr).add(ann.group);
        fibonacciDrawingsArr.lines[fibLevel.id] = chart.renderer.label(infChart.drawingUtils.common.formatValue(fibLevel.value, 1) + "%", fibLevel.drawingPosX, fibLevel.drawingPosY).css(labelStyles).attr(labelAttr).add(ann.group);
    });

    hiddenLevels.forEach(function (id) {
        self.onFibFansLevelChange(id, false, false);
    });

    ann.selectionMarker = [];
    infChart.drawingUtils.common.addSelectionMarker.call(self, ann, 0, 0);
};

infChart.fibFansDrawing.prototype.bindSettingsEvents = function () {
    var self = this;
    var onFibFansLevelChange = function (checked, value) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onFibFansLevelChange.call(self, value, checked, isPropertyChange);
    };
    return infChart.drawingUtils.common.bindFibSettingsEvents.call(this, infChart.drawingUtils.common.baseBorderColor, infChart.drawingUtils.common.baseLineWidth, onFibFansLevelChange);
};

infChart.fibFansDrawing.prototype.getConfig = function () {
    var self = this,
        annotation = self.annotation,
        options = annotation.options,
        fibLevels = options.fibLevels ? options.fibLevels : self.fibLevels;
    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);

    return {
        shape: 'fibFans',
        fibLevels: fibLevels,
        borderColor: annotation.options.lineColor,
        fillColor: annotation.options.fillColor,
        fillOpacity: annotation.options.fillOpacity,
        strokeWidth: annotation.options.lineWidth,
        fontColor: annotation.options.fontColor,
        fontSize: annotation.options.fontSize,
        fontWeight: annotation.options.fontWeight,
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        isSingleColor: annotation.options.isSingleColor,
        enabledMyDefaultButton:annotation.options.enabledMyDefaultButton,
        isLocked : annotation.options.isLocked

    };
};

infChart.fibFansDrawing.prototype.getContextMenuOptions = function (chartId, drawingId, options , event) {
    var self = this;
    var level = event.target.getAttribute('level');
     var contextMenu = {};
    if (!self.isVisibleLastLevel()) {
        var eraseThis = {
            icon: options.erase.icon,
            displayText: options.erase.displayText,
            action: function () {
                if (level) {
                    self.onFibFansLevelChange.call(self, level, false, true, true);
                }
            }
        }
        contextMenu["eraseThis"] = eraseThis;
    }
    if(level) {
        contextMenu = Object.assign(contextMenu, infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options));
        return infChart.drawingUtils.common.reorderContextMenu(contextMenu);
    } else {
        return infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options);
    }
};

infChart.fibFansDrawing.prototype.getOptions = function (properties) {
    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0]
            }
        }
    };
    var theme = infChart.drawingUtils.common.getTheme.call(this);
    var baseFillColor = (theme.fibFans && theme.fibFans.singleFillColor) ? theme.fibFans.singleFillColor : (theme.fibonacci && theme.fibonacci.singleFillColor) ? theme.fibonacci.singleFillColor : infChart.drawingUtils.common.baseFillColor;
    var baseFillOpacity = (theme.fibFans && typeof theme.fibFans.fillOpacity !== "undefined") ? theme.fibFans.fillOpacity : (theme.fibonacci && typeof theme.fibonacci.fillOpacity !== "undefined") ? theme.fibonacci.fillOpacity : infChart.drawingUtils.common.baseFillOpacity;
    var baseBorderColor = (theme.fibFans && theme.fibFans.borderColor) ? theme.fibFans.borderColor : (theme.fibonacci && theme.fibonacci.borderColor) ? theme.fibonacci.borderColor : infChart.drawingUtils.common.baseBorderColor;
    var baseLineWidth = (theme.fibFans && typeof theme.fibFans.lineWidth !== "undefined") ? theme.fibFans.lineWidth : (theme.fibonacci && theme.fibonacci.lineWidth) ? theme.fibonacci.lineWidth : infChart.drawingUtils.common.baseLineWidth;
    var baseFontColor = (theme.fibFans && theme.fibFans.fontColor) ? theme.fibFans.fontColor: (theme.fibonacci && theme.fibonacci.fontColor) ? theme.fibonacci.fontColor : infChart.drawingUtils.common.baseFontColor;
    var baseFontSize = (theme.fibFans && theme.fibFans.fontSize) ? theme.fibFans.fontSize: (theme.fibonacci && theme.fibonacci.fontSize) ? theme.fibonacci.fontSize : infChart.drawingUtils.common.baseFontSize;
    var baseFontWeight = (theme.fibFans && theme.fibFans.fontWeight) ? theme.fibFans.fontWeight: (theme.fibonacci && theme.fibonacci.fontWeight) ? theme.fibonacci.fontWeight : infChart.drawingUtils.common.baseFontWeight;

    options.fillColor = properties.fillColor ? properties.fillColor : baseFillColor;
    options.fillOpacity = properties.fillOpacity ? properties.fillOpacity : baseFillOpacity;
    options.lineColor = properties.borderColor ? properties.borderColor : baseBorderColor;
    options.lineWidth = properties.strokeWidth ? properties.strokeWidth : baseLineWidth;
    options.fontColor = properties.fontColor ? properties.fontColor : baseFontColor;
    options.fontSize = properties.fontSize ? properties.fontSize : baseFontSize;
    options.fontWeight = properties.fontWeight ? properties.fontWeight : baseFontWeight;

    options.shape.params.fill = options.fillColor;
    options.shape.params['fill-opacity'] = options.fillOpacity;
    options.shape.params.stroke = options.lineColor;
    options.shape.params['stroke-width'] = options.lineWidth;
    options.shape.params['font-color'] = options.fontColor;
    options.shape.params['font-size'] = options.fontSize;


    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
    }
    if (properties.isSingleColor) {
        options.isSingleColor = properties.isSingleColor;
    }
    options.fibLevels = properties.fibLevels ? properties.fibLevels : this.fibLevels;
    options.fibLevels = infChart.drawingUtils.common.getFibLevelsWithOpacity(infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels), baseFillOpacity);
    options.validateTranslationFn = this.validateTranslation;

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.fibFansDrawing.prototype.validateTranslation = function (newXValue) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        seriesData = chart.series[0].xData,
        dataMin = seriesData[0],
        xVal = options.xValue,
        xValEnd = options.xValueEnd,
        newXValueEnd = xValEnd - xVal + newXValue,
        totalPoints = infChart.drawingsManager.getTotalPoints(chart),
        dataMax = totalPoints[totalPoints.length - 1];

    return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax);
};

infChart.fibFansDrawing.prototype.getQuickSettingsPopup = function () {
    var self = this;
    var options = self.annotation.options;
    var fillColor = options.fillColor;
    var fillOpacity = options.fillOpacity;
    var lineColor = options.lineColor;
    var fontColor = options.fontColor;
    var fontSize = options.fontSize;
    var fontWeight = options.fontWeight;
    return infChart.drawingUtils.common.getFibQuickSettings(fillColor, fillOpacity, lineColor, fontColor, fontSize);
};

infChart.fibFansDrawing.prototype.getSettingsPopup = function () {
    var self = this;
    var options = self.annotation.options;
    var fibLevels = options.fibLevels ? options.fibLevels : self.fibLevels;
    var properties = {
        fillColor: options.fillColor,
        fillOpacity: options.fillOpacity,
        lineColor: options.lineColor,
        lineWidth: options.lineWidth,
        fontColor: options.fontColor,
        fontSize: options.fontSize,
        fontWeight: options.fontWeight,
        fibLevels: fibLevels,
        showFibModeToggle: false,
        showSnapToHighLowToggle: false,
        templates: self.getDrawingTemplates(),
        userDefaultSettings: self.getUserDefaultSettings()
    }
    return infChart.drawingUtils.common.getFibSettings(properties);
};

/**
 * Change the Fib fan levels
 * IMPORTANT :: this method is uesd in commands.wrappers to set undo/redo actions
 * @param {string} currentLevel 
 * @param {boolean} checked 
 * @param {boolean|undefined} isPropertyChange property change 
 */
infChart.fibFansDrawing.prototype.onFibFansLevelChange = function (currentLevel, checked, isPropertyChange, ignoreSettingsSave) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        line = ann.shape.d.split(' ');
    var drawing = self.additionalDrawings.lines[currentLevel];
    var label = self.fibonacciDrawings.lines[currentLevel];
    var fill = self.fibonacciDrawings.fill[currentLevel],
        options = self.annotation.options,
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels),
        currentOrderIdx,
        prevLine, prevFill, nextFill,
        currentLinePoints,
        i,
        lineD,
        next;

    fibLevels.some(function (fibLevel, i) {
        if (fibLevel.id == currentLevel) {
            currentOrderIdx = i;
            return true;
        }
    });
    fibLevels[currentOrderIdx].enable = checked;

    if (checked) {
        drawing.show();
        label.show();
        fill.show();

        for (i = currentOrderIdx + 1; i < fibLevels.length; i++) {
            lineD = self.additionalDrawings.lines[fibLevels[i].id];
            if (lineD && lineD.visibility != "hidden") {
                prevLine = lineD;
                prevFill = self.fibonacciDrawings.fill[fibLevels[i].id];
                break;
            }
        }
        for (i = currentOrderIdx - 1; i >= 0; i--) {
            lineD = self.additionalDrawings.lines[fibLevels[i].id];
            if (lineD && lineD.visibility != "hidden") {
                next = lineD;
                nextFill = self.fibonacciDrawings.fill[fibLevels[i].id];
                break;
            }
        }

        currentLinePoints = drawing.d.split(' ');

        if (prevLine && prevFill) {
            prvLinePoints = prevLine.d.split(' ');
            prevFill.attr({
                d: ['M', prvLinePoints[1], prvLinePoints[2], 'L', prvLinePoints[4], prvLinePoints[5], 'L', currentLinePoints[4], currentLinePoints[5], 'L', prvLinePoints[1], prvLinePoints[2]]
            });

        }

        if (fill && nextFill) {
            nextLinePoints = next.d.split(' ');
            fill.attr({
                d: ['M', nextLinePoints[1], nextLinePoints[2], 'L', nextLinePoints[4], nextLinePoints[5], 'L', currentLinePoints[4], currentLinePoints[5], 'L', nextLinePoints[1], nextLinePoints[2]]
            });
        } else if (fill){
            var annotationLine = self.annotation.shape.d.split(' ');
            if(annotationLine[1] === "0" && annotationLine[2] === "0" && currentLinePoints[1] !== "0" && currentLinePoints[2] !== "0"){
                fill.attr({
                    d: ['M',  annotationLine[1], annotationLine[2], 'L', currentLinePoints[1], currentLinePoints[2], 'L', currentLinePoints[4], currentLinePoints[5], 'L', annotationLine[1], annotationLine[2]]
                });
            } else {
                fill.attr({
                    d: ['M', currentLinePoints[1], currentLinePoints[2], 'L', currentLinePoints[4], currentLinePoints[5], 'L', annotationLine[4], annotationLine[5], 'L', currentLinePoints[1], currentLinePoints[2]]
                });
            }
        }

    } else {
        drawing.hide();
        label.hide();
        fill.hide();

        for (i = currentOrderIdx + 1; i < fibLevels.length; i++) {
            lineD = self.additionalDrawings.lines[fibLevels[i].id];
            if (lineD && lineD.visibility != "hidden") {
                prevLine = lineD;
                prevFill = self.fibonacciDrawings.fill[fibLevels[i].id];
                break;
            }
        }

        for (i = currentOrderIdx - 1; i >= 0; i--) {
            lineD = self.additionalDrawings.lines[fibLevels[i].id];
            if (lineD && lineD.visibility != "hidden") {
                next = lineD;
                nextFill = self.fibonacciDrawings.fill[fibLevels[i].id];
                break;
            }
        }
        if (prevLine && next) {
            var prvLinePoints = prevLine.d.split(' '),
                nextLinePoints = next.d.split(' ');
            prevFill.attr({
                d: ['M', nextLinePoints[1], nextLinePoints[2], 'L', nextLinePoints[4], nextLinePoints[5], 'L', prvLinePoints[4], prvLinePoints[5], 'L', nextLinePoints[1], nextLinePoints[2]]
            })
        } else if (prevLine) {
            var prvLinePoints = prevLine.d.split(' ');
            var jointLinePoints = self.annotation.shape.d.split(' ');
            if(jointLinePoints[1] === "0" && jointLinePoints[2] === "0" && prvLinePoints[1] !== "0" && prvLinePoints[2] !== "0"){
                prevFill.attr({
                    d: ['M', jointLinePoints[1], jointLinePoints[2], 'L', prvLinePoints[1], prvLinePoints[2], 'L', prvLinePoints[4], prvLinePoints[5], 'L', jointLinePoints[1], jointLinePoints[2]]
                });
            } else {
                prevFill.attr({
                    d: ['M', prvLinePoints[1], prvLinePoints[2], 'L', prvLinePoints[4], prvLinePoints[5], 'L', jointLinePoints[4], jointLinePoints[5], 'L', prvLinePoints[1], prvLinePoints[2]]
                });
            }
        }
    }

    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', 0, 0, 'L', line[4], line[5]], self.dragSupporters);
    $.each(self.additionalDrawings.lines, function (key, value) {
        if (value.visibility !== 'hidden') {
            var line = value.d.split(' ');
            var customAttributes = {
                'level': key,
                'type': "additionalDrawing"
            }
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes);
        }
    });
    self.highlightEachLine();

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }    
};

infChart.fibFansDrawing.prototype.scale = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        line = ann.shape.d.split(' '),
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        plotWidth = chart.plotWidth * infChart.drawingUtils.common.correctionFactor,
        fibonacciDrawings = self.fibonacciDrawings.lines,
        fibonacciDrawingsFill = self.fibonacciDrawings.fill,
        fibLevels = options.fibLevels ? options.fibLevels : this.fibLevels,
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);

    var xEnd = xAxis.toPixels(options.xValueEnd) - xAxis.toPixels(options.xValue),
        yEnd = yAxis.toPixels(options.yValueEnd) - yAxis.toPixels(options.yValue);

    line[4] = (!isNaN(xEnd) && xEnd) || 0;
    line[5] = (!isNaN(yEnd) && yEnd) || 0;

    ann.update({
        shape: {
            params: {
                d: line
            }
        }
    });

    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', 0, 0, 'L', line[4], line[5]], self.dragSupporters);

    var dx = line[4], dy = line[5];

    $.each(this.additionalDrawings.lines, function (key, value) {
        var fibLevel = fibLevels.find(function (level) {
            return level.id === key;
        });
        // var percentage = parseFloat(key.split("_")[1]);
        var percentage = parseFloat(fibLevel.value);
        var percentageY = (dx > 0 ? -dy : dy) * percentage / 100 + (dx > 0 ? dy : 0);
        var m = dx > 0 ? percentageY / dx : (percentageY - dy) / (0 - dx);
        var startPointX = dx > 0 ? 0 : dx;
        var startPointY = dx > 0 ? 0 : dy;
        var drawingLabel = fibonacciDrawings[key];
        var labelBBox = drawingLabel.getBBox();
        var labelStartPosition = dx > 0 ? labelBBox.x + parseInt(dx, 10) : labelBBox.x;
        var line = ["M", startPointX, startPointY, 'L', plotWidth, plotWidth * m + (dx > 0 ? 0 : percentageY)];

        value.attr({
            d: line
        });

        drawingLabel.attr({
            x: labelStartPosition,
            y: percentageY - 10
        });

        drawingLabel.textSetter(infChart.drawingUtils.common.formatValue(fibLevel.value, 1) + "%");
        if (value.visibility !== 'hidden') {
            var customAttributes = {
                'level': key,
                'type': "additionalDrawing"
            }

            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes);
        }
    });

    $.each(fibonacciDrawingsFill, function (key, value) {
        var lineD = self.additionalDrawings.lines[key],
            currentLineP = lineD && lineD.d.split(' '),
            currentOrderIdx,
            lineD_,
            lineD_P;

        fibLevels.some(function (fibLevel, i) {
            if (fibLevel.id == key) {
                currentOrderIdx = i;
                return true;
            }
        });

        for (var i = currentOrderIdx - 1; i >= 0; i--) {
            var lineTemp = self.additionalDrawings.lines[fibLevels[i].id];
            if (lineTemp && lineTemp.visibility != "hidden") {
                lineD_ = lineTemp;
                break;
            }
        }

        if (!lineD_) {
            lineD_ = ann.shape;
        }

        lineD_P = lineD_.d.split(' ');
        if (currentLineP && lineD_P) {
            if(lineD_P[1] === "0" && lineD_P[2] === "0" && currentLineP[1] !== "0" && currentLineP[2] !== "0"){
                value.attr({
                    d: ['M', lineD_P[1], lineD_P[2], 'L', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', lineD_P[1], lineD_P[2]]
                });
            } else {
                value.attr({
                    d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', lineD_P[4], lineD_P[5], 'L', currentLineP[1], currentLineP[2]]
                });
            }

        }

    });
    self.highlightEachLine();
};

infChart.fibFansDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation,
        pathDefinition, width, height;

    ann.events.deselect.call(ann);
    ann.selectionMarker = [];
    pathDefinition = ann.shape.d.split(' ');
    width = parseFloat(pathDefinition[4]);
    height = parseFloat(pathDefinition[5]);

    if (!isNaN(width) && !isNaN(height)) {
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, 0, 0, this.stepFunction, this.stop, true);
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, width, height, this.stepFunction, this.stop, false);
    }
};

infChart.fibFansDrawing.prototype.step = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        plotWidth = chart.plotWidth * infChart.drawingUtils.common.correctionFactor,
        fibonacciDrawings = self.fibonacciDrawings.lines,
        points = infChart.drawingUtils.common.calculateInitialPoints(e, ann, isStartPoint, 0, 0),
        fibonacciDrawingsFill = self.fibonacciDrawings.fill,
        fibLevels = options.fibLevels ? options.fibLevels : this.fibLevels,
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);


    var line = ["M", 0, 0, 'L', parseInt(points.dx, 10), parseInt(points.dy, 10)];
    ann.shape.attr({
        d: line
    });

    var prevLine = line;

    $.each(self.additionalDrawings.lines, function (key, value) {
        var fibLevel = fibLevels.find(function (level) {
            return level.id === key;
        });
        var percentage = parseFloat(fibLevel.value);
        var percentageY = (points.dx > 0 ? -points.dy : points.dy) * percentage / 100 + (points.dx > 0 ? points.dy : 0);
        var m = points.dx > 0 ? percentageY / points.dx : (percentageY - points.dy) / (0 - points.dx);
        var startPointX = points.dx > 0 ? 0 : points.dx;
        var startPointY = points.dx > 0 ? 0 : points.dy;
        var drawingLabel = fibonacciDrawings[key];
        var labelBBox = drawingLabel.getBBox();
        var labelStartPosition = points.dx > 0 ? labelBBox.x + parseInt(points.dx, 10) : labelBBox.x;
        var line = ["M", startPointX, startPointY, 'L', plotWidth, plotWidth * m + (points.dx > 0 ? 0 : percentageY)];

        value.attr({
            d: line
        });

        drawingLabel.attr({
            x: labelStartPosition,
            y: percentageY - 10
        });

        var fill = fibonacciDrawingsFill[key];
        if (value.visibility != "hidden" && prevLine && line) {
            fill.attr({
                d: ['M', prevLine[1], prevLine[2], 'L', prevLine[4], prevLine[5], 'L', line[4], line[5], 'L', prevLine[1], prevLine[2]]
            });
            prevLine = line;
        }

    });

    return line;
};

infChart.fibFansDrawing.prototype.stop = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        line = self.stepFunction(e, isStartPoint),
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        x = xAxis.toValue(line[4] + xAxis.toPixels(ann.options.xValue)),
        y = yAxis.toValue(line[5] + yAxis.toPixels(ann.options.yValue));

    ann.update({
        xValueEnd: x,
        yValueEnd: y,
        shape: {
            params: {
                d: line
            }
        }
    });

    infChart.drawingUtils.common.saveBaseYValues.call(self, ann.options.yValue, y);
    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', 0, 0, 'L', line[4], line[5]], self.dragSupporters);

    $.each(self.additionalDrawings.lines, function (key, value) {
        if (value.visibility !== 'hidden') {
            var line = value.d.split(' ');
            var customAttributes = {
                'level': key,
                'type': "additionalDrawing"
            }
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes);
        }
    });
    self.highlightEachLine();

    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
    infChart.drawingUtils.common.onPropertyChange.call(self);
};

infChart.fibFansDrawing.prototype.translateEnd = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        line = ann.shape.d.split(' ');
    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', 0, 0, 'L', line[4], line[5]], self.dragSupporters);
    $.each(self.additionalDrawings.lines, function (key, value) {
        if (value.visibility !== 'hidden') {
            var line = value.d.split(' ');
            var customAttributes = {
                'level': key,
                'type': "additionalDrawing"
            }
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes);
        }
    });
    self.highlightEachLine();
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.fibFansDrawing.prototype.updateSettings = function (properties) {
    var updateProperties = {
        fillColor: properties.fillColor,
        fillOpacity: properties.fillOpacity,
        lineColor: properties.borderColor,
        lineWidth: properties.strokeWidth,
        fontSize: properties.fontSize,
        fontColor: properties.fontColor,
        isSingleColor: properties.isSingleColor,
        fibLevels: properties.fibLevels
    }
    infChart.structureManager.drawingTools.updateFibSettings(this.settingsPopup, updateProperties);
};

infChart.fibFansDrawing.prototype.highlightEachLine = function(){
    let self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        dragSupporters = self.dragSupporters,
        additionalDrawings = self.additionalDrawings,
        fibonacciDrawings = self.fibonacciDrawings,
        container = chart.container,
        selectedLevel,
        fibLabels = fibonacciDrawings.lines,
        fibLines = additionalDrawings.lines;

        dragSupporters.forEach(function (dragSupporter) {
            $(dragSupporter.element).mouseenter( function (event) {   
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                if(selectedLevel){
                    var selectedLine = fibLines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    $(container).find("path[class*='line-hover']").attr({class:''});
                    $(container).find("g[class*='label-hover']").attr({class:'highcharts-label'});
                    if(selectedLine){
                        selectedLine.addClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.addClass('label-hover');
                    }
                }
                event.stopPropagation();
            });

            $(dragSupporter.element).mouseleave( function (event) {   
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                if(selectedLevel){
                    var selectedLine = fibLines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    if(selectedLine){
                        selectedLine.removeClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.removeClass('label-hover');
                    }
                }
                event.stopPropagation();
            });
        })
};
window.infChart = window.infChart || {};

infChart.fibRetracementsDrawing = function () {
    this.closeIcon = '<img style = "width : 15px; height : 15px;" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI3LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA1NzYgNTc2IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1NzYgNTc2OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6Izg2ODY4Njt9Cgkuc3Qxe2ZpbGw6I0ZGRkZGRjt9Cjwvc3R5bGU+CjxnPgoJPGcgaWQ9Imljb21vb24taWdub3JlIj4KCTwvZz4KCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0yODgsMS41QzEyOS44LDEuNSwxLjUsMTI5LjgsMS41LDI4OFMxMjkuOCw1NzQuNSwyODgsNTc0LjVTNTc0LjUsNDQ2LjIsNTc0LjUsMjg4UzQ0Ni4yLDEuNSwyODgsMS41eiIvPgoJPHBhdGggY2xhc3M9InN0MSIgZD0iTTMzNC4yLDI4OGw3OS4xLTc5LjFjMTIuOC0xMi44LDEyLjgtMzMuNCwwLTQ2LjJsMCwwYy0xMi44LTEyLjgtMzMuNC0xMi44LTQ2LjIsMEwyODgsMjQxLjhsLTc5LjEtNzkuMQoJCWMtMTIuOC0xMi44LTMzLjQtMTIuOC00Ni4yLDBsMCwwYy0xMi44LDEyLjgtMTIuOCwzMy40LDAsNDYuMmw3OS4xLDc5LjFsLTc5LjEsNzkuMWMtMTIuOCwxMi44LTEyLjgsMzMuNCwwLDQ2LjJsMCwwCgkJYzEyLjgsMTIuOCwzMy40LDEyLjgsNDYuMiwwbDc5LjEtNzkuMWw3OS4xLDc5LjFjMTIuOCwxMi44LDMzLjQsMTIuOCw0Ni4yLDBsMCwwYzEyLjgtMTIuOCwxMi44LTMzLjQsMC00Ni4yTDMzNC4yLDI4OHoiLz4KPC9nPgo8L3N2Zz4K" alt="Close" />';
    infChart.drawingObject.apply(this, arguments);
    this.fibLevels = [
        {
            id: 'level_0',
            value: 0.0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#726a6f',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_1',
            value: 23.6,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#835974',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_2',
            value: 38.2,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#7b6171',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_3',
            value: 50,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f8bce2',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_4',
            value: 61.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f075c3',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_5',
            value: 78.6,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#eb40ab',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_6',
            value: 100,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#c71585',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_7',
            value: 127.2,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#800e56',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_8',
            value: 161.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#4b0832',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_9',
            value: 200,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#726a6f',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_10',
            value: 261.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#835974',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_11',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#7b6171',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_12',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f8bce2',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_13',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f075c3',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        }
    ];
    this.defaultDragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', type:'mainDrawing'});
    this.fibLevelDragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', type:'additionalDrawing'});
    // this.settings = {
    //    /**
    //     * on fib mode change
    //     * @param {boolean} checked - fib mode checked
    //     * @param {boolean} isPropertyChange - is propery changed
    //     */
    //    onFibModeChange: function (checked, isPropertyChange) {
    //       var self = this;
    //       var ann = self.annotation,
    //          options = ann.options;

    //       options.isContinuousMode = checked;

    //       self.scale();
    //       self.updateSettings(self.getConfig());
    //       isPropertyChange && self.onPropertyChange();
    //       if (this.settingsPopup) {
    //          this.settingsPopup.data("infUndoRedo", false);
    //       }
    //    }
    // };
};

infChart.fibRetracementsDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.fibRetracementsDrawing.prototype.getConfig = function () {
    var self = this,
        annotation = self.annotation,
        options = annotation.options,
        fibLevels = options.fibLevels ? options.fibLevels : self.fibLevels;
    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);

    return {
        shape: 'fibRetracements',
        fibLevels: fibLevels,
        borderColor: annotation.options.lineColor,
        fillColor: annotation.options.fillColor,
        fillOpacity: annotation.options.fillOpacity,
        strokeWidth: annotation.options.lineWidth,
        fontColor: annotation.options.fontColor,
        fontSize: annotation.options.fontSize,
        fontWeight: annotation.options.fontWeight,
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        isContinuousMode: annotation.options.isContinuousMode,
        isSingleColor: annotation.options.isSingleColor,
        isSnapTopHighLow: annotation.options.isSnapTopHighLow,
        isTrendLineAlways: annotation.options.isTrendLineAlways,
        trendLineColor: annotation.options.trendLineColor,
        trendLineOpacity: annotation.options.trendLineOpacity,
        trendLineWidth: annotation.options.trendLineWidth,
        trendLineStyle: annotation.options.trendLineStyle,
        isLocked : annotation.options.isLocked

    };
};

infChart.fibRetracementsDrawing.prototype.getNearestYValue = function (isSnapTopHighLow, yValue, nearestDataPoint, chart) {
    var self = this;
    var nearestYValue = yValue;
    if(!chart){
        chart = this.annotation.chart;
    }
    var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart);
    var chartInstance = infChart.manager.getChart(stockChartId);

    var nearestYValueOpen, nearestYValueClose;
    if (chartInstance.isLog || chartInstance.isCompare) {
        nearestYValueOpen = infChart.drawingUtils.common.getYValue.call(self, nearestDataPoint.yData[1]);
        nearestYValueClose = infChart.drawingUtils.common.getYValue.call(self, nearestDataPoint.yData[2]);
    } else {
        nearestYValueOpen = nearestDataPoint.yData[1];
        nearestYValueClose = nearestDataPoint.yData[2];
    }

    if (yValue && isSnapTopHighLow) {
        if (Math.abs(yValue - nearestYValueOpen) < Math.abs(yValue - nearestYValueClose)) {
            nearestYValue = nearestDataPoint.yData[1];
        } else {
            nearestYValue = nearestDataPoint.yData[2];
        }
    }

    return nearestYValue;
};

infChart.fibRetracementsDrawing.prototype.getOptions = function (properties, chart) {
    var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, properties.xValue, undefined, true, true);
    var futureValue = chart.series[0].xData[chart.series[0].xData.length-1];
    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        nearestXValue: nearestDataForXValue.xData,
        allowDragX: true,
        allowDragY: true,
        allowDragByHandle: true,
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0]
            }
        }
    };
    var theme = infChart.drawingUtils.common.getTheme.call(this);
    var shapeTheme = theme["fibRetracements"];
    var baseFillColor = (theme.fibRetracements && theme.fibRetracements.singleFillColor) ? theme.fibRetracements.singleFillColor : (theme.fibonacci && theme.fibonacci.singleFillColor) ? theme.fibonacci.singleFillColor : infChart.drawingUtils.common.baseFillColor;
    var baseFillOpacity = (theme.fibRetracements && typeof theme.fibRetracements.fillOpacity !== "undefined") ? theme.fibRetracements.fillOpacity : (theme.fibonacci && typeof theme.fibonacci.fillOpacity !== "undefined") ? theme.fibonacci.fillOpacity : infChart.drawingUtils.common.baseFillOpacity;
    var baseBorderColor = (theme.fibRetracements && theme.fibRetracements.borderColor) ? theme.fibRetracements.borderColor : (theme.fibonacci && theme.fibonacci.borderColor) ? theme.fibonacci.borderColor : infChart.drawingUtils.common.baseBorderColor;
    var baseLineWidth = (theme.fibRetracements && typeof theme.fibRetracements.lineWidth !== "undefined") ? theme.fibRetracements.lineWidth : (theme.fibonacci && theme.fibonacci.lineWidth) ? theme.fibonacci.lineWidth : infChart.drawingUtils.common.baseLineWidth;
    var baseFontColor = (theme.fibRetracements && theme.fibRetracements.fontColor) ? theme.fibRetracements.fontColor : (theme.fibonacci && theme.fibonacci.fontColor) ? theme.fibonacci.fontColor : infChart.drawingUtils.common.baseFontColor;
    var baseFontSize = (theme.fibRetracements && theme.fibRetracements.fontSize) ? theme.fibRetracements.fontSize : (theme.fibonacci && theme.fibonacci.fontSize) ? theme.fibonacci.fontSize : infChart.drawingUtils.common.baseFontSize;
    var baseFontWeight = (theme.fibRetracements && theme.fibRetracements.fontWeight) ? theme.fibRetracements.fontWeight : (theme.fibonacci && theme.fibonacci.fontWeight) ? theme.fibonacci.fontWeight : infChart.drawingUtils.common.baseFontWeight;
    options.fillColor = properties.fillColor ? properties.fillColor : baseFillColor;
    options.fillOpacity = properties.fillOpacity ? properties.fillOpacity : baseFillOpacity;
    options.lineColor = properties.borderColor ? properties.borderColor : baseBorderColor;
    options.lineWidth = properties.strokeWidth ? properties.strokeWidth : baseLineWidth;
    options.fontColor = properties.fontColor ? properties.fontColor : baseFontColor;
    options.fontSize = properties.fontSize ? properties.fontSize : baseFontSize;
    options.fontWeight = properties.fontWeight ? properties.fontWeight : baseFontWeight;

    options.trendLineColor = properties.trendLineColor ? properties.trendLineColor : shapeTheme.stroke || "#959595";
    options.trendLineOpacity = properties.trendLineOpacity ? properties.trendLineOpacity : shapeTheme.opacity || 1;
    options.trendLineWidth = properties.trendLineWidth ? properties.trendLineWidth : baseLineWidth || 1;
    options.trendLineStyle = properties.trendLineStyle ? properties.trendLineStyle : shapeTheme.dashstyle || 'solid';

    options.shape.params.fill = options.fillColor;
    options.shape.params['fill-opacity'] = options.fillOpacity;
    options.shape.params.stroke = options.trendLineColor;
    options.shape.params.opacity =  options.trendLineOpacity;
    options.shape.params['stroke-width'] = options.trendLineWidth;
    options.shape.params.dashstyle = options.trendLineStyle;
    options.shape.params['font-color'] = options.fontColor;
    options.shape.params['font-size'] = options.fontSize;
    options.isSingleColor = typeof properties.isSingleColor !== "undefined" ? properties.isSingleColor : false;
    options.fibLevels = properties.fibLevels ? properties.fibLevels : this.fibLevels;
    options.fibLevels = infChart.drawingUtils.common.getFibLevelsWithOpacity(infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels), baseFillOpacity);
    options.showFibModeToggle = true;
    options.isContinuousMode = typeof properties.isContinuousMode !== "undefined" ? properties.isContinuousMode : true;
    options.showSnapToHighLowToggle = true;
    options.showTrendLineAlwaysToggle = true;
    options.isSnapTopHighLow = typeof properties.isSnapTopHighLow !== "undefined" ? properties.isSnapTopHighLow : false;
    options.isTrendLineAlways = typeof properties.isTrendLineAlways !== "undefined" ? properties.isTrendLineAlways : true;
    if(futureValue >= nearestDataForXValue.xData){
        options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isSnapTopHighLow, properties.yValue, nearestDataForXValue, chart));
    } else {
        options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, properties.yValue);
    }
    if(options.isSnapTopHighLow){
        options.yValue = options.nearestYValue;
    }

    if (properties.xValueEnd && properties.yValueEnd) {
        var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, properties.xValueEnd, undefined, true, true);
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
        options.nearestXValueEnd = nearestDataForXValueEnd.xData;
        if(futureValue >= nearestDataForXValueEnd.xData){
            options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isSnapTopHighLow, options.yValueEnd, nearestDataForXValueEnd, chart));
        } else {
            options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, options.yValueEnd);
        }
        if(options.isSnapTopHighLow){
            options.yValueEnd = options.nearestYValueEnd;
        }
    }

    options.isRealTimeTranslation = true;
    options.validateTranslationFn = function (newXValue) {
        var annotation = this.annotation,
            chart = annotation.chart,
            options = annotation.options,
            xVal = options.xValue,
            xValEnd = options.xValueEnd,
            newXValueEnd = xValEnd - xVal + newXValue,
            xAxis = chart.xAxis[options.xAxis],
            seriesData = chart.series[0].xData,
            dataMin = seriesData[0],
            totalPoints = infChart.drawingsManager.getTotalPoints(chart),
            dataMax = totalPoints[totalPoints.length - 1];

        return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax) && (options.selectedDrawing == "mainDrawing");
    }

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.fibRetracementsDrawing.prototype.additionalDrawingsFunction = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        fibLevels = options.fibLevels ? options.fibLevels : this.fibLevels,
        additionalDrawingsArr = self.additionalDrawings,
        fibonacciDrawingsArr = self.fibonacciDrawings,
        theme = infChart.drawingUtils.common.getTheme.call(this),
        drawingFillAttr,
        drawingAttr,
        labelAttribs,
        baseFillOpacity = (theme.fibRetracements && typeof theme.fibRetracements.fillOpacity !== "undefined") ? theme.fibRetracements.fillOpacity : infChart.drawingUtils.common.baseFillOpacity,
        nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true),
        newX = xAxis.toPixels(nearestDataForXValue.xData) - xAxis.toPixels(options.xValue),
        futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];
        var nearestYValue;
        if(futureValue >= nearestDataForXValue.xData){
            nearestYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isSnapTopHighLow, options.yValue, nearestDataForXValue));
        } else {
            nearestYValue = infChart.drawingUtils.common.getYValue.call(this, options.yValue);
        }
    var newY = yAxis.toPixels(nearestYValue) - yAxis.toPixels(options.yValue),
        baseFontColor = (theme.fibRetracements && typeof theme.fibRetracements.fontColor !== "undefined") ? theme.fibRetracements.fontColor : infChart.drawingUtils.common.baseFontColor,
        baseFontSize = (theme.fibRetracements && typeof theme.fibRetracements.fontSize !== "undefined") ? theme.fibRetracements.fontSize : infChart.drawingUtils.common.baseFontSize,
        baseFontWeight = (theme.fibRetracements && typeof theme.fibRetracements.fontWeight !== "undefined") ? theme.fibRetracements.fontWeight : infChart.drawingUtils.common.baseFontWeight,

        labelStyles = {
            'color': baseFontColor,
            fontSize: baseFontSize,
            'font-weight': baseFontWeight
        };

    additionalDrawingsArr.lines = {};
    fibonacciDrawingsArr.lines = {};
    fibonacciDrawingsArr.fill = {};
    additionalDrawingsArr.hideFibLevelButton = {};

    var hiddenLevels = [];

    // add fill objects first to avoid overlapping lines with and texts with them
    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);
    fibLevels.forEach(function (fibLevel) {
        var themeFillColor = theme.fibRetracements && theme.fibRetracements.fibLevelFillColors && theme.fibRetracements.fibLevelFillColors[fibLevel.id];
        if (!fibLevel.enable) {
            hiddenLevels.push(fibLevel.id);
        }
        drawingFillAttr = {
            'stroke-width': 0,
            fill: options.isSingleColor && options.fillColor ? options.fillColor : fibLevel && fibLevel.fillColor ? fibLevel.fillColor : themeFillColor,
            'fill-opacity': options.isSingleColor && options.fillOpacity ? options.fillOpacity : fibLevel && fibLevel.fillOpacity ? fibLevel.fillOpacity : baseFillOpacity,
            stroke: ann.options.shape.params.stroke,
            'z-index': 2,
            cursor: 'default',
            'level': fibLevel.id,
            'pointer-events':'none'
        };
        drawingAttr = {
            'stroke-width': options.isSingleColor && options.lineWidth ? options.lineWidth : fibLevel && fibLevel.lineWidth ? fibLevel.lineWidth : ann.options.shape.params['stroke-width'],
            fill: ann.options.shape.params.fill,
            stroke: options.isSingleColor && options.lineColor ? options.lineColor : fibLevel && fibLevel.lineColor ? fibLevel.lineColor : ann.options.shape.params.stroke,
            'z-index': 2,
            cursor: 'default',
            'level': fibLevel.id
        };
        var fontColor = options.isSingleColor && options.fontColor ? options.fontColor : fibLevel && fibLevel.fontColor ? fibLevel.fontColor : baseFontColor;
        var fontSize = options.isSingleColor && options.fontSize ? options.fontSize : fibLevel && fibLevel.fontSize ? fibLevel.fontSize : baseFontSize;
        var fontWeight = options.isSingleColor && options.fontWeight ? options.fontWeight : fibLevel && fibLevel.fontWeight ? fibLevel.fontWeight : baseFontWeight;

        labelStyles = {
            'color': fontColor,
            fontSize: fontSize + 'px',
            'font-weight': fontWeight
        };

        labelAttribs = {
            'level': fibLevel.id,
            'font-color': fontColor,
            'font-size': fontSize,
            'font-weight': fontWeight
        }

        fibonacciDrawingsArr.fill[fibLevel.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0]).attr(drawingFillAttr).add(ann.group);
        additionalDrawingsArr.lines[fibLevel.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingAttr).add(ann.group);
        fibonacciDrawingsArr.lines[fibLevel.id] = chart.renderer.label(infChart.drawingUtils.common.formatValue(fibLevel.value, 1), fibLevel.drawingPosX, fibLevel.drawingPosY).css(labelStyles).attr(labelAttribs).add(ann.group);
        additionalDrawingsArr.hideFibLevelButton[fibLevel.id] = chart.renderer.createElement('foreignObject').add(ann.group).attr({
            width: '20',
            height: '20',
            level: fibLevel.id,
            rel: 'hideFibLevelButton',
            cursor: 'pointer'
        });
        var labelHtml = "<div>" + self.closeIcon + "</div>";
        additionalDrawingsArr.hideFibLevelButton[fibLevel.id].element.innerHTML = labelHtml;

        $(additionalDrawingsArr.hideFibLevelButton[fibLevel.id].element).mousedown( function (event) {
            if (event.which == 1 || event.button == 0) {
                event.stopPropagation();
                setTimeout(function () {
                    var selectedLevel = event.currentTarget.getAttribute('level');
                    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(self.annotation.chart);
                    if (selectedLevel) {
                        if (self.isVisibleLastLevel()) {
                            infChart.drawingsManager.removeDrawing(chartId, self.drawingId, undefined, true);
                        } else {
                            infChart.drawingUtils.common.settings.onFibLevelChange.call(self, selectedLevel, false, true, true);
                        }
                    }
                }, 0);
            }
        });

        additionalDrawingsArr.hideFibLevelButton[fibLevel.id].toFront();
    });

    hiddenLevels.forEach(function (id) {
        infChart.drawingUtils.common.settings.onFibLevelChange.call(self, id, false, false, true);
    });

    ann.selectionMarker = [];
    if (!options.isSnapTopHighLow) {
        newY = 0;
    }
    infChart.drawingUtils.common.addSelectionMarker.call(this, ann, newX, newY);
};

infChart.fibRetracementsDrawing.prototype.setNearestYValues = function (options, chart) {
    var self = this;
    var futureValue = chart.series[0].xData[chart.series[0].xData.length-1];

    var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
    if(futureValue >= nearestDataForXValue.xData){
        self.nearestYValue = self.getNearestYValue(options.isSnapTopHighLow, options.yValue, nearestDataForXValue, chart);
    } else {
        self.nearestYValue =  options.yValue;
    }

    var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);
    if(futureValue >= nearestDataForXValueEnd.xData){
        self.nearestYValueEnd = self.getNearestYValue(options.isSnapTopHighLow, options.yValueEnd, nearestDataForXValueEnd, chart);
    } else {
        self.nearestYValueEnd = options.yValueEnd;
    }
};

infChart.fibRetracementsDrawing.prototype.step = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id)),
        points = infChart.drawingUtils.common.calculateInitialPoints(e, ann, isStartPoint, 0, 0),
        plotWidth = chart.plotWidth * infChart.drawingUtils.common.correctionFactor,
        fibonacciDrawings = self.fibonacciDrawings.lines,
        fibLevels = options.fibLevels ? options.fibLevels : this.fibLevels,
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels),
        fibonacciDrawingsFill = self.fibonacciDrawings.fill,
        options = ann && ann.options,
        lineDrawings = self.additionalDrawings.lines,
        fill,
        currentLine,
        currentLineP,
        nextLine,
        nextLineP,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        xValueEnd = xAxis.toValue(xAxis.toPixels(options.xValue) + points.dx),
        yValueEnd = yAxis.toValue(yAxis.toPixels(options.yValue) + points.dy),
        nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true),
        nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, xValueEnd, undefined, true, true),
        nearestXValue = nearestDataForXValue.xData,
        nearestXValueEnd = nearestDataForXValueEnd.xData,
        newX = xAxis.toPixels(nearestXValue) - xAxis.toPixels(ann.options.xValue),
        newXEnd = xAxis.toPixels(nearestXValueEnd) - xAxis.toPixels(ann.options.xValue);
        var futureValue = chart.series[0].xData[chart.series[0].xData.length-1];
        var nearestYValue, nearestYValueEnd, newY, newYEnd;

        if(options.isSnapTopHighLow){
            if(isStartPoint) {
                if(futureValue >= nearestXValue){
                    nearestYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isSnapTopHighLow, options.yValue, nearestDataForXValue));
                } else {
                    nearestYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue));
                }
                ann.update({
                    yValue: nearestYValue
                });
                nearestYValueEnd = yValueEnd;
            } else {
                if(futureValue >= nearestXValueEnd){
                    nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isSnapTopHighLow, yValueEnd, nearestDataForXValueEnd));
                } else {
                    nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(self, yValueEnd));
                }
                ann.update({
                    yValueEnd: nearestYValueEnd
                });
                nearestYValue = options.yValue;
            }
        } else {
            nearestYValue = options.yValue;
            nearestYValueEnd = yValueEnd;
        }

        newYEnd = yAxis.toPixels(nearestYValueEnd) - yAxis.toPixels(nearestYValue);
        var line = ["M", newX, 0, 'L', parseInt(newXEnd, 10), parseInt(newYEnd, 10)];

    ann.shape.attr({
        d: line
    });

    $.each(this.additionalDrawings.lines, function (key, value) {
        var fibLevel = fibLevels.find(function (level) {
            return level.id === key;
        });
        var percentage = parseFloat(fibLevel.value);
        var percentageY = -((yAxis.toPixels(nearestYValueEnd) - yAxis.toPixels(nearestYValue)) * percentage / 100) + newYEnd;
        var lineStartPosition = points.dx > 0 && !options.isContinuousMode ? newX : newXEnd;
        //var lineEndPosition = options.isContinuousMode ? (xAxis.width - xAxis.toPixels(ann.options.xValue)) : points.dx > 0 ? newXEnd : newX;
        var lineEndPosition = xAxis.width - xAxis.toPixels(ann.options.xValue);
        var drawingLabel = fibonacciDrawings[key];
        var hideFibLevelButton = self.additionalDrawings.hideFibLevelButton[key];
        var labelStartPosition = lineEndPosition;
        var line = ["M", lineStartPosition, percentageY, 'L', lineEndPosition, percentageY];

        value.attr({
            d: line
        });

        var percentageValue = percentage / 100;
        var labelYValue = nearestYValueEnd > nearestYValue ? nearestYValueEnd - (nearestYValueEnd - nearestYValue) * percentageValue : nearestYValueEnd + (nearestYValue - nearestYValueEnd) * percentageValue;
        fibLevel.labelYValue = labelYValue;

        if (options.isContinuousMode) {
            drawingLabel.textSetter(self.getFormattedLabel(yAxis, nearestYValue, nearestYValueEnd, percentage, stockChart));
        }

        self.positionHideIcon(hideFibLevelButton, labelStartPosition, drawingLabel, percentageY);

        drawingLabel.attr({
            x: labelStartPosition - drawingLabel.width ,
            y: percentageY - drawingLabel.height
        });
    });

    fibLevels.forEach(function (value, index, arr) {
        fill = fibonacciDrawingsFill && fibonacciDrawingsFill[value.id];
        currentLine = lineDrawings[value.id];
        currentLineP = currentLine && currentLine.d.split(' ');

        for (var i = index + 1; i < arr.length; i++) {
            var lineTemp = self.additionalDrawings.lines[arr[i].id];
            if (lineTemp && lineTemp.visibility != "hidden") {
                nextLine = lineTemp;
                break;
            }
        }
        nextLineP = nextLine && nextLine.d.split(' ');
        if (currentLine && nextLine) {
            fill.attr({
                d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
            });
        }
        nextLine = undefined;
    });

    return {
        line: line,
        points: points,
        nearestXValue: nearestXValue,
        nearestXValueEnd: nearestXValueEnd,
        nearestYValue: nearestYValue,
        nearestYValueEnd: nearestYValueEnd
    };
};

infChart.fibRetracementsDrawing.prototype.stop = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        lineData = this.stepFunction(e, isStartPoint),
        line = lineData.line,
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        x = xAxis.toValue(lineData.points.dx + xAxis.toPixels(ann.options.xValue)),
        y = yAxis.toValue(line[5] + yAxis.toPixels(ann.options.yValue));

        // if (options.isSnapTopHighLow) {
        //     //line[2] = 0;
        //     if (!isStartPoint) {
        //         line[5] = yAxis.toPixels(lineData.nearestYValueEnd) - yAxis.toPixels(options.yValue);
        //     } else {
        //         line[5] = yAxis.toPixels(lineData.nearestYValueEnd) - yAxis.toPixels(lineData.nearestYValue);
        //     }

        //     ann.update({
        //         xValueEnd: x,
        //         yValue:  (!isStartPoint) ? (options.yValue) : lineData.nearestYValue,
        //         yValueEnd: (!isStartPoint) ? lineData.nearestYValueEnd : (options.yValueEnd),
        //         nearestXValue: lineData.nearestXValue,
        //         nearestXValueEnd: lineData.nearestXValueEnd,
        //         nearestYValue: (!isStartPoint) ? (options.yValue) : lineData.nearestYValue,
        //         nearestYValueEnd: (!isStartPoint) ? lineData.nearestYValueEnd : (options.yValueEnd),
        //         shape: {
        //             params: {
        //                 d: line
        //             }
        //         }
        //     });
        //     self.scale();
        // } else {
            ann.update({
                xValueEnd: x,
                yValue:  lineData.nearestYValue,
                yValueEnd: lineData.nearestYValueEnd,
                nearestXValue: lineData.nearestXValue,
                nearestXValueEnd: lineData.nearestXValueEnd,
                shape: {
                    params: {
                        d: line
                    }
                }
            });
        // }

    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, ann.options.yValueEnd);
    // infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd);
    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, line, self.dragSupporters, undefined, self.defaultDragSupporterStyles);

    $.each(self.additionalDrawings.lines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'stroke-width': 10
            }            
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
        }
    });
    self.highlightEachLine();

    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.fibRetracementsDrawing.prototype.scale = function (isCalculateNewValueForScale) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        stockChart,
        options = ann.options,
        line = ann.shape.d.split(' '),
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        plotWidth = chart.plotWidth * infChart.drawingUtils.common.correctionFactor,
        fibonacciDrawings = self.fibonacciDrawings.lines,
        fibLevels = options.fibLevels ? options.fibLevels : this.fibLevels,
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels),
        fibonacciDrawingsFill = self.fibonacciDrawings.fill,
        lineDrawings = self.additionalDrawings.lines,
        stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart),
        chartInstance = infChart.manager.getChart(stockChartId),
        fill,
        currentLine,
        currentLineP,
        nextLine,
        nextLineId,
        nextLineP,
        xValueInPixels = xAxis.toPixels(options.xValue),
        yValueInPixels = yAxis.toPixels(options.yValue),
        stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id)),
        fibLevelLines = {};

    if(isCalculateNewValueForScale){
        var futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];
        var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
        var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);
        
        options.nearestXValue = nearestDataForXValue.xData;
        options.nearestXValueEnd = nearestDataForXValueEnd.xData;

        // if (options.isSnapTopHighLow) {
        //     if(futureValue >= options.nearestXValue){
        //         options.nearestYValue = infChart.drawingUtils.common.getYValue.call(self, self.getNearestYValue(options.isSnapTopHighLow, options.yValue, nearestDataForXValue));
        //     } else {
        //         options.nearestYValue = infChart.drawingUtils.common.getYValue.call(self, infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue));
        //     }
        //     if(futureValue >= options.nearestXValueEnd){
        //         options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(self, self.getNearestYValue(options.isSnapTopHighLow, options.yValueEnd, nearestDataForXValueEnd));
        //     } else {
        //         options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(self, infChart.drawingUtils.common.getBaseYValues.call(self, options.yValueEnd));
        //     }
        // } else {
        //     if(futureValue >= options.nearestXValue){
        //         options.nearestYValue =  this.getNearestYValue(options.isSnapTopHighLow, options.yValue, nearestDataForXValue);
        //     } else {
        //         options.nearestYValue = options.yValue;
        //     }

        //     if(futureValue >= options.nearestXValue){
        //         options.nearestYValueEnd = this.getNearestYValue(options.isSnapTopHighLow, options.yValueEnd, nearestDataForXValueEnd);
        //     } else {
        //         options.nearestYValueEnd = options.yValueEnd;
        //     }
        // }

        // if (chartInstance.isLog || chartInstance.isCompare) {
        //     self.nearestYValue = infChart.drawingUtils.common.getBaseYValue.call(self, options.nearestYValue);
        //     self.nearestYValueEnd = infChart.drawingUtils.common.getBaseYValue.call(self, options.nearestYValueEnd);
        // } else {
        //     self.nearestYValue = options.nearestYValue;
        //     self.nearestYValueEnd = options.nearestYValueEnd;
        // }

        ann.update({
            nearestXValue: nearestDataForXValue.xData,
            nearestXValueEnd: nearestDataForXValueEnd.xData
            // nearestYValue : options.nearestYValue,
            // nearestYValueEnd: options.nearestYValueEnd
        });
    } 

    var yValueEndInPixels = yAxis.toPixels(options.yValueEnd),
        newX = xAxis.toPixels(options.nearestXValue) - xValueInPixels,
        newXEnd = xAxis.toPixels(options.nearestXValueEnd) - xValueInPixels,
        newY = yAxis.toPixels(options.yValue) - yValueInPixels,
        newYEnd = yValueEndInPixels - yValueInPixels;

    line[1] = (!isNaN(newX) && newX) || 0;
    line[2] = (!isNaN(newY) && newY) || 0;
    line[4] = (!isNaN(newXEnd) && newXEnd) || 0;
    line[5] = (!isNaN(newYEnd) && newYEnd) || 0;

    ann.update({
        shape: {
            params: {
                d: line
            }
        }
    });

    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    if (ann.shape.visibility !== "hidden") {
        infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, line, self.dragSupporters, undefined, self.defaultDragSupporterStyles);
    }

    var dx = line[4], dy = line[5];
    var lineStartPosition = dx > 0 && !options.isContinuousMode ? newX : newXEnd;
    var lineEndPosition = xAxis.width - xValueInPixels,
        lineWidthInPixels = yValueEndInPixels - yAxis.toPixels(options.yValue);

    $.each(this.additionalDrawings.lines, function (key, value) {
        var fibLevel = fibLevels.find(function (level) {
            return level.id === key;
        });
        var percentage = parseFloat(fibLevel.value);
        var percentageY = -(lineWidthInPixels * percentage / 100) + dy;
        //var lineEndPosition = options.isContinuousMode && xAxis.toValue(xAxis.width) > Math.min(options.xValue, options.xValueEnd) ? (xAxis.width - xAxis.toPixels(ann.options.xValue)) : dx > 0 ? newXEnd : newX;
        var drawingLabel = fibonacciDrawings[key];
        //var labelBBox = drawingLabel.getBBox();
        var labelStartPosition = lineEndPosition;
        var line = ["M", lineStartPosition, percentageY, 'L', lineEndPosition, percentageY];
        fibLevelLines[key] = line;

        value.attr({
            d: line
        });

        var percentageValue = percentage / 100;
        var labelYValue = options.yValueEnd > options.yValue ? options.yValueEnd - (options.yValueEnd - options.yValue) * percentageValue : options.yValueEnd + (options.yValue - options.yValueEnd) * percentageValue;
        fibLevel.labelYValue = labelYValue;

        if (options.isContinuousMode) {
            drawingLabel.textSetter(self.getFormattedLabel(yAxis, options.yValue, options.yValueEnd, percentage, stockChart));
        } else {
            drawingLabel.textSetter(infChart.drawingUtils.common.formatValue(fibLevel.value, 1));
        }

        drawingLabel.attr({
            x: labelStartPosition - drawingLabel.width,
            y: percentageY - drawingLabel.height
        });

        if(chart.selectedAnnotation && chart.selectedAnnotation.options.id === options.id) {
            self.positionHideIcon(self.additionalDrawings.hideFibLevelButton[key], labelStartPosition, drawingLabel, percentageY);
        }

        if(value.visibility !== 'hidden'){
            var customAttributes = {
                'level' : key,
                'stroke-width': 10
            }
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
        }
    });
    self.highlightEachLine();

    options.fibLevels = fibLevels;

    fibLevels.forEach(function (value, index, arr) {
        fill = fibonacciDrawingsFill && fibonacciDrawingsFill[value.id];
        currentLine = lineDrawings[value.id];
        currentLineP = currentLine && fibLevelLines[value.id];

        for (var i = index + 1; i < arr.length; i++) {
            var lineTemp = self.additionalDrawings.lines[arr[i].id];
            if (lineTemp && lineTemp.visibility != "hidden") {
                nextLine = lineTemp;
                nextLineId = arr[i].id;
                break;
            }
        }
        nextLineP = nextLine && fibLevelLines[nextLineId];
        if (currentLine && nextLine) {
            fill.attr({
                d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
            });
        }
        nextLine = undefined;
    });
};

infChart.fibRetracementsDrawing.prototype.select = function(event){
    var self = this,
    ann = self.annotation,
    options = ann.options;

    if (event && event.target) {
        var drawingtype = event.target.getAttribute('type');
        if (drawingtype) {
            if (drawingtype == "mainDrawing") {
                options.selectedDrawing = "mainDrawing";
            }
            if (drawingtype == "additionalDrawing") {
                options.selectedDrawing = "additionalDrawing";
            }
        } else if (event.target.parentNode.getAttribute('type')) {
            //this used when clicked on levels of start, end, trend
            var drawingtype = event.target.parentNode.getAttribute('type');
            if (drawingtype == "additionalDrawing") {
                options.selectedDrawing = "additionalDrawing";
            }
        } else {
            //this used when clicked on fibbonacci levels
            if (event.target.parentNode.parentNode.getAttribute('type')) {
                var drawingtype = event.target.parentNode.parentNode.getAttribute('type');
                if (drawingtype == "additionalDrawing") {
                    options.selectedDrawing = "additionalDrawing";
                }
            }
        }
    }
};

infChart.fibRetracementsDrawing.prototype.translate = function (e) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id)),
        options = ann.options,
        line = ann.shape.d.split(' '),
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        fibonacciDrawings = this.fibonacciDrawings.lines,
        fibLevels = options.fibLevels ? options.fibLevels : this.fibLevels,
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels),
        fibonacciDrawingsFill = this.fibonacciDrawings.fill,
        lineDrawings = self.additionalDrawings.lines,
        fill,
        currentLine,
        currentLineP,
        nextLine,
        nextLineP;

    $.each(this.additionalDrawings.lines, function (key, value) {
        var fibLevel = fibLevels.find(function (level) {
            return level.id === key;
        });
        var percentage = parseFloat(fibLevel.value);
        var line = value.d.split(' ');
        var drawingLabel = fibonacciDrawings[key];
        var hideFibLevelButton = self.additionalDrawings.hideFibLevelButton[key];
        var lineEndPosition = xAxis.width - xAxis.toPixels(ann.options.xValue);
        var newLine = ["M", line[1], line[2], 'L', lineEndPosition, line[5]];

        value.attr({
            d: newLine
        });

        if (options.isContinuousMode) {
            drawingLabel.textSetter(self.getFormattedLabel(yAxis, options.yValue, options.yValueEnd, percentage, stockChart));
        }

        var labelStartPosition = lineEndPosition - drawingLabel.width;

        drawingLabel.attr({
            x: labelStartPosition,
            y: line[2] - drawingLabel.height
        });

        self.positionHideIcon(hideFibLevelButton, labelStartPosition, drawingLabel, line[2]);

    });

    fibLevels.forEach(function (value, index, arr) {
        fill = fibonacciDrawingsFill && fibonacciDrawingsFill[value.id];
        currentLine = lineDrawings[value.id];
        currentLineP = currentLine && currentLine.d.split(' ');

        for (var i = index + 1; i < arr.length; i++) {
            var lineTemp = self.additionalDrawings.lines[arr[i].id];
            if (lineTemp && lineTemp.visibility != "hidden") {
                nextLine = lineTemp;
                break;
            }
        }
        nextLineP = nextLine && nextLine.d.split(' ');
        if (currentLine && nextLine) {
            fill.attr({
                d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
            });
        }
        nextLine = undefined;
    });
    self.toggleFibLevelEraseIcon(true);
};

infChart.fibRetracementsDrawing.prototype.translateEnd = function () {
    var self = this,
    ann = self.annotation,
    chart = ann.chart,
    stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id)),
    options = ann.options,
    line = ann.shape.d.split(' '),
    xAxis = chart.xAxis[options.xAxis],
    yAxis = chart.yAxis[options.yAxis],
    fibonacciDrawings = this.fibonacciDrawings.lines,
    fibLevels = options.fibLevels ? options.fibLevels : this.fibLevels,
    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels),
    fibonacciDrawingsFill = this.fibonacciDrawings.fill,
    lineDrawings = self.additionalDrawings.lines,
    fill,
    currentLine,
    currentLineP,
    nextLine,
    nextLineP,
    futureValue = chart.series[0].xData[chart.series[0].xData.length - 1],
    nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true),
    nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true),
    nearestXValue = nearestDataForXValue.xData,
    nearestXValueEnd = nearestDataForXValueEnd.xData;
    // newX = xAxis.toPixels(nearestXValue) - xAxis.toPixels(options.xValue),
    // newXEnd = xAxis.toPixels(nearestXValueEnd) - xAxis.toPixels(options.xValue);

    var nearestYValue = options.yValue,
        nearestYValueEnd = options.yValueEnd;
    // if(futureValue >= nearestXValue){
    //     nearestYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(false, options.yValue, nearestDataForXValue));
    // } else {
    //     nearestYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.yValue));
    // }

    // if(futureValue >= nearestXValueEnd){
    //     nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(false, options.yValueEnd, nearestDataForXValueEnd));
    // } else {
    //     nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.yValueEnd));
    // }

    // if(options.isSnapTopHighLow){
    //     var newX = xAxis.toPixels(nearestXValue) - xAxis.toPixels(nearestXValue),
    //         newXEnd = xAxis.toPixels(nearestXValueEnd) - xAxis.toPixels(nearestXValue),
    //         newY = yAxis.toPixels(nearestYValue) - yAxis.toPixels(nearestYValue),
    //         newYEnd = yAxis.toPixels(nearestYValueEnd) - yAxis.toPixels(nearestYValue);

    //     var mainLine = ["M", newX, newY, 'L', parseInt(newXEnd, 10), parseInt(newYEnd, 10)];

    //     ann.update({
    //         xValue: nearestXValue,
    //         xValueEnd: nearestXValueEnd,
    //         yValue: nearestYValue,
    //         yValueEnd: nearestYValueEnd,
    //         nearestXValue: nearestXValue,
    //         nearestXValueEnd: nearestXValueEnd,
    //         nearestYValue: nearestYValue,
    //         nearestYValueEnd: nearestYValueEnd,
    //         shape: {
    //             params: {
    //                 d: mainLine
    //             }
    //         }
    //     });
    // } else {

        var newX = xAxis.toPixels(nearestXValue) - xAxis.toPixels(nearestXValue),
            newXEnd = xAxis.toPixels(nearestXValueEnd) - xAxis.toPixels(nearestXValue),
            // newY = yAxis.toPixels(nearestYValue) - yAxis.toPixels(options.yValue),
            newYEnd = yAxis.toPixels(options.yValueEnd) - yAxis.toPixels(options.yValue);

        var mainLine = ["M", newX, 0, 'L', parseInt(newXEnd, 10), parseInt(newYEnd, 10)];

        ann.update({
            xValue: nearestXValue,
            xValueEnd: nearestXValueEnd,
            nearestXValue: nearestXValue,
            nearestXValueEnd: nearestXValueEnd,
            // nearestYValue: nearestYValue,
            // nearestYValueEnd: nearestYValueEnd,
            shape: {
                params: {
                    d: mainLine
                }
            }
        });
    //}

    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, mainLine, self.dragSupporters, undefined, self.defaultDragSupporterStyles);

    $.each(this.additionalDrawings.lines, function (key, value) {
        var fibLevel = fibLevels.find(function (level) {
            return level.id === key;
        });
        var percentage = parseFloat(fibLevel.value);
        var percentageY = -((yAxis.toPixels(nearestYValueEnd) - yAxis.toPixels(nearestYValue)) * percentage / 100) + mainLine[5];
        var drawingLabel = fibonacciDrawings[key];
        var hideFibLevelButton = self.additionalDrawings.hideFibLevelButton[key];
        var lineStartPosition = line[4] > 0 && !options.isContinuousMode ? newX : newXEnd;
        //var lineEndPosition = options.isContinuousMode ? xAxis.width - xAxis.toPixels(ann.options.xValue) : line[4] > 0 ? newXEnd : newX;
        var lineEndPosition = xAxis.width - xAxis.toPixels(ann.options.xValue);
        var newLine = ["M", lineStartPosition, percentageY, 'L', lineEndPosition, percentageY];

        value.attr({
            d: newLine
        });

        var percentageValue = percentage / 100;
        var labelYValue = nearestYValueEnd > nearestYValue ? nearestYValueEnd - (nearestYValueEnd - nearestYValue) * percentageValue : nearestYValueEnd + (nearestYValue - nearestYValueEnd) * percentageValue;
        fibLevel.labelYValue = labelYValue;

        if (options.isContinuousMode) {
            drawingLabel.textSetter(self.getFormattedLabel(yAxis, nearestYValue, nearestYValueEnd, percentage, stockChart));
        }

        var labelStartPosition = lineEndPosition - drawingLabel.width;

        drawingLabel.attr({
            x: labelStartPosition,
            y: percentageY - drawingLabel.height
        });

        self.positionHideIcon(hideFibLevelButton, labelStartPosition, drawingLabel, percentageY);

        if(value.visibility !== 'hidden'){
            var customAttributes = {
                'level' : key,
                'stroke-width': 10
            }
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, newLine, self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
        }
    });

    fibLevels.forEach(function (value, index, arr) {
        fill = fibonacciDrawingsFill && fibonacciDrawingsFill[value.id];
        currentLine = lineDrawings[value.id];
        currentLineP = currentLine && currentLine.d.split(' ');

        for (var i = index + 1; i < arr.length; i++) {
            var lineTemp = self.additionalDrawings.lines[arr[i].id];
            if (lineTemp && lineTemp.visibility != "hidden") {
                nextLine = lineTemp;
                break;
            }
        }
        nextLineP = nextLine && nextLine.d.split(' ');
        if (currentLine && nextLine) {
            fill.attr({
                d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
            });
        }
        nextLine = undefined;
    });

    //self.scale();
    self.highlightEachLine();
    self.selectAndBindResize();
    chart.selectedAnnotation = ann;
    options.selectedDrawing = undefined;
    self.toggleFibLevelEraseIcon(false);
    // infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd);
    if (!ann.chart.isContextMenuOpen) {
        self.showQuickDrawingSettings();
    }
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

// infChart.fibRetracementsDrawing.prototype.bindFibSettingsEvents = function () {
//     var self = this;
//     var onFibModeChange = function (checked, isPropertyChange) {
//         self.onFibModeChange.call(self, checked, isPropertyChange);
//     };

//     var onChangeSnapToHighLow = function (checked, isPropertyChange) {
//         self.onChangeSnapToHighLow.call(self, checked, isPropertyChange);
//     };

//     var onTrendLineToggleShow = function (show) {
//         var isPropertyChange = true;
//         if (self.settingsPopup) {
//             isPropertyChange = self.isSettingsPropertyChange();
//         }
//         self.onTrendLineToggleShow.call(self, show, isPropertyChange);
//     };

//     return infChart.drawingUtils.common.bindFibSettingsEvents.call(this, infChart.drawingUtils.common.baseBorderColor, infChart.drawingUtils.common.baseLineWidth,
//         undefined, onFibModeChange, onChangeSnapToHighLow, onTrendLineToggleShow);
// };

infChart.fibRetracementsDrawing.prototype.bindSettingsEvents = function () {
    var self = this;
    var onFibModeChange = function (checked, isPropertyChange) {
        this.onFibModeChange.call(self, checked, isPropertyChange);
    };
    var onChangeSnapToHighLow = function (checked, isPropertyChange) {
        self.onChangeSnapToHighLow.call(self, checked, isPropertyChange);
    };

    var onTrendLineToggleShow = function (show) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onTrendLineToggleShow.call(self, show, isPropertyChange);
    };

    return infChart.drawingUtils.common.bindFibSettingsEvents.call(this, infChart.drawingUtils.common.baseBorderColor, infChart.drawingUtils.common.baseLineWidth,
        undefined, onFibModeChange, onChangeSnapToHighLow, onTrendLineToggleShow);
};

infChart.fibRetracementsDrawing.prototype.deselect = function (isMouseOut) {
    infChart.drawingUtils.common.onDeselect.call(this);
    this.annotation.options.selectedDrawing = undefined;
    if (isMouseOut) {
        if(this.annotation.options && !this.annotation.options.isTrendLineAlways){
            this.annotation.shape.hide();
            this.resetDragSupporters();
        }
        this.toggleFibLevelEraseIcon(true);
    }
};

infChart.fibRetracementsDrawing.prototype.toggleFibLevelEraseIcon = function (hide) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        fibonacciDrawings = self.fibonacciDrawings.lines,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis];

    if (hide) {
        $.each(self.additionalDrawings.hideFibLevelButton, function (key, value) {
            var hideFibLevelButton = self.additionalDrawings.hideFibLevelButton[key];
            hideFibLevelButton.hide();
        });
    } else {
        $.each(self.additionalDrawings.lines, function (key, value) {
            if (self.additionalDrawings.lines[key].visibility !== "hidden") {
                var hideFibLevelButton = self.additionalDrawings.hideFibLevelButton[key];
                var drawingLabel = fibonacciDrawings[key];
                var labelStartPosition = (xAxis.width - xAxis.toPixels(ann.options.xValue));

                self.positionHideIcon(hideFibLevelButton, labelStartPosition, drawingLabel, value.d.split(' ')[5]);
                hideFibLevelButton.show();
            }
        });
    }
};

infChart.fibRetracementsDrawing.prototype.getContextMenuOptions = function (chartId, drawingId, options, event) {
    var self = this;
    var selectedLevel;

    selectedLevel = event.target.getAttribute('level');
    if(!selectedLevel && event.target.parentElement){
        selectedLevel = event.target.parentElement.getAttribute('level');
        if(!selectedLevel && event.target.parentElement.parentElement){
            selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
        }
    }
    var contextMenu = {
        "copyToClipboard" : {
            icon : options.copyToClipboard.icon,
            displayText : options.copyToClipboard.displayText,
            action : function () {
                if(selectedLevel) {
                  infChart.drawingUtils.common.onFibLevelCopy.call(self, selectedLevel);
                }
            }
        }
    };

    if (!self.isVisibleLastLevel()) {
        var eraseThis = {
            icon: options.erase.icon,
            displayText: options.erase.displayText,
            action: function () {
                if (selectedLevel) {
                    infChart.drawingUtils.common.settings.onFibLevelChange.call(self, selectedLevel, false, true, true);
                }
            }
        }
        contextMenu["eraseThis"] = eraseThis;
    }
    if (selectedLevel) {
        contextMenu = Object.assign(contextMenu, infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options));
        return infChart.drawingUtils.common.reorderContextMenu(contextMenu);
     } else {
        return infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options);
     }
};

infChart.fibRetracementsDrawing.prototype.getFormattedLabel = function (yAxis, yValue, yValueEnd, percentage, stockChart) {
    var percentageValue = percentage / 100;
    var labelYValue = yValueEnd > yValue ? yValueEnd - (yValueEnd - yValue) * percentageValue : yValueEnd + (yValue - yValueEnd) * percentageValue;
    var formatedLabelYValue = stockChart.formatValue(labelYValue, stockChart.getMainSeries().options.dp, undefined, false, false, NO_OF_SPECIFIC_DECIMAL_POINTS);
    return formatedLabelYValue + ((percentageValue === 0 || percentageValue === 1) ? " " : percentageValue < 1 ? "Ret" : "EX") + " " + infChart.drawingUtils.common.formatValue(percentageValue, 3);
};

infChart.fibRetracementsDrawing.prototype.getQuickSettingsPopup = function () {
    var self = this;
    var options = self.annotation.options;
    var fillColor = options.fillColor;
    var fillOpacity = options.fillOpacity;
    var lineColor = options.lineColor;
    var fontColor = options.fontColor;
    var fontSize = options.fontSize;
    var fontWeight = options.fontWeight;
    return infChart.drawingUtils.common.getFibQuickSettings(fillColor, fillOpacity, lineColor, fontColor, fontSize);
};

infChart.fibRetracementsDrawing.prototype.getSettingsPopup = function () {
    var self = this;
    var options = self.annotation.options;
    var fibLevels = options.fibLevels ? options.fibLevels : self.fibLevels;

    var properties = {
        fillColor: options.fillColor,
        fillOpacity: options.fillOpacity,
        lineColor: options.lineColor,
        lineWidth: options.lineWidth,
        fontColor: options.fontColor,
        fontSize: options.fontSize,
        fontWeight: options.fontWeight,
        fibLevels: fibLevels,
        showFibModeToggle: options.showFibModeToggle,
        fibModeLabel: "Continuous Mode",
        showSnapToHighLowToggle: options.showSnapToHighLowToggle,
        templates: self.getDrawingTemplates(),
        userDefaultSettings: self.getUserDefaultSettings(),
        showTrendLineAlwaysToggle: options.showTrendLineAlwaysToggle,
        trendLineColor: options.trendLineColor,
        trendLineOpacity: options.trendLineOpacity,
        trendLineWidth: options.trendLineWidth,
        trendLineStyle: options.trendLineStyle
    }

    return infChart.drawingUtils.common.getFibSettings(properties);
};

/**
 * on fib mode change
 * @param {boolean} checked - fib mode checked
 * @param {boolean} isPropertyChange - is propery changed
 * @param {boolean} ignoreSettingsSave - this is to indicate to this change does not affect to subsequent drawing
 */
infChart.fibRetracementsDrawing.prototype.onFibModeChange = function (checked, isPropertyChange, ignoreSettingsSave) {
    var self = this;
    var ann = self.annotation,
        options = ann.options;

    options.isContinuousMode = checked;

    self.scale();
    self.updateSettings(self.getConfig());
    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

/**
 * on snap to high/low change
 * @param {boolean} checked - snap to high/low checked
 * @param {boolean} isPropertyChange - is propery changed
 * @param {boolean} ignoreSettingsSave - this is to indicate to this change does not affect to subsequent drawing
 */
infChart.fibRetracementsDrawing.prototype.onChangeSnapToHighLow = function (checked, isPropertyChange, ignoreSettingsSave) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart;
        // xAxis = chart.xAxis[options.xAxis],
        // yAxis = chart.yAxis[options.yAxis],
        // futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];

    options.isSnapTopHighLow = checked;

    // if (options.isSnapTopHighLow) {
    //     var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true),
    //         nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);

    //     if(futureValue >= nearestDataForXValue.xData){
    //         options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, self.getNearestYValue(options.isSnapTopHighLow, options.yValue, nearestDataForXValue));
    //     } else {
    //         options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue));
    //     }
    //     if(futureValue >= nearestDataForXValueEnd.xData){
    //         options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, self.getNearestYValue(options.isSnapTopHighLow, options.yValueEnd, nearestDataForXValueEnd));
    //     } else {
    //         options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(self, options.yValueEnd));
    //     }
    // } else {
    //     options.nearestYValue = options.yValue;
    //     options.nearestYValueEnd = options.yValueEnd;
    // }

    //infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd);

    // self.scale();
    // self.selectAndBindResize();
    // chart.selectedAnnotation = ann;
    // self.updateSettings(self.getConfig());
    isPropertyChange && self.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fibRetracementsDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation,
        pathDefinition, width, height;

    ann.events.deselect.call(ann);
    ann.shape.show();
    this.toggleFibLevelEraseIcon(false);
    ann.selectionMarker = [];
    pathDefinition = ann.shape.d.split(' ');
    width = parseFloat(pathDefinition[4]);
    height = parseFloat(pathDefinition[5]);

    this.resetDragSupporters();
    if (!isNaN(width) && !isNaN(height)) {
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, parseFloat(pathDefinition[1]), parseFloat(pathDefinition[2]), this.stepFunction, this.stop, true);
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, width, height, this.stepFunction, this.stop, false);
    }
};

infChart.fibRetracementsDrawing.prototype.positionHideIcon = function (hideFibLevelButton, labelStartPosition, drawingLabel, percentageY) {
    hideFibLevelButton.attr({
        x: labelStartPosition - drawingLabel.width - hideFibLevelButton.getBBox().width - 5,
        y: percentageY - hideFibLevelButton.getBBox().height
    });
};

infChart.fibRetracementsDrawing.prototype.resetDragSupporters = function(){
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        line = ann.shape.d.split(' ');
    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    if (ann.shape.visibility !== "hidden") {
        infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, undefined, self.defaultDragSupporterStyles);
    }

    $.each(self.additionalDrawings.lines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'stroke-width': 10
            }
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
        }
    });
    self.highlightEachLine();
};

infChart.fibRetracementsDrawing.prototype.updateSettings = function (properties) {
    var updateProperties = {
        fillColor: properties.fillColor,
        fillOpacity: properties.fillOpacity,
        lineColor: properties.borderColor,
        lineWidth: properties.strokeWidth,
        fontSize: properties.fontSize,
        fontColor: properties.fontColor,
        isSingleColor: properties.isSingleColor,
        fibLevels: properties.fibLevels,
        isFibModeEnabled: properties.isContinuousMode,
        isSnapTopHighLowEnabled: properties.isSnapTopHighLow,
        isTrendLineAlwaysEnabled: properties.isTrendLineAlways,
        trendLineColor: properties.trendLineColor,
        trendLineOpacity: properties.trendLineOpacity,
        trendLineWidth: properties.trendLineWidth,
        trendLineStyle: properties.trendLineStyle
    }
    infChart.structureManager.drawingTools.updateFibSettings(this.settingsPopup, updateProperties);
};

infChart.fibRetracementsDrawing.prototype.updateOptions = function (options) {
    this.setNearestYValues(options, this.annotation.chart);
};

infChart.fibRetracementsDrawing.prototype.highlightEachLine = function(){
    let self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        dragSupporters = self.dragSupporters,
        additionalDrawings = self.additionalDrawings,
        fibonacciDrawings = self.fibonacciDrawings,
        fibLabels = self.fibonacciDrawings.lines,
        container = chart.container,
        selectedLevel;

        dragSupporters.forEach(function (dragSupporter) {
            $(dragSupporter.element).mouseenter( function (event) {
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                if(selectedLevel){
                    var lines = additionalDrawings.lines;
                    var fibLabels = fibonacciDrawings.lines;
                    var selectedLine = lines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    $(container).find("path[class*='line-hover']").attr({class:''});
                    $(container).find("g[class*='label-hover']").attr({class:''});
                    if(selectedLine){
                        selectedLine.addClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.addClass('label-hover');
                    }
                }
                event.stopPropagation();
            });

            $(dragSupporters.element).mouseleave( function (event) {
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                if(selectedLevel){
                    var lines = additionalDrawings.lines;
                    var fibLabels = fibonacciDrawings.lines;
                    var selectedLine = lines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    if(selectedLine){
                        selectedLine.removeClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.removeClass('label-hover');
                    }
                }
                event.stopPropagation();
            });
        })

        $.each(fibLabels, function (key, fibonacciLabel) {
            $(fibonacciLabel.element).mouseenter( function (event) {
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                var lines = additionalDrawings.lines;
                var fibLabels = fibonacciDrawings.lines;
                if(selectedLevel){
                    var selectedLine = lines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    $(container).find("path[class*='line-hover']").attr({class:''});
                    $(container).find("g[class*='label-hover']").attr({class:''});
                    if(selectedLine){
                        selectedLine.addClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.addClass('label-hover');
                    }
                }
                event.stopPropagation();
            });

            $(fibonacciLabel.element).mouseleave( function (event) {
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                var lines = additionalDrawings.lines;
                var fibLabels = fibonacciDrawings.lines;
                if(selectedLevel){
                    var selectedLine = lines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    if(selectedLine){
                        selectedLine.removeClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.removeClass('label-hover');
                    }
                }
                event.stopPropagation();
            });
        })
};

infChart.fibRetracementsDrawing.prototype.onTrendLineColorChange = function (rgb, color, opacity, isPropertyChange){
    var self = this;
    self.annotation.update({
        shape: {
            params: {
                stroke: color,
                opacity: opacity
            }
        }
    });

    self.annotation.options.trendLineColor = color;
    self.annotation.options.trendLineOpacity = opacity;

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fibRetracementsDrawing.prototype.onTrendLineWidthChange =  function (strokeWidth, isPropertyChange) {
    var self = this;
    var strokeDashArray = infChart.drawingUtils.common.settings.getStrokeDashArray.call(self, self.annotation.options.trendLineStyle, strokeWidth);
    self.annotation.update({
        shape: {
            params: {
                'stroke-width': strokeWidth,
                'stroke-dasharray': strokeDashArray
            }
        }
    });

    self.annotation.options.trendLineWidth = strokeWidth;

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fibRetracementsDrawing.prototype.onTrendLineStyleChange = function (dashStyle, isPropertyChange) {
    var self = this;
    var strokeDashArray = infChart.drawingUtils.common.settings.getStrokeDashArray.call(self, dashStyle, self.annotation.options.trendLineWidth);

    self.annotation.update({
        shape: {
            params: {
                dashstyle: dashStyle,
                'stroke-dasharray': strokeDashArray
            }
        }
    });

    self.annotation.options.trendLineStyle = dashStyle;

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fibRetracementsDrawing.prototype.onTrendLineToggleShow = function(checked, isPropertyChange){
    var self = this,
        ann = self.annotation,
        options = ann.options;

    options.isTrendLineAlways = checked;
    if(checked){
        if(ann){
            ann.shape.show();
            self.resetDragSupporters();
        }
    }

    isPropertyChange && self.onPropertyChange();
    if (self.settingsPopup) {
        self.settingsPopup.data("infUndoRedo", false);
    }
};

window.infChart = window.infChart || {};

infChart.fibVerRetracementsDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
    this.fibLevels = [
        {
            id: 'level_0',
            value: 0.0,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#726a6f',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_1',
            value: 23.6,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#835974',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_2',
            value: 38.2,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#7b6171',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_3',
            value: 50,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f8bce2',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_4',
            value: 61.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f075c3',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_5',
            value: 78.6,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#eb40ab',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_6',
            value: 100,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#c71585',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_7',
            value: 127.2,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#800e56',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_8',
            value: 161.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#4b0832',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_9',
            value: 200,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#726a6f',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_10',
            value: 261.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#835974',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_11',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#7b6171',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_12',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f8bce2',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_13',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f075c3',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        }
    ];
    this.mainDrawingDragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {'type': 'mainDrawing'});
    this.additionalDrawingDragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {'type': 'additionalDrawing'});
};

infChart.fibVerRetracementsDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.fibVerRetracementsDrawing.prototype.additionalDrawingsFunction = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis];

    if (options.xValueEnd) {
        options.distance = options.xValueEndDataIndex - options.xValueDataIndex;
    } else {
        options.distance = 0;
    }
    options.adjustment = 0;
    self.createAdditionalDrawings();
};

infChart.fibVerRetracementsDrawing.prototype.applyAllToFibLines = function (enabled, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, isPropertyChange) {
    var self = this;
    var options = self.annotation.options;
    options.isSingleColor = enabled;
    if (enabled) {
        self.changeAllFibLines('fillColor', { fill: fillColor, opacity: fillOpacity }, false);
        self.changeAllFibLines('lineColor', lineColor, false);
        self.changeAllFibLines('lineWidth', parseInt(lineWidth, 10), false);
        self.changeAllFibLabels('fontColor', fontColor, false);
        self.changeAllFibLabels('fontSize', fontSize, false);
        self.changeAllFibLabels('fontWeight', fontWeight, false);
    } else {
        var fibLevels = options.fibLevels;
        for (i = 0; i < fibLevels.length; i++) {
            var fibLevel = fibLevels[i];
            var fibLevelId = fibLevel.id;
            var preFibOption = prevOptions[fibLevelId];
            self.changeFibLine(fibLevelId, 'fillColor', { fill: preFibOption.fillColor, opacity: fibLevel.fillOpacity }, true, false);
            self.changeFibLine(fibLevelId, 'lineColor', preFibOption.lineColor, true, false);
            self.changeFibLine(fibLevelId, 'lineWidth', parseInt(preFibOption.lineWidth, 10), true, false);
            self.changeFibLabel(fibLevelId, 'fontColor', preFibOption.fontColor, true, false);
            self.changeFibLabel(fibLevelId, 'fontSize', preFibOption.fontSize, true, false);
            self.changeFibLabel(fibLevelId, 'fontWeight', preFibOption.fontWeight, true, false);
        }
        self.additionalDrawingBackToDefault();
        var shape = self.shape;
        var drawingTheme = infChart.drawingUtils.common.getTheme()[shape];
    }

    if (isPropertyChange) {
        self.onPropertyChange();
    }
};

infChart.fibVerRetracementsDrawing.prototype.shapeBackToDefault = function (property, propertyValue) {
    var self = this;
    var options = self.annotation.options;
    switch (property) {
        case 'lineColor':
            options.shape.params['stroke'] = propertyValue;
            self.annotation.shape.attr({
                'stroke': propertyValue
            });
            break;
        case 'lineWidth':
            options.shape.params['stroke-width'] = propertyValue;
            self.annotation.shape.attr({
                'stroke-width': propertyValue
            });
            break;
    }
}

infChart.fibVerRetracementsDrawing.prototype.beforeDestroy = function () {
    this.destroyAdditionalDrawings();
};

infChart.fibVerRetracementsDrawing.prototype.bindSettingsEvents = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chartId = ann.chart.renderTo.id,
        shape = self.shape,
        stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chartId));

    var isPropertyChange = function () {
        self.annotation.options.enabledMyDefaultButton = true;
        var isPropertyChange = true;
        if (this.settingsPopup) {
            isPropertyChange = this.isSettingsPropertyChange();
        }
        return isPropertyChange;
    };

    var onTrendLineToggleShow = function (show) {
        self.onTrendLineToggleShow.call(self, show, isPropertyChange.call(self));
    };

    // var onClose = function () {
    //     infChart.drawingUtils.common.removeDrawing.call(self);
    // }

    /**
     * fib level line color change event
     * @param {object} rgb - color rgb
     * @param {string} lineColor - hash color
     */
    var onSingleLineColorChange = function (rgb, lineColor) {
        self.changeAllFibLines('lineColor', lineColor, isPropertyChange.call(self));
    }

    /**
     * change fibonacci drawing to single color or apply settings panle colors
     * @param {object} rgb color rgb
     * @param {string} value color hex
     * @param {number} opacity opacity
     * @param {boolean} isSingleColor is single color or not
     * @param {object} fibLevelColors fib level colors in settings panel
     */
    var onSingleFillColorChange = function (value, opacity) {
        self.changeAllFibLines('fillColor', { fill: value, opacity: opacity }, isPropertyChange.call(self));
    };

    /**
     * change fibonacci single line width change
     * @param {number} strokeWidth - strock size
     * @param {boolean} isSingleColor - is single color or not
     * @param {object} fibLevelWidths - fib level widths in settings panel
     */
    var onSingleLineWidthChange = function (strokeWidth) {
        self.changeAllFibLines('lineWidth', parseInt(strokeWidth, 10), isPropertyChange.call(self));
    };

    /**
     * single option change event
     * @param {string} fillColor - hex fill color
     * @param {number} fillOpacity - fill opacity
     * @param {string} lineColor - hex line color
     * @param {number} lineWidth - line width
     * @param {object} prevOptions - prev options object
     * @param {boolean} isSingleColor - is single color or not
     * @param {boolean} isPropertyChange - is property change or not
     */
    var onSingleOptionChange = function (fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, isSingleColor) {
        self.applyAllToFibLines(isSingleColor, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, isPropertyChange.call(self));
    }

    /**
     * on fill color change event
     * @param {object} rgb - color rgb
     * @param {string} value - color hex
     * @param {number} opacity - opacity 0 - 1
     * @param {string} fibLevelId - fib level id
     * @param {boolean} isPropertyChange - is property change
     */
    var onFibLevelFillColorChange = function (rgb, value, opacity, fibLevelId) {
        self.changeFibLine(fibLevelId, 'fillColor', { fill: value, opacity: opacity }, false, isPropertyChange.call(self));
    };

    /**
     * fib level line color change event
     * @param {object} rgb - color rgb
     * @param {string} value - hash color
     * @param {string} fibLevelId - fib level id
     * @param {boolean} isPropertyChange - is property change
     */
    var onFibLevelLineColorChange = function (rgb, value, fibLevelId) {
        self.changeFibLine(fibLevelId, 'lineColor', value, false, isPropertyChange.call(self));
    };

    /**
     * line width change event used for both single level and all level
     * @param {number} strokeWidth - stroke width
     * @param {string} fibLevelId - fib level id
     */
    var onFibLevelLineWidthChange = function (strokeWidth, fibLevelId) {
        self.changeFibLine(fibLevelId, 'lineWidth', parseInt(strokeWidth, 10), false, isPropertyChange.call(self));
    };

    var onFibLevelChange = function (checked, fibLevelId) {
        self.changeFibLine(fibLevelId, 'enabled', checked, false, isPropertyChange.call(self));
    };

    var onFibLvlValueChange = function (fibLevelId, value) {
        self.changeFibLine(fibLevelId, 'value', value, false, isPropertyChange.call(self));
    };

    var onFibModeChange = function (checked) {
        self.changeMode(checked, isPropertyChange.call(self));
    };

    var onFibSingleFontColorChange = function (rgb, value) {
        self.changeAllFibLabels('fontColor', value, isPropertyChange.call(self));
    };

    var onFibSingleFontSizeChange = function (fontSize) {
        self.changeAllFibLabels('fontSize', fontSize, isPropertyChange.call(self));
    };

    var onFibLevelFontColorChange = function (rgb, value, fibLevelId) {
        self.changeFibLabel(fibLevelId, 'fontColor', value, false, isPropertyChange.call(self));
    };

    var onFibLevelFontSizeChange = function (fontSize, fibLevelId) {
        self.changeFibLabel(fibLevelId, 'fontSize', fontSize, false, isPropertyChange.call(self));
    };

    var onFibLevelFontWeightChange = function (fibLevelId, value) {
        self.changeFibLabel(fibLevelId, 'fontWeight', value, false, isPropertyChange.call(self));
    };

    var onFibSingleFontWeightChange = function (value) {
        self.changeAllFibLabels('fontWeight', value, isPropertyChange.call(self));
    };

    var onFibApplyAllButtonClick = function (fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions) {
        infChart.drawingUtils.common.settings.onFibApplyAllButtonClick.call(self, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, true);
        self.annotation.options.enabledMyDefaultButton = true;
    };

    var onToggleSnapToHighLow = function (checked) { };

    var onSaveTemplate = function (templateName) {
        self.saveDrawingTemplate(templateName);
    };

    var onApplyTemplate = function (templateName) {
        self.applyDrawingTemplate(templateName);
    };

    var onDeleteTemplate = function (templateName) {
        self.deleteDrawingTemplate(templateName);
    };

    function onSetAsMyDefaultSettings() {
        infChart.drawingUtils.common.saveDrawingProperties.call(self);
        options.enabledMyDefaultButton = false;
    }

    function onResetToAppDefaultSettings() {
        self.updateSavedDrawingProperties(true);
    }

    function onResetToMyDefaultSettings() {
        self.resetToUserDefaultDrawingProperties();
    }

    function resetEnabledMyDefaultButton(chartId, shape, drawingId, value){
        infChart.drawingsManager.resetEnabledMyDefaultButton.call(self, chartId, shape, drawingId, value);
    }

    function getEnabledMyDefaultButton(){
        return self.annotation && self.annotation.options && self.annotation.options.enabledMyDefaultButton;
    }

    function onTrendLineColorChange(rgb, color, opacity) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onTrendLineColorChange.call(self, rgb, color,opacity, isPropertyChange);
    }

    function onTrendLineWidthChange(strokeWidth) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onTrendLineWidthChange.call(self, strokeWidth, isPropertyChange);
    }

    function onTrendLineStyleChange(dashStyle) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onTrendLineStyleChange.call(self, dashStyle, isPropertyChange);
    }

    var enabledMyDefaultButton = {};
    enabledMyDefaultButton.shape = shape;
    enabledMyDefaultButton.chartId = stockChart.id;
    enabledMyDefaultButton.drawingId = self.drawingId;
    enabledMyDefaultButton.resetEnabledMyDefaultButton = resetEnabledMyDefaultButton;
    enabledMyDefaultButton.getEnabledMyDefaultButton = getEnabledMyDefaultButton;

    var callBackFnFibSettings = {
        onSingleLineColorChange: onSingleLineColorChange,
        onSingleFillColorChange: onSingleFillColorChange,
        onSingleLineWidthChange: onSingleLineWidthChange,
        onSingleOptionChange: onSingleOptionChange,
        onFibLevelFillColorChange: onFibLevelFillColorChange,
        onFibLevelLineColorChange: onFibLevelLineColorChange,
        onFibLevelLineWidthChange: onFibLevelLineWidthChange,
        onToggleFibLevel: onFibLevelChange,
        onFibLvlValueChange: onFibLvlValueChange,
        onToggleFibMode: onFibModeChange,
        onSingleFontColorChange: onFibSingleFontColorChange,
        onFibLevelFontColorChange: onFibLevelFontColorChange,
        onSingleFontSizeChange: onFibSingleFontSizeChange,
        onFibLevelFontSizeChange: onFibLevelFontSizeChange,
        onFibLevelFontWeightChange: onFibLevelFontWeightChange,
        onFibSingleFontWeightChange: onFibSingleFontWeightChange,
        onToggleSnapToHighLow: onToggleSnapToHighLow,
        onSaveTemplate: onSaveTemplate,
        onApplyTemplate: onApplyTemplate,
        onDeleteTemplate: onDeleteTemplate,
        onFibApplyAllButtonClick: onFibApplyAllButtonClick,
        onSetAsMyDefaultSettings: onSetAsMyDefaultSettings,
        onResetToAppDefaultSettings: onResetToAppDefaultSettings,
        onResetToMyDefaultSettings: onResetToMyDefaultSettings,
        onTrendLineToggleShow: onTrendLineToggleShow,
        enabledMyDefaultButton: enabledMyDefaultButton,
        onTrendLineColorChange: onTrendLineColorChange,
        onTrendLineWidthChange:onTrendLineWidthChange,
        onTrendLineStyleChange: onTrendLineStyleChange
    }

    infChart.structureManager.drawingTools.bindFibSettings(self.settingsPopup, callBackFnFibSettings);
};

infChart.fibVerRetracementsDrawing.prototype.changeAdditionalDrawings = function (property, propertyValue) {
    var self = this;
    var additionalDrawingTypes = ['start', 'end', 'trend'];
    additionalDrawingTypes.forEach(function (type) {
        if (property == 'lineColor') {
            if (self.additionalDrawings.lines[type]) {
                self.additionalDrawings.lines[type].attr({
                    'stroke': propertyValue
                });
            }
        }
        if (property == 'lineWidth') {
            if (self.additionalDrawings.lines[type]) {
                self.additionalDrawings.lines[type].attr({
                    'stroke-width': propertyValue
                });
            }
        }
    });
    // additionalDrawingTypes.forEach(function (type) {
    //     if (property == 'lineColor') {
    //         if (self.additionalDrawings.labels[type]) {
    //             self.additionalDrawings.labels[type].css({
    //                 'color': propertyValue
    //             });
    //         }
    //     }
    // });
}

infChart.fibVerRetracementsDrawing.prototype.additionalDrawingBackToDefault = function () {
    var self = this;
    var additionalDrawingTypes = ['start', 'end', 'trend'];
    var shape = self.shape;
    var drawingTheme = infChart.drawingUtils.common.getTheme()[shape];
    additionalDrawingTypes.forEach(function (type) {
        if (self.additionalDrawings.lines[type]) {
            self.additionalDrawings.lines[type].attr({
                'stroke': '#959595',
                'stroke-width': 1
            });
        }
        if (self.additionalDrawings.labels[type]) {
            self.additionalDrawings.labels[type].attr({
                'font-color': '#959595',
                'font-size': 10
            }).css({
                'color': '#959595',
                'fontSize': 10 + 'px'
            });
        }
    });
    if (self.additionalDrawings.jointLine) {
        self.additionalDrawings.jointLine.attr({
            'stroke': '#959595',
            'stroke-width': 1
        });
    }
}

infChart.fibVerRetracementsDrawing.prototype.calculateLineStartPosition = function (fibLevel, isMain) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        yAxis = chart.yAxis[options.yAxis];

    var lineStartPosition;
    var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart);
    var chartInstance = infChart.manager.getChart(stockChartId);
    if (self.additionalDrawings.lines['start'].d == ["M 0 0 L 0 0"]) {
        if (options.jointLineValue) {
            if (chartInstance.isLog || chartInstance.isCompare) {
                var yValueDiff = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(this, options.jointLineValue)) - yAxis.toPixels(options.yValue);
            } else {
                var yValueDiff = yAxis.toPixels(options.jointLineValue) - yAxis.toPixels(options.yValue);
            }
            lineStartPosition = yValueDiff;
        } else {
            lineStartPosition = 0 - yAxis.toPixels(options.yValue);
            options.lineStartPosition = lineStartPosition;
            var value = yAxis.toValue(0);
            options.jointLineValue = infChart.drawingUtils.common.getBaseYValue.call(this, value);
        }
    } else if (isMain) {
        if (chartInstance.isLog || chartInstance.isCompare) {
            var yValueDiff = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(this, options.jointLineValue)) - yAxis.toPixels(options.yValue);
        } else {
            var yValueDiff = yAxis.toPixels(options.jointLineValue) - yAxis.toPixels(options.yValue);
        }
        lineStartPosition = yValueDiff;
        options.jointLineValue = infChart.drawingUtils.common.getBaseYValue.call(this, yAxis.toValue(lineStartPosition + yAxis.toPixels(options.yValue)));
    } else if (isMain !== undefined) {
        var yValueDiff = yAxis.toPixels(options.chartY) - yAxis.toPixels(options.yValue);
        lineStartPosition = yValueDiff;
        options.jointLineValue = infChart.drawingUtils.common.getBaseYValue.call(this, yAxis.toValue(lineStartPosition + yAxis.toPixels(options.yValue)));
    } else {
        if (chartInstance.isLog || chartInstance.isCompare) {
            var yValueDiff = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(this, options.jointLineValue)) - yAxis.toPixels(options.yValue);
        } else {
            var yValueDiff = yAxis.toPixels(options.jointLineValue) - yAxis.toPixels(options.yValue);
        }
        lineStartPosition = yValueDiff;
    }
    return lineStartPosition;
};

infChart.fibVerRetracementsDrawing.prototype.changeAllFibLines = function (property, propertyValue, isPropertyChange) {
    var self = this;
    var options = self.annotation.options;
    if (isPropertyChange) {
        options.isSingleColor = true;
    }
    var fibLevels = options.fibLevels;
    switch (property) {
        case 'lineColor':
            options.lineColor = propertyValue;
            options.jointLineColor = propertyValue;
            self.changeAdditionalDrawings(property, propertyValue);
            if (self.additionalDrawings.jointLine) {
                self.additionalDrawings.jointLine.attr({
                    'stroke': propertyValue
                });
            }
            break;
        case 'fillColor':
            options.fillColor = propertyValue.fill;
            options.opacity = propertyValue.opacity;
            break;
        case 'lineWidth':
            options.lineWidth = propertyValue;
            options.jointLineWidth = propertyValue;
            self.changeAdditionalDrawings(property, propertyValue);
            if (self.additionalDrawings.jointLine) {
                self.additionalDrawings.jointLine.attr({
                    'stroke-width': propertyValue
                });
            }
            break;
    }
    fibLevels.forEach(function (fibLevel) {
        self.changeFibLine(fibLevel.id, property, propertyValue, true, false);
    });

    if (isPropertyChange) {
        self.onPropertyChange();
    }
};

infChart.fibVerRetracementsDrawing.prototype.changeAllFibLabels = function (property, propertyValue, isPropertyChange) {
    var self = this;
    var options = self.annotation.options;
    if (isPropertyChange) {
        options.isSingleColor = true;
    }
    var fibLevels = options.fibLevels;
    switch (property) {
        case 'fontColor':
            options.fontColor = propertyValue;
            if (self.additionalDrawings && self.additionalDrawings.labels['start']) {
                self.additionalDrawings.labels['start'].attr({
                    'font-color': propertyValue
                }).css({
                    'color': propertyValue
                });
            }
            if (self.additionalDrawings && self.additionalDrawings.labels['end']) {
                self.additionalDrawings.labels['end'].attr({
                    'font-color': propertyValue
                }).css({
                    'color': propertyValue
                });
            }
            if (self.additionalDrawings && self.additionalDrawings.labels['trend']) {
                self.additionalDrawings.labels['trend'].attr({
                    'font-color': propertyValue
                }).css({
                    'color': propertyValue
                });
            }
            break;
        case 'fontSize':
            options.fontSize = propertyValue;
            if (self.additionalDrawings && self.additionalDrawings.labels['start']) {
                self.additionalDrawings.labels['start'].attr({
                    'font-size': propertyValue
                }).css({
                    'fontSize': propertyValue + 'px'
                });
            }
            if (self.additionalDrawings && self.additionalDrawings.labels['end']) {
                self.additionalDrawings.labels['end'].attr({
                    'font-size': propertyValue
                }).css({
                    'fontSize': propertyValue + 'px'
                });
            }
            if (self.additionalDrawings && self.additionalDrawings.labels['trend']) {
                self.additionalDrawings.labels['trend'].attr({
                    'font-size': propertyValue
                }).css({
                    'fontSize': propertyValue + 'px'
                });
            }
            break;
        case 'fontWeight':
            options.fontWeight = propertyValue;
            if (self.additionalDrawings && self.additionalDrawings.labels['start']) {
                self.additionalDrawings.labels['start'].attr({
                    'font-weight': propertyValue
                }).css({
                    'font-weight': propertyValue
                });
            }
            if (self.additionalDrawings && self.additionalDrawings.labels['end']) {
                self.additionalDrawings.labels['end'].attr({
                    'font-weight': propertyValue
                }).css({
                    'font-weight': propertyValue
                });
            }
            if (self.additionalDrawings && self.additionalDrawings.labels['trend']) {
                self.additionalDrawings.labels['trend'].attr({
                    'font-weight': propertyValue
                }).css({
                    'font-weight': propertyValue
                });
            }
            break;
        default:
            break;
    }
    fibLevels.forEach(function (fibLevel) {
        self.changeFibLabel(fibLevel.id, property, propertyValue, true, false);
    });
    if (isPropertyChange) {
        self.onPropertyChange();
    }
};

infChart.fibVerRetracementsDrawing.prototype.changeFibLine = function (level, property, propertyValue, isAll, isPropertyChange, ignoreSettingsSave) {
    var self = this;
    var options = this.annotation.options;
    var fibLevels, fibLevel, fibIndex = -1;
    if (!isAll) {
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels);
        for (var i = 0; i < fibLevels.length; i++) {
            if (level === fibLevels[i].id) {
                fibLevel = fibLevels[i];
                fibIndex = i;
                break;
            }
        }
    }

    var additionalDrawings = this.additionalDrawings;
    switch (property) {
        case 'enabled':
            if (propertyValue) {
                additionalDrawings.lines[level].show();
                additionalDrawings.labels[level].show();
                if (!options.isShort) {
                    additionalDrawings.fill[level].show();
                }
            } else {
                additionalDrawings.lines[level].hide();
                additionalDrawings.labels[level].hide();
                if (!options.isShort) {
                    additionalDrawings.fill[level].hide();
                }
            }
            fibLevel.enable = propertyValue;
            var isFirstLevelDisabled = true, k = fibIndex;
            for (k; k >= 0; k--) {
                if (fibLevels[k].enable) {
                    isFirstLevelDisabled = false;
                    break;
                }
            }
            var currentFibIndex = fibIndex;
            if (isFirstLevelDisabled) {
                for (currentFibIndex; currentFibIndex < fibLevels.length; currentFibIndex++) {
                    if (fibLevels[currentFibIndex].enable) {
                        break;
                    }
                }
                if (options.isShort) {
                    this.updateJointLine(parseFloat(this.additionalDrawings.lines[fibLevels[fibIndex].id].d.split(' ')[4]), fibIndex, fibLevels);
                }
            } else {
                if (options.isShort) {
                    this.updateJointLine(parseFloat(this.additionalDrawings.lines[fibLevels[k].id].d.split(' ')[4]), k, fibLevels);
                } else {
                    this.updateFill(fibLevels[k], k, fibLevels);
                }
            }
            break;
        case 'value':
            fibLevel.value = propertyValue;
            var x = this.updateFibLevel(fibLevel, fibIndex, fibLevels, this.annotation.options.distance, false, true);
            this.updateJointLine(x, fibIndex, fibLevels);
            break;
        case 'lineColor':
            additionalDrawings.lines[level].attr({
                'stroke': propertyValue
            });
            if (!isAll) {
                fibLevel.lineColor = propertyValue;
            }
            break;
        case 'fillColor':
            if (!options.isShort) {
                additionalDrawings.fill[level].attr({
                    'fill': propertyValue.fill,
                    'fill-opacity': propertyValue.opacity
                });
            } else {
                if (propertyValue.opacity === 0) {
                    propertyValue.fill = this.annotation.options.shape.params.fill;
                }
            }
            if (!isAll) {
                fibLevel.fillColor = propertyValue.fill;
                fibLevel.fillOpacity = propertyValue.opacity;
            }
            break;
        case 'lineWidth':
            additionalDrawings.lines[level].attr({
                'stroke-width': propertyValue
            });
            if (!isAll) {
                fibLevel.lineWidth = propertyValue;
            }
            break;
    }

    if (isPropertyChange) {
        this.onPropertyChange();
    }
};

infChart.fibVerRetracementsDrawing.prototype.changeFibLabel = function (level, property, propertyValue, isAll, isPropertyChange) {
    var self = this;
    var options = this.annotation.options;
    var fibLevels, fibLevel;
    if (!isAll) {
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels);
        for (var i = 0; i < fibLevels.length; i++) {
            if (level === fibLevels[i].id) {
                fibLevel = fibLevels[i];
                break;
            }
        }
    }

    var additionalDrawings = this.additionalDrawings;
    switch (property) {
        case 'fontColor':
            if (options.isShort) {
                additionalDrawings.labels[level].attr({
                    'font-color': propertyValue
                }).css({
                    'color': propertyValue
                });
                if (!isAll) {
                    fibLevel.fontColor = propertyValue;
                }
            }
            break;
        case 'fontSize':
            if (options.isShort) {
                additionalDrawings.labels[level].attr({
                    'font-size': propertyValue
                }).css({
                    'fontSize': propertyValue + 'px'
                });
                if (!isAll) {
                    fibLevel.fontSize = propertyValue;
                }
            }
            break;
        case 'fontWeight':
            if (options.isShort) {
                additionalDrawings.labels[level].attr({
                    'font-size': propertyValue
                }).css({
                    'font-weight': propertyValue
                });
                if (!isAll) {
                    fibLevel.fontWeight = propertyValue;
                }
            }
            break;
        default:
            break;

    }
    if (isPropertyChange) {
        self.onPropertyChange();
    }
};

infChart.fibVerRetracementsDrawing.prototype.changeMode = function (enabled, isPropertyChange) {
    var self = this;
    var ann = self.annotation, options = ann.options;
    self.beforeDestroy();
    options.isShort = enabled;
    self.additionalDrawingsFunction();
    self.scale();
    self.updateSettings(self.getConfig());

    if (isPropertyChange) {
        self.onPropertyChange();
    }
};

infChart.fibVerRetracementsDrawing.prototype.createAdditionalDrawings = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        dx = options.distance,
        adjustment = options.adjustment,
        fibLevels = options.fibLevels,
        shapeParams = options.shape.params,
        theme = infChart.drawingUtils.common.getTheme.call(this),
        baseFillOpacity = (theme.fibVerRetracements && typeof theme.fibVerRetracements.fillOpacity !== "undefined") ? theme.fibVerRetracements.fillOpacity : infChart.drawingUtils.common.baseFillOpacity,
        baseFontColor = (theme.fibVerRetracements && typeof theme.fibVerRetracements.fontColor !== "undefined") ? theme.fibVerRetracements.fontColor : infChart.drawingUtils.common.baseFontColor,
        baseFontSize = (theme.fibVerRetracements && typeof theme.fibVerRetracements.fontSize !== "undefined") ? theme.fibVerRetracements.fontSize : infChart.drawingUtils.common.baseFontSize,
        baseFontWeight = (theme.fibVerRetracements && typeof theme.fibVerRetracements.fontWeight !== "undefined") ? theme.fibVerRetracements.fontWeight : infChart.drawingUtils.common.baseFontWeight;

    self.additionalDrawings = {
        labels: {},
        lines: {},
        fill: {}
    };

    var drawingFillAttr = {
        'stroke-width': 0,
        'z-index': 2,
        cursor: 'default',
        color: shapeParams.stroke,
        'pointer-events': 'none'
    };
    var drawingAttr = {
        'z-index': 2,
        'stroke-width': shapeParams['stroke-width'],
        fill: shapeParams.fill,
        cursor: 'move',
        stroke: shapeParams.stroke
    };
    var labelCssAttr = {
        fontSize: baseFontSize + 'px',
        color: baseFontColor,
        'font-weight': baseFontWeight
    };
    var labelAttr = {
        'font-color': baseFontColor,
        'font-size': baseFontSize,
        'font-weight': baseFontWeight,
        'type': 'additionalDrawing',
        cursor: 'move'
    };

    var dateLabelAttr = Object.assign({}, labelAttr);
    var dateLabelCssAttr = Object.assign({}, labelCssAttr);
    var dateDrawingAttr = Object.assign({}, drawingAttr);

    // add fill objects first to avoid overlapping lines with and texts with them
    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);

    var isStartEnabled = false, isEndEnabled = false;
    fibLevels.forEach(function (fibLevel) {
        var distanceMultiplier = parseFloat(fibLevel.value) / 100;
        var x = adjustment + (dx > 0 ? dx : -dx) * distanceMultiplier;
        var themeFillColor = theme.fibVerRetracements && theme.fibVerRetracements.fibLevelFillColors && theme.fibVerRetracements.fibLevelFillColors[fibLevel.id];
        var lineWidth = options.isSingleColor ? options.lineWidth : (fibLevel.lineWidth ? fibLevel.lineWidth : shapeParams['stroke-width']);
        var lineColor = options.isSingleColor ? options.lineColor : (fibLevel.lineColor ? fibLevel.lineColor : shapeParams.stroke);
        var opacity = options.isSingleColor ? options.opacity : (fibLevel.fillOpacity ? fibLevel.fillOpacity : baseFillOpacity);
        var fontColor = options.isSingleColor ? options.fontColor : (fibLevel.fontColor ? fibLevel.fontColor : baseFontColor);
        var fontSize = options.isSingleColor ? options.fontSize : (fibLevel.fontSize ? fibLevel.fontSize : baseFontSize);
        var fontWeight = options.isSingleColor ? options.fontWeight : (fibLevel.fontWeight ? fibLevel.fontWeight : baseFontWeight);

        drawingFillAttr.fill = options.isSingleColor ? options.fillColor : (fibLevel.fillColor ? fibLevel.fillColor : themeFillColor);
        drawingFillAttr['fill-opacity'] = opacity;
        drawingFillAttr.stroke = lineColor;
        drawingFillAttr.level = fibLevel.id;

        drawingAttr['stroke-width'] = parseInt(lineWidth, 10);
        drawingAttr.stroke = lineColor;
        drawingAttr.level = fibLevel.id;

        labelCssAttr.color = fontColor;
        labelCssAttr.fontSize = fontSize + 'px';
        labelCssAttr['font-weight'] = fontWeight;

        labelAttr['level'] = fibLevel.id;
        labelAttr['font-color'] = fontColor;
        labelAttr['font-size'] = fontSize;
        labelCssAttr['font-weight'] = fontWeight;

        var labelValue = self.getLineLabelText(x, fibLevel);
        if (!options.isShort) {
            self.additionalDrawings.fill[fibLevel.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0]).attr(drawingFillAttr).add(ann.group);
        }
        self.additionalDrawings.lines[fibLevel.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingAttr).add(ann.group);
        self.additionalDrawings.labels[fibLevel.id] = chart.renderer.label(labelValue, fibLevel.drawingPosX, fibLevel.drawingPosY).css(labelCssAttr).attr(labelAttr).add(ann.group);
        if (!fibLevel.enable) {
            self.additionalDrawings.lines[fibLevel.id].hide();
            self.additionalDrawings.labels[fibLevel.id].hide();
            if (!options.isShort) {
                self.additionalDrawings.fill[fibLevel.id].hide();
            }
        } else {
            if (fibLevel.value === 0) {
                isStartEnabled = true;
            }
            if (fibLevel.value === 100) {
                isEndEnabled = true;
            }
        }
    });

    if (options.isSingleColor) {
        dateLabelAttr = labelAttr;
        dateLabelCssAttr = labelCssAttr;
        dateDrawingAttr = drawingAttr;
        delete dateDrawingAttr['level'];
        delete dateLabelAttr['level'];
    }

    dateDrawingAttr['stroke-width'] = options.jointLineWidth;
    dateDrawingAttr.stroke = options.jointLineColor

    if (options.isShort) {
        var startValue = self.formatDate(options.nearestXValue, self.stockChart.interval);
        self.additionalDrawings.lines['start'] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(dateDrawingAttr).add(ann.group);
        self.additionalDrawings.labels['start'] = chart.renderer.label(startValue).css(dateLabelCssAttr).attr(dateLabelAttr).add(ann.group);
        if (!options.trendXValue && isStartEnabled) {
            self.additionalDrawings.lines['start'].hide();
            self.additionalDrawings.labels['start'].hide();
        }

        var endValue = self.formatDate(options.nearestXValueEnd, self.stockChart.interval);
        self.additionalDrawings.lines['end'] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(dateDrawingAttr).add(ann.group);
        self.additionalDrawings.labels['end'] = chart.renderer.label(endValue).css(dateLabelCssAttr).attr(dateLabelAttr).add(ann.group);
        if (!options.trendXValue && isEndEnabled) {
            self.additionalDrawings.lines['end'].hide();
            self.additionalDrawings.labels['end'].hide();
        }

        var jointLineWidth = options.isSingleColor ? options.lineWidth : options.jointLineWidth;
        var jointLineColor = options.isSingleColor ? options.lineColor : options.jointLineColor;

        self.additionalDrawings.jointLine = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr({
            'stroke-width': jointLineWidth,
            fill: ann.options.shape.params.fill,
            stroke: jointLineColor,
            'z-index': 2,
            cursor: 'move'
        }).add(ann.group);

        //options.shape.params['stroke'] = jointLineColor;
        //options.shape.params['stroke-width'] = jointLineWidth;
    }
};

infChart.fibVerRetracementsDrawing.prototype.deselect = function (isMouseOut) {
    var self = this;
    var options = self.annotation.options;
    infChart.drawingUtils.common.onDeselect.call(this);
    if (isMouseOut) {
        if(this.annotation.options && !this.annotation.options.isTrendLineAlways){
            this.annotation.shape.hide();
            self.setDragSupporters();
        }
    }
};

infChart.fibVerRetracementsDrawing.prototype.destroyAdditionalDrawings = function () {
    var self = this;
    var options = self.annotation.options;
    var fibLevels = options.fibLevels;
    fibLevels.forEach(function (fibLevel) {
        self.additionalDrawings.labels[fibLevel.id].destroy();
        self.additionalDrawings.lines[fibLevel.id].destroy();
        if (self.additionalDrawings.fill[fibLevel.id]) {
            self.additionalDrawings.fill[fibLevel.id].destroy();
        }
    });
    if (self.additionalDrawings.jointLine) {
        self.additionalDrawings.jointLine.destroy();
    }
    if (self.additionalDrawings.labels['start']) {
        self.additionalDrawings.labels['start'].destroy();
        self.additionalDrawings.lines['start'].destroy();
    }
    if (self.additionalDrawings.labels['end']) {
        self.additionalDrawings.labels['end'].destroy();
        self.additionalDrawings.lines['end'].destroy();
    }
};

infChart.fibVerRetracementsDrawing.prototype.formatDate = function (timeInMillis, chartInterval) {
    var _getMonth = function (val) {
        var shortFormat = "";
        switch (val) {
            case 1:
                shortFormat = "Ja";
                break;
            case 2:
                shortFormat = "Fb";
                break;
            case 3:
                shortFormat = "Ma";
                break;
            case 4:
                shortFormat = "Ap";
                break;
            case 5:
                shortFormat = "My";
                break;
            case 6:
                shortFormat = "Jn";
                break;
            case 7:
                shortFormat = "Jl";
                break;
            case 8:
                shortFormat = "Au";
                break;
            case 9:
                shortFormat = "Se";
                break;
            case 10:
                shortFormat = "Oc";
                break;
            case 11:
                shortFormat = "Nv";
                break;
            case 12:
                shortFormat = "Dc";
                break;
        }
        return shortFormat;
    };

    var _replaceMonth = function (val) {
        var parts = val.split(".");
        if (parts.length > 2) {
            val = val.replace("." + parts[1] + ".", _getMonth(parseInt(parts[1], 10)));
        } else if (parts.length > 1) {
            val = val.replace(parts[1] + ".", _getMonth(parseInt(parts[1], 10)));
        }
        return val;
    };

    var format;
    switch (chartInterval) {
        case 'T':
            format = '%d.%m.%y %H:%M:%S';
            break;
        case 'M':
            format = '%b.%y';
            break;
        case 'Y':
            format = '%y';
            break;
        case 'D':
        case 'W':
            format = '%d.%m.%y';
            break;
        default:
            format = '%d.%m.%y %H:%M';
            break;

    }
    return _replaceMonth(infChart.util.formatDate(timeInMillis, format));
};

infChart.fibVerRetracementsDrawing.prototype.getConfig = function () {
    var self = this,
        options = self.annotation.options,
        fibLevels = options.fibLevels;
    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels);
    return {
        shape: 'fibVerRetracements',
        fibLevels: fibLevels,
        lineColor: options.lineColor,
        fillColor: options.fillColor,
        opacity: options.opacity,
        lineWidth: options.lineWidth,
        fontColor: options.fontColor,
        fontSize: options.fontSize,
        fontWeight: options.fontWeight,
        xValue: options.xValue,
        xValueDataIndex: options.xValueDataIndex,
        yValue: options.yValue,
        xValueEnd: options.xValueEnd,
        xValueEndDataIndex: options.xValueEndDataIndex,
        yValueEnd: options.yValueEnd,
        isSingleColor: options.isSingleColor,
        isShort: options.isShort,
        borderColor: options.lineColor, //Todo : refactor this check getOptions method
        jointLineValue: options.jointLineValue,
        isTrendLineAlways: options.isTrendLineAlways,
        trendLineColor: options.trendLineColor,
        trendLineOpacity: options.trendLineOpacity,
        trendLineWidth: options.trendLineWidth,
        trendLineStyle: options.trendLineStyle,
        jointLineColor: options.jointLineColor,
        jointLineWidth: options.jointLineWidth,
        isLocked : options.isLocked

    };
};

infChart.fibVerRetracementsDrawing.prototype.getContextMenuOptions = function (chartId, drawingId, options, event) {
    var self = this;
    var level = event.target.getAttribute('level');
    if (!level && event.target.parentElement) {
        if (event.target.parentElement && event.target.parentElement.getAttribute('level')) {
            level = event.target.parentElement.getAttribute('level');
        } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
            level = event.target.parentElement.parentElement.getAttribute('level');
        }
    }

    var contextMenu = {
        "copyToClipboard": {
            icon: options.copyToClipboard.icon,
            displayText: options.copyToClipboard.displayText,
            action: function () {
                if (level) {
                    infChart.drawingUtils.common.onFibLevelCopy.call(self, level);
                }
            }
        },
        "eraseThis": {
            icon: options.erase.icon,
            displayText: options.erase.displayText,
            action: function () {
                if (level) {
                    self.eraseFibLevel(level, false, true, true);
                }
            }
        }
    };

    if (level) {
        contextMenu = Object.assign(contextMenu, infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options));
        return infChart.drawingUtils.common.reorderContextMenu(contextMenu);
    } else {
        return infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options)
    }
};

infChart.fibVerRetracementsDrawing.prototype.eraseFibLevel = function (level, checked, isPropertyChange, ignoreSettingsSave) {
    var self = this;
    self.additionalDrawings.lines[level].hide();
    self.additionalDrawings.labels[level].hide();
    if (self.additionalDrawings.fill[level]) {
        self.additionalDrawings.fill[level].hide();
    }
    var propeties = self.getConfig();

    propeties.fibLevels.forEach(function (fibLevel) {
        if (fibLevel.id === level) {
            fibLevel.enable = false;
        }
    });
    if (!self.isEndLevelEnabled()) {
        self.additionalDrawings.lines['end'].show();
        self.additionalDrawings.labels['end'].show();
    }
    if (!self.isStartLevelEnabled()) {
        self.additionalDrawings.lines['start'].show();
        self.additionalDrawings.labels['start'].show();
    }
    self.changeFibLine(level, 'enabled', checked, false, false, ignoreSettingsSave);
};

infChart.fibVerRetracementsDrawing.prototype.getCurrentPropertyValue = function (level, property, isAll) {
    var options = this.annotation.options;
    var fibLevel;
    if (!isAll) {
        var fibLevels = options.fibLevels;
        fibLevel = fibLevels.find(function (fibLevel) {
            return fibLevel.id === level;
        });
    }
    var propertyValue;
    if (fibLevel || (isAll && property !== 'enabled' && property !== 'value')) {
        switch (property) {
            case 'enabled':
                propertyValue = fibLevel.enable;
                break;
            case 'value':
                propertyValue = fibLevel.value;
                break;
            case 'lineColor':
                propertyValue = isAll ? options.lineColor : fibLevel.lineColor;
                break;
            case 'fillColor':
                propertyValue = {
                    fill: isAll ? options.fillColor : fibLevel.fillColor,
                    opacity: isAll ? options.opacity : fibLevel.fillOpacity
                }
                break;
            case 'lineWidth':
            case 'fontSize':
                propertyValue = isAll ? parseInt(options[property], 10) : parseInt(fibLevel[property], 10);
                break;
            default:
                propertyValue = isAll ? options[property] : fibLevel[property];
                break;
        }
    }
    return propertyValue;
};

infChart.fibVerRetracementsDrawing.prototype.getLineLabelText = function (x, fibLevel) {
    var self = this;
    var options = self.annotation.options;
    var chart = self.annotation.chart;
    var xAxis = chart.xAxis[options.xAxis];
    var labelValue;
    var fibLevelValue = infChart.drawingUtils.common.formatValue(fibLevel.value / 100, 3);
    if (options.isShort) {
        var time = xAxis.toValue(x + xAxis.toPixels(options.xValue));
        labelValue = self.formatDate(time, self.stockChart.interval) + '<br/>' + fibLevelValue;
    } else {
        labelValue = fibLevelValue;
    }
    return labelValue;
};

infChart.fibVerRetracementsDrawing.prototype.getOptions = function (properties, chart) {
    var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, properties.xValue, undefined, true, true);
    var options = {
        xValue: properties.xValue,
        nearestXValue: nearestDataForXValue.xData,
        xValueDataIndex: properties.xValueDataIndex,
        yValue: properties.yValue,
        allowDragX: false,
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0]
            }
        }
    };
    var theme = infChart.drawingUtils.common.getTheme.call(this);
    var shapeTheme = theme["fibVerRetracements"];
    var baseFillColor = (theme.fibVerRetracements && theme.fibVerRetracements.singleFillColor) ? theme.fibVerRetracements.singleFillColor : (theme.fibonacci && theme.fibonacci.singleFillColor) ? theme.fibonacci.singleFillColor : infChart.drawingUtils.common.baseFillColor;
    var baseFillOpacity = (theme.fibVerRetracements && typeof theme.fibVerRetracements.fillOpacity !== "undefined") ? theme.fibVerRetracements.fillOpacity : (theme.fibonacci && typeof theme.fibonacci.fillOpacity !== "undefined") ? theme.fibonacci.fillOpacity : infChart.drawingUtils.common.baseFillOpacity;
    var baseBorderColor = (theme.fibVerRetracements && theme.fibVerRetracements.borderColor) ? theme.fibVerRetracements.borderColor : (theme.fibonacci && theme.fibonacci.borderColor) ? theme.fibonacci.borderColor : infChart.drawingUtils.common.baseBorderColor;
    var baseLineWidth = (theme.fibVerRetracements && typeof theme.fibVerRetracements.lineWidth !== "undefined") ? theme.fibVerRetracements.lineWidth : (theme.fibonacci && theme.fibonacci.lineWidth) ? theme.fibonacci.lineWidth : infChart.drawingUtils.common.baseLineWidth;
    var baseFontColor = (theme.fibVerRetracements && theme.fibVerRetracements.fontColor) ? theme.fibVerRetracements.fontColor : (theme.fibonacci && theme.fibonacci.fontColor) ? theme.fibonacci.fontColor : infChart.drawingUtils.common.baseFontColor;
    var baseFontSize = (theme.fibVerRetracements && theme.fibVerRetracements.fontSize) ? theme.fibVerRetracements.fontSize : (theme.fibonacci && theme.fibonacci.fontSize) ? theme.fibonacci.fontSize : infChart.drawingUtils.common.baseFontSize;
    var baseFontWeight = (theme.fibVerRetracements && theme.fibVerRetracements.fontWeight) ? theme.fibVerRetracements.fontWeight : (theme.fibonacci && theme.fibonacci.fontWeight) ? theme.fibonacci.fontWeight : infChart.drawingUtils.common.baseFontWeight;

    options.trendLineColor = properties.trendLineColor ? properties.trendLineColor : shapeTheme.stroke || "#959595";
    options.trendLineOpacity = properties.trendLineOpacity ? properties.trendLineOpacity : shapeTheme.opacity || 1;
    options.trendLineWidth = properties.trendLineWidth ? properties.trendLineWidth : baseLineWidth || 1;
    options.trendLineStyle = properties.trendLineStyle ? properties.trendLineStyle : shapeTheme.dashstyle || 'solid';

    options.fillColor = properties.fillColor ? properties.fillColor : baseFillColor;
    options.opacity = properties.fillOpacity ? properties.fillOpacity : baseFillOpacity;
    options.lineColor = properties.borderColor ? properties.borderColor : baseBorderColor;
    options.lineWidth = properties.strokeWidth ? properties.strokeWidth : properties.lineWidth ? properties.lineWidth : baseLineWidth;
    options.fontColor = properties.fontColor ? properties.fontColor : baseFontColor;
    options.fontSize = properties.fontSize ? properties.fontSize : baseFontSize;
    options.fontWeight = properties.fontWeight ? properties.fontWeight : baseFontWeight;

    if (properties.xValueEnd && properties.yValueEnd) {
        var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, properties.xValueEnd, undefined, true, true);
        options.xValueEnd = properties.xValueEnd;
        options.xValueEndDataIndex = properties.xValueEndDataIndex;
        options.yValueEnd = properties.yValueEnd;
        options.nearestXValueEnd = nearestDataForXValueEnd.xData;
    }
    if (properties.isSingleColor) {
        options.isSingleColor = properties.isSingleColor;
    }
    options.fibLevels = properties.fibLevels ? properties.fibLevels : this.fibLevels;
    options.fibLevels = infChart.drawingUtils.common.getFibLevelsWithOpacity(infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels), baseFillOpacity);
    options.showFibModeToggle = true;
    options.showTrendLineAlwaysToggle = true;
    options.isShort = typeof properties.isShort !== "undefined" ? properties.isShort : true;
    options.isTrendLineAlways = typeof properties.isTrendLineAlways !== "undefined" ? properties.isTrendLineAlways : true;
    options.isRealTimeTranslation = options.isShort;
    options.useAllXDataToFindNearestPoint = true;
    options.useFutureDate = true;
    options.jointLineValue = properties.jointLineValue;

    options.shape.params['stroke'] = options.trendLineColor;
    options.shape.params.opacity =  options.trendLineOpacity;
    options.shape.params['stroke-width'] = options.trendLineWidth;
    options.shape.params.dashstyle = options.trendLineStyle;
    if (properties.jointLineColor){
        options.jointLineColor = properties.jointLineColor;
    } else {
        options.jointLineColor = "#959595";
    }
    if (properties.jointLineWidth){
        options.jointLineWidth = properties.jointLineWidth;
    } else {
        options.jointLineWidth = 1;
    }

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.fibVerRetracementsDrawing.prototype.getQuickSettingsPopup = function () {
    var self = this;
    var options = self.annotation.options;
    var fillOpacity = (Object.hasOwnProperty(options, 'fillOpacity')) ? options.fillOpacity : (Object.hasOwnProperty(options, 'opacity')) ? options.opacity : 0;
    return infChart.drawingUtils.common.getFibQuickSettings(options.fillColor, fillOpacity, options.lineColor, options.fontColor, options.fontSize);
};

infChart.fibVerRetracementsDrawing.prototype.getSettingsPopup = function () {
    var self = this;
    var options = self.annotation.options;
    var userDefaultSettings = self.getUserDefaultSettings();
    var templates = self.getDrawingTemplates();

    var properties = {
        fillColor: options.fillColor,
        fillOpacity: options.opacity,
        lineColor: options.lineColor,
        lineWidth: options.lineWidth,
        fontColor: options.fontColor,
        fontSize: options.fontSize,
        fontWeight: options.fontWeight,
        fibLevels: options.fibLevels,
        showFibModeToggle: false,
        showSnapToHighLowToggle: false,
        templates: templates,
        userDefaultSettings: userDefaultSettings,
        showTrendLineAlwaysToggle: options.showTrendLineAlwaysToggle,
        trendLineColor: options.trendLineColor,
        trendLineOpacity: options.trendLineOpacity,
        trendLineWidth: options.trendLineWidth,
        trendLineStyle: options.trendLineStyle
    }
    return infChart.drawingUtils.common.getFibSettings(properties);
};

infChart.fibVerRetracementsDrawing.prototype.isEndLevelEnabled = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        fibLevels = options.fibLevels;

    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);
    var isEndEnabled = false;
    fibLevels.forEach(function (fibLevel) {
        if (fibLevel.enable && fibLevel.value === 100) {
            isEndEnabled = true;
        }
    });
    return isEndEnabled;
};

infChart.fibVerRetracementsDrawing.prototype.isStartLevelEnabled = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        fibLevels = options.fibLevels;

    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);
    var isStartEnabled = false;
    fibLevels.forEach(function (fibLevel) {
        if (fibLevel.enable && fibLevel.value === 0) {
            isStartEnabled = true;
        }
    });
    return isStartEnabled;
};

infChart.fibVerRetracementsDrawing.prototype.scale = function (isCalculateNewValueForScale) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        line = ann.shape.d.split(' '),
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];

    if (isCalculateNewValueForScale) {
        nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
        nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
        options.nearestXValue = nearestDataForXValue.xData;
        options.nearestXValueEnd = nearestDataForXValueEnd.xData;
    }

    var newX = xAxis.toPixels(options.nearestXValue) - xAxis.toPixels(options.xValue),
        xEnd = xAxis.toPixels(options.nearestXValueEnd) - xAxis.toPixels(options.xValue),
        yEnd = yAxis.toPixels(options.yValueEnd) - yAxis.toPixels(options.yValue);

    line[1] = (!isNaN(newX) && newX) || 0;
    line[4] = (!isNaN(xEnd) && xEnd) || 0;
    line[5] = (!isNaN(yEnd) && yEnd) || 0;

    if (isCalculateNewValueForScale) {
        ann.update({
            xValueDataIndex: nearestDataForXValue.dataIndex,
            xValueEndDataIndex: nearestDataForXValueEnd.dataIndex,
            shape: {
                params: {
                    d: line,
                },
            },
        });
        ann.options.distance = nearestDataForXValueEnd.dataIndex- nearestDataForXValue.dataIndex;
    } else {
        ann.update({
            shape: {
                params: {
                    d: line,
                },
            },
        });
    }

    if (ann.selectionMarker && ann.selectionMarker.length > 1) {
        ann.selectionMarker[1].attr({
            x: line[4],
            y: line[5]
        });
    }

    self.updateAdditionalDrawings(false);
    self.setDragSupporters();
};

infChart.fibVerRetracementsDrawing.prototype.select = function (event) {
    var self = this,
        ann = self.annotation,
        options = ann.options;

    if (event && event.target) {
        var drawingtype = event.target.getAttribute('type');
        if (drawingtype) {
            if (drawingtype == "mainDrawing") {
                options.selectedDrawing = "mainDrawing";
            }
            if (drawingtype == "additionalDrawing") {
                options.selectedDrawing = "additionalDrawing";
            }
        } else if (event.target.parentNode.getAttribute('type')) {
            //this used when clicked on levels of start, end, trend
            var drawingtype = event.target.parentNode.getAttribute('type');
            if (drawingtype == "additionalDrawing") {
                options.selectedDrawing = "additionalDrawing";
            }
        } else {
            //this used when clicked on fibbonacci levels
            if (event.target.parentNode.parentNode.getAttribute('type')) {
                var drawingtype = event.target.parentNode.parentNode.getAttribute('type');
                if (drawingtype == "additionalDrawing") {
                    options.selectedDrawing = "additionalDrawing";
                }
            }
        }
    }
};

infChart.fibVerRetracementsDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        pathDefinition, width, height;

    ann.events.deselect.call(ann);
    ann.shape.show();
    ann.selectionMarker = [];
    pathDefinition = ann.shape.d.split(' ');
    width = parseFloat(pathDefinition[4]);
    height = parseFloat(pathDefinition[5]);
    newX = xAxis.toPixels(options.nearestXValue) - xAxis.toPixels(options.xValue);

    if (!isNaN(width) && !isNaN(height)) {
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, newX, 0, this.stepFunction, this.stop, true);
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, width, height, this.stepFunction, this.stop, false);
    }
};

infChart.fibVerRetracementsDrawing.prototype.setDragSupporters = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        line = ann.shape.d.split(' ');
    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    if (ann.shape.visibility !== "hidden") {
        infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, line, self.dragSupporters, undefined, self.mainDrawingDragSupporterStyles);
    }
    if (options.isShort) {
        infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, self.additionalDrawings.jointLine.d.split(' '), self.dragSupporters, undefined, self.additionalDrawingDragSupporterStyles);
    }
    self.highlightEachLine();
};

infChart.fibVerRetracementsDrawing.prototype.step = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        points = infChart.drawingUtils.common.calculateInitialPoints(e, ann, isStartPoint, 0, 0),
        xValueEnd = xAxis.toValue(xAxis.toPixels(options.xValue) + points.dx),
        yValueEnd = yAxis.toValue(yAxis.toPixels(options.yValue) + points.dy),
        nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate),
        nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, xValueEnd, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate),
        nearestXValue = nearestDataForXValue.xData,
        nearestXValueEnd = nearestDataForXValueEnd.xData,
        newX = xAxis.toPixels(nearestXValue) - xAxis.toPixels(ann.options.xValue),
        newXEnd = xAxis.toPixels(nearestXValueEnd) - xAxis.toPixels(ann.options.xValue);

    y = points.dy;
    var line = ["M", newX, 0, 'L', newXEnd, y];

    ann.update({
        xValueDataIndex: nearestDataForXValue.dataIndex,
        xValueEndDataIndex: nearestDataForXValueEnd.dataIndex,
        nearestXValue: nearestXValue,
        nearestXValueEnd: nearestXValueEnd,
        shape: {
            params: {
                d: line
            }
        }
    });

    ann.options.distance = options.xValueEndDataIndex - options.xValueDataIndex;
    self.updateAdditionalDrawings(false, true);
    return line;
};

infChart.fibVerRetracementsDrawing.prototype.stop = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        line = self.stepFunction(e, isStartPoint),
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        x = xAxis.toValue(line[4] + xAxis.toPixels(options.xValue)),
        y = yAxis.toValue(line[5] + yAxis.toPixels(options.yValue));

    ann.update({
        xValueEnd: x,
        yValueEnd: y,
        nearestXValue: options.nearestXValue,
        nearestXValueEnd: options.nearestXValueEnd,
        shape: {
            params: {
                d: line
            }
        }
    });

    if (ann.selectionMarker && ann.selectionMarker.length > 1) {
        ann.selectionMarker[1].attr({
            x: line[4],
            y: line[5]
        });
    }

    infChart.drawingUtils.common.saveBaseYValues.call(self, options.yValue, y);

    self.setDragSupporters();
    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
    infChart.drawingUtils.common.onPropertyChange.call(self);
};

infChart.fibVerRetracementsDrawing.prototype.translate = function (event) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];

    if (options.selectedDrawing == "mainDrawing") {
        this.updateAdditionalDrawings(false, true);
        this.scale();
    }
    if (options.selectedDrawing == "additionalDrawing") {
        options.chartY = yAxis.toValue(event.chartY);

        ann.update({
            yValue: options.yValueStore,
            yValueEnd: options.yValueEndStore
        });

        this.updateAdditionalDrawings(false, false);
    }
};

infChart.fibVerRetracementsDrawing.prototype.translateEnd = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options;
    options.selectedDrawing = undefined;
    self.scale();
    infChart.drawingUtils.common.saveBaseYValues.call(self, options.yValue, options.yValueEnd);
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.fibVerRetracementsDrawing.prototype.updateAdditionalDrawings = function (isScale, isMain) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        dx = options.distance,
        adjustment = options.adjustment,
        yAxis = chart.yAxis[options.yAxis],
        xAxis = chart.xAxis[options.xAxis],
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels);

    var fibIndex = 0, fibLevelLength = fibLevels.length, lastX = 0, lastVal = 0, isStartEnabled = false, isEndEnabled = false;
    for (fibIndex; fibIndex < fibLevelLength; fibIndex++) {
        var fibLevel = fibLevels[fibIndex];
        var x = self.updateFibLevel(fibLevel, fibIndex, fibLevels, dx, isScale, false, isMain);
        if (fibLevel.enable) {
            if (fibLevel.value === 0) {
                isStartEnabled = true;
            }
            if (fibLevel.value === 100) {
                isEndEnabled = true;
            }
            lastVal = fibLevel.value;
            if ((dx < 0 && lastX > x) || (dx > 0 && lastX < x)) {
                lastX = x;
            }
        }
    }

    if (options.isShort) {
        var startDrawingLabel = self.additionalDrawings.labels['start'];
        var endDrawingLabel = self.additionalDrawings.labels['end'];
        var startDrawingLine = self.additionalDrawings.lines['start'];
        var endDrawingLine = self.additionalDrawings.lines['end'];
        newX = xAxis.toPixels(options.nearestXValue) - xAxis.toPixels(options.xValue);
        if (!isScale) {
            var startValue = self.formatDate(options.nearestXValue, self.stockChart.interval);
            startDrawingLabel.textSetter(startValue);
            var endValue = self.formatDate(this.calculateFibLevelCandleValue(dx, 100), self.stockChart.interval);
            endDrawingLabel.textSetter(endValue);
        }

        var lineStartPosition = this.calculateLineStartPosition(fibLevel, isMain);
        var lineEndPosition = lineStartPosition + 10;

        startDrawingLabel.attr({
            x: newX - startDrawingLabel.width / 2,
            y: lineEndPosition + 5
        });
        startDrawingLine.attr({
            d: ["M", newX, lineStartPosition, 'L', newX, lineEndPosition]
        });
        var endX = adjustment === 0 ? parseFloat(ann.shape.d.split(' ')[4]) : adjustment;
        endDrawingLabel.attr({
            x: endX - endDrawingLabel.width / 2,
            y: lineEndPosition + 5
        });
        endDrawingLine.attr({
            d: ["M", endX, lineStartPosition, 'L', endX, lineEndPosition]
        });

        if (adjustment === 0 && lastVal < 100) {
            lastX = ann.shape.d.split(' ')[4];
        }
        self.additionalDrawings.jointLine.attr({
            d: ['M', newX, lineStartPosition, 'L', lastX, lineStartPosition]
        });
    }
};

infChart.fibVerRetracementsDrawing.prototype.updateFibLevel = function (fibLevel, fibIndex, fibLevels, dx, isScale, isValueUpdate, isMain) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        correctionFactor = infChart.drawingUtils.common.correctionFactor,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis];

    var x = xAxis.toPixels(this.calculateFibLevelCandleValue(dx, fibLevel.value)) - xAxis.toPixels(options.xValue);
    var previousLineStart = self.calculateLineStartPosition(fibLevel, isMain);
    var y1, y2, lineStartPosition = previousLineStart,
        lineEndPosition;
    if (options.isShort) {
        lineEndPosition = lineStartPosition + 10;
        y1 = lineStartPosition;
        y2 = lineEndPosition;
    } else {
        lineEndPosition = chart.plotHeight + lineStartPosition;
        y1 = lineStartPosition - chart.plotHeight * correctionFactor;
        y2 = lineEndPosition + chart.plotHeight * correctionFactor;
    }

    self.additionalDrawings.lines[fibLevel.id].attr({
        d: ["M", x, y1, 'L', x, y2]
    });

    var drawingLabel = self.additionalDrawings.labels[fibLevel.id];

    if (options.isShort) {
        if (!isScale) {
            drawingLabel.textSetter(self.getLineLabelText(x, fibLevel));
        }
    } else {
        if (isValueUpdate) {
            self.updateFill(fibLevel, fibIndex, fibLevels);
        }
        var isFirstLevel = true;
        fibIndex--;
        for (fibIndex; fibIndex >= 0; fibIndex--) {
            if (fibLevels[fibIndex].enable) {
                isFirstLevel = false;
                break;
            }
        }
        if (!isFirstLevel) {
            self.updateFill(fibLevels[fibIndex], fibIndex, fibLevels);
        }
    }

    drawingLabel.attr({
        x: options.isShort ? x - drawingLabel.width / 2 : x + 5,
        y: options.isShort ? lineEndPosition + 5 : lineEndPosition - 25
    });
    return x;
};

infChart.fibVerRetracementsDrawing.prototype.updateFill = function (fibLevel, fibIndex, fibLevels) {
    var self = this;
    var currentLine = self.additionalDrawings.lines[fibLevel.id], nextLine;
    var currentLineP = currentLine.d.split(' ');
    for (var i = fibIndex + 1; i < fibLevels.length; i++) {
        if (fibLevels[i].enable) {
            nextLine = self.additionalDrawings.lines[fibLevels[i].id];
            break;
        }
    }
    if (nextLine) {
        var nextLineP = nextLine.d.split(' ');
        self.additionalDrawings.fill[fibLevel.id].attr({
            d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
        });
    }
};

infChart.fibVerRetracementsDrawing.prototype.updateJointLine = function (x, fibIndex, fibLevels) {
    var self = this, options = self.annotation.options;
    if (options.isShort) {
        var maxFibLevel, isStartEnabled = false, isEndEnabled = false;
        for (var i = 0; i < fibLevels.length; i++) {
            if (fibLevels[i].enable) {
                if (typeof maxFibLevel === 'undefined') {
                    maxFibLevel = fibLevels[i];
                }
                if (fibLevels[i].value === 0) {
                    isStartEnabled = true;
                }
                if (fibLevels[i].value > maxFibLevel.value) {
                    if (fibLevels[i].value === 100) {
                        isEndEnabled = true;
                    }
                    maxFibLevel = fibLevels[i];
                }
            }
        }

        var jointLineLastX;
        if (typeof maxFibLevel === 'undefined' || (maxFibLevel.value < 100 && !options.trendXValue)) {
            jointLineLastX = self.annotation.shape.d.split(' ')[4];
        } else {
            jointLineLastX = self.additionalDrawings.lines[maxFibLevel.id].d.split(' ')[4];
        }
        var jointLine = self.additionalDrawings.jointLine, jointLineArray = jointLine.d.split(' ');
        jointLine.attr({
            d: ['M', jointLineArray[1], jointLineArray[2], 'L', jointLineLastX, jointLineArray[5]]
        });

        if (!options.trendXValue) {
            if (!isStartEnabled) {
                self.additionalDrawings.labels['start'].show();
                self.additionalDrawings.lines['start'].show();
            } else {
                self.additionalDrawings.labels['start'].hide();
                self.additionalDrawings.lines['start'].hide();
            }

            if (!isEndEnabled) {
                self.additionalDrawings.labels['end'].show();
                self.additionalDrawings.lines['end'].show();
            } else {
                self.additionalDrawings.labels['end'].hide();
                self.additionalDrawings.lines['end'].hide();
            }
        }
    }
};

infChart.fibVerRetracementsDrawing.prototype.updateLineLabelText = function (x, fibLevel) {
    var self = this;
    var options = self.annotation.options;
    var chart = self.annotation.chart;
    var xAxis = chart.xAxis[options.xAxis];
    var labelValue;
    var fibLevelValue = infChart.drawingUtils.common.formatValue(fibLevel.value / 100, 3);
    if (options.isShort) {
        var time = xAxis.toValue(x + xAxis.toPixels(options.xValue));
        var _getMonth = function (val) {
            var shortFormat = "";
            switch (val) {
                case 1:
                    shortFormat = "Ja";
                    break;
                case 2:
                    shortFormat = "Fb";
                    break;
                case 3:
                    shortFormat = "Ma";
                    break;
                case 4:
                    shortFormat = "Ap";
                    break;
                case 5:
                    shortFormat = "My";
                    break;
                case 6:
                    shortFormat = "Jn";
                    break;
                case 7:
                    shortFormat = "Jl";
                    break;
                case 8:
                    shortFormat = "Au";
                    break;
                case 9:
                    shortFormat = "Se";
                    break;
                case 10:
                    shortFormat = "Oc";
                    break;
                case 11:
                    shortFormat = "Nv";
                    break;
                case 12:
                    shortFormat = "Dc";
                    break;
            }
            return shortFormat;
        };

        var _replaceMonth = function (val) {
            var parts = val.split(".");
            if (parts.length > 2) {
                val = val.replace("." + parts[1] + ".", _getMonth(parseInt(parts[1], 10)));
            } else if (parts.length > 1) {
                val = val.replace(parts[1] + ".", _getMonth(parseInt(parts[1], 10)));
            }
            return val;
        };

        var format;
        switch (self.stockChart.interval) {
            case 'T':
                format = '%d.%m.%y %H:%M:%S';
                break;
            case 'M':
                format = '%b.%y';
                break;
            case 'Y':
                format = '%y';
                break;
            case 'D':
            case 'W':
                format = '%d.%m.%y';
                break;
            default:
                format = '%d.%m.%y %H:%M';
                break;

        }
        // time = infChart.math.findNearestXDataPoint(chart, time);
        labelValue = _replaceMonth(infChart.util.formatDate(time, format)) + '<br/>' + fibLevelValue;
    } else {
        labelValue = fibLevelValue;
    }
    return labelValue;
};

infChart.fibVerRetracementsDrawing.prototype.updateSettings = function (properties) {
    var updateProperties = {
        fillColor: properties.fillColor,
        fillOpacity: properties.opacity,
        lineColor: properties.lineColor,
        lineWidth: properties.lineWidth,
        fontSize: properties.fontSize,
        fontColor: properties.fontColor,
        isSingleColor: properties.isSingleColor,
        fibLevels: properties.fibLevels,
        isFibModeEnabled: properties.isShort,
        isTrendLineAlwaysEnabled: properties.isTrendLineAlways,
        trendLineColor: properties.trendLineColor,
        trendLineOpacity: properties.trendLineOpacity,
        trendLineWidth: properties.trendLineWidth,
        trendLineStyle: properties.trendLineStyle
    }
    infChart.structureManager.drawingTools.updateFibSettings(this.settingsPopup, updateProperties);
};

infChart.fibVerRetracementsDrawing.prototype.calculateFibLevelCandleValue = function (dx, fibValue) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        candleValue,
        calculatedCandleIndex,
        seriesXData = chart.series[0].xData,
        distanceMultiplier = parseFloat(fibValue) / 100;

    calculatedCandleIndex = Math.round(dx * distanceMultiplier) + options.xValueDataIndex;
    calculatedCandleIndex = calculatedCandleIndex >= 0 ? calculatedCandleIndex : 0;

    if (seriesXData.length > calculatedCandleIndex) {
        candleValue = seriesXData[calculatedCandleIndex];
    } else {
        candleValue = Math.round(infChart.math.getFutureXValueForGivenIndex(chart, calculatedCandleIndex));
    }

    return candleValue;
}

infChart.fibVerRetracementsDrawing.prototype.specificCursorChange = function(url){
    var self = this,
        ann = self.annotation,
        options = ann.options,
        additionalDrawings = self.additionalDrawings;

        $.each(additionalDrawings.labels, function (key, value) {
                if(url){
                    value.css({'cursor': 'url("' + url + '"), default'});
                } else {
                    infChart.util.setCursor(value, 'move');
                    value.css({'cursor': 'move'});
                }
        });
};

infChart.fibVerRetracementsDrawing.prototype.highlightEachLine = function(){
    let self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        selectedLevel
        dragSupporters = self.dragSupporters,
        container = chart.container,
        additionalDrawings = self.additionalDrawings,
        fibLabels = additionalDrawings.labels,
        fibLines = additionalDrawings.lines;

        $.each(fibLabels, function (key, fibLabel) {
            $(fibLabel.element).mouseenter( function (event) {   
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                if(selectedLevel){                
                    var selectedLine = fibLines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    $(container).find("path[class*='line-hover']").attr({class:''});
                    $(container).find("g[class*='label-hover']").attr({class:'highcharts-label'});
                    if(selectedLine){
                        selectedLine.addClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.addClass('label-hover');
                    }
                }
                event.stopPropagation();
            });

            $(fibLabel.element).mouseleave( function (event) {   
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                if(selectedLevel){  
                    var selectedLine = fibLines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    if(selectedLine){
                        selectedLine.removeClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.removeClass('label-hover');
                    }
                }
                event.stopPropagation();
            });
        })
};

infChart.fibVerRetracementsDrawing.prototype.onTrendLineColorChange = function (rgb, color, opacity, isPropertyChange){
    var self = this;
    self.annotation.update({
        shape: {
            params: {
                stroke: color,
                opacity: opacity
            }
        }
    });

    self.annotation.options.trendLineColor = color;
    self.annotation.options.trendLineOpacity = opacity;

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.fibVerRetracementsDrawing.prototype.onTrendLineWidthChange =  function (strokeWidth, isPropertyChange) {
    var self = this;
    var strokeDashArray = infChart.drawingUtils.common.settings.getStrokeDashArray.call(self, self.annotation.options.trendLineStyle, strokeWidth);
    self.annotation.update({
        shape: {
            params: {
                'stroke-width': strokeWidth,
                'stroke-dasharray': strokeDashArray
            }
        }
    });

    self.annotation.options.trendLineWidth = strokeWidth;

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};


infChart.fibVerRetracementsDrawing.prototype.onTrendLineStyleChange = function (dashStyle, isPropertyChange) {
    var self = this;
    var strokeDashArray = infChart.drawingUtils.common.settings.getStrokeDashArray.call(self, dashStyle, self.annotation.options.trendLineWidth);

    self.annotation.update({
        shape: {
            params: {
                dashstyle: dashStyle,
                'stroke-dasharray': strokeDashArray
            }
        }
    });

    self.annotation.options.trendLineStyle = dashStyle;

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.fibVerRetracementsDrawing.prototype.onTrendLineToggleShow = function(checked, isPropertyChange){
    var self = this,
        ann = self.annotation,
        options = ann.options;

    options.isTrendLineAlways = checked;
    if(checked){
        if(ann){
            ann.shape.show();
            self.setDragSupporters();
        }
    }

    isPropertyChange && self.onPropertyChange();
    if (self.settingsPopup) {
        self.settingsPopup.data("infUndoRedo", false);
    }
};
window.infChart = window.infChart || {};

infChart.fibArcsDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
    this.fibLevels = [
        {
            id: 'level_0',
            value: 38.2,
            enable: true,
            drawingPosX: -35,
            drawingPosY: 7,
            fillColor: '#4b0832',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight : 'normal'
        },
        {
            id: 'level_1',
            value: 50,
            enable: true,
            drawingPosX: -35,
            drawingPosY: 7,
            fillColor: '#f075c3',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight : 'normal'
        },
        {
            id: 'level_2',
            value: 61.8,
            enable: true,
            drawingPosX: -35,
            drawingPosY: 7,
            fillColor: '#f6aada',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight : 'normal'
        }
    ];
};

infChart.fibArcsDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.fibArcsDrawing.prototype.additionalDrawingsFunction = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        fibLevels = options.fibLevels ? options.fibLevels : this.fibLevels,
        additionalDrawingsArr = self.additionalDrawings,
        fibonacciDrawingsArr = self.fibonacciDrawings,
        theme = infChart.drawingUtils.common.getTheme.call(this),
        drawingFillAttr,
        drawingAttr,
        labelAttr,
        baseFillOpacity = (theme.fibArcs && typeof theme.fibArcs.fillOpacity !== "undefined") ? theme.fibArcs.fillOpacity : infChart.drawingUtils.common.baseFillOpacity,
        baseFontColor = (theme.fibArcs && typeof theme.fibArcs.fontColor !== "undefined") ? theme.fibArcs.fontColor : infChart.drawingUtils.common.baseFontColor,
        baseFontSize = (theme.fibArcs && typeof theme.fibArcs.fontSize !== "undefined") ? theme.fibArcs.fontSize : infChart.drawingUtils.common.baseFontSize,
        baseFontWeight = (theme.fibArcs && typeof theme.fibArcs.fontWeight !== "undefined") ? theme.fibArcs.fontWeight : infChart.drawingUtils.common.baseFontWeight,

        labelStyles = {
            'color': baseFontColor,
            fontSize: baseFontSize,
        };

    additionalDrawingsArr.lines = {};
    fibonacciDrawingsArr.lines = {};
    fibonacciDrawingsArr.fill = {};

    var hiddenLevels = [];

    // add fill objects first to avoid overlapping lines with and texts with them
    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);
    fibLevels.forEach(function (fibLevel) {

        var themeFillColor = theme.fibArcs && theme.fibArcs.fibLevelFillColors && theme.fibArcs.fibLevelFillColors[fibLevel.id];
        if (!fibLevel.enable) {
            hiddenLevels.push(fibLevel.id);
        }

        drawingFillAttr = {
            'stroke-width': 0,
            fill: options.isSingleColor && options.fillColor ? options.fillColor : fibLevel && fibLevel.fillColor ? fibLevel.fillColor : themeFillColor,
            'fill-opacity': options.isSingleColor && options.fillOpacity ? options.fillOpacity : fibLevel && fibLevel.fillOpacity ? fibLevel.fillOpacity : baseFillOpacity,
            stroke: ann.options.shape.params.stroke,
            'z-index': 2,
            cursor: 'default',
            'level': fibLevel.id,
            'pointer-events':'none'
        };
        drawingAttr = {
            'stroke-width': options.isSingleColor && options.lineWidth ? options.lineWidth : fibLevel && fibLevel.lineWidth ? fibLevel.lineWidth : ann.options.shape.params['stroke-width'],
            fill: ann.options.shape.params.fill,
            stroke: options.isSingleColor && options.lineColor ? options.lineColor : fibLevel && fibLevel.lineColor ? fibLevel.lineColor : ann.options.shape.params.stroke,
            'z-index': 2,
            cursor: 'move',
            'level': fibLevel.id
        };

        var fontColor = options.isSingleColor && options.fontColor ? options.fontColor : fibLevel && fibLevel.fontColor ? fibLevel.fontColor : baseFontColor;
        var fontSize = options.isSingleColor && options.fontSize ? options.fontSize :fibLevel && fibLevel.fontSize ? fibLevel.fontSize : baseFontSize;
        var fontWeight = options.isSingleColor && options.fontWeight ? options.fontWeight : fibLevel && fibLevel.fontWeight ? fibLevel.fontWeight : baseFontWeight;

        labelStyles = {
            'color': fontColor,
            fontSize: fontSize + 'px',
            'font-weight': fontWeight
        };
        labelAttr = {
            'level': fibLevel.id,
            'font-color': fontColor,
            'font-size': fontSize,
            'font-weight': fontWeight
        };
        fibonacciDrawingsArr.fill[fibLevel.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0]).attr(drawingFillAttr).add(ann.group);
        additionalDrawingsArr.lines[fibLevel.id] = chart.renderer.arc(0, 0, 0, 0, 0, Math.PI).attr(drawingAttr).add(ann.group);
        fibonacciDrawingsArr.lines[fibLevel.id] = chart.renderer.label(infChart.drawingUtils.common.formatValue(fibLevel.value, 1), fibLevel.drawingPosX, fibLevel.drawingPosY).css(labelStyles).attr(labelAttr).add(ann.group);
    });

    hiddenLevels.forEach(function (id) {
        self.onFibArcsLevelChange(id, false, false);
    });
    ann.selectionMarker = [];
    infChart.drawingUtils.common.addSelectionMarker.call(this, ann, 0, 0);
};

infChart.fibArcsDrawing.prototype.bindSettingsEvents = function () {
    var self = this;
    var onFibArcsLevelChange = function (checked, value) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onFibArcsLevelChange.call(self, value, checked, isPropertyChange);
    };

    return infChart.drawingUtils.common.bindFibSettingsEvents.call(this, infChart.drawingUtils.common.baseBorderColor, infChart.drawingUtils.common.baseLineWidth, onFibArcsLevelChange);
};

infChart.fibArcsDrawing.prototype.getConfig = function () {
    var self = this,
        annotation = self.annotation,
        options = annotation.options,
        fibLevels = options.fibLevels ? options.fibLevels : self.fibLevels;
    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);
    return {
        shape: 'fibArcs',
        fibLevels: fibLevels,
        borderColor: annotation.options.lineColor,
        fillColor: annotation.options.fillColor,
        fillOpacity: annotation.options.fillOpacity,
        strokeWidth: annotation.options.lineWidth,
        fontColor: annotation.options.fontColor,
        fontSize: annotation.options.fontSize,
        fontWeight: annotation.options.fontWeight,
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        isSingleColor: annotation.options.isSingleColor,
        isLocked : annotation.options.isLocked

    };
};

infChart.fibArcsDrawing.prototype.getContextMenuOptions = function (chartId, drawingId, options, event) {
    var self = this;
    var level = event.target.getAttribute('level');
    var contextMenu = {};

    if (!self.isVisibleLastLevel()) {
        var eraseThis = {
            icon: options.erase.icon,
            displayText: options.erase.displayText,
            action: function () {
                if (level) {
                    self.onFibArcsLevelChange.call(self, level, false, true, true);
                }
            }
        }
        contextMenu["eraseThis"] = eraseThis;
    }

    if (level) {
        contextMenu = Object.assign(contextMenu, infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options));
        return infChart.drawingUtils.common.reorderContextMenu(contextMenu);
    } else {
        return infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options);
    }
};

infChart.fibArcsDrawing.prototype.getOptions = function (properties) {
    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0]
            }
        }
    };
    var theme = infChart.drawingUtils.common.getTheme.call(this);
    var baseFillColor = (theme.fibArcs && theme.fibArcs.singleFillColor) ? theme.fibArcs.singleFillColor : (theme.fibonacci && theme.fibonacci.singleFillColor) ? theme.fibonacci.singleFillColor : infChart.drawingUtils.common.baseFillColor;
    var baseFillOpacity = (theme.fibArcs && typeof theme.fibArcs.fillOpacity !== "undefined") ? theme.fibArcs.fillOpacity : (theme.fibonacci && typeof theme.fibonacci.fillOpacity !== "undefined") ? theme.fibonacci.fillOpacity : infChart.drawingUtils.common.baseFillOpacity;
    var baseBorderColor = (theme.fibArcs && theme.fibArcs.borderColor) ? theme.fibArcs.borderColor : (theme.fibonacci && theme.fibonacci.borderColor) ? theme.fibonacci.borderColor : infChart.drawingUtils.common.baseBorderColor;
    var baseLineWidth = (theme.fibArcs && typeof theme.fibArcs.lineWidth !== "undefined") ? theme.fibArcs.lineWidth : (theme.fibonacci && theme.fibonacci.lineWidth) ? theme.fibonacci.lineWidth : infChart.drawingUtils.common.baseLineWidth;
    var baseFontColor = (theme.fibArcs && theme.fibArcs.fontColor) ? theme.fibArcs.fontColor: (theme.fibonacci && theme.fibonacci.fontColor) ? theme.fibonacci.fontColor : infChart.drawingUtils.common.baseFontColor;
    var baseFontSize = (theme.fibArcs && theme.fibArcs.fontSize) ? theme.fibArcs.fontSize: (theme.fibonacci && theme.fibonacci.fontSize) ? theme.fibonacci.fontSize : infChart.drawingUtils.common.baseFontSize;
    var baseFontWeight = (theme.fibArcs && theme.fibArcs.fontWeight) ? theme.fibArcs.fontWeight: (theme.fibonacci && theme.fibonacci.fontWeight) ? theme.fibonacci.fontWeight : infChart.drawingUtils.common.fontWeight;

    options.fillColor = properties.fillColor ? properties.fillColor : baseFillColor;
    options.fillOpacity = properties.fillOpacity ? properties.fillOpacity : baseFillOpacity;
    options.lineColor = properties.borderColor ? properties.borderColor : baseBorderColor;
    options.lineWidth = properties.strokeWidth ? properties.strokeWidth : baseLineWidth;
    options.fontColor = properties.fontColor ? properties.fontColor : baseFontColor;
    options.fontSize = properties.fontSize ? properties.fontSize : baseFontSize;
    options.fontWeight = properties.fontWeight ? properties.fontWeight : baseFontWeight;

    options.shape.params.fill = options.fillColor;
    options.shape.params['fill-opacity'] = options.fillOpacity;
    options.shape.params.stroke = options.lineColor;
    options.shape.params['stroke-width'] = options.lineWidth;
    options.shape.params['font-color'] = options.fontColor;
    options.shape.params['font-size'] = options.fontSize;

    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
    }
    if (properties.isSingleColor) {
        options.isSingleColor = properties.isSingleColor;
    }
    options.fibLevels = properties.fibLevels ? properties.fibLevels : this.fibLevels;
    options.fibLevels = infChart.drawingUtils.common.getFibLevelsWithOpacity(infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels), baseFillOpacity);
    options.validateTranslationFn = this.validateTranslation;

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.fibArcsDrawing.prototype.validateTranslation = function (newXValue) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        seriesData = chart.series[0].xData,
        dataMin = seriesData[0],
        xVal = options.xValue,
        xValEnd = options.xValueEnd,
        newXValueEnd = xValEnd - xVal + newXValue,
        totalPoints = infChart.drawingsManager.getTotalPoints(chart),
        dataMax = totalPoints[totalPoints.length - 1];

    return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax);
};

infChart.fibArcsDrawing.prototype.getQuickSettingsPopup = function () {
    var self = this;
    var options = self.annotation.options;
    var fillColor = options.fillColor;
    var fillOpacity = options.fillOpacity;
    var lineColor = options.lineColor;
    var fontColor = options.fontColor;
    var fontSize = options.fontSize;
    var fontWeight = options.fontWeight;
    return infChart.drawingUtils.common.getFibQuickSettings(fillColor, fillOpacity, lineColor, fontColor, fontSize);
};

infChart.fibArcsDrawing.prototype.getSettingsPopup = function () {
    var self = this;
    var options = self.annotation.options;
    var fibLevels = options.fibLevels ? options.fibLevels : self.fibLevels;

    var properties = {
        fillColor: options.fillColor,
        fillOpacity: options.fillOpacity,
        lineColor: options.lineColor,
        lineWidth: options.lineWidth,
        fontColor: options.fontColor,
        fontSize: options.fontSize,
        fontWeight: options.fontWeight,
        fibLevels: fibLevels,
        showFibModeToggle: false,
        showSnapToHighLowToggle: false,
        templates: self.getDrawingTemplates(),
        userDefaultSettings: self.getUserDefaultSettings()
    }
    return infChart.drawingUtils.common.getFibSettings(properties);
};

/**
 * Change the visibility of Fib arcs' levels
 * IMPORTANT :: this method is uesd in commands.wrappers to set undo/redo actions
 * @param {string} currentLevel level that is going to be changed
 * @param {boolean} checked visibility
 * @param  {boolean|undefined} isPropertyChange property change
 * @param {boolean} ignoreSettingsSave - this is to indicate to this change does not affect to subsequent drawing
 */
infChart.fibArcsDrawing.prototype.onFibArcsLevelChange = function (currentLevel, checked, isPropertyChange, ignoreSettingsSave) {
    var self = this, 
        ann = self.annotation,
        chart = ann.chart,
        line = ann.shape.d.split(' '),
        drawing = self.additionalDrawings.lines[currentLevel];
    var label = self.fibonacciDrawings.lines[currentLevel];
    var fill = self.fibonacciDrawings.fill[currentLevel],
        options = self.annotation.options,
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels),
        currentOrderIdx,
        prevLine, prevFill, nextFill,
        currentLinePoints,
        nextLinePoints,
        prvLinePoints,
        i,
        lineD,
        next;

    fibLevels.some(function (fibLevel, index) {
        if (fibLevel.id == currentLevel) {
            currentOrderIdx = index;
            return true;
        }
    });
    fibLevels[currentOrderIdx].enable = checked;

    if (checked) {

        drawing.show();
        label.show();
        fill.show();

        for (i = currentOrderIdx + 1; i < fibLevels.length; i++) {
            lineD = self.additionalDrawings.lines[fibLevels[i].id];
            if (lineD && lineD.visibility != "hidden") {
                next = lineD;
                nextFill = self.fibonacciDrawings.fill[fibLevels[i].id];
                break;
            }
        }
        for (i = currentOrderIdx - 1; i >= 0; i--) {
            lineD = self.additionalDrawings.lines[fibLevels[i].id];
            if (lineD && lineD.visibility != "hidden") {
                prevLine = lineD;
                prevFill = self.fibonacciDrawings.fill[fibLevels[i].id];
                break;
            }
        }

        currentLinePoints = drawing.d.split(' ');

        if (prevLine && prevFill) {

            prvLinePoints = prevLine && prevLine.d.split(' ');
            fill.attr({
                d: ['M', prvLinePoints[1], prvLinePoints[2],
                    'A', prvLinePoints[4], prvLinePoints[5], prvLinePoints[6], prvLinePoints[7], prvLinePoints[8], prvLinePoints[9], prvLinePoints[10],
                    'L', currentLinePoints[9], currentLinePoints[10],
                    'A', currentLinePoints[4], currentLinePoints[5], 360 - currentLinePoints[6], currentLinePoints[7], currentLinePoints[8] ? 0 : 1, currentLinePoints[1], currentLinePoints[2],
                    'L', prvLinePoints[1], prvLinePoints[2]
                ]
            });
        } else if (fill) {
            fill.attr({
                d: ['M', currentLinePoints[9], currentLinePoints[10],
                    'A', currentLinePoints[4], currentLinePoints[5], 360 - currentLinePoints[6], currentLinePoints[7], currentLinePoints[8] ? 0 : 1, currentLinePoints[1], currentLinePoints[2],
                    'L', currentLinePoints[9], currentLinePoints[10]
                ]
            });
        }

        if (next && nextFill) {
            nextLinePoints = next.d.split(' ');
            nextFill.attr({
                d: ['M', currentLinePoints[1], currentLinePoints[2],
                    'A', currentLinePoints[4], currentLinePoints[5], currentLinePoints[6], currentLinePoints[7], currentLinePoints[8], currentLinePoints[9], currentLinePoints[10],
                    'L', nextLinePoints[9], nextLinePoints[10],
                    'A', nextLinePoints[4], nextLinePoints[5], 360 - nextLinePoints[6], nextLinePoints[7], nextLinePoints[8] ? 0 : 1, nextLinePoints[1], nextLinePoints[2],
                    'L', currentLinePoints[1], currentLinePoints[2]
                ]
            });
        }

    } else {
        drawing.hide();
        label.hide();
        fill.hide();

        for (i = currentOrderIdx + 1; i < fibLevels.length; i++) {
            lineD = self.additionalDrawings.lines[fibLevels[i].id];
            if (lineD && lineD.visibility != "hidden") {
                next = lineD;
                nextFill = self.fibonacciDrawings.fill[fibLevels[i].id];
                break;
            }
        }

        for (i = currentOrderIdx - 1; i >= 0; i--) {
            lineD = self.additionalDrawings.lines[fibLevels[i].id];
            if (lineD && lineD.visibility != "hidden") {
                prevLine = lineD;
                prevFill = self.fibonacciDrawings.fill[fibLevels[i].id];
                break;
            }
        }
        if (prevLine && next) {
            prvLinePoints = prevLine.d.split(' ');
            nextLinePoints = next.d.split(' ');
            nextFill.attr({
                d: ['M', nextLinePoints[1], nextLinePoints[2],
                    'A', nextLinePoints[4], nextLinePoints[5], nextLinePoints[6], nextLinePoints[7], nextLinePoints[8], nextLinePoints[9], nextLinePoints[10],
                    'L', prvLinePoints[9], prvLinePoints[10],
                    'A', prvLinePoints[4], prvLinePoints[5], 360 - prvLinePoints[6], prvLinePoints[7], prvLinePoints[8] ? 0 : 1, prvLinePoints[1], prvLinePoints[2],
                    'L', nextLinePoints[1], nextLinePoints[2]
                ]
            });
        } else if (next) {
            nextLinePoints = next.d.split(' ');
            nextFill.attr({
                d: ['M', nextLinePoints[9], nextLinePoints[10],
                    'A', nextLinePoints[4], nextLinePoints[5], 360 - nextLinePoints[6], nextLinePoints[7], nextLinePoints[8] ? 0 : 1, nextLinePoints[1], nextLinePoints[2],
                    'L', nextLinePoints[9], nextLinePoints[10]
                ]
            });
        }

    }

    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', 0, 0, 'L', line[4], line[5]], self.dragSupporters);
    $.each(self.additionalDrawings.lines, function (key, value) {
        if (value.visibility !== 'hidden') {
            var radius = value.r;
            var arcStart = radius > 0 ? 0 : Math.PI,
                arcEnd = radius > 0 ? Math.PI : 0;

            var customAttributes = {
                'level': key,
                'type': "additionalDrawing"
            }

            var mergedragSupporterStyles = {};
            var dragSupporterStyles = Object.assign(mergedragSupporterStyles, infChart.drawingUtils.common.dragSupporterStyles, customAttributes);
            self.dragSupporters.push(chart.renderer.arc(0, 0, Math.abs(radius), Math.abs(radius), arcStart, arcEnd).attr(dragSupporterStyles).add(ann.group));
            infChart.drawingUtils.common.setDeleteCursor.call(self);
            infChart.drawingUtils.common.setDeleteModeCursor.call(self);
        }
    });
    self.highlightEachLine();
    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }   
};

infChart.fibArcsDrawing.prototype.scale = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        line = ann.shape.d.split(' '),
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        fibonacciDrawings = this.fibonacciDrawings.lines,
        fibonacciDrawingsFill = this.fibonacciDrawings.fill,
        fibLevels = options.fibLevels ? options.fibLevels : this.fibLevels,
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels),
        lineDrawings = self.additionalDrawings.lines,
        fill,
        currentLine,
        currentLineP,
        prvLine,
        prvLineP;

    var xEnd = xAxis.toPixels(options.xValueEnd) - xAxis.toPixels(options.xValue),
        yEnd = yAxis.toPixels(options.yValueEnd) - yAxis.toPixels(options.yValue);

    line[4] = (!isNaN(xEnd) && xEnd) || 0;
    line[5] = (!isNaN(yEnd) && yEnd) || 0;

    ann.update({
        shape: {
            params: {
                d: line
            }
        }
    });

    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', 0, 0, 'L', line[4], line[5]], self.dragSupporters);

    var dx = line[4], dy = line[5],
        dxAbs = Math.abs(dx),
        dyAbs = Math.abs(dy),
        lineWidth = Math.sqrt(dxAbs * dxAbs + dyAbs * dyAbs);

    $.each(this.additionalDrawings.lines, function (key, value) {
        var fibLevel = fibLevels.find(function (level) {
            return level.id === key;
        });
        var percentage = parseFloat(fibLevel.value);
        var radius = (lineWidth * percentage / 100) * (dy > 0 ? 1 : -1);
        var drawingLabel = fibonacciDrawings[key];

        value.attr({
            r: radius,
            innerR: radius
        });

        drawingLabel.attr({
            y: radius
        });

        drawingLabel.textSetter(infChart.drawingUtils.common.formatValue(fibLevel.value, 1));

        var arcStart = radius > 0 ? 0 : Math.PI,
            arcEnd = radius > 0 ? Math.PI : 0;

        if (value.visibility !== 'hidden') {
            var customAttributes = {
                'level': key,
                'type': "additionalDrawing"
            }

            var mergedragSupporterStyles = {};
            var dragSupporterStyles = Object.assign(mergedragSupporterStyles, infChart.drawingUtils.common.dragSupporterStyles, customAttributes);
            self.dragSupporters.push(chart.renderer.arc(0, 0, Math.abs(radius), Math.abs(radius), arcStart, arcEnd).attr(dragSupporterStyles).add(ann.group));
            infChart.drawingUtils.common.setDeleteCursor.call(self);
            infChart.drawingUtils.common.setDeleteModeCursor.call(self);
        }
    });
    self.highlightEachLine();
    fibLevels.forEach(function (value, index, arr) {
        fill = fibonacciDrawingsFill && fibonacciDrawingsFill[value.id];
        currentLine = lineDrawings[value.id];
        currentLineP = currentLine && currentLine.d.split(' ');

        for (var i = index - 1; i >= 0; i--) {
            var lineTemp = self.additionalDrawings.lines[arr[i].id];
            if (lineTemp && lineTemp.visibility != "hidden") {
                prvLine = lineTemp;
                break;
            }
        }
        if (currentLine && fill && prvLine) {

            prvLineP = prvLine && prvLine.d.split(' ');
            fill.attr({
                d: ['M', prvLineP[1], prvLineP[2],
                    'A', prvLineP[4], prvLineP[5], prvLineP[6], prvLineP[7], prvLineP[8], prvLineP[9], prvLineP[10],
                    'L', currentLineP[9], currentLineP[10],
                    'A', currentLineP[4], currentLineP[5], 360 - currentLineP[6], currentLineP[7], currentLineP[8] ? 0 : 1, currentLineP[1], currentLineP[2],
                    'L', prvLineP[1], prvLineP[2]
                ]
            });
        } else if (currentLine && fill) {
            fill.attr({
                d: ['M', currentLineP[9], currentLineP[10],
                    'A', currentLineP[4], currentLineP[5], 360 - currentLineP[6], currentLineP[7], currentLineP[8] ? 0 : 1, currentLineP[1], currentLineP[2],
                    'L', currentLineP[9], currentLineP[10]
                ]
            });
        }
        prvLine = undefined;
    });
};

infChart.fibArcsDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation,
        pathDefinition, width, height;

    ann.events.deselect.call(ann);
    ann.selectionMarker = [];
    pathDefinition = ann.shape.d.split(' ');
    width = parseFloat(pathDefinition[4]);
    height = parseFloat(pathDefinition[5]);
    if (!isNaN(width) && !isNaN(height)) {
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, 0, 0, this.stepFunction, this.stop, true);
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, width, height, this.stepFunction, this.stop, false);
    }
};

infChart.fibArcsDrawing.prototype.step = function (e, isStartPoint) {
    var self = this,
        ann = this.annotation,
        options = ann.options,
        points = infChart.drawingUtils.common.calculateInitialPoints(e, ann, isStartPoint, 0, 0),
        dxAbs = Math.abs(points.dx),
        dyAbs = Math.abs(points.dy),
        lineWidth = Math.sqrt(dxAbs * dxAbs + dyAbs * dyAbs),
        fibonacciDrawings = this.fibonacciDrawings.lines,
        fibonacciDrawingsFill = this.fibonacciDrawings.fill,
        fibLevels = options.fibLevels ? options.fibLevels : this.fibLevels,
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels),
        lineDrawings = self.additionalDrawings.lines,
        fill,
        currentLine,
        currentLineP,
        prvLine,
        prvLineP;

    var line = ["M", 0, 0, 'L', parseInt(points.dx, 10), parseInt(points.dy, 10)];
    ann.shape.attr({
        d: line
    });

    $.each(this.additionalDrawings.lines, function (key, value) {
        var fibLevel = fibLevels.find(function (level) {
            return level.id === key;
        });
        var percentage = parseFloat(fibLevel.value);
        var radius = (lineWidth * percentage / 100) * (points.dy > 0 ? 1 : -1);
        var drawingLabel = fibonacciDrawings[key];

        value.attr({
            r: radius,
            innerR: radius
        });

        drawingLabel.attr({
            y: radius
        });
    });

    fibLevels.forEach(function (value, index, arr) {
        fill = fibonacciDrawingsFill && fibonacciDrawingsFill[value.id];
        currentLine = lineDrawings[value.id];
        currentLineP = currentLine && currentLine.d.split(' ');

        for (var i = index - 1; i >= 0; i--) {
            var lineTemp = self.additionalDrawings.lines[arr[i].id];
            if (lineTemp && lineTemp.visibility != "hidden") {
                prvLine = lineTemp;
                break;
            }
        }
        if (currentLine && fill && prvLine) {

            prvLineP = prvLine && prvLine.d.split(' ');
            fill.attr({
                d: ['M', prvLineP[1], prvLineP[2],
                    'A', prvLineP[4], prvLineP[5], prvLineP[6], prvLineP[7], prvLineP[8], prvLineP[9], prvLineP[10],
                    'L', currentLineP[9], currentLineP[10],
                    'A', currentLineP[4], currentLineP[5], 360 - currentLineP[6], currentLineP[7], currentLineP[8] ? 0 : 1, currentLineP[1], currentLineP[2],
                    'L', prvLineP[1], prvLineP[2]
                ]
            });
        } else if (currentLine && fill) {
            fill.attr({
                d: ['M', currentLineP[9], currentLineP[10],
                    'A', currentLineP[4], currentLineP[5], 360 - currentLineP[6], currentLineP[7], currentLineP[8] ? 0 : 1, currentLineP[1], currentLineP[2],
                    'L', currentLineP[9], currentLineP[10]
                ]
            });
        }
        prvLine = undefined;
    });

    return line;
};

infChart.fibArcsDrawing.prototype.stop = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        line = this.stepFunction(e, isStartPoint),
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        x = xAxis.toValue(line[4] + xAxis.toPixels(ann.options.xValue)),
        y = yAxis.toValue(line[5] + yAxis.toPixels(ann.options.yValue));

    ann.update({
        xValueEnd: x,
        yValueEnd: y,
        shape: {
            params: {
                d: line
            }
        }
    });

    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, y);
    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', 0, 0, 'L', line[4], line[5]], self.dragSupporters);

    $.each(self.additionalDrawings.lines, function (key, value) {
        if (value.visibility !== 'hidden') {
            var radius = value.r;
            var arcStart = radius > 0 ? 0 : Math.PI,
                arcEnd = radius > 0 ? Math.PI : 0;

            var customAttributes = {
                'level': key,
                'type': "additionalDrawing"
            }

            var mergedragSupporterStyles = {};
            var dragSupporterStyles = Object.assign(mergedragSupporterStyles, infChart.drawingUtils.common.dragSupporterStyles, customAttributes);
            self.dragSupporters.push(chart.renderer.arc(0, 0, Math.abs(radius), Math.abs(radius), arcStart, arcEnd).attr(dragSupporterStyles).add(ann.group));
            infChart.drawingUtils.common.setDeleteCursor.call(self);
            infChart.drawingUtils.common.setDeleteModeCursor.call(self);
        }
    });
    self.highlightEachLine();
    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.fibArcsDrawing.prototype.translateEnd = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        line = ann.shape.d.split(' ');
    
    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', 0, 0, 'L', line[4], line[5]], self.dragSupporters);
    $.each(self.additionalDrawings.lines, function (key, value) {
        if (value.visibility !== 'hidden') {
            var radius = value.r;
            var arcStart = radius > 0 ? 0 : Math.PI,
                arcEnd = radius > 0 ? Math.PI : 0;

            var customAttributes = {
                'level': key,
                'type': "additionalDrawing"
            }

            var mergedragSupporterStyles = {};
            var dragSupporterStyles = Object.assign(mergedragSupporterStyles, infChart.drawingUtils.common.dragSupporterStyles, customAttributes);
            self.dragSupporters.push(chart.renderer.arc(0, 0, Math.abs(radius), Math.abs(radius), arcStart, arcEnd).attr(dragSupporterStyles).add(ann.group));
            infChart.drawingUtils.common.setDeleteCursor.call(self);
            infChart.drawingUtils.common.setDeleteModeCursor.call(self);
        }
    });
    self.highlightEachLine();
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.fibArcsDrawing.prototype.updateSettings = function (properties) {
    var updateProperties = {
        fillColor: properties.fillColor,
        fillOpacity: properties.fillOpacity,
        lineColor: properties.borderColor,
        lineWidth: properties.strokeWidth,
        fontSize: properties.fontSize,
        fontColor: properties.fontColor,
        isSingleColor: properties.isSingleColor,
        fibLevels: properties.fibLevels,
        isTrendLineAlwaysEnabled: properties.isTrendLineAlways
    }
    infChart.structureManager.drawingTools.updateFibSettings(this.settingsPopup, updateProperties);
};

infChart.fibArcsDrawing.prototype.highlightEachLine = function(){
    let self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        dragSupporters = self.dragSupporters,
        additionalDrawings = self.additionalDrawings,
        fibonacciDrawings = self.fibonacciDrawings,
        container = chart.container,
        selectedLevel,
        fibLabels = fibonacciDrawings.lines,
        fibLines = additionalDrawings.lines;

        dragSupporters.forEach(function (dragSupporter) {
            $(dragSupporter.element).mouseenter( function (event) {   
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                if(selectedLevel){
                    var selectedLine = fibLines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    $(container).find("path[class*='line-hover']").attr({class:''});
                    $(container).find("g[class*='label-hover']").attr({class:'highcharts-label'});
                    if(selectedLine){
                        selectedLine.addClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.addClass('label-hover');
                    }
                }
                event.stopPropagation();
            });

            $(dragSupporter.element).mouseleave( function (event) {   
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                if(selectedLevel){
                    var selectedLine = fibLines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    if(selectedLine){
                        selectedLine.removeClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.removeClass('label-hover');
                    }
                }
                event.stopPropagation();
            });
        })
};

window.infChart = window.infChart || {};

infChart.fib3PointPriceProjectionDrawing = function () {
    this.closeIcon = '<img style = "width : 15px; height : 15px;" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI3LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA1NzYgNTc2IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1NzYgNTc2OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6Izg2ODY4Njt9Cgkuc3Qxe2ZpbGw6I0ZGRkZGRjt9Cjwvc3R5bGU+CjxnPgoJPGcgaWQ9Imljb21vb24taWdub3JlIj4KCTwvZz4KCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0yODgsMS41QzEyOS44LDEuNSwxLjUsMTI5LjgsMS41LDI4OFMxMjkuOCw1NzQuNSwyODgsNTc0LjVTNTc0LjUsNDQ2LjIsNTc0LjUsMjg4UzQ0Ni4yLDEuNSwyODgsMS41eiIvPgoJPHBhdGggY2xhc3M9InN0MSIgZD0iTTMzNC4yLDI4OGw3OS4xLTc5LjFjMTIuOC0xMi44LDEyLjgtMzMuNCwwLTQ2LjJsMCwwYy0xMi44LTEyLjgtMzMuNC0xMi44LTQ2LjIsMEwyODgsMjQxLjhsLTc5LjEtNzkuMQoJCWMtMTIuOC0xMi44LTMzLjQtMTIuOC00Ni4yLDBsMCwwYy0xMi44LDEyLjgtMTIuOCwzMy40LDAsNDYuMmw3OS4xLDc5LjFsLTc5LjEsNzkuMWMtMTIuOCwxMi44LTEyLjgsMzMuNCwwLDQ2LjJsMCwwCgkJYzEyLjgsMTIuOCwzMy40LDEyLjgsNDYuMiwwbDc5LjEtNzkuMWw3OS4xLDc5LjFjMTIuOCwxMi44LDMzLjQsMTIuOCw0Ni4yLDBsMCwwYzEyLjgtMTIuOCwxMi44LTMzLjQsMC00Ni4yTDMzNC4yLDI4OHoiLz4KPC9nPgo8L3N2Zz4K" alt="Close" />';
    infChart.drawingObject.apply(this, arguments);
    this.fibLevels = [
        {
            id: 'level_0',
            value: 0.0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#726a6f',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_1',
            value: 23.6,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#835974',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_2',
            value: 38.2,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#7b6171',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_3',
            value: 50,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f8bce2',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_4',
            value: 61.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f075c3',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_5',
            value: 78.6,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#eb40ab',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_6',
            value: 100,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#c71585',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_7',
            value: 127.2,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#800e56',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_8',
            value: 161.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#4b0832',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_9',
            value: 200,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#726a6f',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_10',
            value: 261.8,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#835974',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_11',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#7b6171',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_12',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f8bce2',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_13',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f075c3',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        }
    ];
    this.settings = {};
    this.defaultDragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', type:'mainDrawing'});
    this.fibLevelDragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', type:'additionalDrawing'});
};

infChart.fib3PointPriceProjectionDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.fib3PointPriceProjectionDrawing.prototype.additionalDrawingsFunction = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];

        var nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true),
            newX = xAxis.toPixels(nearestDataPointForXValue.xData) - xAxis.toPixels(options.xValue);
        var nearestYValue, newY;
        if(futureValue >= nearestDataPointForXValue.xData){
            nearestYValue = infChart.drawingUtils.common.getYValue.call(this, self.getNearestYValue(options.isHLH, true, options.yValue, nearestDataPointForXValue, options.trendXValue,  options.isSnapTopHighLow));
        } else {
            nearestYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.yValue));
        }
        newY = yAxis.toPixels(nearestYValue) - yAxis.toPixels(options.yValue);

    ann.selectionMarker = [];
    infChart.drawingUtils.common.addSelectionMarker.call(this, ann, newX, newY);

    if (options.trendXValue !== Number.MIN_SAFE_INTEGER && options.trendYValue !== Number.MIN_SAFE_INTEGER) {
        var labelAttr = {
                'color': ann.options.shape.params.stroke,
                fontSize: "12px"
            },
            fibLevels = options.fibLevels ? options.fibLevels : this.fibLevels,
            additionalDrawingsArr = self.additionalDrawings,
            fibonacciDrawingsArr = self.fibonacciDrawings,
            theme = infChart.drawingUtils.common.getTheme.call(this),
            drawingFillAttr,
            drawingAttr,
            baseFillOpacity = (theme.fib3PointPriceProjection && typeof theme.fib3PointPriceProjection.fillOpacity !== "undefined") ? theme.fib3PointPriceProjection.fillOpacity : infChart.drawingUtils.common.baseFillOpacity,
            baseFontColor = (theme.fib3PointPriceProjection && typeof theme.fib3PointPriceProjection.fontColor !== "undefined") ? theme.fib3PointPriceProjection.fontColor : infChart.drawingUtils.common.baseFontColor,
            baseFontSize = (theme.fib3PointPriceProjection && typeof theme.fib3PointPriceProjection.fontSize !== "undefined") ? theme.fib3PointPriceProjection.fontSize : infChart.drawingUtils.common.baseFontSize,
            baseFontWeight = (theme.fib3PointPriceProjection && typeof theme.fib3PointPriceProjection.fontWeight !== "undefined") ? theme.fib3PointPriceProjection.fontWeight : infChart.drawingUtils.common.fontWeight;


        additionalDrawingsArr.lines = {};
        fibonacciDrawingsArr.lines = {};
        fibonacciDrawingsArr.fill = {};
        additionalDrawingsArr.hideFibLevelButton = {};

        var nearestDataPointForTrendXValue = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, true, true);
        var nearestTrendYValue;
        if(futureValue >= nearestDataPointForTrendXValue.xData){
            nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, false, options.trendYValue, nearestDataPointForTrendXValue, options.trendXValue,  options.isSnapTopHighLow));
        } else {
            nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.trendYValue));
        }
        additionalDrawingsArr.referenceLine = chart.renderer.path(["M", xAxis.toPixels(nearestDataPointForTrendXValue.xData) - xAxis.toPixels(options.xValue), yAxis.toPixels(nearestTrendYValue) - yAxis.toPixels(options.yValue), 'L', newX, newY]).attr({
            'stroke-width': options.trendLineWidth,
            fill: ann.options.shape.params.fill,
            stroke: ann.options.shape.params.stroke,
            'z-index': 2,
            cursor: 'default',
            opacity: options.trendLineOpacity,
            dashstyle: options.trendLineStyle                                                                                                                        
        }).add(ann.group);

        var hiddenLevels = [];

        // add fill objects first to avoid overlapping lines with and texts with them
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);
        fibLevels.forEach(function (fibLevel) {
            var themeFillColor = theme.fib3PointPriceProjection && theme.fib3PointPriceProjection.fibLevelFillColors && theme.fib3PointPriceProjection.fibLevelFillColors[fibLevel.id];
            if (!fibLevel.enable) {
                hiddenLevels.push(fibLevel.id);
            }
            drawingFillAttr = {
                'stroke-width': 0,
                fill: options.isSingleColor && options.fillColor ? options.fillColor : fibLevel && fibLevel.fillColor ? fibLevel.fillColor : themeFillColor,
                'fill-opacity': options.isSingleColor && options.fillOpacity ? options.fillOpacity : fibLevel && fibLevel.fillOpacity ? fibLevel.fillOpacity : baseFillOpacity,
                stroke: ann.options.shape.params.stroke,
                'z-index': 2,
                cursor: 'default',
                'level': fibLevel.id,
                'pointer-events':'none'
            };
            drawingAttr = {
                'stroke-width': options.isSingleColor && options.lineWidth ? options.lineWidth : fibLevel && fibLevel.lineWidth ? fibLevel.lineWidth : ann.options.shape.params['stroke-width'],
                fill: ann.options.shape.params.fill,
                stroke: options.isSingleColor && options.lineColor ? options.lineColor : fibLevel && fibLevel.lineColor ? fibLevel.lineColor : ann.options.shape.params.stroke,
                'z-index': 2,
                cursor: 'default',
                'level': fibLevel.id
            };

            var fontColor = options.isSingleColor && options.fontColor ? options.fontColor : fibLevel && fibLevel.fontColor ? fibLevel.fontColor : baseFontColor;
            var fontSize = options.isSingleColor && options.fontSize ? options.fontSize :  fibLevel && fibLevel.fontSize ? fibLevel.fontSize : baseFontSize;
            var fontWeight = options.isSingleColor && options.fontWeight ? options.fontWeight : fibLevel && fibLevel.fontWeight ? fibLevel.fontWeight : baseFontWeight;

            labelCSSAttr = {
                'color': fontColor,
                fontSize: fontSize + 'px',
                'font-weight': fontWeight
            };
            labelAttr = {
                'level': fibLevel.id,
                'font-color': fontColor,
                'font-size': fontSize,
                'font-weight': fontWeight
            };
            
            fibonacciDrawingsArr.fill[fibLevel.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0]).attr(drawingFillAttr).add(ann.group);
            additionalDrawingsArr.lines[fibLevel.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingAttr).add(ann.group);
            fibonacciDrawingsArr.lines[fibLevel.id] = chart.renderer.label(infChart.drawingUtils.common.formatValue(fibLevel.value, 1), fibLevel.drawingPosX, fibLevel.drawingPosY).css(labelCSSAttr).attr(labelAttr).add(ann.group);
            additionalDrawingsArr.hideFibLevelButton[fibLevel.id] = chart.renderer.createElement('foreignObject').add(ann.group).attr({
                width: '20',
                height: '20',
                level: fibLevel.id,
                rel: 'hideFibLevelButton',
                cursor: 'pointer'
            });
            var labelHtml = "<div>" + self.closeIcon + "</div>";
            additionalDrawingsArr.hideFibLevelButton[fibLevel.id].element.innerHTML = labelHtml;
            $(additionalDrawingsArr.hideFibLevelButton[fibLevel.id].element).mousedown(function (event) {
                if (event.which == 1 || event.button == 0) {
                    event.stopPropagation();
                    setTimeout(function () {
                        var selectedLevel = event.currentTarget.getAttribute('level');
                        var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(self.annotation.chart);
                        if (selectedLevel) {
                            if (self.isVisibleLastLevel()) {
                                infChart.drawingsManager.removeDrawing(chartId, self.drawingId, undefined, true);
                            } else {
                                infChart.drawingUtils.common.settings.onFibLevelChange.call(self, selectedLevel, false, true, true);
                            }
                        }
                    }, 0);
                }
            });

            additionalDrawingsArr.hideFibLevelButton[fibLevel.id].toFront();

        });

        hiddenLevels.forEach(function (id) {
            infChart.drawingUtils.common.settings.onFibLevelChange.call(self, id, false, false, true);
        });
    }
};

infChart.fib3PointPriceProjectionDrawing.prototype.bindSettingsEvents = function () {
    var self = this;

    var onChangeSnapToHighLow = function (checked, isPropertyChange) {
        self.onChangeSnapToHighLow.call(self, checked, isPropertyChange);
    };

    var onTrendLineToggleShow = function (show) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onTrendLineToggleShow.call(self, show, isPropertyChange);
    };

    return infChart.drawingUtils.common.bindFibSettingsEvents.call(this, infChart.drawingUtils.common.baseBorderColor, infChart.drawingUtils.common.baseLineWidth, undefined, undefined, onChangeSnapToHighLow, onTrendLineToggleShow);
};

infChart.fib3PointPriceProjectionDrawing.prototype.deselect = function (isMouseOut) {
    infChart.drawingUtils.common.onDeselect.call(this);
    this.annotation.options.selectedDrawing = undefined;
    if (isMouseOut) {
        if (this.annotation) {
            if (this.annotation.options && !this.annotation.options.isTrendLineAlways) {
                this.annotation.shape.hide();
            }
            if (this.additionalDrawings && this.additionalDrawings.referenceLine) {
                if (this.annotation.options && !this.annotation.options.isTrendLineAlways) {
                    this.additionalDrawings.referenceLine.hide();
                    this.resetDragSupporters();
                }
            }
            this.toggleFibLevelEraseIcon(true);
        }
    }
};

infChart.fib3PointPriceProjectionDrawing.prototype.toggleFibLevelEraseIcon = function (hide) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        fibonacciDrawings = self.fibonacciDrawings.lines,
        chart = ann.chart,
        line = ann.shape.d.split(' '),
        dx = line[4],
        xAxis = chart.xAxis[options.xAxis];

    if (hide) {
        if(self.additionalDrawings.hideFibLevelButton){
            $.each(self.additionalDrawings.hideFibLevelButton, function (key, value) {
                var hideFibLevelButton = self.additionalDrawings.hideFibLevelButton[key];
                hideFibLevelButton.hide();
            });
        }
    } else {
        $.each(self.additionalDrawings.lines, function (key, value) {
            if (self.additionalDrawings.lines[key].visibility !== "hidden") {
                var hideFibLevelButton = self.additionalDrawings.hideFibLevelButton[key];
                var drawingLabel = fibonacciDrawings[key];
                var labelStartPosition = xAxis.toValue(xAxis.width) > Math.min(options.xValue, options.xValueEnd) ? (xAxis.width - xAxis.toPixels(ann.options.xValue)) : dx > 0 ? dx : 0;
                self.positionHideIcon(hideFibLevelButton, labelStartPosition, drawingLabel, value.d.split(' ')[5]);
                hideFibLevelButton.show();
            }
        });
    }
};

infChart.fib3PointPriceProjectionDrawing.prototype.getConfig = function (shape) {
    var self = this,
        shape = self.shape,
        annotation = self.annotation,
        options = annotation.options,
        fibLevels = options.fibLevels ? options.fibLevels : self.fibLevels;
    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);

    return {
        shape: shape,
        fibLevels: fibLevels,
        borderColor: annotation.options.lineColor,
        fillColor: annotation.options.fillColor,
        fillOpacity: annotation.options.fillOpacity,
        strokeWidth: annotation.options.lineWidth,
        fontColor: annotation.options.fontColor,
        fontSize: annotation.options.fontSize,
        fontWeight: annotation.options.fontWeight,
        trendXValue: annotation.options.trendXValue,
        trendYValue: annotation.options.trendYValue,
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        isSingleColor: annotation.options.isSingleColor,
        isHLH: annotation.options.isHLH,
        isSnapTopHighLow: annotation.options.isSnapTopHighLow,
        isTrendLineAlways: annotation.options.isTrendLineAlways,
        trendLineColor: annotation.options.trendLineColor,
        trendLineOpacity: annotation.options.trendLineOpacity,
        trendLineWidth: annotation.options.trendLineWidth,
        trendLineStyle: annotation.options.trendLineStyle,
        isLocked : annotation.options.isLocked

    };
};

infChart.fib3PointPriceProjectionDrawing.prototype.getContextMenuOptions = function (chartId, drawingId, options , event) {
    var self = this;
    var level = event.target.getAttribute('level');
    if(!level && event.target.parentElement){
        level = event.target.parentElement.getAttribute('level');
        if(!level && event.target.parentElement.parentElement){
            level = event.target.parentElement.parentElement.getAttribute('level');
        }
    }
    var contextMenu = {
        "copyToClipboard" : {
            icon : options.copyToClipboard.icon,
            displayText : options.copyToClipboard.displayText,
            action : function () {
                if(level) {
                    infChart.drawingUtils.common.onFibLevelCopy.call(self, level);
                }
            }
        }
    };

    if (!self.isVisibleLastLevel()) {
        var eraseThis = {
            icon: options.erase.icon,
            displayText: options.erase.displayText,
            action: function () {
                if (level) {
                    infChart.drawingUtils.common.settings.onFibLevelChange.call(self, level, false, true, true);
                }
            }
        }
        contextMenu["eraseThis"] = eraseThis;
    }
    if(level) {
        contextMenu = Object.assign(contextMenu, infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options));
        return infChart.drawingUtils.common.reorderContextMenu(contextMenu);
    }else{
        return  infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options)
    }
};

infChart.fib3PointPriceProjectionDrawing.prototype.getFormattedLabel = function (yAxis, yValue, trendYValue, yValueEnd, percentage, stockChart) {
    var percentageValue = percentage/100;
    var labelYValue = yValue > trendYValue ? yValueEnd + (yValue - trendYValue) * percentageValue : yValueEnd - (trendYValue - yValue) * percentageValue;
    var formatedLabelYValue = stockChart.formatValue(labelYValue, stockChart.getMainSeries().options.dp, undefined, false, false, NO_OF_SPECIFIC_DECIMAL_POINTS);
    return formatedLabelYValue + (percentageValue === 0 ? " ": "PP") + " " + infChart.drawingUtils.common.formatValue(percentageValue, 3);
};

infChart.fib3PointPriceProjectionDrawing.prototype.getNearestYValue = function (isHLH, isLineStartYValue, referredYValue, nearestDataPoint, trendYValue, isSnapTopHighLow, chart) {
    var nearestYValue = referredYValue;
    if(!chart){
        chart = this.annotation.chart;
    }
    if (!isSnapTopHighLow) {
        var nearestReturnYValue = nearestYValue;
        var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart);
        var chartInstance = infChart.manager.getChart(stockChartId);
        if (chartInstance.isCompare || chartInstance.isLog) {
            nearestReturnYValue = infChart.drawingUtils.common.getBaseYValue.call(this, nearestYValue);
        }
        return nearestReturnYValue;
    }

    if (trendYValue && trendYValue !== Number.MIN_SAFE_INTEGER) {
        if (isHLH) {
            if (isLineStartYValue) {
                nearestYValue = nearestDataPoint.yData[2];
            } else {
                nearestYValue = nearestDataPoint.yData[1];
            }
        } else {
            if (isLineStartYValue) {
                nearestYValue = nearestDataPoint.yData[1];
            } else {
                nearestYValue = nearestDataPoint.yData[2];
            }
        }
    } else {
        if (isHLH) {
            if (isLineStartYValue) {
                nearestYValue = nearestDataPoint.yData[1];
            } else {
                nearestYValue = nearestDataPoint.yData[2];
            }
        } else {
            if (isLineStartYValue) {
                nearestYValue = nearestDataPoint.yData[2];
            } else {
                nearestYValue = nearestDataPoint.yData[1];
            }
        }
    }

    return nearestYValue;
};

infChart.fib3PointPriceProjectionDrawing.prototype.getOptions = function (properties, chart, isHLH) {
    var isHLH = (this.shape == 'fib3PointPriceProjectionHLH') ? true : false ;
    var futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];
    var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, properties.xValue, undefined, true, true);
    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        nearestXValue: nearestDataForXValue.xData,
        trendXValue: Number.MIN_SAFE_INTEGER,
        trendYValue: Number.MIN_SAFE_INTEGER,
        allowDragX: true,
        allowDragY: true,
        allowDragByHandle: true,
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0]
            }
        },
        isHLH: isHLH
    };

    var theme = infChart.drawingUtils.common.getTheme.call(this);
    var shapeTheme = theme["fib3PointPriceProjection"];
    var baseFillColor = (theme.fib3PointPriceProjection && theme.fib3PointPriceProjection.singleFillColor) ? theme.fib3PointPriceProjection.singleFillColor : (theme.fibonacci && theme.fibonacci.singleFillColor) ? theme.fibonacci.singleFillColor : infChart.drawingUtils.common.baseFillColor;
    var baseFillOpacity = (theme.fib3PointPriceProjection && typeof theme.fib3PointPriceProjection.fillOpacity !== "undefined") ? theme.fib3PointPriceProjection.fillOpacity : (theme.fibonacci && typeof theme.fibonacci.fillOpacity !== "undefined") ? theme.fibonacci.fillOpacity : infChart.drawingUtils.common.baseFillOpacity;
    var baseBorderColor = (theme.fib3PointPriceProjection && theme.fib3PointPriceProjection.borderColor) ? theme.fib3PointPriceProjection.borderColor : (theme.fibonacci && theme.fibonacci.borderColor) ? theme.fibonacci.borderColor : infChart.drawingUtils.common.baseBorderColor;
    var baseLineWidth = (theme.fib3PointPriceProjection && typeof theme.fib3PointPriceProjection.lineWidth !== "undefined") ? theme.fib3PointPriceProjection.lineWidth : (theme.fibonacci && theme.fibonacci.lineWidth) ? theme.fibonacci.lineWidth : infChart.drawingUtils.common.baseLineWidth;
    var baseFontColor = (theme.fib3PointPriceProjection && theme.fib3PointPriceProjection.fontColor) ? theme.fib3PointPriceProjection.fontColor: (theme.fibonacci && theme.fibonacci.fontColor) ? theme.fibonacci.fontColor : infChart.drawingUtils.common.baseFontColor;
    var baseFontSize = (theme.fib3PointPriceProjection && theme.fib3PointPriceProjection.fontSize) ? theme.fib3PointPriceProjection.fontSize: (theme.fibonacci && theme.fibonacci.fontSize) ? theme.fibonacci.fontSize : infChart.drawingUtils.common.baseFontSize;
    var baseFontWeight = (theme.fib3PointPriceProjection && theme.fib3PointPriceProjection.fontWeight) ? theme.fib3PointPriceProjection.fontWeight: (theme.fibonacci && theme.fibonacci.fontWeight) ? theme.fibonacci.fontWeight : infChart.drawingUtils.common.baseFontWeight;

    options.fillColor = properties.fillColor ? properties.fillColor : baseFillColor;
    options.fillOpacity = properties.fillOpacity ? properties.fillOpacity : baseFillOpacity;
    options.lineColor = properties.borderColor ? properties.borderColor : baseBorderColor;
    options.lineWidth = properties.strokeWidth ? properties.strokeWidth : baseLineWidth;
    options.fontColor = properties.fontColor ? properties.fontColor : baseFontColor;
    options.fontSize = properties.fontSize ? properties.fontSize : baseFontSize;
    options.fontWeight = properties.fontWeight ? properties.fontWeight : baseFontWeight;
    options.trendLineColor = properties.trendLineColor ? properties.trendLineColor : shapeTheme.stroke || "#959595";
    options.trendLineOpacity = properties.trendLineOpacity ? properties.trendLineOpacity : shapeTheme.opacity || 1;
    options.trendLineWidth = properties.trendLineWidth ? properties.trendLineWidth : baseLineWidth || 1;
    options.trendLineStyle = properties.trendLineStyle ? properties.trendLineStyle : shapeTheme.dashstyle || 'solid';

    options.shape.params.fill = options.fillColor;
    options.shape.params['fill-opacity'] = options.fillOpacity;
    options.shape.params.stroke = options.trendLineColor;
    options.shape.params.opacity =  options.trendLineOpacity;
    options.shape.params['stroke-width'] = options.trendLineWidth;
    options.shape.params.dashstyle = options.trendLineStyle;
    options.shape.params['font-color'] = options.fontColor;
    options.shape.params['font-size'] = options.fontSize;
    options.showSnapToHighLowToggle = true;
    options.showTrendLineAlwaysToggle = true;
    options.isSnapTopHighLow = typeof properties.isSnapTopHighLow !== "undefined" ? properties.isSnapTopHighLow : false;
    options.isTrendLineAlways = typeof properties.isTrendLineAlways !== "undefined" ? properties.isTrendLineAlways : true;
    if(futureValue >= options.nearestXValue){
        options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(isHLH, true, properties.yValue, nearestDataForXValue, properties.trendYValue,  properties.isSnapTopHighLow, chart));
    } else {
        options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, properties.yValue));
    }
    options.yValue = options.nearestYValue;

    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
        var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, properties.xValueEnd, undefined, true, true);
        options.nearestXValueEnd = nearestDataForXValueEnd.xData;
        if(futureValue >= options.nearestXValueEnd){
            options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(isHLH, false, properties.yValueEnd, nearestDataForXValueEnd, properties.trendYValue, properties.isSnapTopHighLow, chart));
        } else {
            options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, properties.yValueEnd));
        }
        options.yValueEnd = options.nearestYValueEnd;
    }

    if (properties.trendXValue && properties.trendYValue) {
        options.trendXValue = properties.trendXValue;
        options.trendYValue = properties.trendYValue;

        var nearestDataForTrendXValue = infChart.math.findNearestDataPoint(chart, properties.trendXValue, undefined, true, true);
        options.nearestTrendXValue = nearestDataForTrendXValue.xData;
        if(futureValue >= options.nearestTrendXValue){
            options.nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this,this.getNearestYValue(options.isHLH, false, options.trendYValue, nearestDataForTrendXValue, options.trendXValue, properties.isSnapTopHighLow, chart));
        } else {
            options.nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.trendYValue));
        }
        options.trendYValue = options.nearestTrendYValue;
    } else {
        options.events = null;
    }

    options.isSingleColor = typeof properties.isSingleColor !== "undefined" ? properties.isSingleColor : false;
    options.fibLevels = properties.fibLevels ? properties.fibLevels : this.fibLevels;
    options.fibLevels = infChart.drawingUtils.common.getFibLevelsWithOpacity(infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels), baseFillOpacity);
    options.isRealTimeTranslation = true;
    options.disableIntermediateScale = true;
    options.validateTranslationFn = function (newXValue) {
        var annotation = this.annotation,
            chart = annotation.chart,
            options = annotation.options,
            xVal = options.xValue,
            xValEnd = options.xValueEnd,
            newXValueEnd = xValEnd - xVal + newXValue,
            newTrendXValueEnd = options.trendXValue - xVal + newXValue,
            xAxis = chart.xAxis[options.xAxis],
            seriesData = chart.series[0].xData,
            dataMin = seriesData[0],
            totalPoints = infChart.drawingsManager.getTotalPoints(chart),
            dataMax = totalPoints[totalPoints.length - 1];

        return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax) && (newTrendXValueEnd >= dataMin && newTrendXValueEnd <= dataMax) && (options.selectedDrawing == "mainDrawing");
    }

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.fib3PointPriceProjectionDrawing.prototype.getQuickSettingsPopup = function () {
    var self = this;
    var options = self.annotation.options;
    var fillColor = options.fillColor;
    var fillOpacity = options.fillOpacity;
    var lineColor = options.lineColor;
    var fontColor = options.fontColor;
    var fontSize = options.fontSize;
    var fontWeight = options.fontWeight;
    return infChart.drawingUtils.common.getFibQuickSettings(fillColor, fillOpacity, lineColor, fontColor, fontSize);
};

infChart.fib3PointPriceProjectionDrawing.prototype.getSettingsPopup = function () {
    var self = this;
    var options = self.annotation.options;
    var fibLevels = options.fibLevels ? options.fibLevels : self.fibLevels;
    var properties = {
        fillColor: options.fillColor,
        fillOpacity: options.fillOpacity,
        lineColor: options.lineColor,
        lineWidth: options.lineWidth,
        fontColor: options.fontColor,
        fontSize: options.fontSize,
        fontWeight: options.fontWeight,
        fibLevels: fibLevels,
        showFibModeToggle: false,
        templates: self.getDrawingTemplates(),
        userDefaultSettings: self.getUserDefaultSettings(),
        showSnapToHighLowToggle: options.showSnapToHighLowToggle,
        showTrendLineAlwaysToggle: options.showTrendLineAlwaysToggle,
        trendLineColor: options.trendLineColor,
        trendLineOpacity: options.trendLineOpacity,
        trendLineWidth: options.trendLineWidth,
        trendLineStyle: options.trendLineStyle
    }

    return infChart.drawingUtils.common.getFibSettings(properties);
};

/**
 * on snap to high/low change
 * @param {boolean} checked - snap to high/low checked
 * @param {boolean} isPropertyChange - is propery changed
 * @param {boolean} ignoreSettingsSave - this is to indicate to this change does not affect to subsequent drawing
 */
infChart.fib3PointPriceProjectionDrawing.prototype.onChangeSnapToHighLow = function (checked, isPropertyChange, ignoreSettingsSave) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart;

    options.isSnapTopHighLow = checked;
    // var futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];
    // if (options.isSnapTopHighLow) {
    //     var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
    //     var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);
    //     var nearestDataPointForTrendXValue = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, true, true);
    //     if(futureValue >= nearestDataPointForTrendXValue.xData){
    //         options.nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, false, options.trendYValue, nearestDataPointForTrendXValue, options.trendXValue,  options.isSnapTopHighLow));
    //     } else {
    //         options.nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.nearestTrendYValue));
    //     }
    //     if(futureValue >= nearestDataForXValue.xData){
    //         options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, true, self.nearestYValue, nearestDataForXValue, options.trendXValue, options.isSnapTopHighLow));
    //     } else {
    //         options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.nearestYValue));
    //     }
    //     if(futureValue >= nearestDataForXValueEnd.xData){
    //         options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, false, self.nearestYValueEnd, nearestDataForXValueEnd, options.trendXValue, options.isSnapTopHighLow));
    //     } else {
    //         options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.nearestYValueEnd));
    //     }
    // } else {
    //     options.nearestYValue = options.yValue;
    //     options.nearestYValueEnd = options.yValueEnd;
    //     options.nearestTrendYValue = options.trendYValue;
    // }

    // infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd);

    // self.scale();
    // self.selectAndBindResize();
    // chart.selectedAnnotation = ann;
    // self.updateSettings( self.getConfig());
    isPropertyChange && self.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionDrawing.prototype.moveStartPoint = function (e) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id)),
        options = ann.options,
        x = e.chartX,
        y = e.chartY,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        fibonacciDrawings = self.fibonacciDrawings.lines,
        fibonacciDrawingsFill = self.fibonacciDrawings.fill,
        lineDrawings = self.additionalDrawings.lines,
        fibLevels = ann.options.fibLevels ? ann.options.fibLevels : this.fibLevels,
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels),
        pathDefinition = ann.shape.d.split(' '),
        dx = parseFloat(pathDefinition[4]),
        dy = parseFloat(pathDefinition[5]),
        futureValue = chart.series[0].xData[chart.series[0].xData.length - 1],
        nearestDataPointForTrendXValue = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, true, true);
        var nearestTrendYValue;

        if(options.isSnapTopHighLow) {
            if(futureValue >= nearestDataPointForTrendXValue.xData){
                nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this,this.getNearestYValue(options.isHLH, false, options.trendYValue, nearestDataPointForTrendXValue, options.trendXValue,  options.isSnapTopHighLow));
            } else {
                nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.trendYValue));
            }
        } else {
            nearestTrendYValue = yAxis.toValue(y);
        }

    ann.update({
        trendXValue: xAxis.toValue(x),
        trendYValue: nearestTrendYValue,
        nearestTrendXValue: nearestDataPointForTrendXValue.xData
    });

    self.additionalDrawings.referenceLine.attr({
        d: ["M", xAxis.toPixels(nearestDataPointForTrendXValue.xData) - xAxis.toPixels(options.xValue), yAxis.toPixels(nearestTrendYValue) - yAxis.toPixels(options.yValue), 'L', pathDefinition[1], pathDefinition[2]]
    });

    $.each(lineDrawings, function (key, value) {
        var fibLevel = fibLevels.find(function (level) {
            return level.id === key;
        });
        var percentage = parseFloat(fibLevel.value);
        var percentageY = -((yAxis.toPixels(nearestTrendYValue) - yAxis.toPixels(options.nearestYValue)) * percentage / 100) + dy;
        var lineEndPosition = (xAxis.width - xAxis.toPixels(ann.options.xValue));
        var drawingLabel = fibonacciDrawings[key];
        var hideFibLevelButton = self.additionalDrawings.hideFibLevelButton[key];
        var line = ["M", dx, percentageY, 'L', lineEndPosition, percentageY];

        value.attr({
            d: line
        });

        drawingLabel.textSetter(self.getFormattedLabel(yAxis, options.nearestYValue, nearestTrendYValue, options.nearestYValueEnd, percentage, stockChart));

        drawingLabel.attr({
            x: lineEndPosition - drawingLabel.width,
            y: percentageY - drawingLabel.height
        });

        self.positionHideIcon(hideFibLevelButton, lineEndPosition, drawingLabel, percentageY);
    });

    fibLevels.forEach(function (value, index, arr) {
        fill = fibonacciDrawingsFill && fibonacciDrawingsFill[value.id];
        currentLine = lineDrawings[value.id];
        currentLineP = currentLine && currentLine.d.split(' ');

        for (var i = index + 1; i < arr.length; i++) {
            var lineTemp = lineDrawings[arr[i].id];
            if (lineTemp && lineTemp.visibility != "hidden") {
                nextLine = lineTemp;
                break;
            }
        }
        nextLineP = nextLine && nextLine.d.split(' ');
        if (currentLine && nextLine) {
            fill.attr({
                d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
            });
        }
        nextLine = undefined;
    });

    return {line: pathDefinition, nearestTrendYValue: nearestTrendYValue};
};

infChart.fib3PointPriceProjectionDrawing.prototype.scale = function (isCalculateNewValueForScale) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        stockChart,
        line = ann.shape.d.split(' '),
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        plotWidth = chart.plotWidth * infChart.drawingUtils.common.correctionFactor,
        fibonacciDrawings = self.fibonacciDrawings.lines,
        fibLevels = options.fibLevels ? options.fibLevels : this.fibLevels,
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels),
        fibonacciDrawingsFill = self.fibonacciDrawings.fill,
        lineDrawings = self.additionalDrawings.lines,
        stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart),
        chartInstance = infChart.manager.getChart(stockChartId),
        futureValue = chart.series[0].xData[chart.series[0].xData.length - 1],
        fill,
        currentLine,
        currentLineP,
        nextLine,
        nextLineId,
        nextLineP,
        xValueInPixels = xAxis.toPixels(options.xValue),
        yValueInPixels = yAxis.toPixels(options.yValue),
        stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id)),
        fibLevelLines = {};

        if (isCalculateNewValueForScale) {
            nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
            options.nearestXValue = nearestDataForXValue.xData;
            nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);
            options.nearestXValueEnd = nearestDataForXValueEnd.xData;
            nearestDataPointForTrendXValue = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, true, true);
            options.nearestTrendXValue = nearestDataPointForTrendXValue.xData;

        if(futureValue >= options.nearestXValue){
            options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, true, options.yValue, nearestDataForXValue, options.trendXValue, false));
        } else {
            options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValue.call(this, options.nearestYValue));
        }
        if(futureValue >= options.nearestXValueEnd){
            options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, false, options.yValueEnd, nearestDataForXValueEnd, options.trendXValue, false));
        } else {
            options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValue.call(self, options.nearestYValueEnd));
        }
        if(futureValue >= options.nearestTrendXValue){
            options.nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this,this.getNearestYValue(options.isHLH, false, options.trendYValue, nearestDataPointForTrendXValue, options.trendXValue,  false));
        } else {
            options.nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValue.call(self, options.trendYValue));
        }

        if (chartInstance.isLog || chartInstance.isCompare) {
            self.nearestYValue = infChart.drawingUtils.common.getBaseYValue.call(self, options.nearestYValue);
            self.nearestYValueEnd = infChart.drawingUtils.common.getBaseYValue.call(self, options.nearestYValueEnd);
                self.nearestTrendYValue = infChart.drawingUtils.common.getBaseYValue.call(self, options.nearestTrendYValue);
        } else {
            self.nearestYValue = options.nearestYValue;
            self.nearestYValueEnd = options.nearestYValueEnd;
            self.nearestTrendYValue = options.nearestTrendYValue;
        }
    }

    var newX = xAxis.toPixels(options.nearestXValue) - xValueInPixels,
        newXEnd = xAxis.toPixels(options.nearestXValueEnd) - xValueInPixels,
        newY = yAxis.toPixels(options.yValue) - yValueInPixels,
        newYEnd = yAxis.toPixels(options.yValueEnd) - yValueInPixels;

    line[1] = (!isNaN(newX) && newX) || 0;
    line[2] = (!isNaN(newY) && newY) || 0;
    line[4] = (!isNaN(newXEnd) && newXEnd) || 0;
    line[5] = (!isNaN(newYEnd) && newYEnd) || 0;

    ann.update({
        shape: {
            params: {
                d: line
            }
        }
    });

    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    if (ann.shape.visibility !== "hidden") {
        infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, undefined, self.defaultDragSupporterStyles);
    }
    if(self.additionalDrawings && self.additionalDrawings.referenceLine){
        var referenceLine = self.additionalDrawings.referenceLine.d.split(' ');
        if(self.additionalDrawings.referenceLine.visibility !== "hidden"){
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', referenceLine[1], referenceLine[2], 'L', referenceLine[4], referenceLine[5]], self.dragSupporters, undefined, self.defaultDragSupporterStyles);
        }
    }

    var dx = line[4], dy = line[5];

    if (lineDrawings) {
        self.additionalDrawings.referenceLine.attr({
            d: ["M", xAxis.toPixels(options.nearestTrendXValue) - xValueInPixels, yAxis.toPixels(options.trendYValue) - yValueInPixels, 'L', newX, newY]
        });
        var lineStartPosition = newXEnd;
        var lineEndPosition = xAxis.toValue(xAxis.width) > Math.min(options.xValue, options.xValueEnd) ? (xAxis.width - xAxis.toPixels(ann.options.xValue)) : dx > 0 ? dx : 0;
        var lineWidthInPixels = (yAxis.toPixels(options.trendYValue) - yAxis.toPixels(options.yValue));

        $.each(lineDrawings, function (key, value) {
            var fibLevel = fibLevels.find(function (level) {
                return level.id === key;
            });
            var percentage = parseFloat(fibLevel.value);
            var percentageY = -(lineWidthInPixels * percentage / 100) + dy;
            var drawingLabel = fibonacciDrawings[key];
            var line = ["M", lineStartPosition, percentageY, 'L', lineEndPosition, percentageY];
            fibLevelLines[key] = line;

            value.attr({
                d: line
            });

            drawingLabel.textSetter(self.getFormattedLabel(yAxis, options.yValue, options.trendYValue, options.yValueEnd, percentage, stockChart));

            drawingLabel.attr({
                x: lineEndPosition - drawingLabel.width,
                y: percentageY - drawingLabel.height
            });

            if(chart.selectedAnnotation && chart.selectedAnnotation.options.id === options.id) {
                self.positionHideIcon(self.additionalDrawings.hideFibLevelButton[key], lineEndPosition, drawingLabel, percentageY);
            }

            if(value.visibility !== 'hidden'){
                var customAttributes = {
                    'level' : key,
                    'visibility':lineDrawings[key].visibility,
                    'stroke-width': 10
                }
                infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
            }
        });

        self.highlightEachLine();

        fibLevels.forEach(function (value, index, arr) {
            fill = fibonacciDrawingsFill && fibonacciDrawingsFill[value.id];
            currentLine = lineDrawings[value.id];
            currentLineP = currentLine && fibLevelLines[value.id];

            for (var i = index + 1; i < arr.length; i++) {
                var lineTemp = lineDrawings[arr[i].id];
                if (lineTemp && lineTemp.visibility != "hidden") {
                    nextLine = lineTemp;
                nextLineId = arr[i].id;
                    break;
                }
            }
            nextLineP = nextLine && fibLevelLines[nextLineId];
            if (currentLine && nextLine) {
                fill.attr({
                    d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
                });
            }
            nextLine = undefined;
        });
    }
};

infChart.fib3PointPriceProjectionDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation,
        pathDefinition, width, height, referenceLine = this.additionalDrawings.referenceLine;

    ann.events.deselect.call(ann);
    ann.shape.show();
    if(referenceLine){
        referenceLine.show();
    }
    this.toggleFibLevelEraseIcon(false);
    ann.selectionMarker = [];
    pathDefinition = ann.shape.d.split(' ');
    width = parseFloat(pathDefinition[4]);
    height = parseFloat(pathDefinition[5]);

    var chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];

    this.resetDragSupporters();
    if (!isNaN(width) && !isNaN(height)) {
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, parseFloat(pathDefinition[1]), parseFloat(pathDefinition[2]), this.stepFunction, this.stop, true);
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, width, height, this.stepFunction, this.stop, false);
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, xAxis.toPixels(options.nearestTrendXValue) - xAxis.toPixels(options.xValue), yAxis.toPixels(options.trendYValue) - yAxis.toPixels(options.yValue), this.moveStartPoint, this.updateMoveStartPoint, true);
    }
};

infChart.fib3PointPriceProjectionDrawing.prototype.setNearestYValues = function (options, chart) {
    var self = this;
    var isHLH = (self.shape === 'fib3PointPriceProjectionHLH');
    var futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];
    var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
    if(futureValue >= nearestDataForXValue.xData){
        self.nearestYValue = self.getNearestYValue(isHLH, true, options.yValue, nearestDataForXValue, options.trendYValue, options.isSnapTopHighLow, chart);
    } else {
        self.nearestYValue = options.yValue;
    }

    var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);
    if(futureValue >= nearestDataForXValueEnd.xData){
        self.nearestYValueEnd = self.getNearestYValue(isHLH, false, options.yValueEnd, nearestDataForXValueEnd, options.trendYValue, options.isSnapTopHighLow, chart);
    } else {
        self.nearestYValueEnd = options.yValueEnd;
    }

    var nearestDataPointForTrendXValue = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, true, true);
    if(futureValue >= nearestDataPointForTrendXValue.xData){
        self.nearestTrendYValue = this.getNearestYValue(options.isHLH, false, options.trendYValue, nearestDataPointForTrendXValue, options.trendXValue,  options.isSnapTopHighLow, chart);
    } else {
        self.nearestYValueEnd = options.trendYValue;
    }
};

infChart.fib3PointPriceProjectionDrawing.prototype.resetDragSupporters = function(){
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        line = ann.shape.d.split(' ');
    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    if (ann.shape.visibility !== "hidden") {
        infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, undefined, self.defaultDragSupporterStyles);
    }
    if (self.additionalDrawings && self.additionalDrawings.referenceLine && self.additionalDrawings.referenceLine.visibility !== "hidden") {
        var referenceLine = self.additionalDrawings.referenceLine.d.split(' ');
        infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', referenceLine[1], referenceLine[2], 'L', referenceLine[4], referenceLine[5]], self.dragSupporters, undefined, self.defaultDragSupporterStyles);
    }

    $.each(self.additionalDrawings.lines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'visibility':self.additionalDrawings.lines[key].visibility,
                'stroke-width': 10
            }
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
        }
    });
    self.highlightEachLine();
};

infChart.fib3PointPriceProjectionDrawing.prototype.positionHideIcon = function (hideFibLevelButton, lineEndPosition, drawingLabel, percentageY) {
    hideFibLevelButton.attr({
        x: lineEndPosition - drawingLabel.width - hideFibLevelButton.getBBox().width - 5,
        y: percentageY - hideFibLevelButton.getBBox().height
    });
};

infChart.fib3PointPriceProjectionDrawing.prototype.step = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id)),
        points = infChart.drawingUtils.common.calculateInitialPoints(e, ann, isStartPoint, 0, 0),
        options = ann.options,
        plotWidth = chart.plotWidth * infChart.drawingUtils.common.correctionFactor,
        fibonacciDrawings = self.fibonacciDrawings.lines,
        fibLevels = options.fibLevels ? options.fibLevels : this.fibLevels,
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels),
        fibonacciDrawingsFill = self.fibonacciDrawings.fill,
        lineDrawings = self.additionalDrawings.lines,
        fill,
        currentLine,
        currentLineP,
        nextLine,
        nextLineP,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        xValueEnd = xAxis.toValue(xAxis.toPixels(options.xValue) + points.dx),
        yValueEnd = yAxis.toValue(yAxis.toPixels(options.yValue) + points.dy),
        nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true),
        nearestXValue = nearestDataPointForXValue.xData,
        nearestDataPointForXValueEnd = infChart.math.findNearestDataPoint(chart, xValueEnd, undefined, true, true),
        nearestXValueEnd = nearestDataPointForXValueEnd.xData,
        newX = xAxis.toPixels(nearestXValue) - xAxis.toPixels(options.xValue),
        newXEnd = xAxis.toPixels(nearestXValueEnd) - xAxis.toPixels(options.xValue);
        var futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];
        var nearestYValue, nearestYValueEnd;

        if(options.isSnapTopHighLow){
            if (isStartPoint) {
                if(futureValue >= nearestXValue){
                    nearestYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, true, options.yValue, nearestDataPointForXValue, options.trendXValue,  options.isSnapTopHighLow));
                } else {
                    nearestYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue));
                }
                ann.update({
                    yValue: nearestYValue
                });
                nearestYValueEnd = yValueEnd;
            } else {
                if(futureValue >= nearestXValueEnd){
                    nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, false, yValueEnd, nearestDataPointForXValueEnd, options.trendXValue,  options.isSnapTopHighLow));
                } else {
                    nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(self, yValueEnd));
                }
                ann.update({
                    yValueEnd: nearestYValueEnd
                });
                nearestYValue = options.yValue;
            }
        } else {
            nearestYValue = options.yValue;
            nearestYValueEnd = yValueEnd;
        }
        // var newY = yAxis.toPixels(nearestYValue) - yAxis.toPixels(options.yValue),
        var newYEnd = yAxis.toPixels(nearestYValueEnd) - yAxis.toPixels(nearestYValue),
            nearestDataPointForTrendXValue,
            nearestTrendYValue;

    var drawingLine = ["M", newX, 0, 'L', parseInt(newXEnd, 10), parseInt(newYEnd, 10)];

    ann.shape.attr({
        d: drawingLine
    });

    if (lineDrawings) {
        nearestDataPointForTrendXValue = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, true, true);
        if (!isStartPoint) {
            if(futureValue >= nearestDataPointForTrendXValue.xData){
                nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, false, options.trendYValue, nearestDataPointForTrendXValue, options.trendXValue,  options.isSnapTopHighLow));
            } else {
                nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(self, options.trendYValue));
            }
        } else {
            nearestTrendYValue = options.trendYValue
        }

        self.additionalDrawings.referenceLine.attr({
            d: ["M", xAxis.toPixels(nearestDataPointForTrendXValue.xData) - xAxis.toPixels(options.xValue), yAxis.toPixels(self.annotation.options.trendYValue) - yAxis.toPixels(self.annotation.options.yValue), 'L', newX, 0]
        });

        $.each(lineDrawings, function (key, value) {
            var fibLevel = fibLevels.find(function (level) {
                return level.id === key;
            });
            var percentage = parseFloat(fibLevel.value);
            var percentageY = -((yAxis.toPixels(nearestTrendYValue) - yAxis.toPixels(nearestYValue)) * percentage / 100) + drawingLine[5];
            var lineStartPosition = newXEnd;
            var lineEndPosition = (xAxis.width - xAxis.toPixels(ann.options.xValue));
            var drawingLabel = fibonacciDrawings[key];
            var hideFibLevelButton = self.additionalDrawings.hideFibLevelButton[key];
            var line = ["M", lineStartPosition, percentageY, 'L', lineEndPosition, percentageY];

            value.attr({
                d: line
            });

            drawingLabel.textSetter(self.getFormattedLabel(yAxis, nearestYValue, nearestTrendYValue, nearestYValueEnd, percentage, stockChart));

            drawingLabel.attr({
                x: lineEndPosition - drawingLabel.width,
                y: percentageY - drawingLabel.height
            });

            self.positionHideIcon(hideFibLevelButton, lineEndPosition, drawingLabel, percentageY);
        });

        fibLevels.forEach(function (value, index, arr) {
            fill = fibonacciDrawingsFill && fibonacciDrawingsFill[value.id];
            currentLine = lineDrawings[value.id];
            currentLineP = currentLine && currentLine.d.split(' ');

            for (var i = index + 1; i < arr.length; i++) {
                var lineTemp = lineDrawings[arr[i].id];
                if (lineTemp && lineTemp.visibility != "hidden") {
                    nextLine = lineTemp;
                    break;
                }
            }
            nextLineP = nextLine && nextLine.d.split(' ');
            if (currentLine && nextLine) {
                fill.attr({
                    d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
                });
            }
            nextLine = undefined;
        });
    }

    return {
        line: drawingLine,
        points: points,
        nearestXValue: nearestXValue,
        nearestXValueEnd: nearestXValueEnd,
        nearestTrendXValue: nearestDataPointForTrendXValue ? nearestDataPointForTrendXValue.xData : Number.MIN_SAFE_INTEGER,
        nearestYValue: nearestYValue,
        nearestYValueEnd: nearestYValueEnd,
        nearestTrendYValue: nearestTrendYValue
    };
};

infChart.fib3PointPriceProjectionDrawing.prototype.stop = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        lineData = this.stepFunction(e, isStartPoint),
        line = lineData.line,
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        x = xAxis.toValue(lineData.points.dx + xAxis.toPixels(ann.options.xValue)),
        y = yAxis.toValue(lineData.points.dy + yAxis.toPixels(ann.options.yValue));

    // if (options.isSnapTopHighLow) {
        line[2] = 0;
        line[5] = yAxis.toPixels(lineData.nearestYValueEnd) - yAxis.toPixels(lineData.nearestYValue);
        referenceLine = self.additionalDrawings.referenceLine.d.split(' ');
        referenceLine[2] =  yAxis.toPixels(options.trendYValue) - yAxis.toPixels(lineData.nearestYValue);
        referenceLine[5] =  0;
        self.additionalDrawings.referenceLine.attr({
            d: ["M", referenceLine[1], yAxis.toPixels(options.trendYValue) - yAxis.toPixels(lineData.nearestYValue), 'L', referenceLine[4], "0"]
        });
    //     ann.update({
    //         xValueEnd: x,
    //         yValue: lineData.nearestYValue,
    //         trendYValue: lineData.nearestTrendYValue,
    //         yValueEnd: lineData.nearestYValueEnd,
    //         nearestXValue: lineData.nearestXValue,
    //         nearestXValueEnd: lineData.nearestXValueEnd,
    //         nearestTrendXValue: lineData.nearestTrendXValue,
    //         nearestYValue: lineData.nearestYValue,
    //         nearestYValueEnd: lineData.nearestYValueEnd,
    //         nearestTrendYValue: lineData.nearestTrendYValue,
    //         shape: {
    //             params: {
    //                 d: line
    //             }
    //         }
    //     });
    //     //self.scale();
    // } else {
        ann.update({
            xValueEnd: x,
            yValue: lineData.nearestYValue,
            yValueEnd: lineData.nearestYValueEnd,
            // trendYValue: lineData.nearestTrendYValue,
            nearestXValue: lineData.nearestXValue,
            nearestXValueEnd: lineData.nearestXValueEnd,
            nearestTrendXValue: lineData.nearestTrendXValue,
            // nearestYValue: lineData.nearestYValue,
            // nearestYValueEnd: lineData.nearestYValueEnd,
            // nearestTrendYValue: lineData.nearestTrendYValue,
            shape: {
                params: {
                    d: line
                }
            }
        });
    // }

    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, ann.options.yValueEnd, ann.options.trendYValue);
    // infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd, ann.options.nearestTrendYValue);
    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    var dragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'default'});
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, undefined, self.defaultDragSupporterStyles);
    var referenceLine = self.additionalDrawings.referenceLine.d.split(' ');
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', referenceLine[1], referenceLine[2], 'L', referenceLine[4], referenceLine[5]], self.dragSupporters, undefined, self.defaultDragSupporterStyles);

    if (self.additionalDrawings && self.additionalDrawings.lines) {
        $.each(self.additionalDrawings.lines, function (key, value) {
            if(value.visibility !== 'hidden'){
                var line = value.d.split(' ');
                var customAttributes = {
                    'level': key,
                    'visibility':self.additionalDrawings.lines[key].visibility,
                    'stroke-width': 10
                }
                infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
            }
        });
    } else {
        console.error("3 point price projection error");
    }
    self.highlightEachLine();

    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.fib3PointPriceProjectionDrawing.prototype.select = function(event){
    var self = this,
    ann = self.annotation,
    options = ann.options;

    if (event && event.target) {
        var drawingtype = event.target.getAttribute('type');
        if (drawingtype) {
            if (drawingtype == "mainDrawing") {
                options.selectedDrawing = "mainDrawing";
            }
            if (drawingtype == "additionalDrawing") {
                options.selectedDrawing = "additionalDrawing";
            }
        } else if (event.target.parentNode.getAttribute('type')) {
            //this used when clicked on levels of start, end, trend
            var drawingtype = event.target.parentNode.getAttribute('type');
            if (drawingtype == "additionalDrawing") {
                options.selectedDrawing = "additionalDrawing";
            }
        } else {
            //this used when clicked on fibbonacci levels
            if (event.target.parentNode.parentNode.getAttribute('type')) {
                var drawingtype = event.target.parentNode.parentNode.getAttribute('type');
                if (drawingtype == "additionalDrawing") {
                    options.selectedDrawing = "additionalDrawing";
                }
            }
        }
    }
};

infChart.fib3PointPriceProjectionDrawing.prototype.translate = function (e) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id)),
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        fibonacciDrawings = this.fibonacciDrawings.lines,
        fibLevels = options.fibLevels ? options.fibLevels : this.fibLevels,
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels),
        fibonacciDrawingsFill = this.fibonacciDrawings.fill,
        lineDrawings = self.additionalDrawings.lines,
        fill,
        currentLine,
        currentLineP,
        nextLine,
        nextLineP;

    $.each(this.additionalDrawings.lines, function (key, value) {
        var fibLevel = fibLevels.find(function (level) {
            return level.id === key;
        });
        var percentage = parseFloat(fibLevel.value);
        var line = value.d.split(' ');
        var lineEndPosition = xAxis.width - xAxis.toPixels(ann.options.xValue);
        var drawingLabel = fibonacciDrawings[key];
        var hideFibLevelButton = self.additionalDrawings.hideFibLevelButton[key];
        var newLine = ["M", line[1], line[2], 'L', lineEndPosition, line[5]];

        value.attr({
            d: newLine
        });

        drawingLabel.textSetter(self.getFormattedLabel(yAxis, options.yValue, options.trendYValue, options.yValueEnd, percentage, stockChart));

        drawingLabel.attr({
            x: lineEndPosition - drawingLabel.width,
            y: line[2] - drawingLabel.height
        });

        self.positionHideIcon(hideFibLevelButton, lineEndPosition, drawingLabel, line[2]);

    });

    fibLevels.forEach(function (value, index, arr) {
        fill = fibonacciDrawingsFill && fibonacciDrawingsFill[value.id];
        currentLine = lineDrawings[value.id];
        currentLineP = currentLine && currentLine.d.split(' ');

        for (var i = index + 1; i < arr.length; i++) {
            var lineTemp = self.additionalDrawings.lines[arr[i].id];
            if (lineTemp && lineTemp.visibility != "hidden") {
                nextLine = lineTemp;
                break;
            }
        }
        nextLineP = nextLine && nextLine.d.split(' ');
        if (currentLine && nextLine) {
            fill.attr({
                d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
            });
        }
        nextLine = undefined;
    });
    this.toggleFibLevelEraseIcon(true);
};

infChart.fib3PointPriceProjectionDrawing.prototype.translateEnd = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id)),
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        fibonacciDrawings = this.fibonacciDrawings.lines,
        fibLevels = options.fibLevels ? options.fibLevels : this.fibLevels,
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels),
        fibonacciDrawingsFill = this.fibonacciDrawings.fill,
        lineDrawings = self.additionalDrawings.lines,
        fill,
        currentLine,
        currentLineP,
        nextLine,
        nextLineP,
        nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true),
        nearestDataPointForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true),
        nearestDataPointForTrendXValue = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, true, true),
        futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];

    var nearestYValue;
    if(futureValue >= nearestDataPointForXValue.xData) {
        nearestYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, true, options.yValue, nearestDataPointForXValue, options.trendXValue,  false));
    } else {
        nearestYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.yValue));
    }

    var nearestYValueEnd;
    if(futureValue >= nearestDataPointForXValueEnd.xData){
        nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, false, options.yValueEnd, nearestDataPointForXValueEnd, options.trendXValue,  false));
    } else {
        nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.yValueEnd));
    }

    var nearestTrendYValue;
    if(futureValue >= nearestDataPointForTrendXValue.xData){
        nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this,this.getNearestYValue(options.isHLH, false, options.trendYValue, nearestDataPointForTrendXValue, options.trendXValue,  false));
    } else {
        nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.trendYValue));
    }

    // if(options.isSnapTopHighLow){
    //     var newX = xAxis.toPixels(nearestDataPointForXValue.xData) - xAxis.toPixels(nearestDataPointForXValue.xData),
    //         newXEnd = xAxis.toPixels(nearestDataPointForXValueEnd.xData) - xAxis.toPixels(nearestDataPointForXValue.xData),
    //         newY = yAxis.toPixels(nearestYValue) - yAxis.toPixels(nearestYValue),
    //         newYEnd = yAxis.toPixels(nearestYValueEnd) - yAxis.toPixels(nearestYValue);

    //     var line = ["M", newX, newY, 'L', parseInt(newXEnd, 10), parseInt(newYEnd, 10)];

    //     ann.update({
    //         xValue: nearestDataPointForXValue.xData,
    //         xValueEnd: nearestDataPointForXValueEnd.xData,
    //         trendXValue: nearestDataPointForTrendXValue.xData,
    //         yValue: nearestYValue,
    //         yValueEnd: nearestYValueEnd,
    //         trendYValue: nearestTrendYValue,
    //         nearestXValue: nearestDataPointForXValue.xData,
    //         nearestXValueEnd: nearestDataPointForXValueEnd.xData,
    //         nearestTrendXValue: nearestDataPointForTrendXValue.xData,
    //         nearestYValue: nearestYValue,
    //         nearestYValueEnd: nearestYValueEnd,
    //         nearestTrendYValue: nearestTrendYValue,
    //         shape: {
    //             params: {
    //                 d: line
    //             }
    //         }
    //     });

    //     var newReferenceLine = ["M", xAxis.toPixels(nearestDataPointForTrendXValue.xData) - xAxis.toPixels(nearestDataPointForXValue.xData), yAxis.toPixels(nearestTrendYValue) - yAxis.toPixels(nearestYValue), 'L', newX, newY];
    //     self.additionalDrawings.referenceLine.attr({
    //         d: newReferenceLine
    //     });
    // } else {
        var newX = xAxis.toPixels(nearestDataPointForXValue.xData) - xAxis.toPixels(nearestDataPointForXValue.xData),
            newXEnd = xAxis.toPixels(nearestDataPointForXValueEnd.xData) - xAxis.toPixels(nearestDataPointForXValue.xData),
            newY = yAxis.toPixels(nearestYValue) - yAxis.toPixels(options.yValue),
            newYEnd = yAxis.toPixels(nearestYValueEnd) - yAxis.toPixels(options.yValue);

        var line = ["M", newX, newY, 'L', parseInt(newXEnd, 10), parseInt(newYEnd, 10)];

        ann.update({
            xValue: nearestDataPointForXValue.xData,
            xValueEnd: nearestDataPointForXValueEnd.xData,
            trendXValue: nearestDataPointForTrendXValue.xData,
            nearestXValue: nearestDataPointForXValue.xData,
            nearestXValueEnd: nearestDataPointForXValueEnd.xData,
            nearestTrendXValue: nearestDataPointForTrendXValue.xData,
            nearestYValue: nearestYValue,
            nearestYValueEnd: nearestYValueEnd,
            nearestTrendYValue: nearestTrendYValue,
            shape: {
                params: {
                    d: line
                }
            }
        });
        var newReferenceLine = ["M", xAxis.toPixels(nearestDataPointForTrendXValue.xData) - xAxis.toPixels(nearestDataPointForXValue.xData), yAxis.toPixels(nearestTrendYValue) - yAxis.toPixels(options.yValue), 'L', newX, newY];
        self.additionalDrawings.referenceLine.attr({
            d: newReferenceLine
        });
    //}

    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, line, self.dragSupporters, undefined, self.defaultDragSupporterStyles);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, newReferenceLine, self.dragSupporters, undefined, self.defaultDragSupporterStyles);

    $.each(this.additionalDrawings.lines, function (key, value) {
        var fibLevel = fibLevels.find(function (level) {
            return level.id === key;
        });
        var percentage = parseFloat(fibLevel.value);
        var percentageY = -((yAxis.toPixels(nearestTrendYValue) - yAxis.toPixels(nearestYValue)) * percentage / 100) + line[5];
        var lineStartPosition = newXEnd;
        var lineEndPosition = xAxis.width - xAxis.toPixels(ann.options.xValue);
        var drawingLabel = fibonacciDrawings[key];
        var hideFibLevelButton = self.additionalDrawings.hideFibLevelButton[key];
        var newLine = ["M", lineStartPosition, percentageY, 'L', lineEndPosition, percentageY];

        value.attr({
            d: newLine
        });

        drawingLabel.textSetter(self.getFormattedLabel(yAxis, nearestYValue, nearestTrendYValue, nearestYValueEnd, percentage, stockChart));

        drawingLabel.attr({
            x: lineEndPosition - drawingLabel.width,
            y: percentageY - drawingLabel.height
        });

        self.positionHideIcon(hideFibLevelButton, lineEndPosition, drawingLabel, percentageY);

        if(value.visibility !== 'hidden'){
            var customAttributes = {
                'level': key,
                'visibility':lineDrawings[key].visibility,
                'stroke-width': 10
            }
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, newLine, self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
        }
    });
    self.highlightEachLine();

    fibLevels.forEach(function (value, index, arr) {
        fill = fibonacciDrawingsFill && fibonacciDrawingsFill[value.id];
        currentLine = lineDrawings[value.id];
        currentLineP = currentLine && currentLine.d.split(' ');

        for (var i = index + 1; i < arr.length; i++) {
            var lineTemp = self.additionalDrawings.lines[arr[i].id];
            if (lineTemp && lineTemp.visibility != "hidden") {
                nextLine = lineTemp;
                break;
            }
        }
        nextLineP = nextLine && nextLine.d.split(' ');
        if (currentLine && nextLine) {
            fill.attr({
                d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
            });
        }
        nextLine = undefined;
    });

    self.selectAndBindResize();
    chart.selectedAnnotation = ann;
    if (!ann.chart.isContextMenuOpen) {
        self.showQuickDrawingSettings();
    }
    options.selectedDrawing = undefined;
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.fib3PointPriceProjectionDrawing.prototype.updateMoveStartPoint = function (e) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        lineData = this.moveStartPoint(e),
        line = lineData.line,
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        y = yAxis.toValue(lineData[5] + yAxis.toPixels(ann.options.yValue));

        // if (options.isSnapTopHighLow) {
        //     line[2] = 0;
        //     line[5] = yAxis.toPixels(options.nearestYValueEnd) - yAxis.toPixels(options.nearestYValue);
        //     referenceLine = self.additionalDrawings.referenceLine.d.split(' ');
        //     referenceLine[2] =  yAxis.toPixels(options.trendYValue) - yAxis.toPixels(options.nearestYValue);
        //     referenceLine[5] =  0;
        //     self.additionalDrawings.referenceLine.attr({
        //         d: ["M", referenceLine[1], yAxis.toPixels(options.trendYValue) - yAxis.toPixels(options.nearestYValue), 'L', referenceLine[4], "0"]
        //     });
        //     ann.update({
        //         yValue: options.nearestYValue,
        //         // trendYValue: options.nearestTrendYValue,
        //         yValueEnd: options.nearestYValueEnd,
        //         shape: {
        //             params: {
        //                 d: line
        //             }
        //         }
        //     });
        //     self.scale();
        // }

        ann.update({
            // yValue: options.nearestYValue,
            trendYValue: lineData.nearestTrendYValue
            // yValueEnd: options.nearestYValueEnd,
            // shape: {
            //     params: {
            //         d: lineData.line
            //     }
            // }
        });

    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, ann.options.yValueEnd, ann.options.trendYValue);
    // infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd, ann.options.trendYValue);
    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, undefined, self.defaultDragSupporterStyles);
    var referenceLine = self.additionalDrawings.referenceLine.d.split(' ');
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', referenceLine[1], referenceLine[2], 'L', referenceLine[4], referenceLine[5]], self.dragSupporters, undefined, self.defaultDragSupporterStyles);

    $.each(self.additionalDrawings.lines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'visibility':self.additionalDrawings.lines[key].visibility,
                'stroke-width': 10
            }
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
        }
    });
    self.highlightEachLine();

    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
    infChart.drawingUtils.common.onPropertyChange.call(self);
};

infChart.fib3PointPriceProjectionDrawing.prototype.updateSettings = function (properties) {
    var updateProperties = {
        fillColor: properties.fillColor,
        fillOpacity: properties.fillOpacity,
        lineColor: properties.borderColor,
        lineWidth: properties.strokeWidth,
        fontSize: properties.fontSize,
        fontColor: properties.fontColor,
        isSingleColor: properties.isSingleColor,
        fibLevels: properties.fibLevels,
        isSnapTopHighLowEnabled: properties.isSnapTopHighLow,
        isTrendLineAlwaysEnabled: properties.isTrendLineAlways,
        trendLineColor: properties.trendLineColor,
        trendLineOpacity: properties.trendLineOpacity,
        trendLineWidth: properties.trendLineWidth,
        trendLineStyle: properties.trendLineStyle
    }
    infChart.structureManager.drawingTools.updateFibSettings(this.settingsPopup, updateProperties);
};

infChart.fib3PointPriceProjectionDrawing.prototype.highlightEachLine = function(){
    let self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        container = chart.container,
        dragSupporters = self.dragSupporters,
        selectedLevel,
        additionalDrawings = self.additionalDrawings,
        fibonacciDrawings = self.fibonacciDrawings,
        fibLabels = self.fibonacciDrawings.lines;

        dragSupporters.forEach(function (dragSupporter) {
            $(dragSupporter.element).mouseenter( function (event) {
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                var lines = additionalDrawings.lines;
                var fibLabels = fibonacciDrawings.lines;
                if(selectedLevel){
                    var selectedLine = lines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    $(container).find("path[class*='line-hover']").attr({class:''});
                    $(container).find("g[class*='label-hover']").attr({class:'highcharts-label'});
                    if(selectedLine){
                        selectedLine.addClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.addClass('label-hover');
                    }
                }
                event.stopPropagation();
            });

            $(dragSupporter.element).mouseleave( function (event) {
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                var lines = additionalDrawings.lines;
                var fibLabels = fibonacciDrawings.lines;
                if(selectedLevel){
                    var selectedLine = lines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    if(selectedLine){
                        selectedLine.removeClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.removeClass('label-hover');
                    }
                }
                event.stopPropagation();
            });
        })

        $.each(fibLabels, function (key, fibonacciLabel) {
            $(fibonacciLabel.element).mouseenter( function (event) {
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                var lines = additionalDrawings.lines;
                var fibLabels = fibonacciDrawings.lines;
                if(selectedLevel){
                    var selectedLine = lines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    $(container).find("path[class*='line-hover']").attr({class:''});
                    $(container).find("g[class*='label-hover']").attr({class:'highcharts-label'});
                    if(selectedLine){
                        selectedLine.addClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.addClass('label-hover');
                    }
                }
                event.stopPropagation();
            });

            $(fibonacciLabel.element).mouseleave( function (event) {
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                var lines = additionalDrawings.lines;
                var fibLabels = fibonacciDrawings.lines;
                if(selectedLevel){
                    var selectedLine = lines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    if(selectedLine){
                        selectedLine.removeClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.removeClass('label-hover');
                    }
                }
                event.stopPropagation();
            });
        })
};

infChart.fib3PointPriceProjectionDrawing.prototype.onTrendLineColorChange = function (rgb, color, opacity, isPropertyChange){
    var self = this;
    self.annotation.update({
        shape: {
            params: {
                stroke: color,
                opacity: opacity
            }
        }
    });

    if (self.additionalDrawings.referenceLine){
        self.additionalDrawings.referenceLine.attr({
            stroke: color,
            opacity: opacity
        });
    }

    self.annotation.options.trendLineColor = color;
    self.annotation.options.trendLineOpacity = opacity;

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.fib3PointPriceProjectionDrawing.prototype.onTrendLineWidthChange =  function (strokeWidth, isPropertyChange) {
    var self = this;
    var strokeDashArray = infChart.drawingUtils.common.settings.getStrokeDashArray.call(self, self.annotation.options.trendLineStyle, strokeWidth);
    self.annotation.update({
        shape: {
            params: {
                'stroke-width': strokeWidth,
                'stroke-dasharray': strokeDashArray
            }
        }
    });

    if (self.additionalDrawings.referenceLine){
        self.additionalDrawings.referenceLine.attr({
            'stroke-width': strokeWidth,
            'stroke-dasharray': strokeDashArray
        });
    }

    self.annotation.options.trendLineWidth = strokeWidth;

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};



infChart.fib3PointPriceProjectionDrawing.prototype.onTrendLineStyleChange = function (dashStyle, isPropertyChange) {
    var self = this;
    var strokeDashArray = infChart.drawingUtils.common.settings.getStrokeDashArray.call(self, dashStyle, self.annotation.options.trendLineWidth);
    self.annotation.update({
        shape: {
            params: {
                dashstyle: dashStyle,
                'stroke-dasharray': strokeDashArray
            }
        }
    });

    if (self.additionalDrawings.referenceLine){
        self.additionalDrawings.referenceLine.attr({
            dashstyle: dashStyle,
            'stroke-dasharray': strokeDashArray
        });
    }

    self.annotation.options.trendLineStyle = dashStyle;

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.fib3PointPriceProjectionDrawing.prototype.onTrendLineToggleShow = function(checked, isPropertyChange){
    var self = this,
        ann = self.annotation,
        options = ann.options,
        additionalDrawings = self.additionalDrawings;

    options.isTrendLineAlways = checked;
    if(checked){
        if(ann){
            ann.shape.show();
            if(additionalDrawings && additionalDrawings.referenceLine){
                additionalDrawings.referenceLine.show();
            }
            self.resetDragSupporters();
        }
    }

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }

};
window.infChart = window.infChart || {};

infChart.fib3PointTimeProjection = function () {
    infChart.fibVerRetracementsDrawing.apply(this, arguments);
    this.fibLevels = [
        {
            id: 'level_0',
            value: 0.0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#726a6f',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_1',
            value: 23.6,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#835974',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_2',
            value: 38.2,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#7b6171',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_3',
            value: 50,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f8bce2',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_4',
            value: 61.8,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f075c3',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_5',
            value: 78.6,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#eb40ab',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_6',
            value: 100,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#c71585',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_7',
            value: 127.2,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#800e56',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_8',
            value: 161.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#4b0832',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_9',
            value: 200,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '726a6f',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_10',
            value: 261.8,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#835974',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_11',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#7b6171',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_12',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f8bce2',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_13',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f075c3',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        }
    ];
    this.mainDragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {'type': 'mainDrawing'});
};

infChart.fib3PointTimeProjection.prototype = Object.create(infChart.fibVerRetracementsDrawing.prototype);

infChart.fib3PointTimeProjection.prototype.additionalDrawingsFunction = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        shapeParams = options.shape.params,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        fibLevels = options.fibLevels,
        theme = infChart.drawingUtils.common.getTheme.call(this);

    if (options.trendXValue !== Number.MIN_SAFE_INTEGER && options.trendYValue !== Number.MIN_SAFE_INTEGER) {
        var x = xAxis.toPixels(options.trendXValue) - xAxis.toPixels(options.xValue);
        var y = yAxis.toPixels(options.trendYValue) - yAxis.toPixels(options.yValue);

        options.distance = options.xValueDataIndex - options.trendXValueDataIndex;
        options.adjustment = parseFloat(ann.shape.d.split(' ')[4]);
        self.createAdditionalDrawings();

        var drawingAttr = {
            'z-index': 2,
            'stroke-width': options.trendLineWidth,
            fill: shapeParams.fill,
            cursor: 'move',
            stroke: shapeParams.stroke,
            opacity: options.trendLineOpacity,
            dashstyle: options.trendLineStyle
        };
        var baseFontColor = (theme.fib3PointTimeProjection && typeof theme.fib3PointTimeProjection.fontColor !== "undefined") ? theme.fib3PointTimeProjection.fontColor : infChart.drawingUtils.common.baseFontColor;
        var baseFontSize = (theme.fib3PointTimeProjection && typeof theme.fib3PointTimeProjection.fontSize !== "undefined") ? theme.fib3PointTimeProjection.fontSize : infChart.drawingUtils.common.baseFontSize;
        var baseFontWeight = (theme.fib3PointTimeProjection && typeof theme.fib3PointTimeProjection.fontWeight !== "undefined") ? theme.fib3PointTimeProjection.fontWeight : infChart.drawingUtils.common.baseFontWeight;

        var labelStyles = {
            'color': baseFontColor,
            fontSize: baseFontSize + 'px',
            'font-weight' : baseFontWeight
        };
        var labelAttr = {
            'font-color': baseFontColor,
            'font-size': baseFontSize,
            'font-weight' : baseFontWeight,
            'type': 'additionalDrawing',
            cursor: 'move'
        };
        var fixedLevelAttr = {
            'z-index': 2,
            'stroke-width': options.jointLineWidth,
            fill: shapeParams.fill,
            cursor: 'move',
            stroke: options.jointLineColor,
        };

        // var referenceLineDrawingAttr = drawingAttr;

        // referenceLineDrawingAttr['stroke-width'] = options.isSingleColor ? options.lineWidth : shapeParams['stroke-width'];
        // referenceLineDrawingAttr['stroke'] = options.isSingleColor ? options.lineColor : shapeParams.stroke;

        self.additionalDrawings.referenceLine = chart.renderer.path(["M", x, y, 'L', 0, 0]).attr(drawingAttr).add(ann.group);
        
        if (options.isShort) { 
            var startValue = self.formatDate(options.nearestXValue, self.stockChart.interval);
            self.additionalDrawings.lines['start'] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(fixedLevelAttr).add(ann.group);
            self.additionalDrawings.labels['start'] = chart.renderer.label(startValue).css(labelStyles).attr(labelAttr).add(ann.group);
    
            var endValue = self.formatDate(options.nearestXValueEnd, self.stockChart.interval);
            self.additionalDrawings.lines['end'] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(fixedLevelAttr).add(ann.group);
            self.additionalDrawings.labels['end'] = chart.renderer.label(endValue).css(labelStyles).attr(labelAttr).add(ann.group);
            if (!self.isEndLevelEnabled()) {
                self.additionalDrawings.lines['end'].hide();
                self.additionalDrawings.labels['end'].hide();
            }

            var trendValue = infChart.fibVerRetracementsDrawing.prototype.formatDate.call(self, options.nearestTrendXValue, self.stockChart.interval);
            self.additionalDrawings.lines['trend'] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(fixedLevelAttr).add(ann.group);
            self.additionalDrawings.labels['trend'] = chart.renderer.label(trendValue).css(labelStyles).attr(labelAttr).add(ann.group);

        var jointLineWidth = options.isSingleColor ? options.lineWidth : options.jointLineWidth;
        var jointLineColor = options.isSingleColor ? options.lineColor : options.jointLineColor;

            self.additionalDrawings.jointLine = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr({
                'stroke-width': jointLineWidth,
                fill: ann.options.shape.params.fill,
                stroke: jointLineColor,
                'z-index': 2,
                cursor: 'move'
            }).add(ann.group);
        }
    }
};

infChart.fib3PointTimeProjection.prototype.isEndLevelEnabled = function (){
    var self = this,
        ann = self.annotation,
        options = ann.options,
        fibLevels = options.fibLevels;

    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);
    var isEndEnabled = true;
    fibLevels.forEach(function (fibLevel) {
        if(fibLevel.enable && fibLevel.value === 0){
                isEndEnabled = false;
        }
    });
    return isEndEnabled;
};

infChart.fib3PointTimeProjection.prototype.beforeDestroy = function () {
    var options = this.annotation.options;
    if (options.trendXValue !== Number.MIN_SAFE_INTEGER && options.trendYValue !== Number.MIN_SAFE_INTEGER) {
        infChart.fibVerRetracementsDrawing.prototype.destroyAdditionalDrawings.call(this);
        if (this.additionalDrawings.referenceLine) {
            this.additionalDrawings.referenceLine.destroy();
        }
        if (this.additionalDrawings.labels['trend']) {
            this.additionalDrawings.labels['trend'].destroy();
            this.additionalDrawings.lines['trend'].destroy();
        }
    }
};

infChart.fib3PointTimeProjection.prototype.bindSettingsEvents = function () {
    infChart.fibVerRetracementsDrawing.prototype.bindSettingsEvents.call(this);
};

infChart.fib3PointTimeProjection.prototype.createAdditionalDrawings = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        dx = options.distance,
        adjustment = options.adjustment,
        fibLevels = options.fibLevels,
        shapeParams = options.shape.params,
        theme = infChart.drawingUtils.common.getTheme.call(this),
        baseFillOpacity = (theme.fibVerRetracements && typeof theme.fibVerRetracements.fillOpacity !== "undefined") ? theme.fibVerRetracements.fillOpacity : infChart.drawingUtils.common.baseFillOpacity,
        baseFontColor = (theme.fibVerRetracements && typeof theme.fibVerRetracements.fontColor !== "undefined") ? theme.fibVerRetracements.fontColor : infChart.drawingUtils.common.baseFontColor,
        baseFontSize = (theme.fibVerRetracements && typeof theme.fibVerRetracements.fontSize !== "undefined") ? theme.fibVerRetracements.fontSize : infChart.drawingUtils.common.baseFontSize;
        baseFontWeight = (theme.fibVerRetracements && typeof theme.fibVerRetracements.fontWeight !== "undefined") ? theme.fibVerRetracements.fontWeight : infChart.drawingUtils.common.baseFontWeight;

    self.additionalDrawings = {
        labels: {},
        lines: {},
        fill: {}
    };

    var drawingFillAttr = {
        'stroke-width': 0,
        'z-index': 2,
        cursor: 'default',
        color: shapeParams.stroke,
        'pointer-events':'none'
    };

    var drawingAttr = {
        'z-index': 2,
        'stroke-width': shapeParams['stroke-width'],
        fill: shapeParams.fill,
        cursor: 'move',
        stroke: shapeParams.stroke
    };
    var labelCssAttr = {
        fontSize: baseFontSize + 'px',
        color: baseFontColor,
        'font-weight' : baseFontWeight
    };
    var labelAttr = {
        'font-color': baseFontColor,
        'font-size': baseFontSize,
        'font-weight' : baseFontWeight,
        'type': 'additionalDrawing',
        cursor: 'move'
    };

    var dateLabelAttr = Object.assign({}, labelAttr);
    var dateLabelCssAttr = Object.assign({}, labelCssAttr);
    var dateDrawingAttr = Object.assign({}, drawingAttr);

    // add fill objects first to avoid overlapping lines with and texts with them
    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);

    var isEndEnabled = false;
    fibLevels.forEach(function (fibLevel) {
        var distanceMultiplier = parseFloat(fibLevel.value) / 100;
        var x = adjustment + (dx > 0 ? dx : -dx) * distanceMultiplier;
        var themeFillColor = theme.fibVerRetracements && theme.fibVerRetracements.fibLevelFillColors && theme.fibVerRetracements.fibLevelFillColors[fibLevel.id];
        var lineWidth = options.isSingleColor ? options.lineWidth : (fibLevel.lineWidth ? fibLevel.lineWidth : shapeParams['stroke-width']);
        var lineColor = options.isSingleColor ? options.lineColor : (fibLevel.lineColor ? fibLevel.lineColor : shapeParams.stroke);
        var opacity = options.isSingleColor ? options.opacity : (fibLevel.fillOpacity ? fibLevel.fillOpacity : baseFillOpacity);
        var fontColor = options.isSingleColor ? options.fontColor : (fibLevel.fontColor ? fibLevel.fontColor : baseFontColor);
        var fontSize = options.isSingleColor ? options.fontSize : (fibLevel.fontSize ? fibLevel.fontSize : baseFontSize);
        var fontWeight = options.isSingleColor ? options.fontWeight : (fibLevel.fontWeight ? fibLevel.fontWeight : baseFontWeight);

        drawingFillAttr.fill = options.isSingleColor ? options.fillColor : (fibLevel.fillColor ? fibLevel.fillColor : themeFillColor);
        drawingFillAttr['fill-opacity'] = opacity;
        drawingFillAttr.stroke = lineColor;
        drawingFillAttr.level = fibLevel.id;

        drawingAttr['stroke-width'] = parseInt(lineWidth, 10);
        drawingAttr.stroke = lineColor;
        drawingAttr.level = fibLevel.id;

        labelCssAttr.color = fontColor;
        labelCssAttr.fontSize = fontSize + 'px';
        labelCssAttr['font-weight'] = fontWeight;

        labelAttr['level'] = fibLevel.id;
        labelAttr['font-color'] = fontColor;
        labelAttr['font-size'] = fontSize;
        labelAttr['font-weight'] = fontWeight;

        var labelValue = self.getLineLabelText(x, fibLevel);
        if (!options.isShort) {
            self.additionalDrawings.fill[fibLevel.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0]).attr(drawingFillAttr).add(ann.group);
        }
        self.additionalDrawings.lines[fibLevel.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingAttr).add(ann.group);
        self.additionalDrawings.labels[fibLevel.id] = chart.renderer.label(labelValue, fibLevel.drawingPosX, fibLevel.drawingPosY).css(labelCssAttr).attr(labelAttr).add(ann.group);
        if (!fibLevel.enable) {
            self.additionalDrawings.lines[fibLevel.id].hide();
            self.additionalDrawings.labels[fibLevel.id].hide();
            if (!options.isShort) {
                self.additionalDrawings.fill[fibLevel.id].hide();
            }
        } else {
            if (fibLevel.value === 0) {
                isEndEnabled = true;
            }
        }
    });

    if(options.isSingleColor){
        dateLabelAttr = labelAttr;
        dateLabelCssAttr = labelCssAttr;
        dateDrawingAttr = drawingAttr;
        delete dateDrawingAttr['level'];
        delete dateLabelAttr['level'];
    }

    dateDrawingAttr['stroke-width'] = options.jointLineWidth;
    dateDrawingAttr.stroke = options.jointLineColor;

    if (options.isShort && options.isSingleColor) {
        var startValue = self.formatDate(options.nearestXValue, self.stockChart.interval);
        self.additionalDrawings.lines['start'] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(dateDrawingAttr).add(ann.group);
        self.additionalDrawings.labels['start'] = chart.renderer.label(startValue).css(dateLabelCssAttr).attr(dateLabelAttr).add(ann.group);

        var endValue = self.formatDate(options.nearestXValueEnd, self.stockChart.interval);
        self.additionalDrawings.lines['end'] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(dateDrawingAttr).add(ann.group);
        self.additionalDrawings.labels['end'] = chart.renderer.label(endValue).css(dateLabelCssAttr).attr(dateLabelAttr).add(ann.group);
        if (!options.trendXValue && isEndEnabled) {
            self.additionalDrawings.lines['end'].hide();
            self.additionalDrawings.labels['end'].hide();
        }

        var trendValue = infChart.fibVerRetracementsDrawing.prototype.formatDate.call(self, options.nearestTrendXValue, self.stockChart.interval);
        self.additionalDrawings.lines['trend'] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(dateDrawingAttr).add(ann.group);
        self.additionalDrawings.labels['trend'] = chart.renderer.label(trendValue).css(dateLabelCssAttr).attr(dateLabelAttr).add(ann.group);

        var jointLineWidth = options.isSingleColor ? options.lineWidth : options.jointLineWidth;
        var jointLineColor = options.isSingleColor ? options.lineColor : options.jointLineColor;

        self.additionalDrawings.jointLine = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr({
            'stroke-width': jointLineWidth,
            fill: ann.options.shape.params.fill,
            stroke: jointLineColor,
            'z-index': 2,
            cursor: 'move'
        }).add(ann.group);

    }
};

infChart.fib3PointTimeProjection.prototype.changeFibLine = function (level, property, propertyValue, isAll, isPropertyChange, ignoreSettingsSave) {
    var self = this;
    var options = this.annotation.options;
    var fibLevels, fibLevel, fibIndex = -1;
    if (!isAll) {
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels);
        for (var i = 0; i < fibLevels.length; i++) {
            if (level === fibLevels[i].id) {
                fibLevel = fibLevels[i];
                fibIndex = i;
                break;
            }
        }
    }
    var additionalDrawings = this.additionalDrawings;
    switch (property) {
        case 'enabled':
            this.showHideLevels(level, propertyValue);
            fibLevel.enable = propertyValue;
            var isEndEnabled = self.isEndLevelEnabled();
            this.showHideLevels('end',isEndEnabled);
            var isFirstLevelDisabled = true, k = fibIndex;
            for (k; k >= 0; k--) {
                if (fibLevels[k].enable) {
                    isFirstLevelDisabled = false;
                    break;
                }
            }
            var changeFibLine = fibIndex;
            if (isFirstLevelDisabled) {
                for (changeFibLine; changeFibLine < fibLevels.length; changeFibLine++) {
                    if (fibLevels[changeFibLine].enable) {
                        break;
                    }
                }
                if (options.isShort) {
                    this.updateJointLine(parseFloat(this.additionalDrawings.lines[fibLevels[fibIndex].id].d.split(' ')[4]), fibIndex, fibLevels);
                }
            } else {
                if (options.isShort) {
                    this.updateJointLine(parseFloat(this.additionalDrawings.lines[fibLevels[k].id].d.split(' ')[4]), k, fibLevels);
                } else {
                    this.updateFill(fibLevels[k], k, fibLevels);
                }
            }
            break;
        case 'value':
            fibLevel.value = propertyValue;
            var x = this.updateFibLevel(fibLevel, fibIndex, fibLevels, this.annotation.options.distance, false, true);
            this.updateJointLine(x, fibIndex, fibLevels);
            break;
        case 'lineColor':
            additionalDrawings.lines[level].attr({
                'stroke': propertyValue
            });
            if (!isAll) {
                fibLevel.lineColor = propertyValue;	
            }
            break;
        case 'fillColor':
            if (!options.isShort) {
                additionalDrawings.fill[level].attr({
                    'fill': propertyValue.fill,
                    'fill-opacity': propertyValue.opacity
                });
            } else {
                if (propertyValue.opacity === 0) {
                    propertyValue.fill = this.annotation.options.shape.params.fill;
                }
            }
            if (!isAll) {
                fibLevel.fillColor = propertyValue.fill;
                fibLevel.fillOpacity = propertyValue.opacity;
            }
            break;
        case 'lineWidth':
            additionalDrawings.lines[level].attr({
                'stroke-width': propertyValue
            });
            if (!isAll) {
                fibLevel.lineWidth = propertyValue;
            }
            break;
    }

    if (isPropertyChange) {
        this.onPropertyChange();
    }
};

infChart.fib3PointTimeProjection.prototype.deselect = function (isMouseOut) {
    var self = this;
    if(isMouseOut){
        if(self.annotation.options && !self.annotation.options.isTrendLineAlways){
            self.additionalDrawings.referenceLine.hide();
        }
    }
    infChart.fibVerRetracementsDrawing.prototype.deselect.call(self, isMouseOut);
};

infChart.fib3PointTimeProjection.prototype.getConfig = function () {
    var self = this,
        options = self.annotation.options;

    var config = infChart.fibVerRetracementsDrawing.prototype.getConfig.call(self);
    config.shape = 'fib3PointTimeProjection';
    config.trendXValue = options.trendXValue;
    config.trendYValue = options.trendYValue;
    return config;
};

infChart.fib3PointTimeProjection.prototype.getContextMenuOptions = function (chartId, drawingId, options, event) {
    var self = this;
    var level = event.target.getAttribute('level');
    if (!level && event.target.parentElement) {
        if (event.target.parentElement && event.target.parentElement.getAttribute('level')) {
            level = event.target.parentElement.getAttribute('level');
        } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
            level = event.target.parentElement.parentElement.getAttribute('level');
        }
    }

     var contextMenu = {
        "copyToClipboard" : {
            icon : options.copyToClipboard.icon,
            displayText : options.copyToClipboard.displayText,
            action : function () {
                if(level) {
                  infChart.drawingUtils.common.onFibLevelCopy.call(self, level); 
                }
            }
        },
        "eraseThis" : {
            icon : options.erase.icon,
            displayText : options.erase.displayText,
            action : function () {
                if(level) {
                    self.eraseFibLevel(level, false, true, true);
                }
            }
        }
    };

    if (level) {
        contextMenu = Object.assign(contextMenu, infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options));
        return infChart.drawingUtils.common.reorderContextMenu(contextMenu);
    } else {
        return infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options)
    }
};

infChart.fib3PointTimeProjection.prototype.eraseFibLevel = function (level, checked, isPropertyChange, ignoreSettingsSave){
    var self = this;
    self.additionalDrawings.lines[level].hide();
    self.additionalDrawings.labels[level].hide();
    if (self.additionalDrawings.fill[level]) {
        self.additionalDrawings.fill[level].hide();
    }
    var propeties = self.getConfig();

    propeties.fibLevels.forEach(function (fibLevel) {
       if(fibLevel.id === level){
        fibLevel.enable = false;
       }
    });
    if(self.isEndLevelEnabled()){
        self.additionalDrawings.lines['end'].show();
        self.additionalDrawings.labels['end'].show();
    }
    self.changeFibLine(level, 'enabled', checked, false, false, ignoreSettingsSave);
};

infChart.fib3PointTimeProjection.prototype.getCurrentPropertyValue = function (level, property, isAll) {
    return infChart.fibVerRetracementsDrawing.prototype.getCurrentPropertyValue.call(this, level, property, isAll);
};

infChart.fib3PointTimeProjection.prototype.getOptions = function (properties, chart) {
    var options = infChart.fibVerRetracementsDrawing.prototype.getOptions.call(this, properties, chart);
    if (properties.trendXValue && properties.trendYValue) {
        options.trendXValue = properties.trendXValue;
        options.trendYValue = properties.trendYValue;

        var nearestDataForTrendXValue = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
        options.trendXValueDataIndex = nearestDataForTrendXValue.trendXValueDataIndex;
        options.nearestTrendXValue = nearestDataForTrendXValue.xData;
    } else {
        options.trendXValue = Number.MIN_SAFE_INTEGER;
        options.trendYValue = Number.MIN_SAFE_INTEGER;
        options.events = null;
    }
    var nearestXValueData = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
    options.nearestXValue = nearestXValueData.xData;
    options.xValueDataIndex = nearestXValueData.dataIndex;
    options.fibLevels = properties.fibLevels ? properties.fibLevels : this.fibLevels;
    options.fibLevels = infChart.drawingUtils.common.getFibLevelsWithOpacity(infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels), options.opacity);
    options.showFibModeToggle = false;
    options.disableIntermediateScale = true;
    return options;
};

infChart.fib3PointTimeProjection.prototype.getQuickSettingsPopup = function () {
    return infChart.fibVerRetracementsDrawing.prototype.getQuickSettingsPopup.call(this);
};

infChart.fib3PointTimeProjection.prototype.getSettingsPopup = function () {
    return infChart.fibVerRetracementsDrawing.prototype.getSettingsPopup.call(this);
};

infChart.fib3PointTimeProjection.prototype.moveStartPoint = function (e) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        x = e.chartX,
        y = e.chartY,
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis];

    var xValue = xAxis.toValue(x);
    var newXValueData = infChart.math.findNearestDataPoint(chart, xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
    ann.update({
        trendXValue: newXValueData.xData,
        trendXValueDataIndex: newXValueData.dataIndex,
        trendYValue: yAxis.toValue(y)
    });

    self.updateReferenceLine();
    self.updateAdditionalDrawings(false, true);
    self.updateJointLines(false);
    self.updateJointLine();

    return ann.shape.d.split(' ');
};

infChart.fib3PointTimeProjection.prototype.scale = function (isCalculateNewValueForScale) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        line = ann.shape.d.split(' '),
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];

    if (isCalculateNewValueForScale) {
        nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
        nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
        nearestDataForTrendXValue = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
        options.nearestXValue = nearestDataForXValue.xData;
        options.nearestXValueEnd = nearestDataForXValueEnd.xData;
        options.nearestTrendXValue = nearestDataForTrendXValue.xData;
    }

    var newX = xAxis.toPixels(options.nearestXValue) - xAxis.toPixels(options.xValue),
        xEnd = xAxis.toPixels(options.nearestXValueEnd) - xAxis.toPixels(options.xValue),
        yEnd = yAxis.toPixels(options.yValueEnd) - yAxis.toPixels(options.yValue);

    line[1] = (!isNaN(newX) && newX) || 0;
    line[4] = (!isNaN(xEnd) && xEnd) || 0;
    line[5] = (!isNaN(yEnd) && yEnd) || 0;

    if(isCalculateNewValueForScale){
        ann.update({
            nearestXValue: nearestDataForXValue.xData,
            nearestXValueEnd: nearestDataForXValueEnd.xData,
            nearestTrendXValue: nearestDataForTrendXValue.xData,
            xValueDataIndex: nearestDataForXValue.dataIndex,
            xValueEndDataIndex: nearestDataForXValueEnd.dataIndex,
            trendXValueDataIndex: nearestDataForTrendXValue.dataIndex,
            shape: {
                params: {
                    d: line
                }
            }
        });
    } else {
        ann.update({
            shape: {
                params: {
                    d: line
                }
            }
        });
    }

    ann.options.adjustment = line[4];
    ann.options.distance = options.xValueDataIndex - options.trendXValueDataIndex;

    if (ann.selectionMarker && ann.selectionMarker.length > 1) {
        ann.selectionMarker[1].attr({
            x: line[4],
            y: line[5]
        });
    }

    if (options.trendXValue !== Number.MIN_SAFE_INTEGER && options.trendYValue !== Number.MIN_SAFE_INTEGER) {
        self.updateReferenceLine(isCalculateNewValueForScale);
        self.updateAdditionalDrawings(false);
        self.updateJointLines(false);
        self.updateJointLine();

        infChart.fibVerRetracementsDrawing.prototype.setDragSupporters.call(self);
        infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, self.additionalDrawings.referenceLine.d.split(' '), self.dragSupporters, undefined, self.mainDragSupporterStyles);
    }
    
    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
};

infChart.fib3PointTimeProjection.prototype.selectAndBindResize = function () {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];


    infChart.fibVerRetracementsDrawing.prototype.selectAndBindResize.call(this);
    this.additionalDrawings.referenceLine.show();

    var x = xAxis.toPixels(options.nearestTrendXValue) - xAxis.toPixels(options.xValue);
    var y = yAxis.toPixels(options.trendYValue) - yAxis.toPixels(options.yValue);

    infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, x, y, this.moveStartPoint, this.updateMoveStartPoint, true);
};

infChart.fib3PointTimeProjection.prototype.showHideLevels = function (level, enabled) {
    var self = this;
    var options = self.annotation.options;
    var additionalDrawings = self.additionalDrawings;

    if (enabled) {
        additionalDrawings.lines[level].show();
        additionalDrawings.labels[level].show();
        if (!options.isShort) {
            additionalDrawings.fill[level].show();
        }
    } else {
        additionalDrawings.lines[level].hide();
        additionalDrawings.labels[level].hide();
        if (!options.isShort) {
            additionalDrawings.fill[level].hide();
        }
    }
}

infChart.fib3PointTimeProjection.prototype.step = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        points = infChart.drawingUtils.common.calculateInitialPoints(e, ann, isStartPoint, 0, 0),
        xValueEnd = xAxis.toValue(xAxis.toPixels(options.xValue) + points.dx),
        yValueEnd = yAxis.toValue(yAxis.toPixels(options.yValue) + points.dy),
        nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate),
        nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, xValueEnd, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate),
        nearestXValue = nearestDataForXValue.xData,
        nearestXValueEnd = nearestDataForXValueEnd.xData,
        newX = xAxis.toPixels(nearestXValue) - xAxis.toPixels(ann.options.xValue),
        newXEnd = xAxis.toPixels(nearestXValueEnd) - xAxis.toPixels(ann.options.xValue);

    y = points.dy;
    var line = ["M", newX, 0, 'L', newXEnd, y];
    ann.update({
        xValueDataIndex: nearestDataForXValue.dataIndex,
        xValueEndDataIndex: nearestDataForXValueEnd.dataIndex,
        nearestXValue: nearestXValue,
        nearestXValueEnd: nearestXValueEnd,
        shape: {
            params: {
                d: line
            }
        }
    });

    if (options.trendXValue !== Number.MIN_SAFE_INTEGER && options.trendYValue !== Number.MIN_SAFE_INTEGER) {
        ann.options.adjustment = line[4];
        self.updateReferenceLine();
        self.updateAdditionalDrawings(false, true);
        self.updateJointLines(false);
        self.updateJointLine();
    }
    return {line: line, points: points};
};

infChart.fib3PointTimeProjection.prototype.stop = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        lineData = self.stepFunction(e, isStartPoint),
        line = lineData.line,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        x = xAxis.toValue(line[4] + xAxis.toPixels(options.xValue)),
        y = yAxis.toValue(line[5] + yAxis.toPixels(options.yValue));

    ann.update({
        xValueEnd: x,
        yValueEnd: y,
        shape: {
            params: {
                d: line
            }
        }
    });

    infChart.drawingUtils.common.saveBaseYValues.call(self, options.yValue, y, options.trendYValue);

    infChart.fibVerRetracementsDrawing.prototype.setDragSupporters.call(self);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, self.additionalDrawings.referenceLine.d.split(' '), self.dragSupporters, undefined, self.mainDragSupporterStyles);

    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);

    infChart.drawingUtils.common.onPropertyChange.call(self);
};

infChart.fib3PointTimeProjection.prototype.translate = function (event) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        trendXValueData = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);

    options.trendXValue = trendXValueData.xData;
    options.trendXValueDataIndex = trendXValueData.dataIndex;
    var newX = xAxis.toPixels(options.trendXValue) - xAxis.toPixels(options.xValue);

    if (options.selectedDrawing === "mainDrawing") {
        ann.update({
            trendXValue: options.trendXValue
        });

        if (ann.selectionMarker && ann.selectionMarker.length > 1) {
            ann.selectionMarker[2].attr({
                x: newX
            });
        }

        this.updateAdditionalDrawings(false, true);
        this.scale();
    } else if (options.selectedDrawing === "additionalDrawing") {

        options.chartY = yAxis.toValue(event.chartY);

        ann.update({
            yValue: options.yValueStore,
            trendYValue: options.trendYValueStore,
            yValueEnd: options.yValueEndStore
        });

        this.updateAdditionalDrawings(false, false);
    }

    this.updateJointLines(false);
    this.updateJointLine();
};

infChart.fib3PointTimeProjection.prototype.translateEnd = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options;
    options.selectedDrawing = undefined;
    self.scale();
    infChart.drawingUtils.common.saveBaseYValues.call(self, options.yValue, options.yValueEnd, options.trendYValue);
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.fib3PointTimeProjection.prototype.updateAdditionalDrawings = function (isScale, isMain) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        dx = options.distance,
        adjustment = options.adjustment,
        yAxis = chart.yAxis[options.yAxis],
        xAxis = chart.xAxis[options.xAxis],
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels);

    var fibIndex = 0, fibLevelLength = fibLevels.length, lastX = 0, lastVal = 0, isStartEnabled = false, isEndEnabled = false, trendDistance;
    for (fibIndex; fibIndex < fibLevelLength; fibIndex++) {
        var fibLevel = fibLevels[fibIndex];
        var x = self.updateFibLevel(fibLevel, fibIndex, fibLevels, dx, isScale, false, isMain);
        if (fibLevel.value === 0) {
            trendDistance = x;
        }
        if (fibLevel.enable) {
            if (fibLevel.value === 0) {
                isStartEnabled = true;
            }
            if (fibLevel.value === 100) {
                isEndEnabled = true;
            }
            lastVal = fibLevel.value;
            if ((dx < 0 && lastX > x) || (dx > 0 && lastX < x)) {
                lastX = x;
            }
        }
    }

    if (options.isShort) {
        var startDrawingLabel = self.additionalDrawings.labels['start'];
        var endDrawingLabel = self.additionalDrawings.labels['end'];
        var startDrawingLine = self.additionalDrawings.lines['start'];
        var endDrawingLine = self.additionalDrawings.lines['end'];
        newX = xAxis.toPixels(options.nearestXValue) - xAxis.toPixels(options.xValue);
        if (!isScale) {
            var startValue = self.formatDate(options.nearestXValue, self.stockChart.interval);
            startDrawingLabel.textSetter(startValue);
            var endValue = self.formatDate(this.calculateFibLevelCandleValue(dx, 0), self.stockChart.interval);
            endDrawingLabel.textSetter(endValue);
        }

        var lineStartPosition = this.calculateLineStartPosition(fibLevel, isMain);
        var lineEndPosition = lineStartPosition + 10;

        startDrawingLabel.attr({
            x: newX - startDrawingLabel.width / 2,
            y: lineEndPosition + 5
        });
        startDrawingLine.attr({
            d: ["M", newX, lineStartPosition, 'L', newX, lineEndPosition]
        });
        var endX = adjustment === 0 ? dx : adjustment;
        endDrawingLabel.attr({
            x: endX - endDrawingLabel.width / 2,
            y: lineEndPosition + 5
        });
        endDrawingLine.attr({
            d: ["M", endX, lineStartPosition, 'L', endX, lineEndPosition]
        });

        if (adjustment === 0 && lastVal < 100) {
            lastX = ann.shape.d.split(' ')[4];
        }
        self.additionalDrawings.jointLine.attr({
            d: ['M', newX, lineStartPosition, 'L', lastX, lineStartPosition]
        });
    }
};

infChart.fib3PointTimeProjection.prototype.updateFibLevel = function (fibLevel, fibIndex, fibLevels, dx, isScale, isValueUpdate, isMain) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        correctionFactor = infChart.drawingUtils.common.correctionFactor,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];

    var x = xAxis.toPixels(this.calculateFibLevelCandleValue(dx, fibLevel.value)) - xAxis.toPixels(options.xValue);

    var previousLineStart = self.calculateLineStartPosition(fibLevel, isMain);
    var y1, y2, lineStartPosition = previousLineStart,
        lineEndPosition;
    if (options.isShort) {
        lineEndPosition = lineStartPosition + 10;
        y1 = lineStartPosition;
        y2 = lineEndPosition;
    } else {
        lineEndPosition = chart.plotHeight + lineStartPosition;
        y1 = lineStartPosition - chart.plotHeight * correctionFactor;
        y2 = lineEndPosition + chart.plotHeight * correctionFactor;
    }

    self.additionalDrawings.lines[fibLevel.id].attr({
        d: ["M", x, y1, 'L', x, y2]
    });

    var drawingLabel = self.additionalDrawings.labels[fibLevel.id];

    if (options.isShort) {
        if (!isScale) {
            drawingLabel.textSetter(self.getLineLabelText(x, fibLevel));
        }
    } else {
        if (isValueUpdate) {
            self.updateFill(fibLevel, fibIndex, fibLevels);
        }
        var isFirstLevel = true;
        fibIndex--;
        for (fibIndex; fibIndex >= 0; fibIndex--) {
            if (fibLevels[fibIndex].enable) {
                isFirstLevel = false;
                break;
            }
        }
        if (!isFirstLevel) {
            self.updateFill(fibLevels[fibIndex], fibIndex, fibLevels);
        }
    }

    drawingLabel.attr({
        x: options.isShort ? x - drawingLabel.width / 2 : x + 5,
        y: options.isShort ? lineEndPosition + 5 : lineEndPosition - 25
    });
    return x;
};

infChart.fib3PointTimeProjection.prototype.updateXValue = function (x, dx) {
    var self = this,
        ann = self.annotation,
        options = ann.options;

    if (dx >= 0) {
        return x;
    } else {
        if (options.adjustment >= 0) {
            var value = x - options.adjustment;
            var x = options.adjustment - value;
            return x;
        } else {
            var value = options.adjustment - x;
            var x = options.adjustment + value;
            return x;
        }
    }
}

infChart.fib3PointTimeProjection.prototype.updateJointLine = function (x, fibIndex, fibLevels) {
    var self = this, options = self.annotation.options;
    var fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels);
    if(options.isShort){
        var fibLevels;
        var enabledFibLevels = [];
        for (var i = 0; i < fibLevels.length; i++) {
            if (fibLevels[i].enable) {
                enabledFibLevels.push(fibLevels[i]);
            }
        }
        var minLeft, maxLeft;
        for(var i=0; i< enabledFibLevels.length; i++){
            var drawing = self.additionalDrawings.lines[enabledFibLevels[i].id];
            if(typeof minLeft === 'undefined' && typeof maxLeft === 'undefined'){
                minLeft = drawing.d.split(' ')[1];
                maxLeft = drawing.d.split(' ')[4];
            }
            if(parseFloat(minLeft) > parseFloat(drawing.d.split(' ')[1])){
                minLeft = drawing.d.split(' ')[1];
            }
            if(parseFloat(maxLeft) < parseFloat(drawing.d.split(' ')[4])){
                maxLeft = drawing.d.split(' ')[4];
            }
        }

        if(enabledFibLevels.length == 0){
            minLeft = self.additionalDrawings.lines['end'].d.split(' ')[1];
            maxLeft = self.additionalDrawings.lines['end'].d.split(' ')[4];
        }

        if(parseFloat(minLeft) > parseFloat(self.additionalDrawings.lines['end'].d.split(' ')[1])){
            minLeft = self.additionalDrawings.lines['end'].d.split(' ')[1];
        }
        if(parseFloat(minLeft) > parseFloat(self.additionalDrawings.lines['start'].d.split(' ')[1])){
            minLeft = self.additionalDrawings.lines['start'].d.split(' ')[1];
        }
        if(parseFloat(minLeft) > parseFloat(self.additionalDrawings.lines['trend'].d.split(' ')[1])){
            minLeft = self.additionalDrawings.lines['trend'].d.split(' ')[1];
        }

        if(parseFloat(maxLeft) < parseFloat(self.additionalDrawings.lines['end'].d.split(' ')[4])){
            maxLeft = self.additionalDrawings.lines['end'].d.split(' ')[4];
        }
        if(parseFloat(maxLeft) < parseFloat(self.additionalDrawings.lines['start'].d.split(' ')[4])){
            maxLeft = self.additionalDrawings.lines['start'].d.split(' ')[4];
        }
        if(parseFloat(maxLeft) < parseFloat(self.additionalDrawings.lines['trend'].d.split(' ')[4])){
            maxLeft = self.additionalDrawings.lines['trend'].d.split(' ')[4];
        }

        var jointLine = self.additionalDrawings.jointLine, jointLineArray = jointLine.d.split(' ');
        jointLine.attr({
            d: ['M', minLeft, jointLineArray[2], 'L', maxLeft, jointLineArray[5]]
        });
    }
};

infChart.fib3PointTimeProjection.prototype.updateJointLines = function(isScale){
    var jointLine = this.additionalDrawings.jointLine;
    var trendLabel = this.additionalDrawings.labels['trend'];
    var jointLineAttr = jointLine.d.split(' ');
    var referenceLineAttr = this.additionalDrawings.referenceLine.d.split(' ');
    var x = referenceLineAttr[1];
    var y = jointLineAttr[2];
    var lineStartPosition = parseFloat(y) + 10;
    var lineEndPosition = lineStartPosition + 5;
    jointLine.attr({
        d: ["M", x, y, 'L', jointLineAttr[4], y]
    });
    this.additionalDrawings.lines['trend'].attr({
        d: ['M', x, y, 'L', x, lineStartPosition]
    });
    if(!isScale){
        var trendValue = infChart.fibVerRetracementsDrawing.prototype.formatDate.call(this, this.annotation.options.nearestTrendXValue, this.stockChart.interval);
        trendLabel.textSetter(trendValue);
    }
    trendLabel.attr({
        x: parseFloat(x) - trendLabel.width / 2,
        y: lineEndPosition
    });
};

infChart.fib3PointTimeProjection.prototype.updateMoveStartPoint = function (e) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        line = this.moveStartPoint(e),
        yAxis = chart.yAxis[options.yAxis],
        y = yAxis.toValue(parseFloat(line[5]) + yAxis.toPixels(options.yValue));

    infChart.drawingUtils.common.saveBaseYValues.call(self, options.yValue, y, options.trendYValue);

    infChart.fibVerRetracementsDrawing.prototype.setDragSupporters.call(self);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, self.additionalDrawings.referenceLine.d.split(' '), self.dragSupporters, undefined, self.mainDragSupporterStyles);

    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
    infChart.drawingUtils.common.onPropertyChange.call(self);
};

infChart.fib3PointTimeProjection.prototype.updateReferenceLine = function (useOptionsNearestValue) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];

    if (!useOptionsNearestValue) {
        var nearestDataForTrendXValue = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
        options.nearestTrendXValue = nearestDataForTrendXValue.xData;
        if(!options.trendXValueDataIndex) {
            options.trendXValueDataIndex = nearestDataForTrendXValue.dataIndex;
        }
    }

    var x = xAxis.toPixels(options.nearestTrendXValue) - xAxis.toPixels(options.xValue);
    var y = yAxis.toPixels(options.trendYValue) - yAxis.toPixels(options.yValue);
    var x1 = xAxis.toPixels(options.nearestXValue) - xAxis.toPixels(options.xValue);
    self.additionalDrawings.referenceLine.attr({
        d: ["M", x, y, 'L', x1, 0]
    });
    ann.options.distance = options.xValueDataIndex - options.trendXValueDataIndex;
};

infChart.fib3PointTimeProjection.prototype.updateSettings = function (properties) {
    infChart.fibVerRetracementsDrawing.prototype.updateSettings.call(this, properties);
};

infChart.fib3PointTimeProjection.prototype.calculateFibLevelCandleValue = function (dx, fibValue) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        candleValue,
        calculatedCandleIndex,
        seriesXData = chart.series[0].xData,
        distanceMultiplier = parseFloat(fibValue) / 100;

    calculatedCandleIndex = Math.round(dx * distanceMultiplier) + options.xValueDataIndex + (options.xValueEndDataIndex - options.xValueDataIndex);
    calculatedCandleIndex = calculatedCandleIndex >= 0 ? calculatedCandleIndex : 0;

    if (seriesXData.length > calculatedCandleIndex) {
        candleValue = seriesXData[calculatedCandleIndex];
    } else {
        candleValue = Math.round(infChart.math.getFutureXValueForGivenIndex(chart, calculatedCandleIndex));
    }

    return candleValue;
};

infChart.fib3PointTimeProjection.prototype.onTrendLineColorChange = function (rgb, color, opacity, isPropertyChange){
    var self = this;

    if (self.additionalDrawings.referenceLine){
        self.additionalDrawings.referenceLine.attr({
            stroke: color,
            opacity: opacity
        });
    }

    infChart.fibVerRetracementsDrawing.prototype.onTrendLineColorChange.call(self, rgb, color, opacity, isPropertyChange)

};

infChart.fib3PointTimeProjection.prototype.onTrendLineWidthChange =  function (strokeWidth, isPropertyChange) {
    var self = this;
    var strokeDashArray = infChart.drawingUtils.common.settings.getStrokeDashArray.call(self, self.annotation.options.trendLineStyle, strokeWidth);

    if (self.additionalDrawings.referenceLine){
        self.additionalDrawings.referenceLine.attr({
            'stroke-width': strokeWidth,
            'stroke-dasharray': strokeDashArray
        });
    }

    infChart.fibVerRetracementsDrawing.prototype.onTrendLineWidthChange.call(self, strokeWidth, isPropertyChange)

};

infChart.fib3PointTimeProjection.prototype.onTrendLineStyleChange = function (dashStyle, isPropertyChange) {
    var self = this;
    var strokeDashArray = infChart.drawingUtils.common.settings.getStrokeDashArray.call(self, dashStyle, self.annotation.options.trendLineWidth);

    if (self.additionalDrawings.referenceLine){
        self.additionalDrawings.referenceLine.attr({
            dashstyle: dashStyle,
            'stroke-dasharray': strokeDashArray
        });
    }

    infChart.fibVerRetracementsDrawing.prototype.onTrendLineStyleChange.call(self, dashStyle, isPropertyChange);
};

infChart.fib3PointTimeProjection.prototype.onTrendLineToggleShow = function(checked, isPropertyChange){
    var self = this,
        ann = self.annotation,
        options = ann.options,
        additionalDrawings = self.additionalDrawings;

    options.isTrendLineAlways = checked;
    if(checked){
        if(ann){
            ann.shape.show();
            if(additionalDrawings && additionalDrawings.referenceLine){
                additionalDrawings.referenceLine.show();
            }
            self.setDragSupporters();
        }
    }

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};
window.infChart = window.infChart || {};

infChart.fib3PointPriceProjectionGenericDrawing = function () {
    this.closeIcon = '<img style = "width : 15px; height : 15px;" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI3LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA1NzYgNTc2IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1NzYgNTc2OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6Izg2ODY4Njt9Cgkuc3Qxe2ZpbGw6I0ZGRkZGRjt9Cjwvc3R5bGU+CjxnPgoJPGcgaWQ9Imljb21vb24taWdub3JlIj4KCTwvZz4KCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0yODgsMS41QzEyOS44LDEuNSwxLjUsMTI5LjgsMS41LDI4OFMxMjkuOCw1NzQuNSwyODgsNTc0LjVTNTc0LjUsNDQ2LjIsNTc0LjUsMjg4UzQ0Ni4yLDEuNSwyODgsMS41eiIvPgoJPHBhdGggY2xhc3M9InN0MSIgZD0iTTMzNC4yLDI4OGw3OS4xLTc5LjFjMTIuOC0xMi44LDEyLjgtMzMuNCwwLTQ2LjJsMCwwYy0xMi44LTEyLjgtMzMuNC0xMi44LTQ2LjIsMEwyODgsMjQxLjhsLTc5LjEtNzkuMQoJCWMtMTIuOC0xMi44LTMzLjQtMTIuOC00Ni4yLDBsMCwwYy0xMi44LDEyLjgtMTIuOCwzMy40LDAsNDYuMmw3OS4xLDc5LjFsLTc5LjEsNzkuMWMtMTIuOCwxMi44LTEyLjgsMzMuNCwwLDQ2LjJsMCwwCgkJYzEyLjgsMTIuOCwzMy40LDEyLjgsNDYuMiwwbDc5LjEtNzkuMWw3OS4xLDc5LjFjMTIuOCwxMi44LDMzLjQsMTIuOCw0Ni4yLDBsMCwwYzEyLjgtMTIuOCwxMi44LTMzLjQsMC00Ni4yTDMzNC4yLDI4OHoiLz4KPC9nPgo8L3N2Zz4K" alt="Close" />';
    infChart.drawingObject.apply(this, arguments);
    this.fibLevels = [
        {
            id: 'level_0',
            value: 0.0,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#726a6f',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_1',
            value: 23.6,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#835974',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_2',
            value: 38.2,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#7b6171',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_3',
            value: 50,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f8bce2',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_4',
            value: 61.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f075c3',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_5',
            value: 78.6,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#eb40ab',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_6',
            value: 100,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#c71585',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_7',
            value: 127.2,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#800e56',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_8',
            value: 161.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#4b0832',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_9',
            value: 200,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#726a6f',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_10',
            value: 261.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#835974',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_11',
            value: 300,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#7b6171',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_12',
            value: 361.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f8bce2',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_13',
            value: 461.8,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f075c3',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_14',
            value: 561.8,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#eb40ab',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_15',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#c71585',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        }
    ];
    this.fibExtentionLevels = [
        {
            id: 'level_0',
            value: 0.0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#726a6f',
            lineColor: '#0099FF',
            lineWidth: 1,
            fontColor: '#0099FF',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_1',
            value: 23.6,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#835974',
            lineColor: '#0099FF',
            lineWidth: 1,
            fontColor: '#0099FF',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_2',
            value: 38.2,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#7b6171',
            lineColor: '#0099FF',
            lineWidth: 1,
            fontColor: '#0099FF',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_3',
            value: 50,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f8bce2',
            lineColor: '#0099FF',
            lineWidth: 1,
            fontColor: '#0099FF',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_4',
            value: 61.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f075c3',
            lineColor: '#0099FF',
            lineWidth: 1,
            fontColor: '#0099FF',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_5',
            value: 78.6,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#eb40ab',
            lineColor: '#0099FF',
            lineWidth: 1,
            fontColor: '#0099FF',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_6',
            value: 100,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#c71585',
            lineColor: '#0099FF',
            lineWidth: 1,
            fontColor: '#0099FF',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_7',
            value: 127.2,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#800e56',
            lineColor: '#0099FF',
            lineWidth: 1,
            fontColor: '#0099FF',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_8',
            value: 161.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#4b0832',
            lineColor: '#0099FF',
            lineWidth: 1,
            fontColor: '#0099FF',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_9',
            value: 200,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#726a6f',
            lineColor: '#0099FF',
            lineWidth: 1,
            fontColor: '#0099FF',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_10',
            value: 261.8,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#835974',
            lineColor: '#0099FF',
            lineWidth: 1,
            fontColor: '#0099FF',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_11',
            value: 300,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#7b6171',
            lineColor: '#0099FF',
            lineWidth: 1,
            fontColor: '#0099FF',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_12',
            value: 361.8,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f8bce2',
            lineColor: '#0099FF',
            lineWidth: 1,
            fontColor: '#0099FF',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_13',
            value: 461.8,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f075c3',
            lineColor: '#0099FF',
            lineWidth: 1,
            fontColor: '#0099FF',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_14',
            value: 561.8,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#eb40ab',
            lineColor: '#0099FF',
            lineWidth: 1,
            fontColor: '#0099FF',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_15',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#c71585',
            lineColor: '#0099FF',
            lineWidth: 1,
            fontColor: '#0099FF',
            fontSize: '10',
            fontWeight: 'normal'
        },
    ];
    this.fibRetrancementLevels = [
        {
            id: 'level_0',
            value: 0.0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#726a6f',
            lineColor: '#FF9933',
            lineWidth: 1,
            fontColor: '#FF9933',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_1',
            value: 23.6,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#835974',
            lineColor: '#FF9933',
            lineWidth: 1,
            fontColor: '#FF9933',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_2',
            value: 38.2,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#7b6171',
            lineColor: '#FF9933',
            lineWidth: 1,
            fontColor: '#FF9933',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_3',
            value: 50,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f8bce2',
            lineColor: '#FF9933',
            lineWidth: 1,
            fontColor: '#FF9933',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_4',
            value: 61.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f075c3',
            lineColor: '#FF9933',
            lineWidth: 1,
            fontColor: '#FF9933',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_5',
            value: 78.6,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#eb40ab',
            lineColor: '#FF9933',
            lineWidth: 1,
            fontColor: '#FF9933',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_6',
            value: 100,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#c71585',
            lineColor: '#FF9933',
            lineWidth: 1,
            fontColor: '#FF9933',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_7',
            value: 127.2,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#800e56',
            lineColor: '#FF9933',
            lineWidth: 1,
            fontColor: '#FF9933',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_8',
            value: 161.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#4b0832',
            lineColor: '#FF9933',
            lineWidth: 1,
            fontColor: '#FF9933',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_9',
            value: 200,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#726a6f',
            lineColor: '#FF9933',
            lineWidth: 1,
            fontColor: '#FF9933',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_10',
            value: 261.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#726a6f',
            lineColor: '#FF9933',
            lineWidth: 1,
            fontColor: '#FF9933',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_11',
            value: 300,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#7b6171',
            lineColor: '#FF9933',
            lineWidth: 1,
            fontColor: '#FF9933',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_12',
            value: 361.8,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f8bce2',
            lineColor: '#FF9933',
            lineWidth: 1,
            fontColor: '#FF9933',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_13',
            value: 461.8,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f075c3',
            lineColor: '#FF9933',
            lineWidth: 1,
            fontColor: '#FF9933',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_14',
            value: 561.8,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#eb40ab',
            lineColor: '#FF9933',
            lineWidth: 1,
            fontColor: '#FF9933',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_15',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#c71585',
            lineColor: '#FF9933',
            lineWidth: 1,
            fontColor: '#FF9933',
            fontSize: '10',
            fontWeight: 'normal'
        }
    ];
    this.fibRetrancementAdditionalDrawing = {};
    this.settings = {};
    this.defaultDragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', type:'mainDrawing'});
    this.fibLevelDragSupporterStyles = Object.assign({}, infChart.drawingUtils.common.dragSupporterStyles, {cursor: 'pointer', type:'fibLevelDrawing'});
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.fib3PointPriceProjectionGenericDrawing.prototype.select = function(event){
    var self = this,
    ann = self.annotation,
    options = ann.options;

    if (event && event.target) {
        var drawingtype = event.target.getAttribute('type');
        if (drawingtype) {
            if (drawingtype == "mainDrawing") {
                options.selectedDrawing = "mainDrawing";
            }
            if (drawingtype == "fibLevelDrawing") {
                options.selectedDrawing = "fibLevelDrawing";
            }
        } else if (event.target.parentNode && event.target.parentNode.getAttribute('type')) {
            //this used when clicked on levels of start, end, trend
            var drawingtype = event.target.parentNode.getAttribute('type');
            if (drawingtype == "fibLevelDrawing") {
                options.selectedDrawing = "fibLevelDrawing";
            }
        } else {
            //this used when clicked on fibbonacci levels
            if (event.target.parentNode.parentNode && event.target.parentNode.parentNode.getAttribute('type')) {
                var drawingtype = event.target.parentNode.parentNode.getAttribute('type');
                if (drawingtype == "fibLevelDrawing") {
                    options.selectedDrawing = "fibLevelDrawing";
                }
            }
        }
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.additionalDrawingsFunction = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];
        var nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true),
            newX = xAxis.toPixels(nearestDataPointForXValue.xData) - xAxis.toPixels(options.xValue);
        var nearestYValue, newY;
        if(futureValue >= nearestDataPointForXValue.xData){
            nearestYValue = infChart.drawingUtils.common.getYValue.call(this, self.getNearestYValue(options.isHLH, true, options.yValue, nearestDataPointForXValue, options.trendXValue,  options.isSnapTopHighLow));
        } else {
            nearestYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.yValue));
        }
        newY = yAxis.toPixels(nearestYValue) - yAxis.toPixels(options.yValue);

    ann.selectionMarker = [];
    infChart.drawingUtils.common.addSelectionMarker.call(this, ann, newX, newY);

    if (options.trendXValue !== Number.MIN_SAFE_INTEGER && options.trendYValue !== Number.MIN_SAFE_INTEGER) {
        var labelAttr = {
            'color': ann.options.shape.params.stroke,
            fontSize: "12px"
        };
            
        var fibExtentionLevels = options.fibExtentionLevels ?  options.fibExtentionLevels : this.fibExtentionLevels, 
            fibRetrancementLevels = options.fibRetrancementLevels ?  options.fibRetrancementLevels : this.fibRetrancementLevels,
            additionalDrawingsArr = self.additionalDrawings,
            fibonacciDrawingsArr = self.fibonacciDrawings,
            theme = infChart.drawingUtils.common.getTheme.call(this),
            drawingFillAttr,
            drawingAttr,
            baseFillOpacityExtention = (theme.fib3PointPriceProjectionGeneric && theme.fib3PointPriceProjectionGeneric.fibExtention && typeof theme.fib3PointPriceProjectionGeneric.fibExtention.fillOpacity !== "undefined") ? theme.fib3PointPriceProjectionGeneric.fibExtention.fillOpacity : infChart.drawingUtils.common.baseFillOpacity,
            baseFontColorExtention = (theme.fib3PointPriceProjectionGeneric && theme.fib3PointPriceProjectionGeneric.fibExtention && typeof theme.fib3PointPriceProjectionGeneric.fibExtention.fontColor !== "undefined") ? theme.fib3PointPriceProjectionGeneric.fibExtention.fontColor : infChart.drawingUtils.common.baseFontColor,
            baseFontSizeExtention = (theme.fib3PointPriceProjectionGeneric && theme.fib3PointPriceProjectionGeneric.fibExtention && typeof theme.fib3PointPriceProjectionGeneric.fibExtention.fontSize !== "undefined") ? theme.fib3PointPriceProjectionGeneric.fibExtention.fontSize : infChart.drawingUtils.common.baseFontSize,
            baseFontWeightExtention = (theme.fib3PointPriceProjectionGeneric && theme.fib3PointPriceProjectionGeneric.fibExtention && typeof theme.fib3PointPriceProjectionGeneric.fibExtention.fontWeight !== "undefined") ? theme.fib3PointPriceProjectionGeneric.fibExtention.fontWeight : infChart.drawingUtils.common.fontWeight;


        fibonacciDrawingsArr.labels = {};
        fibonacciDrawingsArr.lines = {};
        fibonacciDrawingsArr.fill = {};
        fibonacciDrawingsArr.hideFibLevelButton = {};

        var nearestDataPointForTrendXValue = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, true, true);
        var nearestTrendYValue;
        if(futureValue >= nearestDataPointForTrendXValue.xData){
            nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, false, options.trendYValue, nearestDataPointForTrendXValue, options.trendXValue,  options.isSnapTopHighLow));
        } else {
            nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.trendYValue));
        }
        additionalDrawingsArr.referenceLine = chart.renderer.path(["M", xAxis.toPixels(nearestDataPointForTrendXValue.xData) - xAxis.toPixels(options.xValue), yAxis.toPixels(nearestTrendYValue) - yAxis.toPixels(options.yValue), 'L', newX, newY]).attr({
            'stroke-width': options.trendLineWidth,
            fill: ann.options.shape.params.fill,
            stroke: ann.options.shape.params.stroke,
            'z-index': 2,
            cursor: 'default',
            opacity: options.trendLineOpacity,
            dashstyle: options.trendLineStyle,                                                                                                                      
        }).add(ann.group);

        var hiddenLevelsEx = [];
        fibExtentionLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibExtentionLevels);
        fibExtentionLevels.forEach(function (fibLevel) {
            var themeFillColor = theme.fib3PointPriceProjectionGeneric && theme.fib3PointPriceProjectionGeneric.fibExtention && theme.fib3PointPriceProjectionGeneric.fibExtention.fibLevelFillColors && theme.fib3PointPriceProjectionGeneric.fibExtention.fibLevelFillColors[fibLevel.id];
            if (!fibLevel.enable) {
                hiddenLevelsEx.push(fibLevel.id);
            }
            drawingFillAttr = {
                'stroke-width': 0,
                fill: options.isSingleColorExtention && options.extentionFillColor ? options.extentionFillColor : fibLevel && fibLevel.fillColor ? fibLevel.fillColor : themeFillColor,
                'fill-opacity': options.isSingleColorExtention && options.extentionFillOpacity ? options.extentionFillOpacity : fibLevel && fibLevel.fillOpacity ? fibLevel.fillOpacity : baseFillOpacityExtention,
                stroke: ann.options.shape.params.stroke,
                'z-index': 2,
                cursor: 'default',
                'level': fibLevel.id,
                'pointer-events':'none'
            };
            drawingAttr = {
                'stroke-width': options.Extention && options.extentionLineWidth  ? options.extentionLineWidth : fibLevel && fibLevel.lineWidth ? fibLevel.lineWidth : ann.options.shape.params['stroke-width'],
                fill: ann.options.shape.params.fill,
                stroke: options.isSingleColorExtention && options.extentionLineColor ? options.extentionLineColor : fibLevel && fibLevel.lineColor ? fibLevel.lineColor : ann.options.shape.params.stroke,
                'z-index': 2,
                cursor: 'default',
                'level': fibLevel.id
            };

            var fontColorExtention = options.isSingleColorExtention && options.extentionFontColor ? options.extentionFontColor : fibLevel && fibLevel.fontColor ? fibLevel.fontColor : baseFontColorExtention;
            var fontSizeExtention = options.isSingleColorExtention && options.extentionFontSize ? options.extentionFontSize :  fibLevel && fibLevel.fontSize ? fibLevel.fontSize : baseFontSizeExtention;
            var fontWeightExtention = options.isSingleColorExtention && options.extentionFontWeight ? options.extentionFontWeight : fibLevel && fibLevel.fontWeight ? fibLevel.fontWeight : baseFontWeightExtention;

            labelCSSAttr = {
                'color': fontColorExtention,
                fontSize: fontSizeExtention + 'px',
                'font-weight': fontWeightExtention
            };
            labelAttr = {
                'level': fibLevel.id,
                'font-color': fontColorExtention,
                'font-size': fontSizeExtention,
                'font-weight': fontWeightExtention,
                subType: 'fibExtention',
            };
            
            fibonacciDrawingsArr.fill[fibLevel.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0]).attr(drawingFillAttr).add(ann.group);
            fibonacciDrawingsArr.lines[fibLevel.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingAttr).add(ann.group);
            fibonacciDrawingsArr.labels[fibLevel.id] = chart.renderer.label(infChart.drawingUtils.common.formatValue(fibLevel.value, 1), fibLevel.drawingPosX, fibLevel.drawingPosY).css(labelCSSAttr).attr(labelAttr).add(ann.group);
            fibonacciDrawingsArr.hideFibLevelButton[fibLevel.id] = chart.renderer.createElement('foreignObject').add(ann.group).attr({
                width: '20',
                height: '20',
                level: fibLevel.id,
                type: 'fibExtention',
                rel: 'hideFibLevelButton',
                cursor: 'pointer'
            }).add(ann.group);
            var labelHtml = "<div>" + self.closeIcon + "</div>";
            fibonacciDrawingsArr.hideFibLevelButton[fibLevel.id].element.innerHTML = labelHtml;
            $(fibonacciDrawingsArr.hideFibLevelButton[fibLevel.id].element).mousedown(function (event) {
                if (event.which == 1 || event.button == 0) {
                    event.stopPropagation();
                    setTimeout(function () {
                        var selectedLevel = event.currentTarget.getAttribute('level');
                        var subType = event.currentTarget.getAttribute('type');
                        var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(self.annotation.chart);
                        if (selectedLevel) {
                            if (self.isVisibleLastLevel()) {
                                infChart.drawingsManager.removeDrawing(chartId, self.drawingId, undefined, true);
                            } else {
                                self.onFibLevelChange(selectedLevel, false, subType, true);
                            }
                        }
                    }, 0);
                }
            });
            fibonacciDrawingsArr.hideFibLevelButton[fibLevel.id].toFront();
        });

        var baseFillOpacityRetransment = (theme.fib3PointPriceProjectionGeneric && theme.fib3PointPriceProjectionGeneric.fibRetrancement && typeof theme.fib3PointPriceProjectionGeneric.fibRetrancement.fillOpacity !== "undefined") ? theme.fib3PointPriceProjectionGeneric.fibRetrancement.fillOpacity : infChart.drawingUtils.common.baseFillOpacity;
        var baseFontColorRetransment = (theme.fib3PointPriceProjectionGeneric && theme.fib3PointPriceProjectionGeneric.fibRetrancement && typeof theme.fib3PointPriceProjectionGeneric.fibRetrancement.fontColor !== "undefined") ? theme.fib3PointPriceProjectionGeneric.fibRetrancement.fontColor : infChart.drawingUtils.common.baseFontColor;
        var baseFontSizeRetransment = (theme.fib3PointPriceProjectionGeneric && theme.fib3PointPriceProjectionGeneric.fibRetrancement && typeof theme.fib3PointPriceProjectionGeneric.fibRetrancement.fontSize !== "undefined") ? theme.fib3PointPriceProjectionGeneric.fibRetrancement.fontSize : infChart.drawingUtils.common.baseFontSize;
        var baseFontWeightRetransment = (theme.fib3PointPriceProjectionGeneric && theme.fib3PointPriceProjectionGeneric.fibRetrancement && typeof theme.fib3PointPriceProjectionGeneric.fibRetrancement.fontWeight !== "undefined") ? theme.fib3PointPriceProjectionGeneric.fibRetrancement.fontWeight : infChart.drawingUtils.common.fontWeight;

        self.fibRetrancementAdditionalDrawing.lines = {};
        self.fibRetrancementAdditionalDrawing.labels = {};
        self.fibRetrancementAdditionalDrawing.fill = {};
        self.fibRetrancementAdditionalDrawing.hideFibLevelButton = {};

        var hiddenLevelsRe = [];
        fibRetrancementLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibRetrancementLevels);
        fibRetrancementLevels.forEach(function (fibLevel) {
            var themeFillColor = theme.fib3PointPriceProjectionGeneric && theme.fib3PointPriceProjectionGeneric.fibRetrancement && theme.fib3PointPriceProjectionGeneric.fibRetrancement.fibLevelFillColors && theme.fib3PointPriceProjectionGeneric.fibRetrancement.fibLevelFillColors[fibLevel.id];
            if (!fibLevel.enable) {
                hiddenLevelsRe.push(fibLevel.id);
            }
            drawingFillAttr = {
                'stroke-width': 0,
                fill: options.isSingleColorRetracement && options.retrancementFillColor ? options.retrancementFillColor : fibLevel && fibLevel.fillColor ? fibLevel.fillColor : themeFillColor,
                'fill-opacity': options.isSingleColorRetracement && options.retrancementFillOpacity ? options.retrancementFillOpacity : fibLevel && fibLevel.fillOpacity ? fibLevel.fillOpacity : baseFillOpacityRetransment,
                stroke: ann.options.shape.params.stroke,
                'z-index': 2,
                cursor: 'default',
                'level': fibLevel.id,
                'pointer-events':'none'
            };
            drawingAttr = {
                'stroke-width': options.isSingleColorRetracement && options.retrancementLineWidth ? options.retrancementLineWidth : fibLevel && fibLevel.lineWidth ? fibLevel.lineWidth : ann.options.shape.params['stroke-width'],
                fill: ann.options.shape.params.fill,
                stroke: options.isSingleColorRetracement && options.retrancementLineColor ? options.retrancementLineColor : fibLevel && fibLevel.lineColor ? fibLevel.lineColor : ann.options.shape.params.stroke,
                'z-index': 2,
                cursor: 'default',
                'level': fibLevel.id
            };

            var fontColorRetransment = options.isSingleColorRetracement && options.retrancementFontColor ? options.retrancementFontColor : fibLevel && fibLevel.fontColor ? fibLevel.fontColor : baseFontColorRetransment;
            var fontSizeRetransment = options.isSingleColorRetracement && options.retrancementFontSize ? options.retrancementFontSize :  fibLevel && fibLevel.fontSize ? fibLevel.fontSize : baseFontSizeRetransment;
            var fontWeightRetrancement = options.isSingleColorRetracement && options.retrancementFontWeight ? options.retrancementFontWeight : fibLevel && fibLevel.fontWeight ? fibLevel.fontWeight : baseFontWeightRetransment;

            labelCSSAttr = {
                'color': fontColorRetransment,
                fontSize: fontSizeRetransment + 'px',
                'font-weight': fontWeightRetrancement
            };
            labelAttr = {
                'level': fibLevel.id,
                'font-color': fontColorRetransment,
                'font-size': fontSizeRetransment,
                'font-weight': fontWeightRetrancement,
                subType: 'fibRetracement'
            };
            
            self.fibRetrancementAdditionalDrawing.fill[fibLevel.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0]).attr(drawingFillAttr).add(ann.group);
            self.fibRetrancementAdditionalDrawing.lines[fibLevel.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingAttr).add(ann.group);
            self.fibRetrancementAdditionalDrawing.labels[fibLevel.id] = chart.renderer.label(infChart.drawingUtils.common.formatValue(fibLevel.value, 1), fibLevel.drawingPosX, fibLevel.drawingPosY).css(labelCSSAttr).attr(labelAttr).add(ann.group);
            self.fibRetrancementAdditionalDrawing.hideFibLevelButton[fibLevel.id] = chart.renderer.createElement('foreignObject').add(ann.group).attr({
                width: '20',
                height: '20',
                level: fibLevel.id,
                type: 'fibRetracement',
                rel: 'hideFibLevelButton',
                cursor: 'pointer'
            }).add(ann.group);
            var labelHtml = "<div>" + self.closeIcon + "</div>";
            self.fibRetrancementAdditionalDrawing.hideFibLevelButton[fibLevel.id].element.innerHTML = labelHtml;
            $(self.fibRetrancementAdditionalDrawing.hideFibLevelButton[fibLevel.id].element).mousedown(function (event) {
                if (event.which == 1 || event.button == 0) {
                    event.stopPropagation();
                    setTimeout(function () {
                        var selectedLevel = event.currentTarget.getAttribute('level');
                        var subType = event.currentTarget.getAttribute('type');
                        var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(self.annotation.chart);
                        if (selectedLevel) {
                            if (self.isVisibleLastLevel()) {
                                infChart.drawingsManager.removeDrawing(chartId, self.drawingId, undefined, true);
                            } else {
                                self.onFibLevelChange(selectedLevel, false, subType, true);
                            }
                        }
                    }, 0);
                }
            });
            self.fibRetrancementAdditionalDrawing.hideFibLevelButton[fibLevel.id].toFront();
        });

        hiddenLevelsEx.forEach(function (id) {
            self.onFibLevelChange(id, false, "fibExtention", false);
        });

        hiddenLevelsRe.forEach(function (id) {
            self.onFibLevelChange(id, false, "fibRetracement", false);
        });
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.isVisibleLastLevel = function () {
    var self = this;
    var count = 0;
    $.each(self.fibonacciDrawings.lines, function (key, value) {
        if (value.visibility !== 'hidden') {
            count = count + 1;
        }
    });
    $.each(self.fibRetrancementAdditionalDrawing.lines, function (key, value) {
        if (value.visibility !== 'hidden') {
            count = count + 1;
        }
    });

    return count === 1;
}

infChart.fib3PointPriceProjectionGenericDrawing.prototype.bindSettingsEvents = function () {
    var self = this;

    var onChangeSnapToHighLow = function (checked, isPropertyChange) {
        self.onChangeSnapToHighLow.call(self, checked, isPropertyChange);
    };

    var onTrendLineToggleShow = function (show) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onTrendLineToggleShow.call(self, show, isPropertyChange);
    };

    return infChart.drawingUtils.common.bindFibGenericSettingsEvents.call(this, infChart.drawingUtils.common.baseBorderColor, infChart.drawingUtils.common.baseLineWidth,
        undefined, undefined, onChangeSnapToHighLow, onTrendLineToggleShow);
};


infChart.fib3PointPriceProjectionGenericDrawing.prototype.deselect = function (isMouseOut) {
    infChart.drawingUtils.common.onDeselect.call(this);
    this.annotation.options.selectedDrawing = undefined;
    if (isMouseOut) {
        if (this.annotation) {
            if(this.annotation.options && !this.annotation.options.isTrendLineAlways){
                this.annotation.shape.hide();
            }
            if(this.additionalDrawings && this.additionalDrawings.referenceLine){
                if(this.annotation.options && !this.annotation.options.isTrendLineAlways){
                    this.additionalDrawings.referenceLine.hide();
                    this.resetDragSupporters();
                }
            }
            this.toggleFibLevelEraseIcon(true);
        }
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.toggleFibLevelEraseIcon = function (hide) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        fibonacciExpansionDrawingLabels = self.fibonacciDrawings.labels,
        fibonacciRetrancementDrawingLabels = self.fibRetrancementAdditionalDrawing.labels,
        chart = ann.chart,
        line = ann.shape.d.split(' '),
        dx = line[4],
        xAxis = chart.xAxis[options.xAxis];

    if (hide) {
        if(self.fibonacciDrawings.hideFibLevelButton){
            $.each(self.fibonacciDrawings.hideFibLevelButton, function (key, value) {
                var hideFibLevelButton = self.fibonacciDrawings.hideFibLevelButton[key];
                if(hideFibLevelButton){
                    hideFibLevelButton.hide();
                }
            });
        }
        if(self.fibRetrancementAdditionalDrawing.hideFibLevelButton){
            $.each(self.fibRetrancementAdditionalDrawing.hideFibLevelButton, function (key, value) {
                var hideFibLevelButton = self.fibRetrancementAdditionalDrawing.hideFibLevelButton[key];
                if(hideFibLevelButton){
                    hideFibLevelButton.hide();
                }
            });
        }
    } else {
        $.each(self.fibonacciDrawings.lines, function (key, value) {
            if (self.fibonacciDrawings.lines[key].visibility !== "hidden") {
                var hideFibLevelButton = self.fibonacciDrawings.hideFibLevelButton[key];
                var drawingLabel = fibonacciExpansionDrawingLabels[key];
                var labelStartPosition = xAxis.toValue(xAxis.width) > Math.min(options.xValue, options.xValueEnd) ? (xAxis.width - xAxis.toPixels(ann.options.xValue)) : dx > 0 ? dx : 0;
                self.positionHideIcon(hideFibLevelButton, labelStartPosition, drawingLabel, value.d.split(' '), "fibExtention");
                if(hideFibLevelButton){
                    hideFibLevelButton.show();
                }
            }
        });

        $.each(self.fibRetrancementAdditionalDrawing.lines, function (key, value) {
            if (self.fibRetrancementAdditionalDrawing.lines[key].visibility !== "hidden") {
                var hideFibLevelButton = self.fibRetrancementAdditionalDrawing.hideFibLevelButton[key];
                var drawingLabel = fibonacciRetrancementDrawingLabels[key];
                var labelStartPosition = xAxis.toValue(xAxis.width) > Math.min(options.xValue, options.xValueEnd) ? (xAxis.width - xAxis.toPixels(ann.options.xValue)) : dx > 0 ? dx : 0;
                self.positionHideIcon(hideFibLevelButton, labelStartPosition, drawingLabel, value.d.split(' '), "fibRetracement");
                if(hideFibLevelButton){
                    hideFibLevelButton.show();
                }
            }
        });
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.getConfig = function (shape) {
    var self = this,
        shape = self.shape,
        annotation = self.annotation,
        options = annotation.options,
        fibLevels = options.fibLevels ? options.fibLevels : self.fibLevels;
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels),
        fibExtentionLevels = options.fibExtentionLevels ? options.fibExtentionLevels : self.fibExtentionLevels,
        fibExtentionLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibExtentionLevels),
        fibRetrancementLevels = options.fibRetrancementLevels ? options.fibRetrancementLevels : self.fibRetrancementLevels,
        fibRetrancementLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibRetrancementLevels);

    return {
        shape: shape,
        extentionLabelPosition: annotation.options.extentionLabelPosition,
        extentionLineColor: annotation.options.extentionLineColor,
        extentionFillColor: annotation.options.extentionFillColor,
        extentionFillOpacity: annotation.options.extentionFillOpacity,
        extentionLineWidth: annotation.options.extentionLineWidth,
        extentionFontColor: annotation.options.extentionFontColor,
        extentionFontSize: annotation.options.extentionFontSize,
        extentionFontWeight: annotation.options.extentionFontWeight,
        retracementLabelPosition: annotation.options.retracementLabelPosition,
        retrancementLineColor: annotation.options.retrancementLineColor,
        retrancementFillColor: annotation.options.retrancementFillColor,
        retrancementFillOpacity: annotation.options.retrancementFillOpacity,
        retrancementLineWidth: annotation.options.retrancementLineWidth,
        retrancementFontColor: annotation.options.retrancementFontColor,
        retrancementFontSize: annotation.options.retrancementFontSize,
        retrancementFontWeight: annotation.options.retrancementFontWeight,
        trendXValue: annotation.options.trendXValue,
        trendYValue: annotation.options.trendYValue,
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        isSingleColorExtention: annotation.options.isSingleColorExtention,
        isSingleColorRetracement: annotation.options.isSingleColorRetracement,
        isHLH: annotation.options.isHLH,
        isSnapTopHighLow: annotation.options.isSnapTopHighLow,
        fibExtentionLevels: fibExtentionLevels,
        fibRetrancementLevels: fibRetrancementLevels,
        isTrendLineAlways: annotation.options.isTrendLineAlways,
        trendLineColor: annotation.options.trendLineColor,
        trendLineOpacity: annotation.options.trendLineOpacity,
        trendLineWidth: annotation.options.trendLineWidth,
        trendLineStyle: annotation.options.trendLineStyle,
        isLocked : annotation.options.isLocked

    };
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.getContextMenuOptions = function (chartId, drawingId, options , event) {
    var self = this;
    var level = event.target.getAttribute('level');
    var subType = event.target.getAttribute('subType');
    if(!level && event.target.parentElement){
        level = event.target.parentElement.getAttribute('level');
        subType = event.target.parentElement.getAttribute('subType');
        if(!level && event.target.parentElement.parentElement){
            level = event.target.parentElement.parentElement.getAttribute('level');
            subType = event.target.parentElement.parentElement.getAttribute('subType');
        }
    }

    var contextMenu = {
        "copyToClipboard" : {
            icon : options.copyToClipboard.icon,
            displayText : options.copyToClipboard.displayText,
            action : function () {
                if(level) {
                    infChart.drawingUtils.common.onFibLevelCopy.call(self, level, subType);
                }
            }
        }
    };
    if (!self.isVisibleLastLevel()) {
        var eraseThis = {
            icon: options.erase.icon,
            displayText: options.erase.displayText,
            action: function () {
                if (level) {
                    self.onFibLevelChange(level, false, subType, true);
                }
            }
        }
        contextMenu["eraseThis"] = eraseThis;
    }
    if(level) {
        contextMenu = Object.assign(contextMenu, infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options));
        return infChart.drawingUtils.common.reorderContextMenu(contextMenu);
    }else{
        return  infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options)
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.getFormattedLabel = function (yAxis, yValue, trendYValue, yValueEnd, percentage, stockChart, type) {
    var percentageValue = percentage/100;
    if(type == "fibExtention"){
        var labelYValue = yValue > trendYValue ? yValueEnd + (yValue - trendYValue) * percentageValue : yValueEnd - (trendYValue - yValue) * percentageValue;
    }
    if(type == "fibRetracement"){
        var labelYValue = yValueEnd > yValue ? yValueEnd - (yValueEnd - yValue) * percentageValue : yValueEnd + (yValue - yValueEnd) * percentageValue; 
    }
    var formatedLabelYValue = stockChart.formatValue(labelYValue, stockChart.getMainSeries().options.dp, undefined, false, false);
    if(type == "fibExtention"){
        return formatedLabelYValue + " " + ((percentageValue == 0) ? "" : percentageValue >= 1 ? "PP": "PP") + " " + infChart.drawingUtils.common.formatValue(percentageValue, 3);
    }
    if(type == "fibRetracement"){
        return formatedLabelYValue + " " + ((percentageValue == 0 || percentageValue == 1) ? "" : percentageValue > 1 ? "EX": "RET") + " " + infChart.drawingUtils.common.formatValue(percentageValue, 3);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.getNearestYValue = function (isHLH, isLineStartYValue, referredYValue, nearestDataPoint, trendYValue, isSnapTopHighLow, chart) {
    var self = this;
    var nearestYValue = referredYValue;
    if(!chart){
        chart = this.annotation.chart; 
    }
    if (!isSnapTopHighLow) {
        var nearestReturnYValue = nearestYValue;
        var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart);
        var chartInstance = infChart.manager.getChart(stockChartId);
        if (chartInstance.isCompare || chartInstance.isLog) {
            nearestReturnYValue = infChart.drawingUtils.common.getBaseYValue.call(this, nearestYValue);
        }
        return nearestReturnYValue;
    }

    var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart);
    var chartInstance = infChart.manager.getChart(stockChartId);

    var nearestYValueOpenValue, nearestYValueCloseValue;
    if (chartInstance.isLog || chartInstance.isCompare) {
        nearestYValueOpenValue = infChart.drawingUtils.common.getYValue.call(self, nearestDataPoint.yData[1]);
        nearestYValueCloseValue = infChart.drawingUtils.common.getYValue.call(self,nearestDataPoint.yData[2]);
    } else {
        nearestYValueOpenValue = nearestDataPoint.yData[1];
        nearestYValueCloseValue = nearestDataPoint.yData[2];
    }

    if (referredYValue) {
        if (Math.abs(referredYValue - nearestYValueOpenValue) < Math.abs(referredYValue - nearestYValueCloseValue)) {
            nearestYValue = nearestDataPoint.yData[1];
        } else {
            nearestYValue = nearestDataPoint.yData[2];
        }
    }

    return nearestYValue;
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.getOptions = function (properties, chart, isHLH) {
    var isHLH = (this.shape == 'fib3PointPriceProjectionHLH') ? true : false ;
    var futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];
    var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, properties.xValue, undefined, true, true);
    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        nearestXValue: nearestDataForXValue.xData,
        trendXValue: Number.MIN_SAFE_INTEGER,
        trendYValue: Number.MIN_SAFE_INTEGER,
        allowDragX: true,
        allowDragY: true,
        allowDragByHandle: true,
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0]
            }
        },
        isHLH: isHLH
    };

    var theme = infChart.drawingUtils.common.getTheme.call(this);
    var shapeTheme = theme["fib3PointPriceProjectionGeneric"];
    var baseFillColor = (theme.fib3PointPriceProjection && theme.fib3PointPriceProjection.singleFillColor) ? theme.fib3PointPriceProjection.singleFillColor : (theme.fibonacci && theme.fibonacci.singleFillColor) ? theme.fibonacci.singleFillColor : infChart.drawingUtils.common.baseFillColor;
    var baseFillOpacity = (theme.fib3PointPriceProjection && typeof theme.fib3PointPriceProjection.fillOpacity !== "undefined") ? theme.fib3PointPriceProjection.fillOpacity : (theme.fibonacci && typeof theme.fibonacci.fillOpacity !== "undefined") ? theme.fibonacci.fillOpacity : infChart.drawingUtils.common.baseFillOpacity;
    var baseBorderColor = (theme.fib3PointPriceProjection && theme.fib3PointPriceProjection.borderColor) ? theme.fib3PointPriceProjection.borderColor : (theme.fibonacci && theme.fibonacci.borderColor) ? theme.fibonacci.borderColor : infChart.drawingUtils.common.baseBorderColor;
    var baseLineWidth = (theme.fib3PointPriceProjection && typeof theme.fib3PointPriceProjection.lineWidth !== "undefined") ? theme.fib3PointPriceProjection.lineWidth : (theme.fibonacci && theme.fibonacci.lineWidth) ? theme.fibonacci.lineWidth : infChart.drawingUtils.common.baseLineWidth;
    var baseFontColor = (theme.fib3PointPriceProjection && theme.fib3PointPriceProjection.fontColor) ? theme.fib3PointPriceProjection.fontColor: (theme.fibonacci && theme.fibonacci.fontColor) ? theme.fibonacci.fontColor : infChart.drawingUtils.common.baseFontColor;
    var baseFontSize = (theme.fib3PointPriceProjection && theme.fib3PointPriceProjection.fontSize) ? theme.fib3PointPriceProjection.fontSize: (theme.fibonacci && theme.fibonacci.fontSize) ? theme.fibonacci.fontSize : infChart.drawingUtils.common.baseFontSize;
    var baseFontWeight = (theme.fib3PointPriceProjection && theme.fib3PointPriceProjection.fontWeight) ? theme.fib3PointPriceProjection.fontWeight: (theme.fibonacci && theme.fibonacci.fontWeight) ? theme.fibonacci.fontWeight : infChart.drawingUtils.common.baseFontWeight;

    options.extentionFillColor = properties.extentionFillColor ? properties.extentionFillColor : baseFillColor;
    options.extentionFillOpacity = properties.extentionFillOpacity ? properties.extentionFillOpacity : baseFillOpacity;
    options.extentionLineColor = properties.extentionLineColor ? properties.extentionLineColor : baseBorderColor;
    options.extentionLineWidth = properties.extentionLineWidth ? properties.extentionLineWidth : baseLineWidth;
    options.extentionFontColor = properties.extentionFontColor ? properties.extentionFontColor : baseFontColor;
    options.extentionFontSize = properties.extentionFontSize ? properties.extentionFontSize : baseFontSize;
    options.extentionFontWeight = properties.extentionFontWeight ? properties.extentionFontWeight : baseFontWeight;
    options.extentionLabelPosition = properties.extentionLabelPosition ? properties.extentionLabelPosition : "topLeft";

    options.trendLineColor = properties.trendLineColor ? properties.trendLineColor : shapeTheme.stroke || "#959595";
    options.trendLineOpacity = properties.trendLineOpacity ? properties.trendLineOpacity : shapeTheme.opacity || 1;
    options.trendLineWidth = properties.trendLineWidth ? properties.trendLineWidth : baseLineWidth || 1;
    options.trendLineStyle = properties.trendLineStyle ? properties.trendLineStyle : shapeTheme.dashstyle || 'solid';

    options.retrancementFillColor = properties.retrancementFillColor ? properties.retrancementFillColor : baseFillColor;
    options.retrancementFillOpacity = properties.retrancementFillOpacity ? properties.retrancementFillOpacity : baseFillOpacity;
    options.retrancementLineColor = properties.retrancementLineColor ? properties.retrancementLineColor : baseBorderColor;
    options.retrancementLineWidth = properties.retrancementLineWidth ? properties.retrancementLineWidth : baseLineWidth;
    options.retrancementFontColor = properties.retrancementFontColor ? properties.retrancementFontColor : baseFontColor;
    options.retrancementFontSize = properties.retrancementFontSize ? properties.retrancementFontSize : baseFontSize;
    options.retrancementFontWeight = properties.retrancementFontWeight ? properties.retrancementFontWeight : baseFontWeight;
    options.retracementLabelPosition = properties.retracementLabelPosition ? properties.retracementLabelPosition : "topRight";

    options.shape.params.fill = baseFillColor;
    options.shape.params['fill-opacity'] = baseFillOpacity;
    options.shape.params.stroke = options.trendLineColor;
    options.shape.params.opacity =  options.trendLineOpacity;
    options.shape.params['stroke-width'] = options.trendLineWidth;
    options.shape.params.dashstyle = options.trendLineStyle ;
    options.shape.params['font-color'] = baseFontColor;
    options.shape.params['font-size'] = baseFontSize;
    options.showSnapToHighLowToggle = true;
    options.showTrendLineAlwaysToggle = true;
    options.isSnapTopHighLow = typeof properties.isSnapTopHighLow !== "undefined" ? properties.isSnapTopHighLow : false;
    options.isTrendLineAlways = typeof properties.isTrendLineAlways !== "undefined" ? properties.isTrendLineAlways : true;
    if(futureValue >= options.nearestXValue){
        options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(isHLH, true, properties.yValue, nearestDataForXValue, properties.trendYValue,  properties.isSnapTopHighLow, chart));
    } else {
        options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, properties.yValue));
    }
    options.yValue = options.nearestYValue;


    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
        var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, properties.xValueEnd, undefined, true, true);
        options.nearestXValueEnd = nearestDataForXValueEnd.xData;
        if(futureValue >= options.nearestXValueEnd){
            options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(isHLH, false, properties.yValueEnd, nearestDataForXValueEnd, properties.trendYValue, properties.isSnapTopHighLow, chart));
        } else {
            options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, properties.yValueEnd));
        }
        options.yValueEnd = options.nearestYValueEnd;
    }

    if (properties.trendXValue && properties.trendYValue) {
        options.trendXValue = properties.trendXValue;
        options.trendYValue = properties.trendYValue;

        var nearestDataForTrendXValue = infChart.math.findNearestDataPoint(chart, properties.trendXValue, undefined, true, true);
        options.nearestTrendXValue = nearestDataForTrendXValue.xData;
        if(futureValue >= options.nearestTrendXValue){
            options.nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this,this.getNearestYValue(options.isHLH, false, options.trendYValue, nearestDataForTrendXValue, options.trendXValue, properties.isSnapTopHighLow, chart));
        } else {
            options.nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.trendYValue));
        }
        options.trendYValue = options.nearestTrendYValue;
    } else {
        options.events = null;
    }

    options.isSingleColorExtention = typeof properties.isSingleColorExtention !== "undefined" ? properties.isSingleColorExtention : false;
    options.isSingleColorRetracement = typeof properties.isSingleColorRetracement !== "undefined" ? properties.isSingleColorRetracement : false;
    options.fibLevels = properties.fibLevels ? properties.fibLevels : this.fibLevels;
    options.fibLevels = infChart.drawingUtils.common.getFibLevelsWithOpacity(infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels), baseFillOpacity);
    options.fibExtentionLevels = properties.fibExtentionLevels ? properties.fibExtentionLevels : this.fibExtentionLevels;
    options.fibExtentionLevels = infChart.drawingUtils.common.getFibLevelsWithOpacity(infChart.drawingUtils.common.sortFibLevelsByValue(options.fibExtentionLevels), baseFillOpacity);
    options.fibRetrancementLevels = properties.fibRetrancementLevels ? properties.fibRetrancementLevels : this.fibRetrancementLevels;
    options.fibRetrancementLevels = infChart.drawingUtils.common.getFibLevelsWithOpacity(infChart.drawingUtils.common.sortFibLevelsByValue(options.fibRetrancementLevels), baseFillOpacity);
    options.isRealTimeTranslation = true;
    options.disableIntermediateScale = true;
    options.validateTranslationFn = function (newXValue) {
        var annotation = this.annotation,
            chart = annotation.chart,
            options = annotation.options,
            xVal = options.xValue,
            xValEnd = options.xValueEnd,
            newXValueEnd = xValEnd - xVal + newXValue,
            newTrendXValueEnd = options.trendXValue - xVal + newXValue,
            xAxis = chart.xAxis[options.xAxis],
            seriesData = chart.series[0].xData,
            dataMin = seriesData[0],
            totalPoints = infChart.drawingsManager.getTotalPoints(chart),
            dataMax = totalPoints[totalPoints.length - 1];

        return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax) && (newTrendXValueEnd >= dataMin && newTrendXValueEnd <= dataMax) && (options.selectedDrawing == "mainDrawing");
    }

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.getQuickSettingsPopup = function () {
    return infChart.drawingUtils.common.getGenericQuickFibSettings();
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.getSettingsPopup = function () {
    var self = this;
    var options = self.annotation.options;
    var fibExtentionLevels = options.fibExtentionLevels ? options.fibExtentionLevels : self.fibExtentionLevels;
    var fibRetrancementLevels = options.fibRetrancementLevels ? options.fibRetrancementLevels : self.fibRetrancementLevels;
    var properties = {
        extentionFillColor: options.extentionFillColor,
        extentionFillOpacity: options.extentionFillOpacity,
        extentionLineColor: options.extentionLineColor,
        extentionLineWidth: options.extentionLineWidth,
        extentionFontColor: options.extentionFontColor,
        extentionFontSize: options.extentionFontSize,
        extentionFontWeight: options.extentionFontWeight,
        retrancementFillColor: options.retrancementFillColor,
        retrancementFillOpacity: options.retrancementFillOpacity,
        retrancementLineColor: options.retrancementLineColor,
        retrancementLineWidth: options.retrancementLineWidth,
        retrancementFontColor: options.retrancementFontColor,
        retrancementFontSize: options.retrancementFontSize,
        retrancementFontWeight: options.retrancementFontWeight,
        fibExtentionLevels: fibExtentionLevels,
        fibRetrancementLevels: fibRetrancementLevels,
        templates: self.getDrawingTemplates(),
        showFibModeToggle: false,
        showSnapToHighLowToggle: options.showSnapToHighLowToggle,
        userDefaultSettings: self.getUserDefaultSettings(),
        showTrendLineAlwaysToggle: options.showTrendLineAlwaysToggle,
        trendLineColor: options.trendLineColor,
        trendLineOpacity: options.trendLineOpacity,
        trendLineWidth: options.trendLineWidth,
        trendLineStyle: options.trendLineStyle
    }
    return infChart.drawingUtils.common.getGenericFibSettings(properties);
};


/**
 * on snap to high/low change
 * @param {boolean} checked - snap to high/low checked
 * @param {boolean} isPropertyChange - is propery changed
 * @param {boolean} ignoreSettingsSave - this is to indicate to this change does not affect to subsequent drawing
 */
infChart.fib3PointPriceProjectionGenericDrawing.prototype.onChangeSnapToHighLow = function (checked, isPropertyChange, ignoreSettingsSave) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart;

    options.isSnapTopHighLow = checked;
    //var futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];
    // if (options.isSnapTopHighLow) {
    //     var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
    //     var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);
    //     var nearestDataPointForTrendXValue = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, true, true);
    //     if(futureValue >= nearestDataPointForTrendXValue.xData){
    //         options.nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, false, options.trendYValue, nearestDataPointForTrendXValue, options.trendXValue,  options.isSnapTopHighLow));
    //     } else {
    //         options.nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.nearestTrendYValue));
    //     }
    //     if(futureValue >= nearestDataForXValue.xData){
    //         options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, true, self.nearestYValue, nearestDataForXValue, options.trendXValue, options.isSnapTopHighLow));
    //     } else {
    //         options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.nearestYValue));
    //     }
    //     if(futureValue >= nearestDataForXValueEnd.xData){
    //         options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, false, self.nearestYValueEnd, nearestDataForXValueEnd, options.trendXValue, options.isSnapTopHighLow));
    //     } else {
    //         options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.nearestYValueEnd));
    //     }
    // } else {
    //     options.nearestYValue = options.yValue;
    //     options.nearestYValueEnd = options.yValueEnd;
    //     options.nearestTrendYValue = options.trendYValue;
    // }

    // infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd);

    // self.scale();
    // self.selectAndBindResize();
    // chart.selectedAnnotation = ann;
    // self.updateSettings( self.getConfig());
    isPropertyChange && self.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.moveStartPoint = function (e) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id)),
        options = ann.options,
        x = e.chartX,
        y = e.chartY,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        fibExtentionLevels = options.fibExtentionLevels ? options.fibExtentionLevels : this.fibExtentionLevels,
        fibExtentionLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibExtentionLevels),
        fibRetrancementLevels = options.fibRetrancementLevels ? options.fibRetrancementLevels : this.fibRetrancementLevels,
        fibRetrancementLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibRetrancementLevels),
        fibonacciExtentionDrawingLabels = self.fibonacciDrawings.labels,
        fibonacciRetrancementDrawingLabels = self.fibRetrancementAdditionalDrawing.labels,
        fibonacciExtentionDrawingsFill = self.fibonacciDrawings.fill,
        fibonacciRetrancementDrawingsFill = self.fibRetrancementAdditionalDrawing.fill,
        fibExtentionlineDrawings = self.fibonacciDrawings.lines,
        fibRetrancementLineDrawings = self.fibRetrancementAdditionalDrawing.lines,
        pathDefinition = ann.shape.d.split(' '),
        dx = parseFloat(pathDefinition[4]),
        dy = parseFloat(pathDefinition[5]),
        futureValue = chart.series[0].xData[chart.series[0].xData.length - 1],
        nearestDataPointForTrendXValue = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, true, true);
        var nearestTrendYValue;
        if(options.isSnapTopHighLow) {
            if(futureValue >= nearestDataPointForTrendXValue.xData){
                nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this,this.getNearestYValue(options.isHLH, false, options.trendYValue, nearestDataPointForTrendXValue, options.trendXValue,  options.isSnapTopHighLow));
            } else {
                nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.trendYValue));
            }
        } else {
            nearestTrendYValue = yAxis.toValue(y);
            //nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.trendYValue));
        }

    ann.update({
        trendXValue: xAxis.toValue(x),
        trendYValue: nearestTrendYValue,
        nearestTrendXValue: nearestDataPointForTrendXValue.xData
        // trendYValue: yAxis.toValue(y),
        // nearestTrendXValue: nearestDataPointForTrendXValue.xData,
        // nearestTrendYValue: nearestTrendYValue
    });

    self.additionalDrawings.referenceLine.attr({
        d: ["M", xAxis.toPixels(nearestDataPointForTrendXValue.xData) - xAxis.toPixels(options.xValue), yAxis.toPixels(nearestTrendYValue) - yAxis.toPixels(options.yValue), 'L', pathDefinition[1], pathDefinition[2]]
    });

    $.each(fibExtentionlineDrawings, function (key, value) {
        var fibLevel = fibExtentionLevels.find(function (level) {
            return level.id === key;
        });
        var percentage = parseFloat(fibLevel.value);
        var percentageY = -((yAxis.toPixels(nearestTrendYValue) - yAxis.toPixels(options.yValue)) * percentage / 100) + dy;
        var lineEndPosition = (xAxis.width - xAxis.toPixels(ann.options.xValue));
        var fibExtentionDrawingLabel = fibonacciExtentionDrawingLabels[key];
        var fibExtentionHideFibLevelButton = self.fibonacciDrawings.hideFibLevelButton[key];
        var line = ["M", 0, percentageY, 'L', lineEndPosition, percentageY];

        value.attr({
            d: line
        });

        fibExtentionDrawingLabel.textSetter(self.getFormattedLabel(yAxis, options.yValue, nearestTrendYValue, options.yValueEnd, percentage, stockChart, "fibExtention"));

        self.positionDrawingLabel(fibExtentionDrawingLabel, line, "fibExtention");
        self.positionHideIcon(fibExtentionHideFibLevelButton, lineEndPosition, fibExtentionDrawingLabel, line, "fibExtention");
    });

    fibExtentionLevels.forEach(function (value, index, arr) {
        fill = fibonacciExtentionDrawingsFill && fibonacciExtentionDrawingsFill[value.id];
        currentLine = fibExtentionlineDrawings[value.id];
        currentLineP = currentLine && currentLine.d.split(' ');

        for (var i = index + 1; i < arr.length; i++) {
            var lineTemp = fibExtentionlineDrawings[arr[i].id];
            if (lineTemp && lineTemp.visibility != "hidden") {
                nextLine = lineTemp;
                break;
            }
        }
        nextLineP = nextLine && nextLine.d.split(' ');
        if (currentLine && nextLine) {
            fill.attr({
                d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
            });
        }
        nextLine = undefined;
    });


    $.each(fibRetrancementLineDrawings, function (key, value) {
        var fibLevel = fibRetrancementLevels.find(function (level) {
            return level.id === key;
        });
        var percentage = parseFloat(fibLevel.value);
        var percentageY = -((yAxis.toPixels(options.yValueEnd) - yAxis.toPixels(options.yValue)) * percentage / 100) + dy;
        var lineEndPosition = (xAxis.width - xAxis.toPixels(ann.options.xValue));
        var fibRetrancementDrawingLabel = fibonacciRetrancementDrawingLabels[key];
        var fibRetrancementHideFibLevelButton = self.fibRetrancementAdditionalDrawing.hideFibLevelButton[key];
        var line = ["M", 0, percentageY, 'L', lineEndPosition, percentageY];

        value.attr({
            d: line
        });

        fibRetrancementDrawingLabel.textSetter(self.getFormattedLabel(yAxis, options.yValue, nearestTrendYValue, options.yValueEnd, percentage, stockChart, "fibRetracement"));

        self.positionDrawingLabel(fibRetrancementDrawingLabel, line, "fibRetracement");
        self.positionHideIcon(fibRetrancementHideFibLevelButton, lineEndPosition, fibRetrancementDrawingLabel, line, "fibRetracement");
    });

    fibRetrancementLevels.forEach(function (value, index, arr) {
        fill = fibonacciRetrancementDrawingsFill && fibonacciRetrancementDrawingsFill[value.id];
        currentLine = fibRetrancementLineDrawings[value.id];
        currentLineP = currentLine && currentLine.d.split(' ');

        for (var i = index + 1; i < arr.length; i++) {
            var lineTemp = fibRetrancementLineDrawings[arr[i].id];
            if (lineTemp && lineTemp.visibility != "hidden") {
                nextLine = lineTemp;
                break;
            }
        }
        nextLineP = nextLine && nextLine.d.split(' ');
        if (currentLine && nextLine) {
            fill.attr({
                d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
            });
        }
        nextLine = undefined;
    });

    return {line: pathDefinition, nearestTrendYValue: nearestTrendYValue};
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.scale = function (isCalculateNewValueForScale) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        stockChart,
        line = ann.shape.d.split(' '),
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        fibExtentionLevels = options.fibExtentionLevels ? options.fibExtentionLevels : this.fibExtentionLevels,
        fibExtentionLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibExtentionLevels),
        fibRetrancementLevels = options.fibRetrancementLevels ? options.fibRetrancementLevels : this.fibRetrancementLevels,
        fibRetrancementLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibRetrancementLevels),
        fibonacciExtentionDrawingLabels = self.fibonacciDrawings.labels,
        fibonacciRetrancementDrawingLabels = self.fibRetrancementAdditionalDrawing.labels,
        fibonacciExtentionDrawingsFill = self.fibonacciDrawings.fill,
        fibonacciRetrancementDrawingsFill = self.fibRetrancementAdditionalDrawing.fill,
        fibExtentionlineDrawings = self.fibonacciDrawings.lines,
        fibRetrancementLineDrawings = self.fibRetrancementAdditionalDrawing.lines,
        stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart),
        chartInstance = infChart.manager.getChart(stockChartId),
        futureValue = chart.series[0].xData[chart.series[0].xData.length - 1],
        fill,
        currentLine,
        currentLineP,
        nextLine,
        nextLineId,
        nextLineP,
        xValueInPixels = xAxis.toPixels(options.xValue),
        yValueInPixels = yAxis.toPixels(options.yValue),
        fibLevelLines = {};

        if (isCalculateNewValueForScale) {
            stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id))
            nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
            options.nearestXValue = nearestDataForXValue.xData;
            nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);
            options.nearestXValueEnd = nearestDataForXValueEnd.xData;
            nearestDataPointForTrendXValue = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, true, true);
            options.nearestTrendXValue = nearestDataPointForTrendXValue.xData;

            if(futureValue >= options.nearestXValue){
                options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, true, options.yValue, nearestDataForXValue, options.trendXValue, false));
            } else {
                options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValue.call(this, options.yValue));
            }
            if(futureValue >= options.nearestXValueEnd){
                options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, false, options.yValueEnd, nearestDataForXValueEnd, options.trendXValue, false));
            } else {
                options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValue.call(self, options.yValueEnd));
            }
            if(futureValue >= options.nearestTrendXValue){
                options.nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this,this.getNearestYValue(options.isHLH, false, options.trendYValue, nearestDataPointForTrendXValue, options.trendXValue, false));
            } else {
                options.nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValue.call(self, options.trendYValue));
            }
            
            if (chartInstance.isLog || chartInstance.isCompare) {
                self.nearestYValue = infChart.drawingUtils.common.getBaseYValue.call(self, options.nearestYValue);
                self.nearestYValueEnd = infChart.drawingUtils.common.getBaseYValue.call(self, options.nearestYValueEnd);
                self.nearestTrendYValue = infChart.drawingUtils.common.getBaseYValue.call(self, options.nearestTrendYValue);
            } else {
                self.nearestYValue = options.nearestYValue;
                self.nearestYValueEnd = options.nearestYValueEnd;
                self.nearestTrendYValue = options.nearestTrendYValue;
            }
        } 

        var newX = xAxis.toPixels(options.nearestXValue) - xValueInPixels,
        newXEnd = xAxis.toPixels(options.nearestXValueEnd) - xValueInPixels,
        newY = yAxis.toPixels(options.yValue) - yValueInPixels,
        newYEnd = yAxis.toPixels(options.yValueEnd) - yValueInPixels;

    line[1] = (!isNaN(newX) && newX) || 0;
    line[2] = (!isNaN(newY) && newY) || 0;
    line[4] = (!isNaN(newXEnd) && newXEnd) || 0;
    line[5] = (!isNaN(newYEnd) && newYEnd) || 0;

    ann.update({
        shape: {
            params: {
                d: line
            }
        }
    });

    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    if(ann.shape.visibility !== "hidden"){
        infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, undefined, self.defaultDragSupporterStyles);
    }

    var dx = line[4], dy = line[5];

    if (fibExtentionlineDrawings) {
        self.additionalDrawings.referenceLine.attr({
            d: ["M", xAxis.toPixels(options.nearestTrendXValue) - xValueInPixels, yAxis.toPixels(options.trendYValue) - yValueInPixels, 'L', newX, newY]
        });
        if(self.additionalDrawings && self.additionalDrawings.referenceLine && self.additionalDrawings.referenceLine.visibility !== "hidden"){
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, self.additionalDrawings.referenceLine.d.split(' '), self.dragSupporters, undefined, self.defaultDragSupporterStyles);
        }
        var lineStartPosition = newX;
        var lineEndPosition = xAxis.toValue(xAxis.width) > Math.min(options.xValue, options.xValueEnd) ? (xAxis.width - xAxis.toPixels(ann.options.xValue)) : dx > 0 ? dx : 0;
        var lineWidthInPixels = (yAxis.toPixels(options.trendYValue) - yAxis.toPixels(options.yValue));

        $.each(fibExtentionlineDrawings, function (key, value) {
            var fibLevel = fibExtentionLevels.find(function (level) {
                return level.id === key;
            });
            var percentage = parseFloat(fibLevel.value);
            var percentageY = -(lineWidthInPixels * percentage / 100) + dy;
            var fibExtentionDrawingLabel = fibonacciExtentionDrawingLabels[key];
            var line = ["M", lineStartPosition, percentageY, 'L', lineEndPosition, percentageY];
            fibLevelLines[key] = line;

            value.attr({
                d: line
            });

            if(isCalculateNewValueForScale) {
                fibExtentionDrawingLabel.textSetter(self.getFormattedLabel(yAxis, options.yValue, options.trendYValue, options.yValueEnd, percentage, stockChart, "fibExtention"));
            }

            self.positionDrawingLabel(fibExtentionDrawingLabel, line, "fibExtention");
            if(chart.selectedAnnotation && chart.selectedAnnotation.options.id === options.id) {
                self.positionHideIcon(self.fibonacciDrawings.hideFibLevelButton[key], lineEndPosition, fibExtentionDrawingLabel, line, "fibExtention");
            }

            if(value.visibility !== 'hidden'){
                var customAttributes = {
                    'level' : key,
                    'visibility':fibExtentionlineDrawings[key].visibility,
                    'stroke-width': 10,
                    'subType': 'fibExtention'
                }
                infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
            }
        });

        fibExtentionLevels.forEach(function (value, index, arr) {
            fill = fibonacciExtentionDrawingsFill && fibonacciExtentionDrawingsFill[value.id];
            currentLine = fibExtentionlineDrawings[value.id];
        currentLineP = currentLine && fibLevelLines[value.id];

            for (var i = index + 1; i < arr.length; i++) {
                var lineTemp = fibExtentionlineDrawings[arr[i].id];
                if (lineTemp && lineTemp.visibility != "hidden") {
                    nextLine = lineTemp;
                nextLineId = arr[i].id;
                    break;
                }
            }
        nextLineP = nextLine && fibLevelLines[nextLineId];
            if (currentLine && nextLine) {
                fill.attr({
                    d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
                });
            }
            nextLine = undefined;
        });
    }

    fibLevelLines = {};

    if (fibRetrancementLineDrawings) {
        self.additionalDrawings.referenceLine.attr({
            d: ["M", xAxis.toPixels(options.nearestTrendXValue) - xValueInPixels, yAxis.toPixels(options.trendYValue) - yValueInPixels, 'L', newX, newY]
        });
        var lineStartPosition = newX;
        var lineEndPosition = xAxis.toValue(xAxis.width) > Math.min(options.xValue, options.xValueEnd) ? (xAxis.width - xAxis.toPixels(ann.options.xValue)) : dx > 0 ? dx : 0;
        var lineWidthInPixels = (yAxis.toPixels(options.yValueEnd) - yAxis.toPixels(options.yValue));

        $.each(fibRetrancementLineDrawings, function (key, value) {
            var fibLevel = fibRetrancementLevels.find(function (level) {
                return level.id === key;
            });
            var percentage = parseFloat(fibLevel.value);
            var percentageY = -(lineWidthInPixels * percentage / 100) + dy;
            var fibRetrancementDrawingLabel = fibonacciRetrancementDrawingLabels[key];
            var line = ["M", lineStartPosition, percentageY, 'L', lineEndPosition, percentageY];
            fibLevelLines[key] = line;

            value.attr({
                d: line
            });

            if(isCalculateNewValueForScale) {
                fibRetrancementDrawingLabel.textSetter(self.getFormattedLabel(yAxis, options.yValue, options.trendYValue, options.yValueEnd, percentage, stockChart, "fibRetracement"));
            }
            self.positionDrawingLabel(fibRetrancementDrawingLabel, line, "fibRetracement");

            if(chart.selectedAnnotation && chart.selectedAnnotation.options.id === options.id && !chart.annotationChangeInProgress) {
                self.positionHideIcon(self.fibRetrancementAdditionalDrawing.hideFibLevelButton[key], lineEndPosition, fibRetrancementDrawingLabel, line, "fibRetracement");
            }

            if(value.visibility !== 'hidden'){
                var customAttributes = {
                    'level' : key,
                    'visibility':fibRetrancementLineDrawings[key].visibility,
                    'stroke-width': 10,
                    'subType': 'fibRetracement'
                }
                infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
            }
        });

        fibExtentionLevels.forEach(function (value, index, arr) {
            fill = fibonacciRetrancementDrawingsFill && fibonacciRetrancementDrawingsFill[value.id];
            currentLine = fibRetrancementLineDrawings[value.id];
            currentLineP = currentLine && fibLevelLines[value.id];

            for (var i = index + 1; i < arr.length; i++) {
                var lineTemp = fibRetrancementLineDrawings[arr[i].id];
                if (lineTemp && lineTemp.visibility != "hidden") {
                    nextLine = lineTemp;
                nextLineId = arr[i].id;
                    break;
                }
            }
            nextLineP = nextLine && fibLevelLines[nextLineId];
            if (currentLine && nextLine) {
                fill.attr({
                    d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
                });
            }
            nextLine = undefined;
        });
        self.highlightEachLine();
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation,
        pathDefinition, width, height, referenceLine = this.additionalDrawings.referenceLine;

    ann.events.deselect.call(ann);
    ann.shape.show();
    if(referenceLine){
        referenceLine.show();
    }
    if(ann && ann.chart && !ann.chart.annotationChangeInProgress){
        this.toggleFibLevelEraseIcon(false);
    }
    ann.selectionMarker = [];
    pathDefinition = ann.shape.d.split(' ');
    width = parseFloat(pathDefinition[4]);
    height = parseFloat(pathDefinition[5]);

    var chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];

    this.resetDragSupporters();
    if (!isNaN(width) && !isNaN(height)) {
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, parseFloat(pathDefinition[1]), parseFloat(pathDefinition[2]), this.stepFunction, this.stop, true);
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, width, height, this.stepFunction, this.stop, false);
        infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, xAxis.toPixels(options.nearestTrendXValue) - xAxis.toPixels(options.xValue), yAxis.toPixels(options.trendYValue) - yAxis.toPixels(options.yValue), this.moveStartPoint, this.updateMoveStartPoint, true);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.setNearestYValues = function (options, chart) {
    var self = this;
    var isHLH = (self.shape === 'fib3PointPriceProjectionHLH');
    var futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];
    var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
    if(futureValue >= nearestDataForXValue.xData){
        self.nearestYValue = self.getNearestYValue(isHLH, true, options.yValue, nearestDataForXValue, options.trendYValue, options.isSnapTopHighLow, chart);
    } else {
        self.nearestYValue = options.yValue;
    }

    var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);
    if(futureValue >= nearestDataForXValueEnd.xData){
        self.nearestYValueEnd = self.getNearestYValue(isHLH, false, options.yValueEnd, nearestDataForXValueEnd, options.trendYValue, options.isSnapTopHighLow, chart);
    } else {
        self.nearestYValueEnd = options.yValueEnd;
    }

    var nearestDataPointForTrendXValue = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, true, true);
    if(futureValue >= nearestDataPointForTrendXValue.xData){
        self.nearestTrendYValue = this.getNearestYValue(options.isHLH, false, options.trendYValue, nearestDataPointForTrendXValue, options.trendXValue,  options.isSnapTopHighLow, chart);
    } else {
        self.nearestYValueEnd = options.trendYValue;
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.resetDragSupporters = function(){
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        line = ann.shape.d.split(' ');
    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);

    if(ann.shape.visibility !== "hidden"){
        infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, undefined, self.defaultDragSupporterStyles);
    }
    if(self.additionalDrawings && self.additionalDrawings.referenceLine && self.additionalDrawings.referenceLine.visibility !== "hidden"){
        var referenceLine = self.additionalDrawings.referenceLine.d.split(' ');
        infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', referenceLine[1], referenceLine[2], 'L', referenceLine[4], referenceLine[5]], self.dragSupporters, undefined, self.defaultDragSupporterStyles);
    }

    $.each(self.fibonacciDrawings.lines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'visibility':self.fibonacciDrawings.lines[key].visibility,
                'stroke-width': 10,
                'subType': 'fibExtention'
            }
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
        }
    });

    $.each(self.fibRetrancementAdditionalDrawing.lines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'visibility':self.fibRetrancementAdditionalDrawing.lines[key].visibility,
                'stroke-width': 10,
                'subType': 'fibRetracement'
            }
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
        }
    });
    self.highlightEachLine();
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.positionHideIcon = function (hideFibLevelButton, lineEndPosition, drawingLabel, line, subType) {
    var self = this,
        ann = self.annotation,
        options = ann.options;

    if (subType == "fibExtention") {
        var linePosition = options.extentionLabelPosition;
        if (linePosition == "bottomLeft") {
            hideFibLevelButton.attr({
                x: parseFloat(line[1]) + drawingLabel.width + hideFibLevelButton.getBBox().width,
                y: parseFloat(line[2])
            });
        }
        if (linePosition == "topLeft") {
            hideFibLevelButton.attr({
                x: parseFloat(line[1]) + drawingLabel.width + hideFibLevelButton.getBBox().width,
                y: parseFloat(line[2]) - hideFibLevelButton.getBBox().height
            });
        }
        if (linePosition == "bottomCenter") {
            hideFibLevelButton.attr({
                x: (parseFloat(line[1]) + parseFloat(line[4])) / 2 - drawingLabel.width / 2,
                y: parseFloat(line[2])
            });
        }
        if (linePosition == "topCenter") {
            hideFibLevelButton.attr({
                x: (parseFloat(line[1]) + parseFloat(line[4])) / 2 - drawingLabel.width / 2,
                y: parseFloat(line[2]) - hideFibLevelButton.getBBox().height
            });
        }
        if (linePosition == "bottomRight") {
            hideFibLevelButton.attr({
                x: parseFloat(line[4]) - drawingLabel.width - hideFibLevelButton.getBBox().width,
                y: parseFloat(line[2])
            });
        }
        if (linePosition == "topRight") {
            hideFibLevelButton.attr({
                x: parseFloat(line[4]) - drawingLabel.width - hideFibLevelButton.getBBox().width,
                y: parseFloat(line[2]) - hideFibLevelButton.getBBox().height
            });
        }
    }
    if (subType == "fibRetracement") {
        var linePosition = options.retracementLabelPosition;
        if (linePosition == "bottomLeft") {
            hideFibLevelButton.attr({
                x: parseFloat(line[1]) + drawingLabel.width,
                y: parseFloat(line[2])
            });
        }
        if (linePosition == "topLeft") {
            hideFibLevelButton.attr({
                x: parseFloat(line[1]) + drawingLabel.width,
                y: parseFloat(line[2]) - hideFibLevelButton.getBBox().height
            });
        }
        if (linePosition == "bottomCenter") {
            hideFibLevelButton.attr({
                x: (parseFloat(line[1]) + parseFloat(line[4])) / 2 - drawingLabel.width / 2 - hideFibLevelButton.getBBox().width,
                y: parseFloat(line[2])
            });
        }
        if (linePosition == "topCenter") {
            hideFibLevelButton.attr({
                x: (parseFloat(line[1]) + parseFloat(line[4])) / 2 - drawingLabel.width / 2 - hideFibLevelButton.getBBox().width,
                y: parseFloat(line[2]) - hideFibLevelButton.getBBox().height
            });
        }
        if (linePosition == "bottomRight") {
            hideFibLevelButton.attr({
                x: parseFloat(line[4]) - drawingLabel.width - hideFibLevelButton.getBBox().width,
                y: parseFloat(line[2])
            });
        }
        if (linePosition == "topRight") {
            hideFibLevelButton.attr({
                x: parseFloat(line[4]) - drawingLabel.width - hideFibLevelButton.getBBox().width,
                y: parseFloat(line[2]) - hideFibLevelButton.getBBox().height
            });
        }
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.positionDrawingLabel = function (drawingLabel, line, subType) {
    var self = this,
        ann = self.annotation,
        options = ann.options;


    if (subType == "fibExtention") {
        var linePosition = options.extentionLabelPosition;
        if (linePosition == "bottomLeft") {
            drawingLabel.attr({
                x: line[1],
                y: parseFloat(line[2])
            });
        }
        if (linePosition == "topLeft") {
            drawingLabel.attr({
                x: line[1],
                y: parseFloat(line[2]) - drawingLabel.height
            });
        }
        if (linePosition == "bottomCenter") {
            drawingLabel.attr({
                x: (parseFloat(line[1]) + parseFloat(line[4])) / 2,
                y: parseFloat(line[2])
            });
        }
        if (linePosition == "topCenter") {
            drawingLabel.attr({
                x: (parseFloat(line[1]) + parseFloat(line[4])) / 2,
                y: parseFloat(line[2]) - drawingLabel.height
            });
        }
        if (linePosition == "bottomRight") {
            drawingLabel.attr({
                x: line[4] - drawingLabel.width,
                y: parseFloat(line[2])
            });
        }
        if (linePosition == "topRight") {
            drawingLabel.attr({
                x: line[4] - drawingLabel.width,
                y: parseFloat(line[2]) - drawingLabel.height
            });
        }
    }
    if (subType == "fibRetracement") {
        var linePosition = options.retracementLabelPosition;
        if (linePosition == "bottomLeft") {
            drawingLabel.attr({
                x: line[1],
                y: parseFloat(line[2])
            });
        }
        if (linePosition == "topLeft") {
            drawingLabel.attr({
                x: line[1],
                y: parseFloat(line[2]) - drawingLabel.height
            });
        }
        if (linePosition == "bottomCenter") {
            drawingLabel.attr({
                x: (parseFloat(line[1]) + parseFloat(line[4])) / 2,
                y: parseFloat(line[2])
            });
        }
        if (linePosition == "topCenter") {
            drawingLabel.attr({
                x: (parseFloat(line[1]) + parseFloat(line[4])) / 2,
                y: parseFloat(line[2]) - drawingLabel.height
            });
        }
        if (linePosition == "bottomRight") {
            drawingLabel.attr({
                x: parseFloat(line[4]) - drawingLabel.width,
                y: parseFloat(line[2])
            });
        }
        if (linePosition == "topRight") {
            drawingLabel.attr({
                x: parseFloat(line[4]) - drawingLabel.width,
                y: parseFloat(line[2]) - drawingLabel.height
            });
        }
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.step = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id)),
        points = infChart.drawingUtils.common.calculateInitialPoints(e, ann, isStartPoint, 0, 0),
        options = ann.options,
        fibExtentionLevels = options.fibExtentionLevels ? options.fibExtentionLevels : this.fibExtentionLevels,
        fibExtentionLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibExtentionLevels),
        fibRetrancementLevels = options.fibRetrancementLevels ? options.fibRetrancementLevels : this.fibRetrancementLevels,
        fibRetrancementLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibRetrancementLevels),
        fibonacciExtentionDrawingLabels = self.fibonacciDrawings.labels,
        fibonacciRetrancementDrawingLabels = self.fibRetrancementAdditionalDrawing.labels,
        fibonacciExtentionDrawingsFill = self.fibonacciDrawings.fill,
        fibonacciRetrancementDrawingsFill = self.fibRetrancementAdditionalDrawing.fill,
        fibExtentionlineDrawings = self.fibonacciDrawings.lines,
        fibRetrancementLineDrawings = self.fibRetrancementAdditionalDrawing.lines,
        fill,
        currentLine,
        currentLineP,
        nextLine,
        nextLineP,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        xValueEnd = xAxis.toValue(xAxis.toPixels(options.xValue) + points.dx),
        yValueEnd = yAxis.toValue(yAxis.toPixels(options.yValue) + points.dy),
        nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true),
        nearestXValue = nearestDataPointForXValue.xData,
        nearestDataPointForXValueEnd = infChart.math.findNearestDataPoint(chart, xValueEnd, undefined, true, true),
        nearestXValueEnd = nearestDataPointForXValueEnd.xData,
        newX = xAxis.toPixels(nearestXValue) - xAxis.toPixels(options.xValue),
        newXEnd = xAxis.toPixels(nearestXValueEnd) - xAxis.toPixels(options.xValue);

        var futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];
        var nearestYValue, nearestYValueEnd;
        if(options.isSnapTopHighLow){
            if (isStartPoint) {
                if(futureValue >= nearestXValue){
                    nearestYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, true, options.yValue, nearestDataPointForXValue, options.trendXValue,  options.isSnapTopHighLow));
                } else {
                    nearestYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(self, options.yValue));
                }
                ann.update({
                    yValue: nearestYValue
                });
                nearestYValueEnd = yValueEnd;
            } else {
                if(futureValue >= nearestXValueEnd){
                    nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, false, yValueEnd, nearestDataPointForXValueEnd, options.trendXValue,  options.isSnapTopHighLow));
                } else {
                    nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(self, yValueEnd));
                }
                ann.update({
                    yValueEnd: nearestYValueEnd
                });
                nearestYValue = options.yValue;
            }
        } else {
            nearestYValue = options.yValue;
            nearestYValueEnd = yValueEnd;
        }

        //var newY = yAxis.toPixels(nearestYValue) - yAxis.toPixels(options.yValue)
        var newYEnd = yAxis.toPixels(nearestYValueEnd) - yAxis.toPixels(nearestYValue),
            nearestDataPointForTrendXValue,
            nearestTrendYValue;
    
        var drawingLine = ["M", newX, 0, 'L', parseInt(newXEnd, 10), parseInt(newYEnd, 10)];
    
        ann.shape.attr({
            d: drawingLine
        });

    if (fibExtentionlineDrawings) {
        nearestDataPointForTrendXValue = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, true, true);
        nearestTrendYValue;
        if (!isStartPoint) {
            if(futureValue >= nearestDataPointForTrendXValue.xData){
                nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, false, options.trendYValue, nearestDataPointForTrendXValue, options.trendXValue,  options.isSnapTopHighLow));
            } else {
                nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(self, options.trendYValue));
            }
        } else {
            nearestTrendYValue = options.trendYValue;
            //nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(self, options.trendYValue));
        }
        self.additionalDrawings.referenceLine.attr({
            d: ["M", xAxis.toPixels(nearestDataPointForTrendXValue.xData) - xAxis.toPixels(options.xValue), yAxis.toPixels(self.annotation.options.trendYValue) - yAxis.toPixels(self.annotation.options.yValue), 'L', newX, 0]
        });

        $.each(fibExtentionlineDrawings, function (key, value) {
            var fibLevel = fibExtentionLevels.find(function (level) {
                return level.id === key;
            });
            var percentage = parseFloat(fibLevel.value);
            var percentageY = -((yAxis.toPixels(nearestTrendYValue) - yAxis.toPixels(nearestYValue)) * percentage / 100) + drawingLine[5];
            var lineStartPosition = newX;
            var lineEndPosition = (xAxis.width - xAxis.toPixels(ann.options.xValue));
            var fibExtentionDrawingLabel = fibonacciExtentionDrawingLabels[key];
            var fibExtentionFibLevelButton = self.fibonacciDrawings.hideFibLevelButton[key];
            var line = ["M", lineStartPosition, percentageY, 'L', lineEndPosition, percentageY];

            value.attr({
                d: line
            });

            fibExtentionDrawingLabel.textSetter(self.getFormattedLabel(yAxis, nearestYValue, nearestTrendYValue, nearestYValueEnd, percentage, stockChart, "fibExtention"));

            self.positionDrawingLabel(fibExtentionDrawingLabel, line, "fibExtention");
            self.positionHideIcon(fibExtentionFibLevelButton, lineEndPosition, fibExtentionDrawingLabel, line, "fibExtention");
        });

        fibExtentionLevels.forEach(function (value, index, arr) {
            fill = fibonacciExtentionDrawingsFill && fibonacciExtentionDrawingsFill[value.id];
            currentLine = fibExtentionlineDrawings[value.id];
            currentLineP = currentLine && currentLine.d.split(' ');

            for (var i = index + 1; i < arr.length; i++) {
                var lineTemp = fibExtentionlineDrawings[arr[i].id];
                if (lineTemp && lineTemp.visibility != "hidden") {
                    nextLine = lineTemp;
                    break;
                }
            }
            nextLineP = nextLine && nextLine.d.split(' ');
            if (currentLine && nextLine) {
                fill.attr({
                    d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
                });
            }
            nextLine = undefined;
        });
    }

    if (fibRetrancementLineDrawings) {
        $.each(fibRetrancementLineDrawings, function (key, value) {
            var fibLevel = fibRetrancementLevels.find(function (level) {
                return level.id === key;
            });
            var percentage = parseFloat(fibLevel.value);
            var percentageY = -((yAxis.toPixels(nearestYValueEnd) - yAxis.toPixels(nearestYValue)) * percentage / 100) + drawingLine[5];
            var lineStartPosition = newX;
            var lineEndPosition = (xAxis.width - xAxis.toPixels(ann.options.xValue));
            var fibRetrancementDrawingLabel = fibonacciRetrancementDrawingLabels[key];
            var fibRetrancementFibLevelButton = self.fibRetrancementAdditionalDrawing.hideFibLevelButton[key];
            var line = ["M", lineStartPosition, percentageY, 'L', lineEndPosition, percentageY];

            value.attr({
                d: line
            });

            fibRetrancementDrawingLabel.textSetter(self.getFormattedLabel(yAxis, nearestYValue, nearestTrendYValue, nearestYValueEnd, percentage, stockChart, "fibRetracement"));

            self.positionDrawingLabel(fibRetrancementDrawingLabel, line, "fibRetracement");
            self.positionHideIcon(fibRetrancementFibLevelButton, lineEndPosition, fibRetrancementDrawingLabel, line, "fibRetracement");
        });

        fibRetrancementLevels.forEach(function (value, index, arr) {
            fill = fibonacciRetrancementDrawingsFill && fibonacciRetrancementDrawingsFill[value.id];
            currentLine = fibRetrancementLineDrawings[value.id];
            currentLineP = currentLine && currentLine.d.split(' ');

            for (var i = index + 1; i < arr.length; i++) {
                var lineTemp = fibRetrancementLineDrawings[arr[i].id];
                if (lineTemp && lineTemp.visibility != "hidden") {
                    nextLine = lineTemp;
                    break;
                }
            }
            nextLineP = nextLine && nextLine.d.split(' ');
            if (currentLine && nextLine) {
                fill.attr({
                    d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
                });
            }
            nextLine = undefined;
        });
    }

    return {
        line: drawingLine,
        points: points,
        nearestXValue: nearestXValue,
        nearestXValueEnd: nearestXValueEnd,
        nearestTrendXValue: nearestDataPointForTrendXValue ? nearestDataPointForTrendXValue.xData : Number.MIN_SAFE_INTEGER,
        nearestYValue: nearestYValue,
        nearestYValueEnd: nearestYValueEnd,
        nearestTrendYValue: nearestTrendYValue
    };
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.stop = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        lineData = this.stepFunction(e, isStartPoint),
        line = lineData.line,
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        x = xAxis.toValue(lineData.points.dx + xAxis.toPixels(ann.options.xValue)),
        y = yAxis.toValue(lineData.points.dy + yAxis.toPixels(ann.options.yValue));

    //if (options.isSnapTopHighLow) {
        line[2] = 0;
        line[5] = yAxis.toPixels(lineData.nearestYValueEnd) - yAxis.toPixels(lineData.nearestYValue);
        referenceLine = self.additionalDrawings.referenceLine.d.split(' ');
        referenceLine[2] =  yAxis.toPixels(options.trendYValue) - yAxis.toPixels(lineData.nearestYValue);
        referenceLine[5] =  0;
        self.additionalDrawings.referenceLine.attr({
            d: ["M", referenceLine[1], yAxis.toPixels(options.trendYValue) - yAxis.toPixels(lineData.nearestYValue), 'L', referenceLine[4], "0"]
        });
    //     ann.update({
    //         xValueEnd: x,
    //         yValue: lineData.nearestYValue,
    //         trendYValue: lineData.nearestTrendYValue,
    //         yValueEnd: lineData.nearestYValueEnd,
    //         nearestXValue: lineData.nearestXValue,
    //         nearestXValueEnd: lineData.nearestXValueEnd,
    //         nearestTrendXValue: lineData.nearestTrendXValue,
    //         nearestYValue: lineData.nearestYValue,
    //         nearestYValueEnd: lineData.nearestYValueEnd,
    //         nearestTrendYValue: lineData.nearestTrendYValue,
    //         shape: {
    //             params: {
    //                 d: line
    //             }
    //         }
    //     });
    //     self.scale(true);
    // } else {
        ann.update({
            xValueEnd: x,
            yValue: lineData.nearestYValue,
            yValueEnd: lineData.nearestYValueEnd,
            nearestXValue: lineData.nearestXValue,
            nearestXValueEnd: lineData.nearestXValueEnd,
            nearestTrendXValue: lineData.nearestTrendXValue,
            //nearestYValue: lineData.nearestYValue,
            //nearestYValueEnd: lineData.nearestYValueEnd,
            //nearestTrendYValue: lineData.nearestTrendYValue,
            shape: {
                params: {
                    d: line
                }
            }
        });
    //}
    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, ann.options.yValueEnd, ann.options.trendYValue);
    //infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd, ann.options.nearestTrendYValue);

    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, undefined, self.defaultDragSupporterStyles);
    var referenceLine = self.additionalDrawings.referenceLine.d.split(' ');
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', referenceLine[1], referenceLine[2], 'L', referenceLine[4], referenceLine[5]], self.dragSupporters, undefined, self.defaultDragSupporterStyles);

    if (self.fibonacciDrawings && self.fibonacciDrawings.lines) {
        $.each(self.fibonacciDrawings.lines, function (key, value) {
            if(value.visibility !== 'hidden'){
                var line = value.d.split(' ');
                var customAttributes = {
                    'level': key,
                    'visibility':self.fibonacciDrawings.lines[key].visibility,
                    'stroke-width': 10,
                    'subType': 'fibExtention'
                }
                infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
            }
        });
    } else {
        console.error("3 point price projection error");
    }

    if (self.fibRetrancementAdditionalDrawing && self.fibRetrancementAdditionalDrawing.lines) {
        $.each(self.fibRetrancementAdditionalDrawing.lines, function (key, value) {
            if(value.visibility !== 'hidden'){
                var line = value.d.split(' ');
                var customAttributes = {
                    'level': key,
                    'visibility':self.fibRetrancementAdditionalDrawing.lines[key].visibility,
                    'stroke-width': 10,
                    'subType': 'fibRetracement'
                }
                infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
            }
        });
    } else {
        console.error("3 point price projection error");
    }
    self.highlightEachLine();

    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.translate = function (e) {
    var self =this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        options = ann.options,
        stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id)),
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        fibExtentionLevels = options.fibExtentionLevels ? options.fibExtentionLevels : this.fibExtentionLevels,
        fibExtentionLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibExtentionLevels),
        fibRetrancementLevels = options.fibRetrancementLevels ? options.fibRetrancementLevels : this.fibRetrancementLevels,
        fibRetrancementLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibRetrancementLevels),
        fibonacciExtentionDrawingLabels = self.fibonacciDrawings.labels,
        fibonacciRetrancementDrawingLabels = self.fibRetrancementAdditionalDrawing.labels,
        fibonacciExtentionDrawingsFill = self.fibonacciDrawings.fill,
        fibonacciRetrancementDrawingsFill = self.fibRetrancementAdditionalDrawing.fill,
        fibExtentionlineDrawings = self.fibonacciDrawings.lines,
        fibRetrancementLineDrawings = self.fibRetrancementAdditionalDrawing.lines, 
        fill,
        currentLine,
        currentLineP,
        nextLine,
        nextLineP;

    $.each(fibExtentionlineDrawings, function (key, value) {
        var fibLevel = fibExtentionLevels.find(function (level) {
            return level.id === key;
        });
        var percentage = parseFloat(fibLevel.value);
        var fibExtentionDrawingLabel = fibonacciExtentionDrawingLabels[key];
        var fibExtentionHideFibLevelButton = self.fibonacciDrawings.hideFibLevelButton[key];
        var line = value.d.split(' ');
        var lineEndPosition = xAxis.width - xAxis.toPixels(options.xValue);
        var newLine = ["M", line[1], line[2], 'L', lineEndPosition, line[5]];

        value.attr({
            d: newLine
        });
        fibExtentionDrawingLabel.textSetter(self.getFormattedLabel(yAxis, options.yValue, options.trendYValue, options.yValueEnd, percentage, stockChart, "fibExtention"));

        self.positionDrawingLabel(fibExtentionDrawingLabel, line, "fibExtention");
        self.positionHideIcon(fibExtentionHideFibLevelButton, lineEndPosition, fibExtentionDrawingLabel, line, "fibExtention");
    });

    fibExtentionLevels.forEach(function (value, index, arr) {
        fill = fibonacciExtentionDrawingsFill && fibonacciExtentionDrawingsFill[value.id];
        currentLine = fibExtentionlineDrawings[value.id];
        currentLineP = currentLine && currentLine.d.split(' ');

        for (var i = index + 1; i < arr.length; i++) {
            var lineTemp = fibExtentionlineDrawings[arr[i].id];
            if (lineTemp && lineTemp.visibility != "hidden") {
                nextLine = lineTemp;
                break;
            }
        }
        nextLineP = nextLine && nextLine.d.split(' ');
        if (currentLine && nextLine) {
            fill.attr({
                d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
            });
        }
        nextLine = undefined;
    });

    $.each(fibRetrancementLineDrawings, function (key, value) {
        var fibLevel = fibRetrancementLevels.find(function (level) {
            return level.id === key;
        });
        var percentage = parseFloat(fibLevel.value);
        var line = value.d.split(' ');
        var lineEndPosition = xAxis.width - xAxis.toPixels(ann.options.xValue);
        var fibRetrancementDrawingLabel = fibonacciRetrancementDrawingLabels[key];
        var fibRetrancementHideFibLevelButton = self.fibonacciDrawings.hideFibLevelButton[key];
        var newLine = ["M", line[1], line[2], 'L', lineEndPosition, line[5]];

        value.attr({
            d: newLine
        });
        fibRetrancementDrawingLabel.textSetter(self.getFormattedLabel(yAxis, options.yValue, options.trendYValue, options.yValueEnd, percentage, stockChart, "fibRetracement"));

        self.positionDrawingLabel(fibRetrancementDrawingLabel, newLine, "fibRetracement");
        self.positionHideIcon(fibRetrancementHideFibLevelButton, lineEndPosition, fibRetrancementDrawingLabel, newLine, "fibRetracement");

    });

    fibRetrancementLevels.forEach(function (value, index, arr) {
        fill = fibonacciRetrancementDrawingsFill && fibonacciRetrancementDrawingsFill[value.id];
        currentLine = fibRetrancementLineDrawings[value.id];
        currentLineP = currentLine && currentLine.d.split(' ');

        for (var i = index + 1; i < arr.length; i++) {
            var lineTemp = fibRetrancementLineDrawings[arr[i].id];
            if (lineTemp && lineTemp.visibility != "hidden") {
                nextLine = lineTemp;
                break;
            }
        }
        nextLineP = nextLine && nextLine.d.split(' ');
        if (currentLine && nextLine) {
            fill.attr({
                d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
            });
        }
        nextLine = undefined;
    });
    this.toggleFibLevelEraseIcon(true);
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.translateEnd = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id)),
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        fibExtentionLevels = options.fibExtentionLevels ? options.fibExtentionLevels : this.fibExtentionLevels,
        fibExtentionLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibExtentionLevels),
        fibRetrancementLevels = options.fibRetrancementLevels ? options.fibRetrancementLevels : this.fibRetrancementLevels,
        fibRetrancementLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibRetrancementLevels),
        fibonacciExtentionDrawingLabels = self.fibonacciDrawings.labels,
        fibonacciRetrancementDrawingLabels = self.fibRetrancementAdditionalDrawing.labels,
        fibonacciExtentionDrawingsFill = self.fibonacciDrawings.fill,
        fibonacciRetrancementDrawingsFill = self.fibRetrancementAdditionalDrawing.fill,
        fibExtentionlineDrawings = self.fibonacciDrawings.lines,
        fibRetrancementLineDrawings = self.fibRetrancementAdditionalDrawing.lines, 
        fill,
        currentLine,
        currentLineP,
        nextLine,
        nextLineP,
        nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true),
        nearestDataPointForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true),
        nearestDataPointForTrendXValue = infChart.math.findNearestDataPoint(chart, options.trendXValue, undefined, true, true),
        futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];

    var nearestYValue;
    if(futureValue >= nearestDataPointForXValue.xData) {
        nearestYValue = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, true, options.yValue, nearestDataPointForXValue, options.trendXValue,  false));
    } else {
        nearestYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.yValue));
    }

    var nearestYValueEnd;
    if(futureValue >= nearestDataPointForXValueEnd.xData){
        nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, this.getNearestYValue(options.isHLH, false, options.yValueEnd, nearestDataPointForXValueEnd, options.trendXValue,  false));
    } else {
        nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.yValueEnd));
    }

    var nearestTrendYValue;
    if(futureValue >= nearestDataPointForTrendXValue.xData){
        nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this,this.getNearestYValue(options.isHLH, false, options.trendYValue, nearestDataPointForTrendXValue, options.trendXValue,  false));
    } else {
        nearestTrendYValue = infChart.drawingUtils.common.getYValue.call(this, infChart.drawingUtils.common.getBaseYValues.call(this, options.trendYValue));
    }
    // if(options.isSnapTopHighLow){
    //     var newX = xAxis.toPixels(nearestDataPointForXValue.xData) - xAxis.toPixels(nearestDataPointForXValue.xData),
    //         newXEnd = xAxis.toPixels(nearestDataPointForXValueEnd.xData) - xAxis.toPixels(nearestDataPointForXValue.xData),
    //         newY = yAxis.toPixels(nearestYValue) - yAxis.toPixels(nearestYValue),
    //         newYEnd = yAxis.toPixels(nearestYValueEnd) - yAxis.toPixels(nearestYValue);

    //     var line = ["M", newX, newY, 'L', parseInt(newXEnd, 10), parseInt(newYEnd, 10)];

    //     ann.update({
    //         xValue: nearestDataPointForXValue.xData,
    //         xValueEnd: nearestDataPointForXValueEnd.xData,
    //         trendXValue: nearestDataPointForTrendXValue.xData,
    //         yValue: nearestYValue,
    //         yValueEnd: nearestYValueEnd,
    //         trendYValue: nearestTrendYValue,
    //         nearestXValue: nearestDataPointForXValue.xData,
    //         nearestXValueEnd: nearestDataPointForXValueEnd.xData,
    //         nearestTrendXValue: nearestDataPointForTrendXValue.xData,
    //         nearestYValue: nearestYValue,
    //         nearestYValueEnd: nearestYValueEnd,
    //         nearestTrendYValue: nearestTrendYValue,
    //         shape: {
    //             params: {
    //                 d: line
    //             }
    //         }
    //     });
    //     var newReferenceLine = ["M", xAxis.toPixels(nearestDataPointForTrendXValue.xData) - xAxis.toPixels(nearestDataPointForXValue.xData), yAxis.toPixels(nearestTrendYValue) - yAxis.toPixels(nearestYValue), 'L', newX, newY];
    //     self.additionalDrawings.referenceLine.attr({
    //         d: newReferenceLine
    //     });
    // } else {
        var newX = xAxis.toPixels(nearestDataPointForXValue.xData) - xAxis.toPixels(nearestDataPointForXValue.xData),
            newXEnd = xAxis.toPixels(nearestDataPointForXValueEnd.xData) - xAxis.toPixels(nearestDataPointForXValue.xData),
            newY = yAxis.toPixels(nearestYValue) - yAxis.toPixels(options.yValue),
            newYEnd = yAxis.toPixels(nearestYValueEnd) - yAxis.toPixels(options.yValue);

        var line = ["M", newX, newY, 'L', parseInt(newXEnd, 10), parseInt(newYEnd, 10)];

        ann.update({
            xValue: nearestDataPointForXValue.xData,
            xValueEnd: nearestDataPointForXValueEnd.xData,
            trendXValue: nearestDataPointForTrendXValue.xData,
            nearestXValue: nearestDataPointForXValue.xData,
            nearestXValueEnd: nearestDataPointForXValueEnd.xData,
            nearestTrendXValue: nearestDataPointForTrendXValue.xData,
            nearestYValue: nearestYValue,
            nearestYValueEnd: nearestYValueEnd,
            nearestTrendYValue: nearestTrendYValue,
            shape: {
                params: {
                    d: line
                }
            }
        });
        var newReferenceLine = ["M", xAxis.toPixels(nearestDataPointForTrendXValue.xData) - xAxis.toPixels(nearestDataPointForXValue.xData), yAxis.toPixels(nearestTrendYValue) - yAxis.toPixels(options.yValue), 'L', newX, newY];
        self.additionalDrawings.referenceLine.attr({
            d: newReferenceLine
        });
    //}

    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, line, self.dragSupporters, undefined, self.defaultDragSupporterStyles);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, newReferenceLine, self.dragSupporters, undefined, self.defaultDragSupporterStyles);

    $.each(fibExtentionlineDrawings, function (key, value) {
        var fibLevel = fibExtentionLevels.find(function (level) {
            return level.id === key;
        });
        var percentage = parseFloat(fibLevel.value);
        var percentageY = -((yAxis.toPixels(nearestTrendYValue) - yAxis.toPixels(nearestYValue)) * percentage / 100) + line[5];
        var lineStartPosition = newX;
        var lineEndPosition = xAxis.width - xAxis.toPixels(ann.options.xValue);
        var fibExtentionDrawingLabel = fibonacciExtentionDrawingLabels[key];
        var fibExtentionHideFibLevelButton = self.fibonacciDrawings.hideFibLevelButton[key];
        var newLine = ["M", lineStartPosition, percentageY, 'L', lineEndPosition, percentageY];

        value.attr({
            d: newLine
        });

        fibExtentionDrawingLabel.textSetter(self.getFormattedLabel(yAxis, nearestYValue, nearestTrendYValue, nearestYValueEnd, percentage, stockChart, "fibExtention"));

        self.positionDrawingLabel(fibExtentionDrawingLabel, newLine, "fibExtention");
        self.positionHideIcon(fibExtentionHideFibLevelButton, lineEndPosition, fibExtentionDrawingLabel, newLine, "fibExtention");

        if(value.visibility !== 'hidden'){
            var customAttributes = {
                'level': key,
                'visibility':fibExtentionlineDrawings[key].visibility,
                'stroke-width': 10,
                'subType': 'fibExtention'
            }
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, newLine, self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
        }
    });

    fibExtentionLevels.forEach(function (value, index, arr) {
        fill = fibonacciExtentionDrawingsFill && fibonacciExtentionDrawingsFill[value.id];
        currentLine = fibExtentionlineDrawings[value.id];
        currentLineP = currentLine && currentLine.d.split(' ');

        for (var i = index + 1; i < arr.length; i++) {
            var lineTemp = fibExtentionlineDrawings[arr[i].id];
            if (lineTemp && lineTemp.visibility != "hidden") {
                nextLine = lineTemp;
                break;
            }
        }
        nextLineP = nextLine && nextLine.d.split(' ');
        if (currentLine && nextLine) {
            fill.attr({
                d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
            });
        }
        nextLine = undefined;
    });

    $.each(fibRetrancementLineDrawings, function (key, value) {
        var fibLevel = fibRetrancementLevels.find(function (level) {
            return level.id === key;
        });
        var percentage = parseFloat(fibLevel.value);
        var percentageY = -((yAxis.toPixels(nearestYValueEnd) - yAxis.toPixels(nearestYValue)) * percentage / 100) + line[5];
        var lineStartPosition = newX;
        var lineEndPosition = xAxis.width - xAxis.toPixels(ann.options.xValue);
        var fibRetrancementDrawingLabel = fibonacciRetrancementDrawingLabels[key];
        var fibRetrancementHideFibLevelButton = self.fibonacciDrawings.hideFibLevelButton[key];
        var newLine = ["M", lineStartPosition, percentageY, 'L', lineEndPosition, percentageY];

        value.attr({
            d: newLine
        });

        fibRetrancementDrawingLabel.textSetter(self.getFormattedLabel(yAxis, nearestYValue, nearestTrendYValue, nearestYValueEnd, percentage, stockChart, "fibRetracement"));

        self.positionDrawingLabel(fibRetrancementDrawingLabel, newLine, "fibRetracement");
        self.positionHideIcon(fibRetrancementHideFibLevelButton, lineEndPosition, fibRetrancementDrawingLabel, newLine, "fibRetracement");

        if(value.visibility !== 'hidden'){
            var customAttributes = {
                'level': key,
                'visibility':fibRetrancementLineDrawings[key].visibility,
                'stroke-width': 10,
                'subType': 'fibRetracement'
            }
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, newLine, self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
        }
    });

    fibRetrancementLevels.forEach(function (value, index, arr) {
        fill = fibonacciRetrancementDrawingsFill && fibonacciRetrancementDrawingsFill[value.id];
        currentLine = fibRetrancementLineDrawings[value.id];
        currentLineP = currentLine && currentLine.d.split(' ');

        for (var i = index + 1; i < arr.length; i++) {
            var lineTemp = fibRetrancementLineDrawings[arr[i].id];
            if (lineTemp && lineTemp.visibility != "hidden") {
                nextLine = lineTemp;
                break;
            }
        }
        nextLineP = nextLine && nextLine.d.split(' ');
        if (currentLine && nextLine) {
            fill.attr({
                d: ['M', currentLineP[1], currentLineP[2], 'L', currentLineP[4], currentLineP[5], 'L', nextLineP[4], nextLineP[5], 'L', nextLineP[1], nextLineP[2], 'L', currentLineP[1], currentLineP[2]]
            });
        }
        nextLine = undefined;
    });

    self.highlightEachLine();
    self.selectAndBindResize();
    chart.selectedAnnotation = ann;
    this.toggleFibLevelEraseIcon(false);
    options.selectedDrawing = undefined;
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.updateMoveStartPoint = function (e) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        lineData = this.moveStartPoint(e),
        line = lineData.line,
        xAxis = chart.xAxis[ann.options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        y = yAxis.toValue(line[5] + yAxis.toPixels(ann.options.yValue));

        // if (options.isSnapTopHighLow) {
        //     line[2] = 0;
        //     line[5] = yAxis.toPixels(options.nearestYValueEnd) - yAxis.toPixels(options.nearestYValue);
        //     referenceLine = self.additionalDrawings.referenceLine.d.split(' ');
        //     referenceLine[2] =  yAxis.toPixels(options.nearestTrendYValue) - yAxis.toPixels(options.nearestYValue);
        //     referenceLine[5] =  0;
        //     self.additionalDrawings.referenceLine.attr({
        //         d: ["M", referenceLine[1], yAxis.toPixels(options.nearestTrendYValue) - yAxis.toPixels(options.nearestYValue), 'L', referenceLine[4], "0"]
        //     });
        //     ann.update({
        //         yValue: options.nearestYValue,
        //         trendYValue: options.nearestTrendYValue,
        //         yValueEnd: options.nearestYValueEnd,
        //         shape: {
        //             params: {
        //                 d: line
        //             }
        //         }
        //     });
        //     self.scale();
        // }
        ann.update({
            trendYValue: lineData.nearestTrendYValue,
            // shape: {
            //     params: {
            //         d: line
            //     }
            // }
        });

    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, ann.options.yValueEnd, ann.options.trendYValue);
    //infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd, ann.options.nearestTrendYValue);
    infChart.drawingUtils.common.removeDragSupporters.call(self, self.dragSupporters);
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, undefined, self.defaultDragSupporterStyles);
    var referenceLine = self.additionalDrawings.referenceLine.d.split(' ');
    infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', referenceLine[1], referenceLine[2], 'L', referenceLine[4], referenceLine[5]], self.dragSupporters, undefined, self.defaultDragSupporterStyles);

    $.each(self.fibonacciDrawings.lines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'visibility':self.fibonacciDrawings.lines[key].visibility,
                'stroke-width': 10,
                'subType': 'fibExtention'
            }
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
        }
    });

    $.each(self.fibRetrancementAdditionalDrawing.lines, function (key, value) {
        if(value.visibility !== 'hidden'){
            var line = value.d.split(' ');
            var customAttributes = {
                'level' : key,
                'visibility':self.fibRetrancementAdditionalDrawing.lines[key].visibility,
                'stroke-width': 10,
                'subType': 'fibRetracement'
            }
            infChart.drawingUtils.common.addDragSupporters.call(self, ann, chart, ['M', line[1], line[2], 'L', line[4], line[5]], self.dragSupporters, customAttributes, self.fibLevelDragSupporterStyles);
        }
    });

    self.highlightEachLine();
    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
    infChart.drawingUtils.common.onPropertyChange.call(self);
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.updateSettings = function (properties) {
    var updateProperties = {
        extentionFillColor: properties.extentionFillColor,
        extentionFillOpacity: properties.extentionFillOpacity,
        extentionLineColor: properties.extentionLineColor,
        extentionLineWidth: properties.extentionLineWidth,
        extentionFontSize: properties.extentionFontSize,
        extentionFontColor: properties.extentionFontColor,
        extentionFontWeight: properties.extentionFontWeight,
        extentionLabelPosition: properties.extentionLabelPosition,
        retrancementFillColor: properties.retrancementFillColor,
        retrancementFillOpacity: properties.retrancementFillOpacity,
        retrancementLineColor: properties.retrancementLineColor,
        retrancementLineWidth: properties.retrancementLineWidth,
        retrancementFontSize: properties.retrancementFontSize,
        retrancementFontColor: properties.retrancementFontColor,
        retrancementFontWeight: properties.retrancementFontWeight,
        retracementLabelPosition: properties.retracementLabelPosition,
        isSingleColorExtention: properties.isSingleColorExtention,
        isSingleColorRetracement: properties.isSingleColorRetracement,
        fibExtentionLevels: properties.fibExtentionLevels,
        fibRetrancementLevels: properties.fibRetrancementLevels,
        isSnapTopHighLowEnabled: properties.isSnapTopHighLow,
        isTrendLineAlwaysEnabled: properties.isTrendLineAlways,
        trendLineColor: properties.trendLineColor,
        trendLineOpacity: properties.trendLineOpacity,
        trendLineWidth: properties.trendLineWidth,
        trendLineStyle: properties.trendLineStyle
    }
    infChart.structureManager.drawingTools.updateGenericFibSettings(this.settingsPopup, updateProperties);
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibLevelLineColorChange = function(rgb, value, fibLevelId, isAll, subType, isPropertyChange){
    var self = this;

    if(subType == "fibRetracement"){
        self.fibRetrancementAdditionalDrawing.lines[fibLevelId].css({
            fill: value
        });
    
        self.fibRetrancementAdditionalDrawing.lines[fibLevelId].attr({
            'stroke': value
        });

        if (!isAll) {
            var fibRetrancementLevels = self.annotation.options.fibRetrancementLevels;
            var fibRetrancementLevel = fibRetrancementLevels.find(function (level) {
                return level.id === fibLevelId;
            });
            fibRetrancementLevel.lineColor = value;
        }
    }
    if(subType == "fibExtention"){
        self.fibonacciDrawings.lines[fibLevelId].css({
            fill: value
        });
    
        self.fibonacciDrawings.lines[fibLevelId].attr({
            'stroke': value
        });

        if (!isAll) {
            var fibExtentionLevels = self.annotation.options.fibExtentionLevels;
            var fibExtentionLevel = fibExtentionLevels.find(function (level) {
                return level.id === fibLevelId;
            });
            fibExtentionLevel.lineColor = value;
        }
    }

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibFillColorChange = function(rgb, value, opacity, level, isAll, subType, isPropertyChange){
    var self = this;

    if(subType == "fibExtention"){
        var fibonacciDrawingsFill = self.fibonacciDrawings.fill[level.id];
        var fibLevels = self.annotation.options.fibExtentionLevels;
        var fibLevel = fibLevels.find(function (fibLevel) {
            return level.id === fibLevel.id;
        });
    }
    if(subType == "fibRetracement"){
        var fibonacciDrawingsFill = self.fibRetrancementAdditionalDrawing.fill[level.id];
        var fibLevels = self.annotation.options.fibRetrancementLevels;
        var fibLevel = fibLevels.find(function (fibLevel) {
            return level.id === fibLevel.id;
        });
    }

    if (fibonacciDrawingsFill) {
        fibonacciDrawingsFill.attr({
            'fill': value,
            'fill-opacity': opacity
        });
        if (!isAll) {
            fibLevel.fillColor = value;
            fibLevel.fillOpacity = opacity;
        }
    }

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibLineWidthChange = function (strokeWidth, fibLevelId, isAll, subType, isPropertyChange){
    var self = this;
    if(subType == "fibExtention"){
        self.fibonacciDrawings.lines[fibLevelId].attr({
            'stroke-width': strokeWidth
        });
        var fibLevels = self.annotation.options.fibExtentionLevels;
        var fibLevel = fibLevels.find(function (fibLevel) {
            return fibLevelId === fibLevel.id;
        });
    }
    if(subType == "fibRetracement"){
        self.fibRetrancementAdditionalDrawing.lines[fibLevelId].attr({
            'stroke-width': strokeWidth
        });
        var fibLevels = self.annotation.options.fibRetrancementLevels;
        var fibLevel = fibLevels.find(function (fibLevel) {
            return fibLevelId === fibLevel.id;
        });
    }

    if (!isAll) {
        fibLevel.lineWidth = strokeWidth;
    }
    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibLevelFontColorChange = function(rgb, value, fibLevel, isAll, subType, isPropertyChange){
    var self = this;
    if(subType == "fibExtention"){
        var fibonacciDrawingsLabel = self.fibonacciDrawings.labels[fibLevel.id];
        var levels = self.annotation.options.fibExtentionLevels;
        var fibLevel = levels.find(function (level) {
            return level.id === fibLevel.id;
        });
    }
    if(subType == "fibRetracement"){
        var fibonacciDrawingsLabel = self.fibRetrancementAdditionalDrawing.labels[fibLevel.id];
        var levels = self.annotation.options.fibRetrancementLevels;
        var fibLevel = levels.find(function (level) {
            return level.id === fibLevel.id;
        });
    }

    if (fibonacciDrawingsLabel) {
        fibonacciDrawingsLabel.attr({
            'font-color': value
        }).css({
            'color': value
        });
    }
    if (!isAll) {
        fibLevel.fontColor = value;
    }
    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibLevelFontSizeChange = function (fontSize, fibLevelId, isAll, subType, isPropertyChange){
    var self= this;
    if(subType == "fibExtention"){
        var fibonacciDrawingsLabel = self.fibonacciDrawings.labels[fibLevelId];
        var levels = self.annotation.options.fibExtentionLevels;
        var fibLevel = levels.find(function (level) {
            return level.id === fibLevelId;
        });
    }
    if(subType == "fibRetracement"){
        var fibonacciDrawingsLabel = self.fibRetrancementAdditionalDrawing.labels[fibLevelId];
        var levels = self.annotation.options.fibRetrancementLevels;
        var fibLevel = levels.find(function (level) {
            return level.id === fibLevelId;
        });
    }
    fibonacciDrawingsLabel.attr({
        'font-size': fontSize
    }).css({
        'fontSize': fontSize + 'px'
    });

    if (!isAll) {
        fibLevel.fontSize = fontSize;
    }
    self.scale(true);
    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibLevelValueChange = function (currentLevel, value, subType, isPropertyChange){
    var self = this;
    var ann = self.annotation,
        options = ann.options;

        if(subType == "fibExtention"){
            fibLevels = options.fibExtentionLevels;
            fibLevels.forEach(function (fibLevel) {
                if (fibLevel.id === currentLevel) {
                    fibLevel.value = value;
                    return;
                }
            });
        }
        if(subType == "fibRetracement"){
            fibLevels = options.fibRetrancementLevels;
            fibLevels.forEach(function (fibLevel) {
                if (fibLevel.id === currentLevel) {
                    fibLevel.value = value;
                    return;
                }
            });
        }

    self.scale(true);
    self.updateSettings(self.getConfig());
    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibLevelFontWeightChange = function (value, fibLevelId, isAll, subType, isPropertyChange){
    var self = this;

    if(subType == "fibExtention"){
        var fibonacciDrawingsLabel = self.fibonacciDrawings.labels[fibLevelId];
        var fibLevels = self.annotation.options.fibExtentionLevels;
        var fibLevel = fibLevels.find(function (level) {
            return level.id === fibLevelId;
        });
    }
    if(subType == "fibRetracement"){
        var fibonacciDrawingsLabel = self.fibRetrancementAdditionalDrawing.labels[fibLevelId];
        var fibLevels = self.annotation.options.fibRetrancementLevels;
        var fibLevel = fibLevels.find(function (level) {
            return level.id === fibLevelId;
        });
    }

    if (fibonacciDrawingsLabel) {
        fibonacciDrawingsLabel.attr({
            'font-weight': value
        }).css({
            'font-weight': value
        });
    }
    if (!isAll) {
        fibLevel.fontWeight = value;
    }
    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibLevelChange = function(currentLevel, checked, subType, isPropertyChange){
    var self = this,
        options = self.annotation.options;
    if(subType == "fibRetracement"){
        var drawing = self.fibRetrancementAdditionalDrawing.lines[currentLevel];
        var label = self.fibRetrancementAdditionalDrawing.labels[currentLevel];
        var hideFibLevelButton = self.fibRetrancementAdditionalDrawing.hideFibLevelButton[currentLevel];
        var fill = self.fibRetrancementAdditionalDrawing.fill[currentLevel];
        var fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibRetrancementLevels);
    } 
    if(subType == "fibExtention"){
        var drawing = self.fibonacciDrawings.lines[currentLevel];
        var label = self.fibonacciDrawings.labels[currentLevel];
        var hideFibLevelButton = self.fibonacciDrawings.hideFibLevelButton[currentLevel];
        var fill = self.fibonacciDrawings.fill[currentLevel];
        var fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibExtentionLevels);
    }

    var currentOrderIdx,
        prevLine, prevFill, nextFill,
        currentLinePoints,
        nextLinePoints,
        prvLinePoints,
        i,
        lineD,
        next;
    if(isPropertyChange){
        self.annotation.options.enabledMyDefaultButton = true;
    }
    fibLevels.some(function (fibLevel, i) {
        if (fibLevel.id == currentLevel) {
            currentOrderIdx = i;
            return true;
        }
    });
    fibLevels[currentOrderIdx].enable = checked;

    if (checked) {
        drawing.show();
        label.show();
        if(hideFibLevelButton && self.annotation.chart.selectedAnnotation == self.annotation){
            self.positionHideIcon(hideFibLevelButton, undefined, label, drawing.d.split(' '), subType);
            hideFibLevelButton.show();
        }

        if(subType == "fibRetracement"){
            for (i = currentOrderIdx + 1; i < fibLevels.length; i++) {
                lineD = self.fibRetrancementAdditionalDrawing.lines[fibLevels[i].id];
                if (lineD && lineD.visibility != "hidden") {
                    prevLine = lineD;
                    prevFill = self.fibRetrancementAdditionalDrawing.fill[fibLevels[i].id];
                    break;
                }
            }
            for (i = currentOrderIdx - 1; i >= 0; i--) {
                lineD = self.fibRetrancementAdditionalDrawing.lines[fibLevels[i].id];
                if (lineD && lineD.visibility != "hidden") {
                    next = lineD;
                    nextFill = self.fibRetrancementAdditionalDrawing.fill[fibLevels[i].id];
                    break;
                }
            }
        }
        if(subType == "fibExtention"){
            for (i = currentOrderIdx + 1; i < fibLevels.length; i++) {
                lineD = self.fibonacciDrawings.lines[fibLevels[i].id];
                if (lineD && lineD.visibility != "hidden") {
                    prevLine = lineD;
                    prevFill = self.fibonacciDrawings.fill[fibLevels[i].id];
                    break;
                }
            }
            for (i = currentOrderIdx - 1; i >= 0; i--) {
                lineD = self.fibonacciDrawings.lines[fibLevels[i].id];
                if (lineD && lineD.visibility != "hidden") {
                    next = lineD;
                    nextFill = self.fibonacciDrawings.fill[fibLevels[i].id];
                    break;
                }
            }
        }

        currentLinePoints = drawing.d.split(' ');

        if (next && nextFill) {
            nextFill.show();
            nextLinePoints = next.d.split(' ');
            nextFill.attr({
                d: ['M', nextLinePoints[1], nextLinePoints[2], 'L', nextLinePoints[4], nextLinePoints[5], 'L', currentLinePoints[4], currentLinePoints[5], 'L', currentLinePoints[1], currentLinePoints[2], 'L', currentLinePoints[1], currentLinePoints[2]]
            });

        }

        if (fill && prevLine) {
            fill.show();
            prvLinePoints = prevLine.d.split(' ');
            fill.attr({
                d: ['M', prvLinePoints[1], prvLinePoints[2], 'L', prvLinePoints[4], prvLinePoints[5], 'L', currentLinePoints[4], currentLinePoints[5], 'L', currentLinePoints[1], currentLinePoints[2], 'L', prvLinePoints[1], prvLinePoints[2]]
            });
        }

    } else {
        drawing.hide();
        label.hide();
        fill.hide();
        if(hideFibLevelButton){
            hideFibLevelButton.hide();
        }

        if(subType == "fibRetracement"){
            for (i = currentOrderIdx + 1; i < fibLevels.length; i++) {
                lineD = self.fibRetrancementAdditionalDrawing.lines[fibLevels[i].id];
                if (lineD && lineD.visibility != "hidden") {
                    prevLine = lineD;
                    prevFill = self.fibRetrancementAdditionalDrawing.fill[fibLevels[i].id];
                    break;
                }
            }

            for (i = currentOrderIdx - 1; i >= 0; i--) {
                lineD = self.fibRetrancementAdditionalDrawing.lines[fibLevels[i].id];
                if (lineD && lineD.visibility != "hidden") {
                    next = lineD;
                    nextFill = self.fibRetrancementAdditionalDrawing.fill[fibLevels[i].id];
                    break;
                }
            }
        }
        if(subType == "fibExtention"){
            for (i = currentOrderIdx + 1; i < fibLevels.length; i++) {
                lineD = self.fibonacciDrawings.lines[fibLevels[i].id];
                if (lineD && lineD.visibility != "hidden") {
                    prevLine = lineD;
                    prevFill = self.fibonacciDrawings.fill[fibLevels[i].id];
                    break;
                }
            }

            for (i = currentOrderIdx - 1; i >= 0; i--) {
                lineD = self.fibonacciDrawings.lines[fibLevels[i].id];
                if (lineD && lineD.visibility != "hidden") {
                    next = lineD;
                    nextFill = self.fibonacciDrawings.fill[fibLevels[i].id];
                    break;
                }
            }
        }
        if (prevLine && next) {
            prvLinePoints = prevLine.d.split(' ');
            nextLinePoints = next.d.split(' ');
            nextFill.attr({
                d: ['M', nextLinePoints[1], nextLinePoints[2], 'L', nextLinePoints[4], nextLinePoints[5], 'L', prvLinePoints[4], prvLinePoints[5], prvLinePoints[1], prvLinePoints[2], 'L', nextLinePoints[1], nextLinePoints[2]]
            })
        } else if (!prevLine && nextFill) {
            nextFill.hide();
        }
    }

    if(self.resetDragSupporters){
        self.resetDragSupporters();
    }

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibSingleLineColorChange = function(rgb, value, isSingleColor, fibLevelColors, subType, isPropertyChange){
    var self = this,
        ann = self.annotation,
        options = ann.options;
    if(subType == "fibExtention"){
        self.isSingleColorExtention = isSingleColor;
        if(isSingleColor){
            options.extentionLineColor = value;
        }
        var fibLevels = self.annotation.options.fibExtentionLevels;
    }
    if(subType == "fibRetracement"){
        self.isSingleColorRetracement = isSingleColor;
        if(isSingleColor){
            options.retrancementLineColor = value;
        }
        var fibLevels = self.annotation.options.fibRetrancementLevels;
    }
    if (isSingleColor) {
        for (i = 0; i < fibLevels.length; i++) {
            self.onFibLevelLineColorChange(rgb, value, fibLevels[i].id, true, subType, false);
        }
    } else {
        for (i = 0; i < fibLevels.length; i++) {
            var lineColor = fibLevelColors[fibLevels[i].id].lineColor;
            self.onFibLevelLineColorChange(rgb, lineColor, fibLevels[i].id, false, subType, false);
        }
    }

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibSingleFillColorChange = function(rgb, value, opacity, isSingleColor, fibLevelColors, subType, isPropertyChange){
    var self = this,
        ann = self.annotation,
        options = ann.options;
    if(subType == "fibExtention"){
        options.isSingleColorExtention = isSingleColor;
        if(isSingleColor){
            options.extentionFillColor = value;
            options.extentionFillOpacity = opacity;
        }
        var fibLevels = self.annotation.options.fibExtentionLevels;
    }
    if(subType == "fibRetracement"){
        options.isSingleColorRetracement = isSingleColor;
        if(isSingleColor){
            options.retrancementFillColor = value;
            options.retrancementFillOpacity = opacity;
        }
        var fibLevels = self.annotation.options.fibRetrancementLevels;
    }
    var i;
    if (isSingleColor) {
        for (i = 0; i < fibLevels.length; i++) {
            self.onFibFillColorChange(rgb, value, opacity, fibLevels[i], true, subType, false);
        }
    } else {
        for (i = 0; i < fibLevels.length; i++) {
            var fibOption = fibLevelColors[fibLevels[i].id];
            self.onFibFillColorChange(rgb, fibOption.fillColor, fibOption.fillOpacity, fibLevels[i], false, subType, false);
        }
    }
    isPropertyChange && self.onPropertyChange();
    if (self.settingsPopup) {
        self.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibSingleFontColorChange = function(rgb, value, isSingleColor, fibLevelColors, subType, isPropertyChange){
    var self = this,
        ann = self.annotation,
        options = ann.options;

    if(subType == "fibExtention"){
        options.isSingleColorExtention = isSingleColor;
        if(isSingleColor){
            options.extentionFontColor = value;
        }
        var fibLevels = self.annotation.options.fibExtentionLevels;
    }
    if(subType == "fibRetracement"){
        options.isSingleColorRetracement = isSingleColor;
        if(isSingleColor){
            options.retrancementFontColor = value;
        }
        var fibLevels = self.annotation.options.fibRetrancementLevels;
    }
    var i;
    if (isSingleColor) {
        for (i = 0; i < fibLevels.length; i++) {
            self.onFibLevelFontColorChange(rgb, value, fibLevels[i], true, subType, false);
        }
    } else {
        for (i = 0; i < fibLevels.length; i++) {
            var fibOption = fibLevelColors[fibLevels[i].id];
            self.onFibLevelFontColorChange(rgb, fibOption.fontColor, fibLevels[i], false, subType, false);
        }
    }
    isPropertyChange && self.onPropertyChange();
    if (self.settingsPopup) {
        self.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibSingleLineWidthChange = function(strokeWidth, isSingleColor, fibLevelWidths, subType, isPropertyChange){
    var self = this;
    ann = self.annotation,
    options = ann.options;

    if(subType == "fibExtention"){
        options.isSingleColorExtention = isSingleColor;
        if(isSingleColor){
            options.extentionLineWidth = strokeWidth;
        }
        var fibLevels = self.annotation.options.fibExtentionLevels;
    }
    if(subType == "fibRetracement"){
        options.isSingleColorRetracement = isSingleColor;
        if(isSingleColor){
            options.retrancementLineWidth = strokeWidth;
        }
        var fibLevels = self.annotation.options.fibRetrancementLevels;
    }
    if (isSingleColor) {
        for (i = 0; i < fibLevels.length; i++) {
            self.onFibLineWidthChange(strokeWidth, fibLevels[i].id, true, subType, false);
        }
    } else {
        for (i = 0; i < fibLevels.length; i++) {
            self.onFibLineWidthChange(fibLevelWidths[fibLevels[i].id].lineWidth, fibLevels[i].id, false, subType, false);
        }
    }

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibSingleFontSizeChange = function(fontSize, isSingleColor, fibLevelFontSizes, subType, isPropertyChange){
    var self = this,
        ann = self.annotation,
        options = ann.options;

    if(subType == "fibExtention"){
        options.isSingleColorExtention = isSingleColor;
        if(isSingleColor){
            options.extentionFontSize = fontSize;
        }
        var fibLevels = self.annotation.options.fibExtentionLevels;
    }
    if(subType == "fibRetracement"){
        options.isSingleColorRetracement = isSingleColor;
        if(isSingleColor){
            options.retrancementFontSize = fontSize;
        }
        var fibLevels = self.annotation.options.fibRetrancementLevels;
    }
    if (isSingleColor) {
        for (i = 0; i < fibLevels.length; i++) {
            self.onFibLevelFontSizeChange(fontSize, fibLevels[i].id, true, subType, false);
        }
    } else {
        for (var i = 0; i < fibLevels.length; i++) {
            self.onFibLevelFontSizeChange(fibLevelFontSizes[fibLevels[i].id].fontSize, fibLevels[i].id, false, subType, false);
        }
    }
    self.scale(true);

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibSingleFontWeightChange = function(value, isSingleColor, fibLevelOptions, subType, isPropertyChange){
    var self = this;
    var ann = self.annotation;
    var options = ann.options;
    if(subType == "fibExtention"){
        options.isSingleColorExtention = isSingleColor;
        if(isSingleColor){
            options.extentionFontWeight = value;
        }
        var fibLevels = self.annotation.options.fibExtentionLevels;
    }
    if(subType == "fibRetracement"){
        options.isSingleColorRetracement = isSingleColor;
        if(isSingleColor){
            options.retrancementFontWeight = value;
        }
        var fibLevels = self.annotation.options.fibRetrancementLevels;
    }
    var i;
    if (isSingleColor) {
        for (i = 0; i < fibLevels.length; i++) {
            self.onFibLevelFontWeightChange(value, fibLevels[i].id, true, subType, false);
        }
    } else {
        for (i = 0; i < fibLevels.length; i++) {
            var fibOption = fibLevelOptions[fibLevels[i].id];
            self.onFibLevelFontWeightChange(fibOption.fontWeight, fibLevels[i].id, false, subType, false);
        }
    }
    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibSingleOptionChange = function(fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, isSingleColor, prevOptions, subType, isPropertyChange){
    var self = this;
    var ann = self.annotation,
        options = ann.options;

    if(subType == "fibExtention"){
        options.isSingleColorExtention = isSingleColor;
    }
    if(subType == "fibRetracement"){
        options.isSingleColorRetracement = isSingleColor;
    }
    self.onFibSingleFillColorChange(undefined, fillColor, fillOpacity, isSingleColor, prevOptions, subType, false);
    self.onFibSingleLineColorChange(undefined, lineColor, isSingleColor, prevOptions, subType, false);
    self.onFibSingleLineWidthChange(lineWidth, isSingleColor, prevOptions, subType, false);
    self.onFibSingleFontColorChange(undefined, fontColor, isSingleColor, prevOptions, subType, false);
    self.onFibSingleFontSizeChange(fontSize, isSingleColor, prevOptions, subType, false);
    self.onFibSingleFontWeightChange(fontWeight, isSingleColor, prevOptions, subType, false)

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibApplyAllButtonClick = function(fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, subType, isPropertyChange){
    var self = this;

    if(subType == "fibExtention"){
        var fibLevels = self.annotation.options.fibExtentionLevels;
    }
    if(subType == "fibRetracement"){
        var fibLevels = self.annotation.options.fibRetrancementLevels;
    }

    fibLevels.forEach(function (fibLevel) {
        fibLevel.fillColor = fillColor;
        fibLevel.fillOpacity = fillOpacity;
        fibLevel.lineColor = lineColor;
        fibLevel.lineWidth = lineWidth;
        fibLevel.fontColor = fontColor;
        fibLevel.fontSize = fontSize;
        fibLevel.fontWeight = fontWeight;
    });

    self.updateSettings(self.getConfig());
    isPropertyChange && self.onPropertyChange();
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onAlignStyleChange = function(linePosition, subType, isPropertyChange){
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        fibExtentionLevels = options.fibExtentionLevels ? options.fibExtentionLevels : this.fibExtentionLevels,
        fibExtentionLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibExtentionLevels),
        fibRetrancementLevels = options.fibRetrancementLevels ? options.fibRetrancementLevels : this.fibRetrancementLevels,
        fibRetrancementLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibRetrancementLevels),
        fibonacciExtentionDrawingLabels = self.fibonacciDrawings.labels,
        fibonacciRetrancementDrawingLabels = self.fibRetrancementAdditionalDrawing.labels,
        fibExtentionlineDrawings = self.fibonacciDrawings.lines,
        fibRetrancementLineDrawings = self.fibRetrancementAdditionalDrawing.lines;

    if(subType == "fibExtention"){
        options.extentionLabelPosition = linePosition;
        if(linePosition == "bottomLeft"){
            $.each(fibExtentionlineDrawings, function (key, value) {
                var line = value.d.split(' ');
                var fibExtentionDrawingLabel = fibonacciExtentionDrawingLabels[key];
                var hideFibLevelButton = self.fibonacciDrawings.hideFibLevelButton[key];
    
                fibExtentionDrawingLabel.attr({
                    x: line[1],
                    y: parseFloat(line[2])
                });
    
                hideFibLevelButton.attr({
                    x: parseFloat(line[1]) + fibExtentionDrawingLabel.width + hideFibLevelButton.getBBox().width,
                    y: parseFloat(line[2])
                });
            });
        }
        if(linePosition == "topLeft"){
            $.each(fibExtentionlineDrawings, function (key, value) {
                var line = value.d.split(' ');
                var fibExtentionDrawingLabel = fibonacciExtentionDrawingLabels[key];
                var hideFibLevelButton = self.fibonacciDrawings.hideFibLevelButton[key];
    
                fibExtentionDrawingLabel.attr({
                    x: line[1],
                    y: parseFloat(line[2]) - fibExtentionDrawingLabel.height
                });
    
                hideFibLevelButton.attr({
                    x: parseFloat(line[1]) + fibExtentionDrawingLabel.width + hideFibLevelButton.getBBox().width,
                    y: parseFloat(line[2]) - hideFibLevelButton.getBBox().height
                });
            });
        }
        if(linePosition == "bottomCenter"){
            $.each(fibExtentionlineDrawings, function (key, value) {
                var line = value.d.split(' ');
                var fibExtentionDrawingLabel = fibonacciExtentionDrawingLabels[key];
                var hideFibLevelButton = self.fibonacciDrawings.hideFibLevelButton[key];
    
                fibExtentionDrawingLabel.attr({
                    x: (parseFloat(line[1]) + parseFloat(line[4]))/2,
                    y: parseFloat(line[2])
                });
    
                hideFibLevelButton.attr({
                    x: (parseFloat(line[1]) + parseFloat(line[4]))/2 - fibExtentionDrawingLabel.width/2,
                    y: parseFloat(line[2])
                });
            });
        }
        if(linePosition == "topCenter"){
            $.each(fibExtentionlineDrawings, function (key, value) {
                var line = value.d.split(' ');
                var fibExtentionDrawingLabel = fibonacciExtentionDrawingLabels[key];
                var hideFibLevelButton = self.fibonacciDrawings.hideFibLevelButton[key];
    
                fibExtentionDrawingLabel.attr({
                    x: (parseFloat(line[1]) + parseFloat(line[4]))/2,
                    y: parseFloat(line[2]) - fibExtentionDrawingLabel.height
                });
    
                hideFibLevelButton.attr({
                    x: (parseFloat(line[1]) + parseFloat(line[4]))/2 - fibExtentionDrawingLabel.width/2,
                    y: parseFloat(line[2]) - hideFibLevelButton.getBBox().height
                });
            });
        }
        if(linePosition == "bottomRight"){
            $.each(fibExtentionlineDrawings, function (key, value) {
                var line = value.d.split(' ');
                var fibExtentionDrawingLabel = fibonacciExtentionDrawingLabels[key];
                var hideFibLevelButton = self.fibonacciDrawings.hideFibLevelButton[key];
    
                fibExtentionDrawingLabel.attr({
                    x: line[4] -  fibExtentionDrawingLabel.width,
                    y: parseFloat(line[2])
                });
    
                hideFibLevelButton.attr({
                    x: parseFloat(line[4]) - fibExtentionDrawingLabel.width - hideFibLevelButton.getBBox().width,
                    y: parseFloat(line[2])
                });
            });
        }
        if(linePosition == "topRight"){
            $.each(fibExtentionlineDrawings, function (key, value) {
                var line = value.d.split(' ');
                var fibExtentionDrawingLabel = fibonacciExtentionDrawingLabels[key];
                var hideFibLevelButton = self.fibonacciDrawings.hideFibLevelButton[key];
    
                fibExtentionDrawingLabel.attr({
                    x: line[4] - fibExtentionDrawingLabel.width,
                    y: parseFloat(line[2]) - fibExtentionDrawingLabel.height
                });
    
                hideFibLevelButton.attr({
                    x: parseFloat(line[4]) - fibExtentionDrawingLabel.width - hideFibLevelButton.getBBox().width,
                    y: parseFloat(line[2]) - hideFibLevelButton.getBBox().height
                });
            });
        }
    }
    if(subType == "fibRetracement"){
        options.retracementLabelPosition = linePosition;
        if(linePosition == "bottomLeft"){
            $.each(fibRetrancementLineDrawings, function (key, value) {
                var line = value.d.split(' ');
                var fibRetrancementDrawingLabel = fibonacciRetrancementDrawingLabels[key];
                var hideFibLevelButton = self.fibRetrancementAdditionalDrawing.hideFibLevelButton[key];
    
                fibRetrancementDrawingLabel.attr({
                    x: line[1],
                    y: parseFloat(line[2])
                });
    
                hideFibLevelButton.attr({
                    x: parseFloat(line[1]) + fibRetrancementDrawingLabel.width,
                    y: parseFloat(line[2])
                });
            });
        }
        if(linePosition == "topLeft"){
            $.each(fibRetrancementLineDrawings, function (key, value) {
                var line = value.d.split(' ');
                var fibRetrancementDrawingLabel = fibonacciRetrancementDrawingLabels[key];
                var hideFibLevelButton = self.fibRetrancementAdditionalDrawing.hideFibLevelButton[key];
    
                fibRetrancementDrawingLabel.attr({
                    x: line[1],
                    y: parseFloat(line[2]) - fibRetrancementDrawingLabel.height
                });
    
                hideFibLevelButton.attr({
                    x: parseFloat(line[1]) + fibRetrancementDrawingLabel.width,
                    y: parseFloat(line[2]) - hideFibLevelButton.getBBox().height
                });
            });
        }
        if(linePosition == "bottomCenter"){
            $.each(fibRetrancementLineDrawings, function (key, value) {
                var line = value.d.split(' ');
                var fibRetrancementDrawingLabel = fibonacciRetrancementDrawingLabels[key];
                var hideFibLevelButton = self.fibRetrancementAdditionalDrawing.hideFibLevelButton[key];
    
                fibRetrancementDrawingLabel.attr({
                    x: (parseFloat(line[1]) + parseFloat(line[4]))/2,
                    y: parseFloat(line[2])
                });
    
                hideFibLevelButton.attr({
                    x: (parseFloat(line[1]) + parseFloat(line[4]))/2 - fibRetrancementDrawingLabel.width/2 - hideFibLevelButton.getBBox().width,
                    y: parseFloat(line[2])
                });
            });
        }
        if(linePosition == "topCenter"){
            $.each(fibRetrancementLineDrawings, function (key, value) {
                var line = value.d.split(' ');
                var fibRetrancementDrawingLabel = fibonacciRetrancementDrawingLabels[key];
                var hideFibLevelButton = self.fibRetrancementAdditionalDrawing.hideFibLevelButton[key];
    
                fibRetrancementDrawingLabel.attr({
                    x: (parseFloat(line[1]) + parseFloat(line[4]))/2,
                    y: parseFloat(line[2]) - fibRetrancementDrawingLabel.height
                });
    
                hideFibLevelButton.attr({
                    x: (parseFloat(line[1]) + parseFloat(line[4]))/2 - fibRetrancementDrawingLabel.width/2 - hideFibLevelButton.getBBox().width,
                    y: parseFloat(line[2]) - hideFibLevelButton.height
                });
            });
        }
        if(linePosition == "bottomRight"){
            $.each(fibRetrancementLineDrawings, function (key, value) {
                var line = value.d.split(' ');
                var fibRetrancementDrawingLabel = fibonacciRetrancementDrawingLabels[key];
                var hideFibLevelButton = self.fibRetrancementAdditionalDrawing.hideFibLevelButton[key];
    
                fibRetrancementDrawingLabel.attr({
                    x: parseFloat(line[4]) - fibRetrancementDrawingLabel.width,
                    y: parseFloat(line[2])
                });
    
                hideFibLevelButton.attr({
                    x: parseFloat(line[4]) - fibRetrancementDrawingLabel.width - hideFibLevelButton.getBBox().width,
                    y: parseFloat(line[2])
                });
            });
        }
        if(linePosition == "topRight"){
            $.each(fibRetrancementLineDrawings, function (key, value) {
                var line = value.d.split(' ');
                var fibRetrancementDrawingLabel = fibonacciRetrancementDrawingLabels[key];
                var hideFibLevelButton = self.fibRetrancementAdditionalDrawing.hideFibLevelButton[key];
    
                fibRetrancementDrawingLabel.attr({
                    x: parseFloat(line[4]) - fibRetrancementDrawingLabel.width,
                    y: parseFloat(line[2]) - fibRetrancementDrawingLabel.height
                });
    
                hideFibLevelButton.attr({
                    x: parseFloat(line[4]) - fibRetrancementDrawingLabel.width - hideFibLevelButton.getBBox().width,
                    y: parseFloat(line[2]) - hideFibLevelButton.getBBox().height
                });
            });
        }
    }
    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.isVisibleLastLevel = function () {
    var self = this;
    var count = 0;
    $.each(self.fibonacciDrawings.lines, function (key, value) {
        if (value.visibility !== 'hidden') {
            count = count + 1;
        }
    });

    $.each(self.fibRetrancementAdditionalDrawing.lines, function (key, value) {
        if (value.visibility !== 'hidden') {
            count = count + 1;
        }
    });

    return count === 1;
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.highlightEachLine = function(){
    let self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        selectedLevel,
        subType,
        dragSupporters = self.dragSupporters,
        container = chart.container,
        additionalDrawings = self.additionalDrawings,
        fibonacciDrawings = self.fibonacciDrawings,
        fibRetrancementAdditionalDrawing = self.fibRetrancementAdditionalDrawing,
        fibExtentionLabels = fibonacciDrawings.labels,
        fibRetrancementLabels = fibRetrancementAdditionalDrawing.labels;

        dragSupporters.forEach(function (dragSupporter) {
            $(dragSupporter.element).mouseenter( function (event) {
                selectedLevel = event.target.getAttribute('level');
                subType = event.target.getAttribute('subType');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }

                if(subType == "fibRetracement"){
                    var lines = fibRetrancementAdditionalDrawing.lines;
                    var fibLabels = fibRetrancementAdditionalDrawing.labels;
                }
                if(subType == "fibExtention"){
                    var lines = fibonacciDrawings.lines;
                    var fibLabels = fibonacciDrawings.labels;
                }
                if(selectedLevel){
                    var selectedLine = lines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    $(container).find("path[class*='line-hover']").attr({class:''});
                    $(container).find("g[class*='label-hover']").attr({class:'highcharts-label'});
                    if(selectedLine){
                        selectedLine.addClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.addClass('label-hover');
                    }
                }
                event.stopPropagation();
            });

            $(dragSupporter.element).mouseleave( function (event) {
                selectedLevel = event.target.getAttribute('level');
                subType = event.target.getAttribute('subType');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                if(subType == "fibRetracement"){
                    var lines = fibRetrancementAdditionalDrawing.lines;
                    var fibLabels = fibRetrancementAdditionalDrawing.labels;
                }
                if(subType == "fibExtention"){
                    var lines = fibonacciDrawings.lines;
                    var fibLabels = fibonacciDrawings.labels;
                }
                if(selectedLevel){
                    var selectedLine = lines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    if(selectedLine){
                        selectedLine.removeClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.removeClass('label-hover');
                    }
                }
                event.stopPropagation();
            });
        })

        $.each(fibExtentionLabels, function (key, fibonacciExtentionLabel) {
            $(fibonacciExtentionLabel.element).mouseenter( function (event) {
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                var lines = fibonacciDrawings.lines;
                var fibLabels = fibonacciDrawings.labels;
                if(selectedLevel){
                    var selectedLine = lines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    $(container).find("path[class*='line-hover']").attr({class:''});
                    $(container).find("g[class*='label-hover']").attr({class:'highcharts-label'});
                    if(selectedLine){
                        selectedLine.addClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.addClass('label-hover');
                    }
                }
                event.stopPropagation();
            });

            $(fibonacciExtentionLabel.element).mouseleave( function (event) {
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                var lines = fibonacciDrawings.lines;
                var fibLabels = fibonacciDrawings.labels;
                if(selectedLevel){
                    var selectedLine = lines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    if(selectedLine){
                        selectedLine.removeClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.removeClass('label-hover');
                    }
                }
                event.stopPropagation();
            });
        })

        $.each(fibRetrancementLabels, function (key, fibRetrancementLabel) {
            $(fibRetrancementLabel.element).mouseenter( function (event) {
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                var lines = fibRetrancementAdditionalDrawing.lines;
                var fibLabels = fibRetrancementAdditionalDrawing.labels;
                if(selectedLevel){
                    var selectedLine = lines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    $(container).find("path[class*='line-hover']").attr({class:''});
                    $(container).find("g[class*='label-hover']").attr({class:'highcharts-label'});
                    if(selectedLine){
                        selectedLine.addClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.addClass('label-hover');
                    }
                }
                event.stopPropagation();
            });

            $(fibRetrancementLabel.element).mouseleave( function (event) {
                selectedLevel = event.target.getAttribute('level');
                if (!selectedLevel && event.target.parentElement) {
                    if (event.target.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.getAttribute('level');
                    } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
                        selectedLevel = event.target.parentElement.parentElement.getAttribute('level');
                    }
                }
                var lines = fibRetrancementAdditionalDrawing.lines;
                var fibLabels = fibRetrancementAdditionalDrawing.labels;
                if(selectedLevel){
                    var selectedLine = lines[selectedLevel];
                    var selectedLabel = fibLabels[selectedLevel];
                    if(selectedLine){
                        selectedLine.removeClass('line-hover');
                    }
                    if(selectedLabel){
                        selectedLabel.removeClass('label-hover');
                    }
                }
                event.stopPropagation();
            });
        })
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onTrendLineColorChange = function (rgb, color, opacity, isPropertyChange){
    var self = this;
    self.annotation.update({
        shape: {
            params: {
                stroke: color,
                opacity: opacity
            }
        }
    });

    if (self.additionalDrawings.referenceLine){
        self.additionalDrawings.referenceLine.attr({
            stroke: color,
            opacity: opacity
        });
    }

    self.annotation.options.trendLineColor = color;
    self.annotation.options.trendLineOpacity = opacity;

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onTrendLineWidthChange =  function (strokeWidth, isPropertyChange) {
    var self = this;
    var strokeDashArray = infChart.drawingUtils.common.settings.getStrokeDashArray.call(self, self.annotation.options.trendLineStyle, strokeWidth);

    self.annotation.update({
        shape: {
            params: {
                'stroke-width': strokeWidth,
                'stroke-dasharray': strokeDashArray
            }
        }
    });

    if (self.additionalDrawings.referenceLine){
        self.additionalDrawings.referenceLine.attr({
            'stroke-width': strokeWidth,
            'stroke-dasharray': strokeDashArray
        });
    }

    self.annotation.options.trendLineWidth = strokeWidth;

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};


infChart.fib3PointPriceProjectionGenericDrawing.prototype.onTrendLineStyleChange = function (dashStyle, isPropertyChange) {
    var self = this;
    var strokeDashArray = infChart.drawingUtils.common.settings.getStrokeDashArray.call(self, dashStyle, self.annotation.options.trendLineWidth);

    self.annotation.update({
        shape: {
            params: {
                dashstyle: dashStyle,
                'stroke-dasharray': strokeDashArray
            }
        }
    });

    if (self.additionalDrawings.referenceLine){
        self.additionalDrawings.referenceLine.attr({
            dashstyle: dashStyle,
            'stroke-dasharray': strokeDashArray
        });
    }

    self.annotation.options.trendLineStyle = dashStyle;

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.fib3PointPriceProjectionGenericDrawing.prototype.onTrendLineToggleShow = function(checked, isPropertyChange){
    var self = this,
        ann = self.annotation,
        options = ann.options,
        additionalDrawings = self.additionalDrawings;

    options.isTrendLineAlways = checked;
    if(checked){
        if(ann){
            ann.shape.show();
            if(additionalDrawings && additionalDrawings.referenceLine){
                additionalDrawings.referenceLine.show();
            }
            self.resetDragSupporters();
        }
    }

    isPropertyChange && self.onPropertyChange();
    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};
window.infChart = window.infChart || {};

infChart.abcdPatternDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
};

infChart.abcdPatternDrawing.prototype = Object.create(infChart.drawingObject.prototype);

/**
* set additional drawings of the tool
*/
infChart.abcdPatternDrawing.prototype.additionalDrawingsFunction = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        yAxis = chart.yAxis[options.yAxis],
        lineShapes = self.getPatternShapes(),
        additionalDrawingsArr = self.additionalDrawings,
        theme = infChart.drawingUtils.common.getTheme(),
        shapeTheme = theme["abcdPattern"],
        pointNamesArr = ["a", "b", "c", "d"];

    additionalDrawingsArr.lines = {};
    additionalDrawingsArr.fill = {};
    additionalDrawingsArr.labels = {};
    additionalDrawingsArr.circles = {};
    additionalDrawingsArr.axisLabels = {};
    additionalDrawingsArr.rect = {};

    ann.selectionMarker = [];

    var drawingLineAttr = {
        'stroke-width': 1,
        'stroke': options.shape.params.stroke || shapeTheme && shapeTheme.stroke || infChart.drawingUtils.common.baseBorderColor,
        'stroke-dasharray': "2 2"
    };

    additionalDrawingsArr.lines["ac"] = chart.renderer.path(lineShapes.ac).attr(drawingLineAttr).add(ann.group);
    additionalDrawingsArr.lines["bd"] = chart.renderer.path(lineShapes.bd).attr(drawingLineAttr).add(ann.group);

    self.setSelectionMarkers();
    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        labelPosition && (additionalDrawingsArr.labels[value + "Label"] = self.getLabel(labelPosition.label, labelPosition.x, labelPosition.y));
    });
    additionalDrawingsArr.labels["ACFib"] = self.getLabel("ACFib", 0, 0).hide();
    additionalDrawingsArr.labels["BDFib"] = self.getLabel("BDFib", 0, 0).hide();

    yAxis.isDirty = true; // need to change the axis offset in the chart
    self.chartRedrawRequired = true;
};

/**
* Get xAxis labels to front when there is an real-time update which is to redraw the chart without extrem changes
*/
infChart.abcdPatternDrawing.prototype.afterRedrawXAxisWithoutSetExtremes = function () { };

infChart.abcdPatternDrawing.prototype.bindSettingsEvents = function () {
    infChart.drawingUtils.common.bindAbcdSettingsEvents.call(this);
};

infChart.abcdPatternDrawing.prototype.deselect = function () {
    this.annotation.selectionMarker = [];
    this.additionalDrawings.axisLabels = {};
    this.additionalDrawings.rect = {};
    this.additionalDrawings.circles = {};
};

/**
* Returns the maximum offset of the axis labels
* @param {Highstock.Axis} axis axis object
* @returns {number} max width
*/
infChart.abcdPatternDrawing.prototype.getAxisOffset = function (axis) {
    return 0;
};

/**
* Returns the base line's path
* @returns Array path to draw base line
*/
infChart.abcdPatternDrawing.prototype.getBasePatternLine = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        x = xAxis.toPixels(options.xValue),
        y = yAxis.toPixels(options.yValue),
        line = ['M', 0, 0];

    infChart.util.forEach(options.intermediatePoints, function (index, value) {
        line.push('L');
        line.push(xAxis.toPixels(value.xValue) - x);
        line.push(yAxis.toPixels(value.yValue) - y);
    });

    if (options.xValueEnd) {
        line.push('L');
        line.push(xAxis.toPixels(options.xValueEnd) - x);
        line.push(yAxis.toPixels(options.yValueEnd) - y);
    }
    return line;
};

infChart.abcdPatternDrawing.prototype.getClickValues = function (clickX, clickY) {
    var ann = this.annotation;
    var chart = ann.chart;
    var options = ann.options;
    var xAxis = chart.xAxis[options.xAxis];
    var yAxis = chart.yAxis[options.yAxis];
    var completedSteps = this.annotation.options.completedSteps;
    var coordinates = {
        xValue: options.xValue,
        yValue: options.yValue,
        intermediatePoints: options.intermediatePoints
    };
    switch (completedSteps) {
        case 1:
            coordinates.intermediatePoints[0].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[0].yValue = yAxis.toValue(clickY);
            break;
        case 2:
            coordinates.intermediatePoints[1].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[1].yValue = yAxis.toValue(clickY);
            break;
        case 3:
            coordinates.xValueEnd = xAxis.toValue(clickX);
            coordinates.yValueEnd = yAxis.toValue(clickY);
            break;
    }
    return coordinates;
};

/**
* Returns the config to save
* @returns {{shape: string, borderColor: *, strokeWidth: *, xValue: *, yValue: *, xValueEnd: *, yValueEnd: *, intermediatePoints: Array}} config object
*/
infChart.abcdPatternDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    var intermediatePoints = [];

    infChart.util.forEach(annotation.options.intermediatePoints, function(index , value){
        intermediatePoints.push({
            xValue: value.xValue,
            yValue: value.yValue
        });
    });

    return {
        shape: 'abcdPattern',
        borderColor: annotation.options.shape.params.stroke,
        strokeWidth: annotation.options.shape.params['stroke-width'],
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        intermediatePoints: intermediatePoints,
        fillColor: 'none',
        textColor: annotation.options.textColor,
        textFontSize: annotation.options.textFontSize,
        isLocked : annotation.options.isLocked
    };
};

/**
 * Create a label and add to the group
 * @param {String} name label text
 * @param {number} x x position
 * @param {number} y y position
 * @returns {SVGElement} the generated label
 */
infChart.abcdPatternDrawing.prototype.getLabel = function (name, x, y) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        theme = infChart.drawingUtils.common.getTheme(),
        shapeTheme = theme["abcdPattern"];

    return chart.renderer.label(name, x, y).attr({
        'zIndex': 20,
        'r': 3,
        'fill': options.shape.params.stroke || shapeTheme && shapeTheme.label && shapeTheme.label.fill || "#2f2e33",
        'opacity': shapeTheme && shapeTheme.label && shapeTheme.label.opacity || 1,
        'stroke': shapeTheme && shapeTheme.label && shapeTheme.label.stroke || "#858587",
        'stroke-width': 0,
        'hAlign': 'center',
        'class': 'harmonic-lbl'
    }).add(ann.group).css(
        {
            color: options.textColor ||shapeTheme && shapeTheme.label && shapeTheme.label.stroke || "#000000",
            fontSize: options.textFontSize || shapeTheme.fontSize || '16px',
            cursor: 'move',
            fontWeight: '500',
            fontStyle: 'normal',
            textDecoration: 'inherit'
        });
};

infChart.abcdPatternDrawing.prototype.getLabelFormattedXValue = function (value, axis) {
    var interval = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(this.chart.renderTo.id)).interval;
    var format = axis.options.dateTimeLabelFormats.day + " " + axis.options.dateTimeLabelFormats.minute;
    if (interval === 'D' || interval === 'W' || interval === 'M' || interval === 'Y') {
        format = axis.options.dateTimeLabelFormats.day;
    }
    return infChart.util.formatDate(value, format);
};

/**
 * Returns the formatted label
 * @param {number} yValue actual value
 * @param {number} optionsyValue value in the options
 * @returns {string} formatted value to be set
 */
infChart.abcdPatternDrawing.prototype.getLabelFormattedYValue = function (yValue, optionsyValue) {
    var stockChart = this.stockChart;
    var value;
    if (stockChart.isPercent) {
        value = stockChart.getYLabel(optionsyValue, true, false, false);
    } else {
        value = stockChart.formatValue(yValue, stockChart.getMainSeries().options.dp);
    }
    return value;
};

infChart.abcdPatternDrawing.prototype.getNextPointOptions = function () {
    var ann = this.annotation;
    var completedSteps = ann.options.completedSteps;
    var pointOptions = { name: "a" };
    switch (completedSteps) {
        case 1:
            pointOptions.name = "b";
            break;
        case 2:
            pointOptions.name = "c";
            break;
        case 3:
            pointOptions.name = "d";
            break;

    }
    return pointOptions;
};

/**
* Returns the the drawing options from saved|initial properties
* @param {object} properties drawing properties
* @returns {{name: *, indicatorId: *, utilizeAxes: string, xValue: *, yValue: *, xValueEnd: *, yValueEnd: *, intermediatePoints: Array, allowDragY: boolean, shape: {params: {fill: string, d: *[]}}, isIndicator: boolean, drawingType: string, allowDragX: boolean}} options to set
*/
infChart.abcdPatternDrawing.prototype.getOptions = function (properties) {
    var theme = infChart.drawingUtils.common.getTheme();
    var shapeTheme = theme["abcdPattern"];
    var options = {
        name: properties.name,
        xValue: properties.xValue,
        yValue: properties.yValue,
        xValueEnd: properties.xValueEnd,
        yValueEnd: properties.yValueEnd,
        intermediatePoints: [],
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0]
            }
        }
    };

    options.shape.params["fill-opacity"] = 0;

    if (properties.borderColor) {
        options.shape.params.stroke = properties.color || properties.borderColor;
    }
    if (properties.strokeWidth) {
        options.shape.params['stroke-width'] = properties.strokeWidth;
    }

    if (properties.intermediatePoints) {
        infChart.util.forEach(properties.intermediatePoints, function(index , value){
            options.intermediatePoints.push({
                xValue: value.xValue,
                yValue: value.yValue
            });
        });
    }
    if (properties.completedSteps) {
        options.completedSteps = properties.completedSteps;
    }

    if(properties.textColor) {
        options.textColor = properties.textColor;
    } else {
        options.textColor = shapeTheme.label.fontColor || "#000000";
    }

    options.textFontSize = properties.textFontSize ? properties.textFontSize : shapeTheme.label.fontSize || 16;

    //options.isRealTimeTranslation = true; // since label value is needed to be changed
    options.validateTranslationFn = this.validateTranslation;

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.abcdPatternDrawing.prototype.validateTranslation = function (newXValue) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        seriesData = chart.series[0].xData,
        dataMin = seriesData[0],
        xVal = options.xValue,
        xValEnd = options.xValueEnd,
        intermediate = options.intermediatePoints,
        newXValueEnd = xValEnd - xVal + newXValue,
        newIntermediateStart = intermediate[0].xValue - xVal + newXValue,
        newIntermediateEnd = intermediate[1].xValue - xVal + newXValue,
        totalPoints = infChart.drawingsManager.getTotalPoints(chart),
        dataMax = totalPoints[totalPoints.length - 1];

    return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax) && (newIntermediateStart >= dataMin && newIntermediateStart <= dataMax) && (newIntermediateEnd >= dataMin && newIntermediateEnd <= dataMax);
};

/**
* Returns the paths, values and positions of the shapes under this drawing
* @returns {object} pattern shapes
*/
infChart.abcdPatternDrawing.prototype.getPatternShapes = function () {
    var nameAdditionalY = 25;
    var patternPaths = {};

    var ann = this.annotation;
    var chart = ann.chart;
    var options = ann.options;
    var intermediatePoints = options.intermediatePoints;
    var intermediatePointsRaw = this.intermediatePoints;
    var xAxis = chart.xAxis[options.xAxis];
    var yAxis = chart.yAxis[options.yAxis];

    var x = xAxis.toPixels(options.xValue);
    var y = yAxis.toPixels(options.yValue);

    var bx = intermediatePoints && intermediatePoints[0] && (xAxis.toPixels(intermediatePoints[0].xValue) - x);
    var by = intermediatePoints && intermediatePoints[0] && (yAxis.toPixels(intermediatePoints[0].yValue) - y);
    var cx = intermediatePoints && intermediatePoints[1] && (xAxis.toPixels(intermediatePoints[1].xValue) - x);
    var cy = intermediatePoints && intermediatePoints[1] && (yAxis.toPixels(intermediatePoints[1].yValue) - y);
    var dx = options.xValueEnd && (xAxis.toPixels(options.xValueEnd) - x);
    var dy = options.yValueEnd && (yAxis.toPixels(options.yValueEnd) - y);

    patternPaths.ac = cx !== undefined ? ['M', 0, 0, 'L', cx, cy] : x !== undefined ? ['M', 0, 0] : [];
    patternPaths.bd = dx !== undefined ? ['M', bx, by, 'L', dx, dy] : bx !== undefined ? ['M', bx, by] : [];

    if (dx !== undefined) {
        if (y < 0) {
            patternPaths.namePosition = { x: (dx) / 2, y: (dy) / 2 + nameAdditionalY };
        } else {
            patternPaths.namePosition = { x: (x + cx) / 2, y: (y + cy) / 2 + nameAdditionalY };
        }
    }

    patternPaths.aCirclePosition = { x: 0, y: 0 };

    patternPaths.positions = {
        pointLabels: {
            a: { x: -5, y: y < 0 ? 5 : -25, label: "A" }
        },
        circles: {
            a: { x: 0, y: 0 },
            b: { x: bx, y: by },
            c: { x: cx, y: cy },
            d: { x: dx, y: dy }
        }
    };

    patternPaths.positions.axisClips = {};

    patternPaths.values = {
        a: {
            xValue: options.xValue,
            yValue: this.yValue,
            optionXValue: options.xValue,
            optionYValue: options.yValue
        }
    };

    if (bx !== undefined) {
        patternPaths.bCirclePosition = { x: bx, y: by };
        patternPaths.positions.pointLabels.b = { x: bx - 5, y: y < by ? by + 5 : by - 25, label: "B" };
        patternPaths.values.b = {
            xValue: intermediatePoints[0].xValue,
            yValue: intermediatePointsRaw[0] ? intermediatePointsRaw[0].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[0].yValue),
            optionXValue: intermediatePoints[0].xValue,
            optionYValue: intermediatePoints[0].yValue
        };

    }
    if (cx !== undefined) {
        patternPaths.cCirclePosition = { x: cx, y: cy };
        patternPaths.positions.pointLabels.c = { x: cx - 5, y: cy < dy ? cy - 25 : cy + 5, label: "C" };
        patternPaths.values.c = {
            xValue: intermediatePoints[1].xValue,
            yValue: intermediatePointsRaw[1] ? intermediatePointsRaw[1].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[1].yValue),
            optionXValue: intermediatePoints[1].xValue,
            optionYValue: intermediatePoints[1].yValue
        };
    }
    if (dx !== undefined) {
        patternPaths.dCirclePosition = { x: dx, y: dy };
        patternPaths.positions.pointLabels.d = { x: dx - 5, y: cy < dy ? dy + 5 : dy - 25, label: "D" };
        patternPaths.values.d = {
            xValue: options.xValueEnd,
            yValue: this.yValueEnd !== undefined ? this.yValueEnd : infChart.drawingUtils.common.getBaseYValue.call(this, options.yValueEnd),
            optionXValue: options.xValueEnd,
            optionYValue: options.yValueEnd
        };

    }
    return patternPaths;
};

infChart.abcdPatternDrawing.prototype.getQuickSettingsPopup = function () {
    var common = infChart.drawingUtils.common;
    return infChart.structureManager.drawingTools.getAbcdQuickSettings(common.baseBorderColor);
};

infChart.abcdPatternDrawing.prototype.getSettingsPopup = function () {
    var common = infChart.drawingUtils.common;
    return infChart.structureManager.drawingTools.getAbcdSettings(infChart.manager.getLabel('label.abcdPattern'), common.baseBorderColor, this.fontColor, this.fontSize);
};

infChart.abcdPatternDrawing.prototype.hasMoreIntermediateSteps = function () {
    return this.annotation.options.completedSteps !== 3;
};

infChart.abcdPatternDrawing.prototype.onclick = function () {
    infChart.drawingUtils.common.getAxisLabelToFront.call(this, this.additionalDrawings.axisLabels["xLabel_x"]);
}

/**
* Scale function of the tool
*/
infChart.abcdPatternDrawing.prototype.scale = function (isCalculateNewValueForScale) {
    var self = this,
        ann = self.annotation,
        line,
        additionalDrawingsArr = self.additionalDrawings,
        pointNamesArr = ["a", "b", "c", "d"];

    line = self.getBasePatternLine();

    ann.update({
        shape: {
            params: {
                d: line
            }
        }
    });

    var lineShapes = self.getPatternShapes();
    additionalDrawingsArr.lines["ac"].attr({ d: lineShapes.ac });
    additionalDrawingsArr.lines["bd"].attr({ d: lineShapes.bd });

    lineShapes.namePosition && additionalDrawingsArr.labels["nameLabel"] && additionalDrawingsArr.labels["nameLabel"].attr({
        x: lineShapes.namePosition.x,
        y: lineShapes.namePosition.y
    });

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        var label = additionalDrawingsArr.labels[value + "Label"];
        label && label.attr({ x: labelPosition.x, y: labelPosition.y });
        // circles
        if (additionalDrawingsArr.circles[value]) {
            var circlePositions = lineShapes.positions["circles"][value];
            additionalDrawingsArr.circles[value].attr({ x: circlePositions.x, y: circlePositions.y });
        }
    });

    var aPoint, bPoint, cPoint, dPoint;

    var ABVal, BCVal, CDVal;

    aPoint = [ann.options.xValue, ann.options.yValue];

    if (ann.options.intermediatePoints[0]) {
        bPoint = [ann.options.intermediatePoints[0].xValue, ann.options.intermediatePoints[0].yValue];
        ABVal = Math.abs(bPoint[1] - aPoint[1]);
    }
    if (ann.options.intermediatePoints[1]) {
        cPoint = [ann.options.intermediatePoints[1].xValue, ann.options.intermediatePoints[1].yValue];
        BCVal = Math.abs(bPoint[1] - cPoint[1]);
    }

    if (ann.options.xValueEnd) {
        dPoint = [ann.options.xValueEnd, ann.options.yValueEnd];
        CDVal = Math.abs(dPoint[1] - cPoint[1]);
    }

    var ACFib, BDFib = 0;

    if (BCVal > 0 && ABVal > 0) {
        ACFib = infChart.drawingUtils.common.formatValue(BCVal / ABVal, 3);
        additionalDrawingsArr.labels["ACFib"].attr({
            x: (lineShapes.positions["pointLabels"]["c"].x - lineShapes.positions["pointLabels"]["a"].x) / 2 + lineShapes.positions["pointLabels"]["a"].x,
            y: (lineShapes.positions["pointLabels"]["c"].y - lineShapes.positions["pointLabels"]["a"].y) / 2 + lineShapes.positions["pointLabels"]["a"].y,
            text: ACFib
        }).show();
    }

    if (CDVal > 0 && BCVal > 0) {
        BDFib = infChart.drawingUtils.common.formatValue(CDVal / BCVal, 3);

        additionalDrawingsArr.labels["BDFib"].attr({
            x: (lineShapes.positions["pointLabels"]["d"].x - lineShapes.positions["pointLabels"]["b"].x) / 2 + lineShapes.positions["pointLabels"]["b"].x,
            y: (lineShapes.positions["pointLabels"]["d"].y - lineShapes.positions["pointLabels"]["b"].y) / 2 + lineShapes.positions["pointLabels"]["b"].y,
            text: BDFib
        }).show();
    }
};

infChart.abcdPatternDrawing.prototype.finalizeEachPoint = function () {
    var self = this,
        ann = self.annotation,
        line,
        additionalDrawingsArr = self.additionalDrawings,
        pointNamesArr = ["a", "b", "c", "d"];

    line = self.getBasePatternLine();

    ann.update({
        shape: {
            params: {
                d: line
            }
        }
    });

    var lineShapes = self.getPatternShapes();
    additionalDrawingsArr.lines["ac"].attr({ d: lineShapes.ac });
    additionalDrawingsArr.lines["bd"].attr({ d: lineShapes.bd });

    lineShapes.namePosition && additionalDrawingsArr.labels["nameLabel"] && additionalDrawingsArr.labels["nameLabel"].attr({
        x: lineShapes.namePosition.x,
        y: lineShapes.namePosition.y
    });

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        var label = additionalDrawingsArr.labels[value + "Label"];
        label && label.attr({ x: labelPosition.x, y: labelPosition.y });
        // circles
        if (additionalDrawingsArr.circles[value]) {
            var circlePositions = lineShapes.positions["circles"][value];
            additionalDrawingsArr.circles[value].attr({ x: circlePositions.x, y: circlePositions.y });
        }
    });

    var aPoint, bPoint, cPoint, dPoint;

    var ABVal, BCVal, CDVal;

    aPoint = [ann.options.xValue, ann.options.yValue];

    if (ann.options.intermediatePoints[0]) {
        bPoint = [ann.options.intermediatePoints[0].xValue, ann.options.intermediatePoints[0].yValue];
        ABVal = Math.abs(bPoint[1] - aPoint[1]);
    }
    if (ann.options.intermediatePoints[1]) {
        cPoint = [ann.options.intermediatePoints[1].xValue, ann.options.intermediatePoints[1].yValue];
        BCVal = Math.abs(bPoint[1] - cPoint[1]);
    }

    if (ann.options.xValueEnd) {
        dPoint = [ann.options.xValueEnd, ann.options.yValueEnd];
        CDVal = Math.abs(dPoint[1] - cPoint[1]);
    }

    var ACFib, BDFib = 0;

    if (BCVal > 0 && ABVal > 0) {
        ACFib = infChart.drawingUtils.common.formatValue(BCVal / ABVal, 3);
        additionalDrawingsArr.labels["ACFib"].attr({
            x: (lineShapes.positions["pointLabels"]["c"].x - lineShapes.positions["pointLabels"]["a"].x) / 2 + lineShapes.positions["pointLabels"]["a"].x,
            y: (lineShapes.positions["pointLabels"]["c"].y - lineShapes.positions["pointLabels"]["a"].y) / 2 + lineShapes.positions["pointLabels"]["a"].y,
            text: ACFib
        }).show();
    }

    if (CDVal > 0 && BCVal > 0) {
        BDFib = infChart.drawingUtils.common.formatValue(CDVal / BCVal, 3);

        additionalDrawingsArr.labels["BDFib"].attr({
            x: (lineShapes.positions["pointLabels"]["d"].x - lineShapes.positions["pointLabels"]["b"].x) / 2 + lineShapes.positions["pointLabels"]["b"].x,
            y: (lineShapes.positions["pointLabels"]["d"].y - lineShapes.positions["pointLabels"]["b"].y) / 2 + lineShapes.positions["pointLabels"]["b"].y,
            text: BDFib
        }).show();
    }
    infChart.drawingUtils.common.saveBaseYValues.call(self, ann.options.yValue, ann.options.yValueEnd, undefined, ann.options.intermediatePoints);
};

infChart.abcdPatternDrawing.prototype.scaleSelectionMarkers = function (lineShapes) {
    var self = this;
    var additionalDrawingsArr = self.additionalDrawings;
    var clipPosX = lineShapes.positions.axisClips.x;
    var clipPosY = lineShapes.positions.axisClips.y;
    additionalDrawingsArr.rect.x && additionalDrawingsArr.rect.x.attr({
        x: clipPosX.x,
        y: clipPosX.y,
        width: clipPosX.w,
        height: clipPosX.h
    });
    additionalDrawingsArr.rect.y && additionalDrawingsArr.rect.y.attr({
        x: clipPosY.x,
        y: clipPosY.y,
        width: clipPosY.w,
        height: clipPosY.h
    });
};

infChart.abcdPatternDrawing.prototype.select = function () { };

infChart.abcdPatternDrawing.prototype.selectAndBindResize = function () {
    var self = this,
        ann = self.annotation;
    ann.events.deselect.call(ann);
    ann.selectionMarker = [];
    self.setSelectionMarkers();
};

infChart.abcdPatternDrawing.prototype.setSelectionMarkers = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];
    var lineShapes = self.getPatternShapes();
    var additionalDrawingsArr = self.additionalDrawings;
    var startX = xAxis.toPixels(options.xValue);
    var futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];

    if (!ann.selectionMarker.length) {
        if(startX > 0){
            infChart.util.forEach(["a", "b", "c", "d"], function (index, value) {
                var circlePosition = lineShapes.positions["circles"][value];
                if (circlePosition && circlePosition.x != undefined && circlePosition.y != undefined) {
                    additionalDrawingsArr.circles[value] = infChart.drawingUtils.common.addAndBindSelectionMarker.call(self, ann, circlePosition.x, circlePosition.y, self.stepFunction, self.stop, true, undefined, { name: value });
                }
            });
        } else {
            var selectionMarkerPoints = self.getSelectionMarkerPositionFromDrawing();
            infChart.util.forEach(["a", "b", "c", "d"], function (index, value) {
                var circlePosition = lineShapes.positions["circles"][value];
                var selectionMarkerPosition = selectionMarkerPoints[value];
                if (circlePosition && selectionMarkerPosition && circlePosition.y != undefined) {
                    additionalDrawingsArr.circles[value] = infChart.drawingUtils.common.addAndBindSelectionMarker.call(self, ann, selectionMarkerPosition, circlePosition.y, self.stepFunction, self.stop, true, undefined, { name: value });
                }
            });
        }

        var clipPosX = lineShapes.positions.axisClips.x;
        var clipPosY = lineShapes.positions.axisClips.y;
        if (clipPosY && !additionalDrawingsArr.rect.y && clipPosX && !additionalDrawingsArr.rect.x) {
            ann.selectionMarker.push(additionalDrawingsArr.rect.x);
            ann.selectionMarker.push(additionalDrawingsArr.rect.y);
        }

    }
};

infChart.abcdPatternDrawing.prototype.getSelectionMarkerPositionFromDrawing = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        shape = ann.shape.d.split(' ');

    return {
        a: shape[1],
        b: shape[4],
        c: shape[7],
        d: shape[10]
    }
};

/**
* Step function
* @param {Event} e event
* @param {boolean} isStartPoint indicate whether the start or not
*/
infChart.abcdPatternDrawing.prototype.step = function (e, isStartPoint, itemProperties) {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        pointx = xAxis.toValue(e.chartX),
        pointy = yAxis.toValue(e.chartY),
        intermediatePoints = options.intermediatePoints,
        newOtions = {};
    switch (itemProperties.name) {
        case 'b':
            if (!intermediatePoints[0]) {
                intermediatePoints[0] = {};
            }
            intermediatePoints[0].xValue = pointx;
            intermediatePoints[0].yValue = pointy;
            break;
        case 'c':
            if (!intermediatePoints[1]) {
                intermediatePoints[1] = {};
            }
            intermediatePoints[1].xValue = pointx;
            intermediatePoints[1].yValue = pointy;
            break;
        case 'd':
            newOtions.xValueEnd = pointx;
            newOtions.yValueEnd = pointy;
            break;
        case 'a':
            newOtions.xValue = pointx;
            newOtions.yValue = pointy;
            break;
        default:
            break;
    }
    newOtions.intermediatePoints = intermediatePoints;
    ann.update(newOtions);
    this.finalizeEachPoint();
};

/**
 * Stop function
 * @param {Event} e event
 * @param {boolean} isStartPoint indicate whether the start or not
 */
infChart.abcdPatternDrawing.prototype.stop = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        lineShapes = self.getPatternShapes(),
        additionalDrawingsArr = self.additionalDrawings;

    // point Labels
    if (!additionalDrawingsArr.labels["dLabel"]) {
        var labelPosition = lineShapes.positions["pointLabels"]["d"];
        labelPosition && (additionalDrawingsArr.labels["dLabel"] = self.getLabel(labelPosition.label, labelPosition.x, labelPosition.y));
    }

    infChart.drawingUtils.common.saveBaseYValues.call(self, ann.options.yValue, ann.options.yValueEnd, undefined, ann.options.intermediatePoints);
    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
};

infChart.abcdPatternDrawing.prototype.translateEnd = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis];
    var futureValue = chart.series[0].xData[chart.series[0].xData.length - 1];
    if(futureValue < options.xValue || futureValue < options.xValueEnd || futureValue < options.intermediatePoints[0].xValue || futureValue < options.intermediatePoints[1].xValue || (futureValue < options.xValueStore) || (futureValue < options.xValueEndStore) || (futureValue < options.intermediatePointsStore[0].xValue) || (futureValue < options.intermediatePointsStore[1].xValue)){
        var shape = self.annotation.shape.d.split(' ');
        var firstIntermediate = shape[4];
        var secondIntermediate = shape[7];
        var xEnd = shape[10];
        var firstIntermediateXValue = xAxis.toValue(parseFloat(firstIntermediate) + xAxis.toPixels(options.xValue));
        var secondIntermediateXValue = xAxis.toValue(parseFloat(secondIntermediate) + xAxis.toPixels(options.xValue));
        var xValueEnd = xAxis.toValue(parseFloat(xEnd) + xAxis.toPixels(options.xValue));
        options.intermediatePoints[0].xValue = firstIntermediateXValue;
        options.intermediatePoints[1].xValue = secondIntermediateXValue;
        ann.update({
            intermediatePoints: options.intermediatePoints,
            xValueEnd: xValueEnd
        });
    }
    self.selectAndBindResize();
    self.scale();
};

infChart.abcdPatternDrawing.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updateAbcdSettings(this.settingsPopup, properties.borderColor, properties.strokeWidth, properties.textColor, properties.textFontSize);
};
window.infChart = window.infChart || {};

infChart.elliotWaveDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
};

infChart.elliotWaveDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.elliotWaveDrawing.prototype.afterRedrawXAxisWithoutSetExtremes = function () { };


infChart.elliotWaveDrawing.prototype.onChangeSnapToHighLow = function (checked, isPropertyChange) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart;

    options.isSnapTopHighLow = checked;
    if (options.isSnapTopHighLow) {
        var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true);
        options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, 
            this.getNearestYValue(options.yValue, nearestDataForXValue, chart, options.isSnapTopHighLow));
        var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true);
        options.nearestYValueEnd =infChart.drawingUtils.common.getYValue.call(this, 
            this.getNearestYValue(options.yValueEnd, nearestDataForXValueEnd, chart, options.isSnapTopHighLow));
        options.nearestYValue = options.yValue;
        options.nearestXValueEnd = nearestDataForXValueEnd.xData;
    }

    var line = self.getBasePatternLine(true);

    ann.update({
        shape: {
            params: {
                d: line
            }
        }
    });

    self.scale(true);
    self.selectAndBindResize();
    chart.selectedAnnotation = ann;
    isPropertyChange && self.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
};

infChart.elliotWaveDrawing.prototype.bindSettingsEvents = function () {
    var onChangeSnapToHighLow = function (checked, isPropertyChange) {
        self.onChangeSnapToHighLow.call(self, checked, isPropertyChange);
    };
    infChart.drawingUtils.common.bindElliotWaveSettingsEvents.call(this,onChangeSnapToHighLow);
};

infChart.elliotWaveDrawing.prototype.beforeDestroy = function () {
    var self = this,
        ann = self.annotation;

    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId);
};

infChart.elliotWaveDrawing.prototype.deselect = function () {
    this.annotation.selectionMarker = [];
    this.additionalDrawings.circles = {};
    this.additionalDrawings.labels["oLabel"].hide();
    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(this.annotation.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId, true);
};

/**
* Returns the maximum offset of the axis labels
* @param {Highstock.Axis} axis axis object
* @returns {number} max width
*/
infChart.elliotWaveDrawing.prototype.getAxisOffset = function (axis) {
    return 0;
};

/**
* Returns the base line's path
* @returns Array path to draw base line
*/
infChart.elliotWaveDrawing.prototype.getBasePatternLine = function (updateNearestValues) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        x = xAxis.toPixels(options.xValue),
        y = yAxis.toPixels(options.yValue);
        if(updateNearestValues){
            var futureValue = chart.series[0].xData[chart.series[0].xData.length-1];
            var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
            if(futureValue >= nearestDataForXValue.xData){
                options.nearestXValue = nearestDataForXValue.xData;
                var nearestYPoint = self.getNearestYValue(options.yValue, nearestDataForXValue, undefined , options.isSnapTopHighLow);
                options.nearestYValue = nearestYPoint.nearestYValue;
                options.startTopOfthePoint = nearestYPoint.topOfThePoint;
            } else {
                options.nearestXValue = nearestDataForXValue.xData;
                options.nearestYValue = options.yValue;
                options.startTopOfthePoint = true;
            }
        }
        var newX = xAxis.toPixels(options.nearestXValue) - x;
        var newY = yAxis.toPixels(options.nearestYValue) - y;
        line = ['M', newX, newY];

    infChart.util.forEach(options.intermediatePoints, function (index, value) {
        line.push('L');
        if(updateNearestValues){
            var futureValue = chart.series[0].xData[chart.series[0].xData.length-1];
            var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, value.xValue, undefined, true, true);
            if(futureValue >= nearestDataForXValue.xData){
                var nearestYInterPoint = self.getNearestYValue(value.yValue, nearestDataForXValue, undefined , options.isSnapTopHighLow);
                var nearestYValue = nearestYInterPoint.nearestYValue;
                var topOfThePoint = nearestYInterPoint.topOfThePoint;
                options.nearestIntermediatePoints[index] = {xValue: nearestDataForXValue.xData, yValue: nearestYValue, topOfThePoint: topOfThePoint};
            } else {
                options.nearestIntermediatePoints[index] = {xValue: nearestDataForXValue.xData, yValue: value.yValue, topOfThePoint: true};
            }
        }
        line.push(xAxis.toPixels(options.nearestIntermediatePoints[index].xValue) - x);
        line.push(yAxis.toPixels(options.nearestIntermediatePoints[index].yValue) - y);
    });

    if (options.xValueEnd) {
        line.push('L');
        if(updateNearestValues){
            var futureValue = chart.series[0].xData[chart.series[0].xData.length-1];
            var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);
            if(futureValue >= nearestDataForXValueEnd.xData){
                options.nearestXValueEnd = nearestDataForXValueEnd.xData;
                var nearestYEndPoint = self.getNearestYValue(options.yValueEnd, nearestDataForXValueEnd, undefined , options.isSnapTopHighLow);
                options.nearestYValueEnd = nearestYEndPoint.nearestYValue;
                options.endTopOfthePoint = nearestYEndPoint.topOfThePoint;
            } else {
                options.nearestXValueEnd = nearestDataForXValueEnd.xData;
                options.nearestYValueEnd = options.yValueEnd;
                options.endTopOfthePoint = true;
            }
        }
        line.push(xAxis.toPixels(options.nearestXValueEnd) - x);
        line.push(yAxis.toPixels(options.nearestYValueEnd) - y);
    }
    return line;
};

infChart.elliotWaveDrawing.prototype.getInfoLabel = function (name, x, y) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        theme = infChart.drawingUtils.common.getTheme(),
        shapeTheme = theme["elliotWave"];;
    var basicText = "";
    basicText = basicText !== "" ? '<br>' : '--';
    var label = chart.renderer.label('--', x, y).attr({
        'zIndex': 30,
        'r': 3,
        'opacity': shapeTheme && shapeTheme.label && shapeTheme.label.opacity || 1,
        'stroke': shapeTheme && shapeTheme.label && shapeTheme.label.stroke || "#858587",
        'stroke-width': 0,
        'hAlign': 'center',
        'class': 'line-lbl',
        'fill': shapeTheme && shapeTheme.label && shapeTheme.label.fill || "#858587",
        'padding': 5,
        'min-width' : 80
    }).css({
        color: shapeTheme && shapeTheme.label && shapeTheme.label.fontColor || "#fff",
        fontSize: '12px',
        cursor: 'move',
        fontWeight: '700',
        fontStyle: 'normal',
        textDecoration: 'inherit'
    }).add(ann.group).hide();
    return label;
};

infChart.elliotWaveDrawing.prototype.getLabelFormattedXValue = function (value, axis) {
    var interval = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(this.chart.renderTo.id)).interval;
    var format = axis.options.dateTimeLabelFormats.day + " " + axis.options.dateTimeLabelFormats.minute;
    if (interval === 'D' || interval === 'W' || interval === 'M' || interval === 'Y') {
        format = axis.options.dateTimeLabelFormats.day;
    }
    return infChart.util.formatDate(value, format);
};

/**
 * Returns the formatted label
 * @param {number} yValue actual value
 * @param {number} optionsyValue value in the options
 * @returns {string} formatted value to be set
 */
 infChart.elliotWaveDrawing.prototype.getLabelFormattedYValue = function (yValue, optionsyValue) {
    var stockChart = this.stockChart;
    var value;
    if (stockChart.isPercent) {
        value = stockChart.getYLabel(optionsyValue, true, false, false);
    } else {
        value = stockChart.formatValue(yValue, stockChart.getMainSeries().options.dp);
    }
    return value;
};

/**
* Returns the the drawing options from saved|initial properties
* @param {object} properties drawing properties
* @returns {{name: *, indicatorId: *, utilizeAxes: string, xValue: *, yValue: *, xValueEnd: *, yValueEnd: *, intermediatePoints: Array, allowDragY: boolean, shape: {params: {fill: string, d: *[]}}, isIndicator: boolean, drawingType: string, allowDragX: boolean}} options to set
*/
infChart.elliotWaveDrawing.prototype.getOptions = function (properties, chart) {
    var self = this;
    var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, properties.xValue, undefined, true, true);
    var futureValue = chart.series[0].xData[chart.series[0].xData.length-1];
    var options = {
        name: properties.name,
        xValue: properties.xValue,
        yValue: properties.yValue,
        xValueEnd: properties.xValueEnd,
        yValueEnd: properties.yValueEnd,
        nearestXValue: nearestDataForXValue.xData,
        allowDragX: false,
        allowDragY: false,
        allowDragByHandle: true,
        intermediatePoints: [],
        nearestIntermediatePoints: [],
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0]
            }
        }
    };

    var nearestStartValues = {};
    if(futureValue >= nearestDataForXValue.xData){
        nearestStartValues = this.getNearestYValue(properties.yValue, nearestDataForXValue, chart , options.isSnapTopHighLow);
    } else {
        nearestStartValues.nearestYValue = properties.yValue;
        nearestStartValues.topOfThePoint = true;
    }
    options.nearestYValue = infChart.drawingUtils.common.getYValue.call(this, nearestStartValues.nearestYValue);
    options.startTopOfthePoint = nearestStartValues.topOfThePoint;

    if (properties.xValueEnd && properties.yValueEnd) {
        var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, properties.xValueEnd, undefined, true, true);
        var nearestEndValues =  {};
        if(futureValue >= nearestDataForXValue.xData){
            var nearestEndValues = this.getNearestYValue(properties.yValueEnd, nearestDataForXValueEnd, chart , options.isSnapTopHighLow);
        } else {
            nearestEndValues.nearestYValue = properties.yValueEnd;
            nearestEndValues.topOfThePoint = true;
        }
        options.nearestXValueEnd = nearestDataForXValueEnd.xData;
        options.nearestYValueEnd = infChart.drawingUtils.common.getYValue.call(this, nearestEndValues.nearestYValue);
        options.endTopOfthePoint = nearestEndValues.topOfThePoint;
    }

    options.shape.params["fill-opacity"] = 0;

    if (properties.currentWaveDegree) {
        options.currentWaveDegree = properties.currentWaveDegree;
    } else {
        options.currentWaveDegree = this.currentWaveDegree;
    }

    if (properties.borderColor || properties.color) {
        options.shape.params.stroke = properties.color || properties.borderColor;
    }else{
        var waveDegreeSelected;
        this.waveDegrees.forEach(function(value, index){
            if(value.name === options.currentWaveDegree){
                waveDegreeSelected = value;
            }
        });
        options.shape.params.stroke = waveDegreeSelected.color;
    }

    if (properties.strokeWidth) {
        options.shape.params['stroke-width'] = properties.strokeWidth;
    }

    if (properties.intermediatePoints) {
        infChart.util.forEach(properties.intermediatePoints, function(index , value){
            options.intermediatePoints.push({
                xValue: value.xValue,
                yValue: value.yValue,
                topOfThePoint: value.topOfThePoint
            });
        });
    }

    if (properties.intermediatePoints) {
        infChart.util.forEach(properties.intermediatePoints, function(index , value){
            var nearestDataForIntermediateValue = infChart.math.findNearestDataPoint(chart, value.xValue, undefined, true, true);
            options.nearestIntermediatePoints.push({
                xValue: nearestDataForIntermediateValue.xData,
                yValue: infChart.drawingUtils.common.getYValue.call(self, self.getNearestYValue(value.yValue, nearestDataForIntermediateValue, chart , options.isSnapTopHighLow).nearestYValue),
                topOfThePoint: value.topOfThePoint
            });
        });
    }

    if (properties.completedSteps) {
        options.completedSteps = properties.completedSteps;
    }

    options.textFontSize = properties.textFontSize ? properties.textFontSize : 16;

    options.isRealTimeTranslation = true; // since label value is needed to be changed
    options.isSnapTopHighLow = typeof properties.isSnapTopHighLow !== "undefined" ? properties.isSnapTopHighLow : false;

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.elliotWaveDrawing.prototype.getQuickSettingsPopup = function () {
    var common = infChart.drawingUtils.common;
    return infChart.structureManager.drawingTools.getElliotWaveQuickSettings(common.baseBorderColor);
};

infChart.elliotWaveDrawing.prototype.onclick = function () {
    infChart.drawingUtils.common.getAxisLabelToFront.call(this, this.additionalDrawings.axisLabels["xLabel_x"]);
};

infChart.elliotWaveDrawing.prototype.scaleSelectionMarkers = function (lineShapes) {
    var self = this;
    var additionalDrawingsArr = self.additionalDrawings;
    var clipPosX = lineShapes.positions.axisClips.x;
    var clipPosY = lineShapes.positions.axisClips.y;
    additionalDrawingsArr.rect.x && additionalDrawingsArr.rect.x.attr({
        x: clipPosX.x,
        y: clipPosX.y,
        width: clipPosX.w,
        height: clipPosX.h
    });
    additionalDrawingsArr.rect.y && additionalDrawingsArr.rect.y.attr({
        x: clipPosY.x,
        y: clipPosY.y,
        width: clipPosY.w,
        height: clipPosY.h
    });
};

infChart.elliotWaveDrawing.prototype.select = function () {
    this.additionalDrawings.labels["oLabel"].show();
    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(this.annotation.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId, true);
 };

infChart.elliotWaveDrawing.prototype.selectAndBindResize = function () {
    this.setSelectionMarkers();
};

infChart.elliotWaveDrawing.prototype.translate = function () {
    this.scaleSelectionMarkers(this.getPatternShapes());
};

infChart.elliotWaveDrawing.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updateElliotWaveSettings(this.settingsPopup, properties.borderColor, properties.strokeWidth, properties.currentWaveDegree,properties.isSnapTopHighLow, properties.textFontSize);
};

infChart.elliotWaveDrawing.prototype.getNearestYValue = function (yValue, nearestDataPoint, chart, isSnapTopHighLow) {
    var self = this,
        ann = self.annotation;

    if(ann){
        chart = ann.chart;
    }
    var nearestYValue = yValue;
    var topOfThePoint = true;

    if (isSnapTopHighLow) {
      var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart);
      var chartInstance = infChart.manager.getChart(stockChartId);

      var nearestYValueOpen, nearestYValueClose;
      if (chartInstance.isLog || chartInstance.isCompare) {
        nearestYValueOpen = infChart.drawingUtils.common.getYValue.call(self, nearestDataPoint.yData[1]);
        nearestYValueClose = infChart.drawingUtils.common.getYValue.call(self, nearestDataPoint.yData[2]);
      } else {
        nearestYValueOpen = nearestDataPoint.yData[1];
        nearestYValueClose = nearestDataPoint.yData[2];
      }
      var topOfThePoint;
      if (yValue) {
        if (Math.abs(yValue - nearestYValueOpen) < Math.abs(yValue - nearestYValueClose)) {
          topOfThePoint = true;
          nearestYValue = nearestYValueOpen;
        } else {
          topOfThePoint = false;
          nearestYValue = nearestYValueClose;
        }
      }
    }
    return {nearestYValue : nearestYValue, topOfThePoint: topOfThePoint};
}; 

infChart.elliotWaveDrawing.prototype.getIntermediatePointsSnappedValues = function(updateNearestValues){
    var self = this,
        ann = self.annotation,    
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis];
        yAxis = chart.yAxis[options.yAxis];
        intermediatePoints = options.intermediatePoints;

    var x = xAxis.toPixels(options.xValue);
    var y = yAxis.toPixels(options.yValue);
    var intermideate = [];
    
    if(intermediatePoints){
        infChart.util.forEach(options.intermediatePoints, function (index, value) {
            if(intermediatePoints[index]){
                if(updateNearestValues){
                    var futureValue = chart.series[0].xData[chart.series[0].xData.length-1];
                    var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, intermediatePoints[index].xValue, undefined, true, true);
                    if(futureValue >= nearestDataForXValue.xData){
                        var nearestYInterPoints = self.getNearestYValue(intermediatePoints[index].yValue, nearestDataForXValue, undefined, options.isSnapTopHighLow);
                        options.nearestIntermediatePoints[index] = {xValue: nearestDataForXValue.xData, yValue: nearestYInterPoints.nearestYValue, topOfThePoint: nearestYInterPoints.topOfThePoint}
                    } else {
                        options.nearestIntermediatePoints[index] = {xValue: nearestDataForXValue.xData, yValue: intermediatePoints[index].yValue, topOfThePoint: true}
                    }
                }
                var newX = xAxis.toPixels(options.nearestIntermediatePoints[index].xValue) - x;
                var newY = yAxis.toPixels(options.nearestIntermediatePoints[index].yValue) - y;
                intermideate.push({x: newX, y: newY, xValue: options.nearestIntermediatePoints[index].xValue, yValue: options.nearestIntermediatePoints[index].yValue, topOfThePoint: options.nearestIntermediatePoints[index].topOfThePoint});
            }
        });
    }

    return intermideate;
};

infChart.elliotWaveDrawing.prototype.getLabelData = function (annotation, calculatedLabelData) {
    self = this;
    var labelHtml = '<div style = "display: grid; grid-row-gap: 5px; padding: 5px">';
    var options = annotation.options;
    var islabelItemAvailable = false;
    $.each(self.labelDataItems, function (index, labelDataItem) {
        switch (labelDataItem.id) {
            case 'price': {
                if(calculatedLabelData.price !== undefined){
                    labelHtml = labelHtml +
                        '<span class="drawing-lbl-box__label" style="color: #ffffff !important; font-weight: 500 !important">' + calculatedLabelData.price.toFixed(2) + '</span></span><br>';
                    islabelItemAvailable = true;
                }
            }
                break;
            case 'type': {
                if(calculatedLabelData.type !== undefined){
                    labelHtml = labelHtml +
                        '<span class="drawing-lbl-box__label" style="color: #ffffff !important; font-weight: 500 !important">' + calculatedLabelData.type + '</span></span><br>';
                    islabelItemAvailable = true;
                }
            }
                break;
            case 'priceDifference': {
                if(calculatedLabelData.priceDifference !== undefined){
                    labelHtml = labelHtml +
                        '<span class="drawing-lbl-box__label" style="color: #ffffff !important; font-weight: 500 !important">' + calculatedLabelData.priceDifference.toFixed(2) + '</span></span><span class="drawing-lbl-box__label" style="color: #ffffff !important; font-weight: 500 !important">, [' + calculatedLabelData.pricePercentage.toFixed(2) +'%]</span></span><br>';
                    islabelItemAvailable = true;
                }else{
                    labelHtml = labelHtml +
                    '<span class="drawing-lbl-box__label" style="color: #ffffff !important; font-weight: 500 !important">' + 'Starting Point' + '</span></span><br>';
                    islabelItemAvailable = true; 
                }
            }
                break;
            case 'waveDegree': {
                if(calculatedLabelData.waveDegree !== undefined){
                    labelHtml = labelHtml +
                        '<span class="drawing-lbl-box__label" style="color: #ffffff !important; font-weight: 500 !important">' + calculatedLabelData.waveDegree + '</span></span><br>';
                    islabelItemAvailable = true;
                }
            }
                break;
        }
    });

    labelHtml = labelHtml + "</div>";

    if (!islabelItemAvailable) {
        labelHtml = null;
    }

    return labelHtml;
}

infChart.elliotWaveDrawing.prototype.getSnappedValues = function (){
    var self = this,
        ann = self.annotation,    
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis];
        yAxis = chart.yAxis[options.yAxis];
        intermediatePoints = options.intermediatePoints;
        var snappedPoints = [];

    var futureValue = chart.series[0].xData[chart.series[0].xData.length-1];
    if(options.xValue && options.yValue){
        var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true);
        var xValue, yValue;
        if(futureValue >= nearestDataForXValue.xData){
            xValue = nearestDataForXValue.xData;
            yValue = self.getNearestYValue(options.yValue, nearestDataForXValue, undefined , options.isSnapTopHighLow).nearestYValue;
        } else {
            xValue = nearestDataForXValue.xData;
            yValue = options.yValue;
        }
        snappedPoints.push({xValue: xValue, yValue: yValue});
    }
    
    if(intermediatePoints){
        infChart.util.forEach(options.intermediatePoints, function (index, value) {
            if(intermediatePoints[index]){
                var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, intermediatePoints[index].xValue, undefined, true);
                if(futureValue >= nearestDataForXValue.xData){
                    var intermediateXValue = nearestDataForXValue.xData;
                    var intermediateYValue = self.getNearestYValue(intermediatePoints[index].yValue, nearestDataForXValue, undefined , options.isSnapTopHighLow).nearestYValue;
                } else {
                    var intermediateXValue = nearestDataForXValue.xData;
                    var intermediateYValue = intermediatePoints[index].yValue;
                }
                snappedPoints.push({xValue: intermediateXValue, yValue: intermediateYValue});
            }
        });
    }

    if(options.xValueEnd && options.yValueEnd){
        var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true);
        if(futureValue >= nearestDataForXValueEnd.xData){
            var xValueEnd = nearestDataForXValueEnd.xData;
            var yValueEnd = self.getNearestYValue(options.yValueEnd, nearestDataForXValueEnd, undefined , options.isSnapTopHighLow).nearestYValue;
        } else {
            var xValueEnd = nearestDataForXValueEnd.xData;
            var yValueEnd = options.yValueEnd;
        }
        snappedPoints.push({xValue: xValueEnd, yValue: yValueEnd});
    }

    return snappedPoints;
};

infChart.elliotWaveDrawing.prototype.setNearestYValues = function(options, chart){
    var self = this;

    var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true);
    self.nearestYValue = self.getNearestYValue(options.yValue, nearestDataForXValue, chart, options.isSnapTopHighLow);

    var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true);
    self.nearestYValueEnd = self.getNearestYValue(options.yValueEnd, nearestDataForXValueEnd, chart , options.isSnapTopHighLow);
};
window.infChart = window.infChart || {};

infChart.elliotTriangleWaveDrawing = function () {
    this.labelDataItems = [
        {id: "price", displayName: "Price", enabled: true},
        {id: "type", displayName: "Type", enabled: true},
        {id: "priceDifference", displayName: "Price Difference", enabled: true},
        {id: "waveDegree", displayName: "Wave Degree", enabled: true}
    ];
    this.waveDegrees = [
        {
            id: "Super Millennium",
            name: "superMillennium",
            label: "label.superMillennium", 
            color: "#78BC61",
            enable: false,
            options:["O", "(((A)))", "(((B)))", "(((C)))", "(((D)))", "(((E)))" ]
        },
        {
            id: "Millennium", 
            name: "millennium",
            label: "label.millennium",
            color: "#EF6351",
            enable: false,
            options:["O", "((A))", "((B))", "((C))", "((D))", "((E))" ]
        },
        {
            id: "Sub Millennium", 
            name: "subMillennium",
            label: "label.subMillennium",
            color: "#3066BE",
            enable: false,
            options:["O", "(A)", "(B)", "(C)", "(D)", "(E)" ]
        },
        {
            id: "Grand Super Cycle", 
            name: "grandSuperCycle",
            label: "label.grandSuperCycle",
            color: "#F93943", 
            enable: false,
            options:["O", "(((a)))", "(((b)))", "(((c)))", "(((d)))", "(((e)))" ]
        },
        {
            id: "Super Cycle", 
            name: "superCycle",
            label: "label.superCycle",
            color: "#7E78D2", 
            enable: false,
            options:["O", "((a))", "((b))", "((c))", "((d))", "((e))" ]
        },
        {
            id: "Cycle", 
            name: "cycle",
            label: "label.cycle",
            color: "#D65780", 
            enable: false,
            options:["O", "(a)", "(b)", "(c)", "(d)", "(e)" ]
        },
        {
            id: "Primary",
            name: "primary",
            label: "label.primary",
            color: "#6C809A", 
            enable: false,
            options:["O", "{{{A}}}", "{{{B}}}", "{{{C}}}", "{{{D}}}", "{{{E}}}" ]
        },
        {
            id: "Intermediate", 
            name: "intermediate",
            label: "label.intermediate",
            color: "#58A4B0", 
            enable: false,
            options:["O", "{{A}}", "{{B}}", "{{C}}", "{{D}}", "{{E}}" ]
        },
        {
            id: "Minor", 
            name: "minor",
            label: "label.minor",
            color: "#5E8C61",
            enable: false, 
            options:["O", "{A}", "{B}", "{C}", "{D}", "{E}" ]
        },
        {
            id: "Minute", 
            name: "minute",
            label: "label.minute",
            color: "#C89933", 
            enable: false,
            options:["O", "{{{a}}}", "{{{b}}}", "{{{c}}}", "{{{d}}}", "{{{e}}}" ]
        },
        {
            id: "Minuette", 
            name: "minuette",
            label: "label.minuette",
            color: "#00A7E1", 
            enable: false,
            options:["O", "{{a}}", "{{b}}", "{{c}}", "{{d}}", "{{e}}" ]
        },
        {
            id: "Sub Minuette", 
            name: "subMinuette",
            label: "label.subMinuette",
            color: "#912F56", 
            enable: false,
            options:["O", "{a}", "{b}", "{c}", "{d}", "{e}" ]
        },
        {
            id: "Micro", 
            name: "micro",
            label: "label.micro",
            color: "#9D75CB", 
            enable: true,
            options:["O", "[[[A]]]", "[[[B]]]", "[[[C]]]", "[[[D]]]", "[[[E]]]" ]
        },
        {
            id: "Sub Micro", 
            name: "subMicro",
            label: "label.subMicro",
            color: "#FE7B72",
            enable: false, 
            options:["O", "[[A]]", "[[B]]", "[[C]]", "[[D]]", "[[E]]" ]
        },
        {
            id: "Nano", 
            name: "nano",
            label: "label.nano",
            color: "#8D818C", 
            enable: false,
            options:["O", "[A]", "[B]", "[C]", "[D]", "[E]" ]
        },
        {
            id: "Sub Nano",
            name: "subNano",
            label: "label.subNano", 
            color: "#387D7A", 
            enable: false,
            options:["O", "A", "B", "C", "D", "E" ]
        }
    ]
    this.labelValueNames = ["oLabel", "aLabel", "bLabel", "cLabel", "dLabel", "eLabel"];
    this.type = "Triangle";
    this.currentWaveDegree = "micro";
    infChart.elliotWaveDrawing.apply(this, arguments);
};

infChart.elliotTriangleWaveDrawing.prototype = Object.create(infChart.elliotWaveDrawing.prototype);

/**
* set additional drawings of the tool
*/
infChart.elliotTriangleWaveDrawing.prototype.additionalDrawingsFunction = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        yAxis = chart.yAxis[options.yAxis],
        lineShapes = self.getPatternShapes(true),
        additionalDrawingsArr = self.additionalDrawings,
        theme = infChart.drawingUtils.common.getTheme(),
        pointNamesArr = ["o", "a", "b", "c", "d", "e"];

    additionalDrawingsArr.lines = {};
    additionalDrawingsArr.labels = {};
    additionalDrawingsArr.circles = {};
    additionalDrawingsArr.axisLabels = {};
    additionalDrawingsArr.rect = {};
    additionalDrawingsArr.infoLabels = {};

    ann.selectionMarker = [];
    self.setSelectionMarkers();

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        labelPosition && (additionalDrawingsArr.infoLabels[value + "Label"] = self.getInfoLabel(labelPosition.label, labelPosition.x, labelPosition.y));
    });

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        labelPosition && (additionalDrawingsArr.labels[value + "Label"] = self.getLabel(labelPosition.label, labelPosition.x, labelPosition.y));
        label = additionalDrawingsArr.labels[value + "Label"];
        if(label){
            label.attr({x: labelPosition.x - label.width/2});
        }
    });
};

infChart.elliotTriangleWaveDrawing.prototype.getClickValues = function (clickX, clickY) {
    var ann = this.annotation;
    var chart = ann.chart;
    var options = ann.options;
    var xAxis = chart.xAxis[options.xAxis];
    var yAxis = chart.yAxis[options.yAxis];
    var completedSteps = this.annotation.options.completedSteps;
    var coordinates = {
        xValue: options.xValue,
        yValue: options.yValue,
        intermediatePoints: options.intermediatePoints
    };
    switch (completedSteps) {
        case 1:
            coordinates.intermediatePoints[0].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[0].yValue = yAxis.toValue(clickY);
            break;
        case 2:
            coordinates.intermediatePoints[1].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[1].yValue = yAxis.toValue(clickY);
            break;
        case 3:
            coordinates.intermediatePoints[2].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[2].yValue = yAxis.toValue(clickY);
            break;
        case 4:
            coordinates.intermediatePoints[3].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[3].yValue = yAxis.toValue(clickY);
            break;
        case 5:
            coordinates.xValueEnd = xAxis.toValue(clickX);
            coordinates.yValueEnd = yAxis.toValue(clickY);
            break;
    }
    return coordinates;
};

/**
* Returns the config to save
* @returns {{shape: string, borderColor: *, strokeWidth: *, xValue: *, yValue: *, xValueEnd: *, yValueEnd: *, intermediatePoints: Array}} config object
*/
infChart.elliotTriangleWaveDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    var intermediatePoints = [];

    infChart.util.forEach(annotation.options.intermediatePoints, function(index , value){
        intermediatePoints.push({
            xValue: value.xValue,
            yValue: value.yValue
        });
    });

    return {
        shape: 'elliotTriangleWave',
        borderColor: annotation.options.shape.params.stroke,
        strokeWidth: annotation.options.shape.params['stroke-width'],
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        intermediatePoints: intermediatePoints,
        fillColor: 'none',
        currentWaveDegree: annotation.options.currentWaveDegree,
        nearestXValue: annotation.options.nearestXValue,
        nearestXValueEnd: annotation.options.nearestXValueEnd,
        nearestYValue: annotation.options.nearestYValue,
        nearestYValueEnd: annotation.options.nearestYValueEnd,
        startTopOfthePoint: annotation.options.startTopOfthePoint,
        endTopOfthePoint: annotation.options.endTopOfthePoint,
        nearestIntermediatePoints: annotation.options.nearestIntermediatePoints,
        isSnapTopHighLow: annotation.options.isSnapTopHighLow,
        textFontSize: annotation.options.textFontSize,
    };
};

/**
 * Create a label and add to the group
 * @param {String} name label text
 * @param {number} x x position
 * @param {number} y y position
 * @returns {SVGElement} the generated label
 */
infChart.elliotTriangleWaveDrawing.prototype.getLabel = function (name, x, y) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        theme = infChart.drawingUtils.common.getTheme(),
        shapeTheme = theme["elliotTriangleWave"];
        var currentColor;

        infChart.util.forEach(self.waveDegrees, function(index , value){
            if(self.waveDegrees[index].name === self.currentWaveDegree){
                currentColor = self.waveDegrees[index].color;
            }
        });

    var labelData = chart.renderer.label(name, x, y).attr({
        'zIndex': 20,
        'r': 3,
        'opacity': shapeTheme && shapeTheme.label && shapeTheme.label.opacity || 1,
        'stroke': options.shape.params.stroke ? options.shape.params.stroke : currentColor,//shapeTheme && shapeTheme.label && shapeTheme.label.stroke || "#858587",
        'stroke-width': 0,
        'hAlign': 'center',
        'class': 'harmonic-lbl',
        'rel': name,
    }).add(ann.group).css(
        {
            color: options.shape.params.stroke ? options.shape.params.stroke : currentColor,//shapeTheme && shapeTheme.label && shapeTheme.label.stroke || "#858587",
            fontSize: options.textFontSize || '16px',
            cursor: 'pointer',
            fontWeight: '700',
            fontStyle: 'normal',
            textDecoration: 'inherit'
        });

    $(labelData.element).mouseover(function (event) {
        event.stopPropagation();
        if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
            var rel = event.currentTarget.getAttribute('rel');
            if(rel === "O"){
                self.additionalDrawings.infoLabels.oLabel.show();
            }
            if(rel === "A"|| rel === "(A)"|| rel === "((A))"|| rel === "(((A)))"|| rel === "(a)"|| rel === "((a))"|| rel === "(((a)))" || rel === "[A]"|| rel === "[[A]]"|| rel === "[[[A]]]"|| rel === "{{{A}}}"|| rel === "{{A}}"|| rel === "{A}"|| rel === "{{{a}}}"|| rel === "{{a}}"|| rel === "{a}"){
                self.additionalDrawings.infoLabels.aLabel.show();
            }
            if(rel === "B"|| rel === "(B)"|| rel === "((B))"|| rel === "(((B)))"|| rel === "(b)"|| rel === "((b))"|| rel === "(((b)))" || rel === "[B]"|| rel === "[[B]]"|| rel === "[[[B]]]"|| rel === "{{{B}}}"|| rel === "{{B}}"|| rel === "{B}"|| rel === "{{{b}}}"|| rel === "{{b}}"|| rel === "{b}"){
                self.additionalDrawings.infoLabels.bLabel.show();
            }
            if(rel === "C"|| rel === "(C)"|| rel === "((C))"|| rel === "(((C)))"|| rel === "(c)"|| rel === "((c))"|| rel === "(((c)))" || rel === "[C]"|| rel === "[[C]]"|| rel === "[[[C]]]"|| rel === "{{{C}}}"|| rel === "{{C}}"|| rel === "{C}"|| rel === "{{{c}}}"|| rel === "{{c}}"|| rel === "{c}"){
                self.additionalDrawings.infoLabels.cLabel.show();
            }
            if(rel === "D"|| rel === "(D)"|| rel === "((D))"|| rel === "(((D)))"|| rel === "(d)"|| rel === "((d))"|| rel === "(((d)))" || rel === "[D]"|| rel === "[[D]]"|| rel === "[[[D]]]"|| rel === "{{{D}}}"|| rel === "{{D}}"|| rel === "{D}"|| rel === "{{{d}}}"|| rel === "{{d}}"|| rel === "{d}"){
                self.additionalDrawings.infoLabels.dLabel.show();
            }        
            if(rel === "E"|| rel === "(E)"|| rel === "((E))"|| rel === "(((E)))"|| rel === "(e)"|| rel === "((e))"|| rel === "(((e)))" || rel === "[E]"|| rel === "[[E]]"|| rel === "[[[E]]]"|| rel === "{{{E}}}"|| rel === "{{E}}"|| rel === "{E}"|| rel === "{{{e}}}"|| rel === "{{e}}"|| rel === "{e}"){
                self.additionalDrawings.infoLabels.eLabel.show();
            }
        }
    });

    $(labelData.element).mouseleave(function (event) {
        event.stopPropagation();
        if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
            var rel = event.currentTarget.getAttribute('rel');
            if(rel === "O"){
                self.additionalDrawings.infoLabels.oLabel.hide();
            }
            if(rel === "A"|| rel === "(A)"|| rel === "((A))"|| rel === "(((A)))"|| rel === "(a)"|| rel === "((a))"|| rel === "(((a)))" || rel === "[A]"|| rel === "[[A]]"|| rel === "[[[A]]]"|| rel === "{{{A}}}"|| rel === "{{A}}"|| rel === "{A}"|| rel === "{{{a}}}"|| rel === "{{a}}"|| rel === "{a}"){
                self.additionalDrawings.infoLabels.aLabel.hide();
            }
            if(rel === "B"|| rel === "(B)"|| rel === "((B))"|| rel === "(((B)))"|| rel === "(b)"|| rel === "((b))"|| rel === "(((b)))" || rel === "[B]"|| rel === "[[B]]"|| rel === "[[[B]]]"|| rel === "{{{B}}}"|| rel === "{{B}}"|| rel === "{B}"|| rel === "{{{b}}}"|| rel === "{{b}}"|| rel === "{b}"){
                self.additionalDrawings.infoLabels.bLabel.hide();
            }
            if(rel === "C"|| rel === "(C)"|| rel === "((C))"|| rel === "(((C)))"|| rel === "(c)"|| rel === "((c))"|| rel === "(((c)))" || rel === "[C]"|| rel === "[[C]]"|| rel === "[[[C]]]"|| rel === "{{{C}}}"|| rel === "{{C}}"|| rel === "{C}"|| rel === "{{{c}}}"|| rel === "{{c}}"|| rel === "{c}"){
                self.additionalDrawings.infoLabels.cLabel.hide();
            }
            if(rel === "D"|| rel === "(D)"|| rel === "((D))"|| rel === "(((D)))"|| rel === "(d)"|| rel === "((d))"|| rel === "(((d)))" || rel === "[D]"|| rel === "[[D]]"|| rel === "[[[D]]]"|| rel === "{{{D}}}"|| rel === "{{D}}"|| rel === "{D}"|| rel === "{{{d}}}"|| rel === "{{d}}"|| rel === "{d}"){
                self.additionalDrawings.infoLabels.dLabel.hide();
            }        
            if(rel === "E"|| rel === "(E)"|| rel === "((E))"|| rel === "(((E)))"|| rel === "(e)"|| rel === "((e))"|| rel === "(((e)))" || rel === "[E]"|| rel === "[[E]]"|| rel === "[[[E]]]"|| rel === "{{{E}}}"|| rel === "{{E}}"|| rel === "{E}"|| rel === "{{{e}}}"|| rel === "{{e}}"|| rel === "{e}"){
                self.additionalDrawings.infoLabels.eLabel.hide();
            }
        }
    });
    return labelData;
};

infChart.elliotTriangleWaveDrawing.prototype.getNextPointOptions = function () {
    var ann = this.annotation;
    var completedSteps = ann.options.completedSteps;
    var pointOptions = { name: "o" };
    switch (completedSteps) {
        case 1:
            pointOptions.name = "a";
            break;
        case 2:
            pointOptions.name = "b";
            break;
        case 3:
            pointOptions.name = "c";
            break;
        case 4:
            pointOptions.name = "d";
            break;
        case 5:
            pointOptions.name = "e";
            break;

    }
    return pointOptions;
};

/**
* Returns the paths, values and positions of the shapes under this drawing
* @returns {object} pattern shapes
*/
infChart.elliotTriangleWaveDrawing.prototype.getPatternShapes = function (updateNearestValues) {
    var nameAdditionalY = 25;
    var patternPaths = {};

    var ann = this.annotation;
    var chart = ann.chart;
    var options = ann.options;
    var intermediatePoints = options.intermediatePoints;
    var intermediatePointsRaw = this.intermediatePoints;
    var xAxis = chart.xAxis[options.xAxis];
    var yAxis = chart.yAxis[options.yAxis];

    var waveDegreeSelected;
    this.waveDegrees.forEach(function(value, index){
        if(value.name === options.currentWaveDegree){
            waveDegreeSelected = value;
        }
    });

    var x = xAxis.toPixels(options.xValue);
    var y = yAxis.toPixels(options.yValue);
    var intermediate = this.getIntermediatePointsSnappedValues(updateNearestValues);
    var ax = intermediate && intermediate[0] && intermediate[0].x;
    var ay = intermediate && intermediate[0] && intermediate[0].y;
    var bx = intermediate && intermediate[1] && intermediate[1].x;
    var by = intermediate && intermediate[1] && intermediate[1].y;
    var cx = intermediate && intermediate[2] && intermediate[2].x;
    var cy = intermediate && intermediate[2] && intermediate[2].y;
    var dx = intermediate && intermediate[3] && intermediate[3].x;
    var dy = intermediate && intermediate[3] && intermediate[3].y;

    var futureValue = chart.series[0].xData[chart.series[0].xData.length-1];
    if(updateNearestValues){
        var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);
        if(futureValue >=  nearestDataForXValueEnd.xData){
            options.nearestXValueEnd = nearestDataForXValueEnd.xData;
            var nearestEndValue = this.getNearestYValue(options.yValueEnd, nearestDataForXValueEnd, undefined, options.isSnapTopHighLow);
            options.nearestYValueEnd = nearestEndValue.nearestYValue;
            options.endTopOfthePoint = nearestEndValue.topOfThePoint;
        } else {
            options.nearestXValueEnd = nearestDataForXValueEnd.xData;
            options.nearestYValueEnd = options.yValueEnd;
            options.endTopOfthePoint = true;
        }
    }
    var newXEnd = xAxis.toPixels(options.nearestXValueEnd) - x;
    var newYEnd = yAxis.toPixels(options.nearestYValueEnd) - y;
    var ex = options.xValueEnd && newXEnd;
    var ey = options.yValueEnd && newYEnd;

    if (ex !== undefined) {
        if (y < 0) {
            patternPaths.namePosition = { x: (ex) / 2, y: (ey) / 2 + nameAdditionalY };
        } else {
            patternPaths.namePosition = { x: (x + dx) / 2, y: (y + dy) / 2 + nameAdditionalY };
        }
    }

    if(updateNearestValues){
        var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
        if(futureValue >=  nearestDataForXValue.xData){
            options.nearestXValue = nearestDataForXValue.xData;
            var nearestStartValue = this.getNearestYValue(options.yValue, nearestDataForXValue, undefined, options.isSnapTopHighLow);
            options.nearestYValue = nearestStartValue.nearestYValue;
            options.startTopOfthePoint = nearestStartValue.topOfThePoint;
        } else {
            options.nearestXValue = nearestDataForXValue.xData;
            options.nearestYValue = options.yValue;
            options.startTopOfthePoint = true;
        }
    }
    var newX = xAxis.toPixels(options.nearestXValue) - x;
    var newY = yAxis.toPixels(options.nearestYValue) - y;
    patternPaths.oCirclePosition = { x: newX, y: newY };

    patternPaths.positions = {
        pointLabels: {
            o: { x: newX, y: options.startTopOfthePoint ? -25 + newY : 5 + newY, label: waveDegreeSelected.options[0],  xValue: options.nearestXValue, yValue: options.nearestYValue, topOfThePoint: options.startTopOfthePoint}
        },
        circles: {
            o: { x: newX, y: newY },
            a: { x: ax, y: ay },
            b: { x: bx, y: by },
            c: { x: cx, y: cy },
            d: { x: dx, y: dy },
            e: { x: ex, y: ey }
        }
    };

    patternPaths.positions.axisClips = {};

    patternPaths.values = {
        o: {
            xValue: options.xValue,
            yValue: this.yValue,
            optionXValue: options.xValue,
            optionYValue: options.yValue
        }
    };

    if (ax !== undefined) {
        patternPaths.aCirclePosition = { x: ax, y: ay };
        patternPaths.positions.pointLabels.a = { x: ax, y: intermediate[0].topOfThePoint ? ay - 25 : ay + 5, label: waveDegreeSelected.options[1], xValue: intermediate[0].xValue, yValue: intermediate[0].yValue, topOfThePoint: intermediate[0].topOfThePoint};
        patternPaths.values.a = {
            xValue: intermediatePoints[0].xValue,
            yValue: intermediatePointsRaw[0] ? intermediatePointsRaw[0].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[0].yValue),
            optionXValue: intermediatePoints[0].xValue,
            optionYValue: intermediatePoints[0].yValue
        };

    }

    if (bx !== undefined) {
        patternPaths.bCirclePosition = { x: bx, y: by };
        patternPaths.positions.pointLabels.b = { x: bx, y: intermediate[1].topOfThePoint ? by - 25 : by + 5, label: waveDegreeSelected.options[2], xValue: intermediate[1].xValue, yValue: intermediate[1].yValue, topOfThePoint: intermediate[1].topOfThePoint };
        patternPaths.values.b = {
            xValue: intermediatePoints[1].xValue,
            yValue: intermediatePointsRaw[1] ? intermediatePointsRaw[1].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[1].yValue),
            optionXValue: intermediatePoints[1].xValue,
            optionYValue: intermediatePoints[1].yValue
        };

    }
    if (cx !== undefined) {
        patternPaths.cCirclePosition = { x: cx, y: cy };
        patternPaths.positions.pointLabels.c = { x: cx, y: intermediate[2].topOfThePoint ? cy - 25 : cy + 5, label: waveDegreeSelected.options[3], xValue: intermediate[2].xValue, yValue: intermediate[2].yValue, topOfThePoint: intermediate[2].topOfThePoint };
        patternPaths.values.c = {
            xValue: intermediatePoints[2].xValue,
            yValue: intermediatePointsRaw[2] ? intermediatePointsRaw[2].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[2].yValue),
            optionXValue: intermediatePoints[2].xValue,
            optionYValue: intermediatePoints[2].yValue
        };
    }
    if (dx !== undefined) {
        patternPaths.dCirclePosition = { x: dx, y: dy };
        patternPaths.positions.pointLabels.d = { x: dx, y: intermediate[3].topOfThePoint ? dy - 25 : dy + 5, label: waveDegreeSelected.options[4], xValue: intermediate[3].xValue, yValue: intermediate[3].yValue, topOfThePoint: intermediate[3].topOfThePoint };
        patternPaths.values.d = {
            xValue: intermediatePoints[3].xValue,
            yValue: intermediatePointsRaw[3] ? intermediatePointsRaw[3].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[3].yValue),
            optionXValue: intermediatePoints[3].xValue,
            optionYValue: intermediatePoints[3].yValue
        };

    }
    if (ex !== undefined) {
        patternPaths.eCirclePosition = { x: ex, y: ey };
        patternPaths.positions.pointLabels.e = { x: ex, y: options.endTopOfthePoint ? ey - 25 : ey + 5, label: waveDegreeSelected.options[5], xValue: options.nearestXValueEnd, yValue: options.nearestYValueEnd, topOfThePoint: options.endTopOfthePoint };
        patternPaths.values.e = {
            xValue: options.xValueEnd,
            yValue: this.yValueEnd !== undefined ? this.yValueEnd : infChart.drawingUtils.common.getBaseYValue.call(this, options.yValueEnd),
            optionXValue: options.xValueEnd,
            optionYValue: options.yValueEnd
        };

    }
    return patternPaths;
};

infChart.elliotTriangleWaveDrawing.prototype.getSettingsPopup = function () {
    var common = infChart.drawingUtils.common;
    return infChart.structureManager.drawingTools.getElliotWaveSettings(infChart.manager.getLabel('label.elliotTriangleWave'), common.baseBorderColor, this.annotation.options.currentWaveDegree, this.waveDegrees, this.fontSize);
};

infChart.elliotTriangleWaveDrawing.prototype.finalizeEachPoint = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        line,
        additionalDrawingsArr = self.additionalDrawings,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        pointNamesArr = ["o", "a", "b", "c", "d", "e"];
        var currentColor;

    line = self.getBasePatternLine(true);
    infChart.util.forEach(self.waveDegrees, function(index , value){
        if(self.waveDegrees[index].id === options.currentWaveDegree){
            currentColor = self.waveDegrees[index].color;
        }
    });

    ann.update({
        shape: {
            params: {
                d: line,
                'stroke': options.shape.params.stroke ? options.shape.params.stroke : currentColor,
            }
        }
    });

    var lineShapes = self.getPatternShapes(true);

    lineShapes.namePosition && additionalDrawingsArr.labels["nameLabel"] && additionalDrawingsArr.labels["nameLabel"].attr({
        x: lineShapes.namePosition.x,
        y: lineShapes.namePosition.y
    });
    
    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        var label = additionalDrawingsArr.labels[value + "Label"];
        label && label.attr({ x: labelPosition.x - label.width/2, y: labelPosition.y });

        // circles
        if (additionalDrawingsArr.circles[value]) {
            var circlePositions = lineShapes.positions["circles"][value];
            additionalDrawingsArr.circles[value].attr({ x: circlePositions.x, y: circlePositions.y });
        }
    });
    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId, true);
    if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
        self.getSnappedValues();
        self.calculateAndUpdateInfoLabel(true);
    }
    infChart.drawingUtils.common.saveBaseYValues.call(self, ann.options.yValue, ann.options.yValueEnd, undefined, ann.options.intermediatePoints);
    infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd, ann.options.nearestTrendYValue, ann.options.nearestIntermediatePoints);
};

/**
* Scale function of the tool
*/
infChart.elliotTriangleWaveDrawing.prototype.scale = function (isCalculateNewValueForScale) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        line,
        additionalDrawingsArr = self.additionalDrawings,
        pointNamesArr = ["o", "a", "b", "c", "d", "e"];
        var currentColor;

    line = self.getBasePatternLine(isCalculateNewValueForScale);
    infChart.util.forEach(self.waveDegrees, function(index , value){
        if(self.waveDegrees[index].id === options.currentWaveDegree){
            currentColor = self.waveDegrees[index].color;
        }
    });

    ann.update({
        shape: {
            params: {
                d: line,
                'stroke': options.shape.params.stroke ? options.shape.params.stroke : currentColor,
            }
        }
    });

    var lineShapes = self.getPatternShapes(isCalculateNewValueForScale);

    lineShapes.namePosition && additionalDrawingsArr.labels["nameLabel"] && additionalDrawingsArr.labels["nameLabel"].attr({
        x: lineShapes.namePosition.x,
        y: lineShapes.namePosition.y
    });
    
    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        var label = additionalDrawingsArr.labels[value + "Label"];
        label && label.attr({ x: labelPosition.x - label.width/2, y: labelPosition.y });

        // circles
        if (additionalDrawingsArr.circles[value]) {
            var circlePositions = lineShapes.positions["circles"][value];
            additionalDrawingsArr.circles[value].attr({ x: circlePositions.x, y: circlePositions.y });
        }
    });
    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId, isCalculateNewValueForScale);
    if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
        self.calculateAndUpdateInfoLabel(isCalculateNewValueForScale);
    }
};

infChart.elliotTriangleWaveDrawing.prototype.setSelectionMarkers = function () {
    var self = this;
    var ann = self.annotation;
    var lineShapes = self.getPatternShapes();
    var additionalDrawingsArr = self.additionalDrawings;

    if (!ann.selectionMarker.length) {
        infChart.util.forEach(["o", "a", "b", "c", "d", "e"], function (index, value) {
            var circlePosition = lineShapes.positions["circles"][value];
            if (circlePosition && circlePosition.x != undefined && circlePosition.y != undefined) {
                additionalDrawingsArr.circles[value] = infChart.drawingUtils.common.addAndBindSelectionMarker.call(self, ann, circlePosition.x, circlePosition.y, self.stepFunction, self.stop, true, undefined, { name: value });
            }
         });

        var clipPosX = lineShapes.positions.axisClips.x;
        var clipPosY = lineShapes.positions.axisClips.y;
        if (clipPosY && !additionalDrawingsArr.rect.y && clipPosX && !additionalDrawingsArr.rect.x) {
            ann.selectionMarker.push(additionalDrawingsArr.rect.x);
            ann.selectionMarker.push(additionalDrawingsArr.rect.y);
        }

    }
};

/**
* Step function
* @param {Event} e event
* @param {boolean} isStartPoint indicate whether the start or not
*/
infChart.elliotTriangleWaveDrawing.prototype.step = function (e, isStartPoint, itemProperties) {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        pointx = xAxis.toValue(e.chartX),
        pointy = yAxis.toValue(e.chartY),
        intermediatePoints = options.intermediatePoints,
        newOtions = {};
    switch (itemProperties.name) {
        case 'a':
            if (!intermediatePoints[0]) {
                intermediatePoints[0] = {};
            }
            intermediatePoints[0].xValue = pointx;
            intermediatePoints[0].yValue = pointy;
            break;
        case 'b':
            if (!intermediatePoints[1]) {
                intermediatePoints[1] = {};
            }
            intermediatePoints[1].xValue = pointx;
            intermediatePoints[1].yValue = pointy;
            break;
        case 'c':
            if (!intermediatePoints[2]) {
                intermediatePoints[2] = {};
            }
            intermediatePoints[2].xValue = pointx;
            intermediatePoints[2].yValue = pointy;
            break;
        case 'd':
            if (!intermediatePoints[3]) {
                intermediatePoints[3] = {};
            }
            intermediatePoints[3].xValue = pointx;
            intermediatePoints[3].yValue = pointy;
            break;
        case 'e':
            newOtions.xValueEnd = pointx;
            newOtions.yValueEnd = pointy;
            break;
        case 'o':
            newOtions.xValue = pointx;
            newOtions.yValue = pointy;
            break;
        default:
            break;
    }
    newOtions.intermediatePoints = intermediatePoints;
    ann.update(newOtions);
    this.finalizeEachPoint();
};

/**
 * Stop function
 * @param {Event} e event
 * @param {boolean} isStartPoint indicate whether the start or not
 */
infChart.elliotTriangleWaveDrawing.prototype.stop = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        lineShapes = self.getPatternShapes(true),
        additionalDrawingsArr = self.additionalDrawings;

    // point Labels
    if (!additionalDrawingsArr.labels["eLabel"]) {
        var labelPosition = lineShapes.positions["pointLabels"]["e"];
        labelPosition && (additionalDrawingsArr.labels["eLabel"] = self.getLabel(labelPosition.label, labelPosition.x, labelPosition.y));
        label = additionalDrawingsArr.labels["eLabel"];
        if(label){
            label.attr({x: labelPosition.x - label.width/2});
        }
    }

    if (!additionalDrawingsArr.infoLabels["eLabel"]) {
        var labelPosition = lineShapes.positions["pointLabels"]["e"];
        labelPosition && (additionalDrawingsArr.infoLabels["eLabel"] = self.getInfoLabel(labelPosition.label, labelPosition.x, labelPosition.y));
    }
    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId, true);
    self.getSnappedValues();
    self.calculateAndUpdateInfoLabel(true);
    self.select();

    infChart.drawingUtils.common.saveBaseYValues.call(self, ann.options.yValue, ann.options.yValueEnd, undefined, ann.options.intermediatePoints);
    infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd, undefined, ann.options.nearestIntermediatePoints);
    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
};

infChart.elliotTriangleWaveDrawing.prototype.hasMoreIntermediateSteps = function () {
    return !(this.annotation.options.completedSteps === 5);
};

infChart.elliotTriangleWaveDrawing.prototype.calculateAndUpdateInfoLabel = function (isCalculateNewValues) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        line = ann.shape.d.split(' '),
        chart = ann.chart,
        additionalDrawingsArr = self.additionalDrawings,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis];

    var snappedValues = self.getSnappedValues();
    var infoLabelTypes = ["oLabel", "aLabel", "bLabel", "cLabel", "dLabel", "eLabel"];

    var waveDegreeSelected;
    this.waveDegrees.forEach(function (value, index) {
        if (value.name === options.currentWaveDegree) {
            waveDegreeSelected = value;
        }
    });

    infChart.util.forEach(snappedValues, function (index, value) {
        var calculatedLabelData = {
            price: snappedValues[index].yValue,
            type: self.type + ', ' + waveDegreeSelected.options[index],
            priceDifference: index !== 0 ? Math.abs(snappedValues[index - 1].yValue - snappedValues[index].yValue) : undefined,
            waveDegree: waveDegreeSelected.id
        };
        calculatedLabelData.pricePercentage = (calculatedLabelData.priceDifference >= 0) ? ((calculatedLabelData.priceDifference / calculatedLabelData.price) * 100) : undefined;

        var labelData = self.getLabelData(ann, calculatedLabelData);
        var label = additionalDrawingsArr.infoLabels[infoLabelTypes[index]];
        if (labelData && label) {
            if(isCalculateNewValues) {
                label.attr({
                    text: labelData
                });
            }

            var labelParameters = self.additionalDrawings.labels[infoLabelTypes[index]];
            var yLabelPosition = labelParameters.y;
            var xLabelPosition = labelParameters.x;

            var labelYValue = yAxis.toValue(yLabelPosition + yAxis.toPixels(options.yValue));
            if (snappedValues[index].yValue > labelYValue) {
                yLabelPosition = yLabelPosition + self.additionalDrawings.labels[infoLabelTypes[index]].height + 5;
            }
            if (snappedValues[index].yValue < labelYValue) {
                yLabelPosition = yLabelPosition - label.height - 5;
            }

            label.attr({
                x: xLabelPosition,
                y: yLabelPosition
            });
        }
    });
}
window.infChart = window.infChart || {};

infChart.elliotImpluseWaveDrawing = function () {
    this.labelDataItems = [
        {id: "price", displayName: "Price", enabled: true},
        {id: "type", displayName: "Type", enabled: true},
        {id: "priceDifference", displayName: "Price Difference", enabled: true},
        {id: "waveDegree", displayName: "Wave Degree", enabled: true}
    ];
    this.waveDegrees = [
        {
            id: "Super Millennium",
            name: "superMillennium",
            label: "label.superMillennium", 
            color: "#78BC61",
            enable: false,
            options:["O", "(((1)))", "(((2)))", "(((3)))", "(((4)))", "(((5)))" ]
        },
        {
            id: "Millennium", 
            name: "millennium",
            label: "label.millennium",
            color: "#EF6351",
            enable: false,
            options:["O", "((1))", "((2))", "((3))", "((4))", "((5))" ]
        },
        {
            id: "Sub Millennium", 
            name: "subMillennium",
            label: "label.subMillennium",
            color: "#3066BE",
            enable: false,
            options:["O", "(1)", "(2)", "(3)", "(4)", "(5)" ]
        },
        {
            id: "Grand Super Cycle", 
            name: "grandSuperCycle",
            label: "label.grandSuperCycle",
            color: "#F93943", 
            enable: false,
            options:["O", "(((I)))", "(((II)))", "(((III)))", "(((IV)))", "(((V)))" ]
        },
        {
            id: "Super Cycle", 
            name: "superCycle",
            label: "label.superCycle",
            color: "#7E78D2", 
            enable: false,
            options:["O", "((I))", "((II))", "((III))", "((IV))", "((V))" ]
        },
        {
            id: "Cycle", 
            name: "cycle",
            label: "label.cycle",
            color: "#D65780", 
            enable: false,
            options:["O", "(I)", "(II)", "(III)", "(IV)", "(V)" ]
        },
        {
            id: "Primary",
            name: "primary",
            label: "label.primary",
            color: "#6C809A", 
            enable: false,
            options:["O", "{{{1}}}", "{{{2}}}", "{{{3}}}", "{{{4}}}", "{{{5}}}" ]
        },
        {
            id: "Intermediate", 
            name: "intermediate",
            label: "label.intermediate",
            color: "#58A4B0", 
            enable: false,
            options:["O", "{{1}}", "{{2}}", "{{3}}", "{{4}}", "{{5}}" ]
        },
        {
            id: "Minor", 
            name: "minor",
            label: "label.minor",
            color: "#5E8C61",
            enable: false, 
            options:["O", "{1}", "{2}", "{3}", "{4}", "{5}" ]
        },
        {
            id: "Minute", 
            name: "minute",
            label: "label.minute",
            color: "#C89933", 
            enable: false,
            options:["O", "{{{i}}}", "{{{ii}}}", "{{{iii}}}", "{{{iv}}}", "{{{v}}}" ]
        },
        {
            id: "Minuette", 
            name: "minuette",
            label: "label.minuette",
            color: "#00A7E1", 
            enable: false,
            options:["O", "{{i}}", "{{ii}}", "{{iii}}", "{{iv}}", "{{v}}" ]
        },
        {
            id: "Sub Minuette", 
            name: "subMinuette",
            label: "label.subMinuette",
            color: "#912F56", 
            enable: false,
            options:["O", "{i}", "{ii}", "{iii}", "{iv}", "{v}" ]
        },
        {
            id: "Micro", 
            name: "micro",
            label: "label.micro",
            color: "#9D75CB", 
            enable: true,
            options:["O", "[[[1]]]", "[[[2]]]", "[[[3]]]", "[[[4]]]", "[[[5]]]" ]
        },
        {
            id: "Sub Micro", 
            name: "subMicro",
            label: "label.subMicro",
            color: "#FE7B72",
            enable: false, 
            options:["O", "[[1]]", "[[2]]", "[[3]]", "[[4]]", "[[5]]" ]
        },
        {
            id: "Nano", 
            name: "nano",
            label: "label.nano",
            color: "#8D818C", 
            enable: false,
            options:["O", "[1]", "[2]", "[3]", "[4]", "[5]" ]
        },
        {
            id: "Sub Nano",
            name: "subNano",
            label: "label.subNano", 
            color: "#387D7A", 
            enable: false,
            options:["O", "1", "2", "3", "4", "5" ]
        }
    ]
    this.type = "Impluse";
    this.labelValueNames = ["oLabel", "no1Label", "no2Label", "no3Label", "no4Label", "no5Label"];
    this.currentWaveDegree = "micro";
    infChart.elliotWaveDrawing.apply(this, arguments);
};

infChart.elliotImpluseWaveDrawing.prototype = Object.create(infChart.elliotWaveDrawing.prototype);

/**
* set additional drawings of the tool
*/
infChart.elliotImpluseWaveDrawing.prototype.additionalDrawingsFunction = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        yAxis = chart.yAxis[options.yAxis],
        lineShapes = self.getPatternShapes(true),
        additionalDrawingsArr = self.additionalDrawings,
        theme = infChart.drawingUtils.common.getTheme(),
        shapeTheme = theme["elliotImpulseWave"],
        pointNamesArr = ["o", "no1", "no2", "no3", "no4", "no5"];

    additionalDrawingsArr.lines = {};
    additionalDrawingsArr.labels = {};
    additionalDrawingsArr.circles = {};
    additionalDrawingsArr.axisLabels = {};
    additionalDrawingsArr.rect = {};
    additionalDrawingsArr.infoLabels = {};

    ann.selectionMarker = [];
    self.setSelectionMarkers();

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        labelPosition && (additionalDrawingsArr.infoLabels[value + "Label"] = self.getInfoLabel(labelPosition.label, labelPosition.x, labelPosition.y));
    });

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        labelPosition && (additionalDrawingsArr.labels[value + "Label"] = self.getLabel(labelPosition.label, labelPosition.x, labelPosition.y));
        label = additionalDrawingsArr.labels[value + "Label"];
        if(label){
            label.attr({x: labelPosition.x - label.width/2});
        }
    });
};

infChart.elliotImpluseWaveDrawing.prototype.getClickValues = function (clickX, clickY) {
    var ann = this.annotation;
    var chart = ann.chart;
    var options = ann.options;
    var xAxis = chart.xAxis[options.xAxis];
    var yAxis = chart.yAxis[options.yAxis];
    var completedSteps = this.annotation.options.completedSteps;
    var coordinates = {
        xValue: options.xValue,
        yValue: options.yValue,
        intermediatePoints: options.intermediatePoints
    };
    switch (completedSteps) {
        case 1:
            coordinates.intermediatePoints[0].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[0].yValue = yAxis.toValue(clickY);
            break;
        case 2:
            coordinates.intermediatePoints[1].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[1].yValue = yAxis.toValue(clickY);
            break;
        case 3:
            coordinates.intermediatePoints[2].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[2].yValue = yAxis.toValue(clickY);
            break;
        case 4:
            coordinates.intermediatePoints[3].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[3].yValue = yAxis.toValue(clickY);
            break;
        case 5:
            coordinates.xValueEnd = xAxis.toValue(clickX);
            coordinates.yValueEnd = yAxis.toValue(clickY);
            break;
    }
    return coordinates;
};

/**
* Returns the config to save
* @returns {{shape: string, borderColor: *, strokeWidth: *, xValue: *, yValue: *, xValueEnd: *, yValueEnd: *, intermediatePoints: Array}} config object
*/
infChart.elliotImpluseWaveDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    var intermediatePoints = [];

    infChart.util.forEach(annotation.options.intermediatePoints, function(index , value){
        intermediatePoints.push({
            xValue: value.xValue,
            yValue: value.yValue
        });
    });

    return {
        shape: 'elliotImpulseWave',
        borderColor: annotation.options.shape.params.stroke,
        strokeWidth: annotation.options.shape.params['stroke-width'],
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        intermediatePoints: intermediatePoints,
        fillColor: 'none',
        currentWaveDegree: annotation.options.currentWaveDegree,
        nearestXValue: annotation.options.nearestXValue,
        nearestXValueEnd: annotation.options.nearestXValueEnd,
        nearestYValue: annotation.options.nearestYValue,
        nearestYValueEnd: annotation.options.nearestYValueEnd,
        startTopOfthePoint: annotation.options.startTopOfthePoint,
        endTopOfthePoint: annotation.options.endTopOfthePoint,
        nearestIntermediatePoints: annotation.options.nearestIntermediatePoints,
        isSnapTopHighLow: annotation.options.isSnapTopHighLow,
        textFontSize: annotation.options.textFontSize,
    };
};

/**
 * Create a label and add to the group
 * @param {String} name label text
 * @param {number} x x position
 * @param {number} y y position
 * @returns {SVGElement} the generated label
 */
infChart.elliotImpluseWaveDrawing.prototype.getLabel = function (name, x, y) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        theme = infChart.drawingUtils.common.getTheme(),
        shapeTheme = theme["elliotImpulseWave"];
        var currentColor;

        infChart.util.forEach(self.waveDegrees, function(index , value){
            if(self.waveDegrees[index].name === self.currentWaveDegree){
                currentColor = self.waveDegrees[index].color;
            }
        });

    var labelData = chart.renderer.label(name, x, y).attr({
        'zIndex': 20,
        'r': 3,
        'opacity': shapeTheme && shapeTheme.label && shapeTheme.label.opacity || 1,
        'stroke': options.shape.params.stroke ? options.shape.params.stroke : currentColor,//shapeTheme && shapeTheme.label && shapeTheme.label.stroke || "#858587",
        'stroke-width': 0,
        'hAlign': 'center',
        'class': 'harmonic-lbl',
        'rel': name,
    }).add(ann.group).css(
        {
            color: options.shape.params.stroke ? options.shape.params.stroke : currentColor,//shapeTheme && shapeTheme.label && shapeTheme.label.stroke || "#858587",
            fontSize: options.textFontSize || '16px',
            cursor: 'pointer',
            fontWeight: '700',
            fontStyle: 'normal',
            textDecoration: 'inherit'
        });

    $(labelData.element).mouseover(function (event) {
        event.stopPropagation();
        if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
            var rel = event.currentTarget.getAttribute('rel');
            if(rel === "O"){
                self.additionalDrawings.infoLabels.oLabel.show();
            }
            if(rel === "1"|| rel === "(1)"|| rel === "((1))"|| rel === "(((1)))"|| rel === "(I)"|| rel === "((I))"|| rel === "(((I)))" || rel === "[1]"|| rel === "[[1]]"|| rel === "[[[1]]]"|| rel === "{{{1}}}"|| rel === "{{1}}"|| rel === "{1}"|| rel === "{{{i}}}"|| rel === "{{i}}"|| rel === "{i}"){
                self.additionalDrawings.infoLabels.no1Label.show();
            }
            if(rel === "2"|| rel === "(2)"|| rel === "((2))"|| rel === "(((2)))"|| rel === "(II)"|| rel === "((II))"|| rel === "(((II)))" || rel === "[2]"|| rel === "[[2]]"|| rel === "[[[2]]]"|| rel === "{{{2}}}"|| rel === "{{2}}"|| rel === "{2}"|| rel === "{{{ii}}}"|| rel === "{{ii}}"|| rel === "{ii}"){
                self.additionalDrawings.infoLabels.no2Label.show();
            }
            if(rel === "3"|| rel === "(3)"|| rel === "((3))"|| rel === "(((3)))"|| rel === "(III)"|| rel === "((III))"|| rel === "(((III)))" || rel === "[3]"|| rel === "[[3]]"|| rel === "[[[3]]]"|| rel === "{{{3}}}"|| rel === "{{3}}"|| rel === "{3}"|| rel === "{{{iii}}}"|| rel === "{{iii}}"|| rel === "{iii}"){
                self.additionalDrawings.infoLabels.no3Label.show();
            }
            if(rel === "4"|| rel === "(4)"|| rel === "((4))"|| rel === "(((4)))"|| rel === "(IV)"|| rel === "((IV))"|| rel === "(((IV)))" || rel === "[4]"|| rel === "[[4]]"|| rel === "[[[4]]]"|| rel === "{{{4}}}"|| rel === "{{4}}"|| rel === "{4}"|| rel === "{{{iv}}}"|| rel === "{{iv}}"|| rel === "{iv}"){
                self.additionalDrawings.infoLabels.no4Label.show();
            }        
            if(rel === "5"|| rel === "(5)"|| rel === "((5))"|| rel === "(((5)))"|| rel === "(V)"|| rel === "((V))"|| rel === "(((V)))" || rel === "[5]"|| rel === "[[5]]"|| rel === "[[[5]]]"|| rel === "{{{5}}}"|| rel === "{{5}}"|| rel === "{5}"|| rel === "{{{v}}}"|| rel === "{{v}}"|| rel === "{v}"){
                self.additionalDrawings.infoLabels.no5Label.show();
            }
        }
    });

    $(labelData.element).mouseleave(function (event) {
        event.stopPropagation();
        if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
            var rel = event.currentTarget.getAttribute('rel');
            if(rel === "O"){
                self.additionalDrawings.infoLabels.oLabel.hide();
            }
            if(rel === "1"|| rel === "(1)"|| rel === "((1))"|| rel === "(((1)))"|| rel === "(I)"|| rel === "((I))"|| rel === "(((I)))" || rel === "[1]"|| rel === "[[1]]"|| rel === "[[[1]]]"|| rel === "{{{1}}}"|| rel === "{{1}}"|| rel === "{1}"|| rel === "{{{i}}}"|| rel === "{{i}}"|| rel === "{i}"){
                self.additionalDrawings.infoLabels.no1Label.hide();
            }
            if(rel === "2"|| rel === "(2)"|| rel === "((2))"|| rel === "(((2)))"|| rel === "(II)"|| rel === "((II))"|| rel === "(((II)))" || rel === "[2]"|| rel === "[[2]]"|| rel === "[[[2]]]"|| rel === "{{{2}}}"|| rel === "{{2}}"|| rel === "{2}"|| rel === "{{{ii}}}"|| rel === "{{ii}}"|| rel === "{ii}"){
                self.additionalDrawings.infoLabels.no2Label.hide();
            }
            if(rel === "3"|| rel === "(3)"|| rel === "((3))"|| rel === "(((3)))"|| rel === "(III)"|| rel === "((III))"|| rel === "(((III)))" || rel === "[3]"|| rel === "[[3]]"|| rel === "[[[3]]]"|| rel === "{{{3}}}"|| rel === "{{3}}"|| rel === "{3}"|| rel === "{{{iii}}}"|| rel === "{{iii}}"|| rel === "{iii}"){
                self.additionalDrawings.infoLabels.no3Label.hide();
            }
            if(rel === "4"|| rel === "(4)"|| rel === "((4))"|| rel === "(((4)))"|| rel === "(IV)"|| rel === "((IV))"|| rel === "(((IV)))" || rel === "[4]"|| rel === "[[4]]"|| rel === "[[[4]]]"|| rel === "{{{4}}}"|| rel === "{{4}}"|| rel === "{4}"|| rel === "{{{iv}}}"|| rel === "{{iv}}"|| rel === "{iv}"){
                self.additionalDrawings.infoLabels.no4Label.hide();
            }        
            if(rel === "5"|| rel === "(5)"|| rel === "((5))"|| rel === "(((5)))"|| rel === "(V)"|| rel === "((V))"|| rel === "(((V)))" || rel === "[5]"|| rel === "[[5]]"|| rel === "[[[5]]]"|| rel === "{{{5}}}"|| rel === "{{5}}"|| rel === "{5}"|| rel === "{{{v}}}"|| rel === "{{v}}"|| rel === "{v}"){
                self.additionalDrawings.infoLabels.no5Label.hide();
            }
        }
    });
    return labelData;
};

infChart.elliotImpluseWaveDrawing.prototype.getNextPointOptions = function () {
    var ann = this.annotation;
    var completedSteps = ann.options.completedSteps;
    var pointOptions = { name: "o" };
    switch (completedSteps) {
        case 1:
            pointOptions.name = "no1";
            break;
        case 2:
            pointOptions.name = "no2";
            break;
        case 3:
            pointOptions.name = "no3";
            break;
        case 4:
            pointOptions.name = "no4";
            break;
        case 5:
            pointOptions.name = "no5";
            break;

    }
    return pointOptions;
};

/**
* Returns the paths, values and positions of the shapes under this drawing
* @returns {object} pattern shapes
*/
infChart.elliotImpluseWaveDrawing.prototype.getPatternShapes = function (updateNearestValues) {
    var nameAdditionalY = 25;
    var patternPaths = {};

    var ann = this.annotation;
    var chart = ann.chart;
    var options = ann.options;
    var intermediatePoints = options.intermediatePoints;
    var intermediatePointsRaw = this.intermediatePoints;
    var xAxis = chart.xAxis[options.xAxis];
    var yAxis = chart.yAxis[options.yAxis];

    var waveDegreeSelected;
    this.waveDegrees.forEach(function(value, index){
        if(value.name === options.currentWaveDegree){
            waveDegreeSelected = value;
        }
    });

    var x = xAxis.toPixels(options.xValue);
    var y = yAxis.toPixels(options.yValue);

    var intermediate = this.getIntermediatePointsSnappedValues(updateNearestValues);
    var ax = intermediate && intermediate[0] && intermediate[0].x;
    var ay = intermediate && intermediate[0] && intermediate[0].y;
    var bx = intermediate && intermediate[1] && intermediate[1].x;
    var by = intermediate && intermediate[1] && intermediate[1].y;
    var cx = intermediate && intermediate[2] && intermediate[2].x;
    var cy = intermediate && intermediate[2] && intermediate[2].y;
    var dx = intermediate && intermediate[3] && intermediate[3].x;
    var dy = intermediate && intermediate[3] && intermediate[3].y;

    var futureValue = chart.series[0].xData[chart.series[0].xData.length-1];
    if(updateNearestValues){
        var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);
        if(futureValue >=  nearestDataForXValueEnd.xData){
            options.nearestXValueEnd = nearestDataForXValueEnd.xData;
            var nearestEndValue = this.getNearestYValue(options.yValueEnd, nearestDataForXValueEnd, undefined, options.isSnapTopHighLow);
            options.nearestYValueEnd = nearestEndValue.nearestYValue;
            options.endTopOfthePoint = nearestEndValue.topOfThePoint;
        } else {
            options.nearestXValueEnd = nearestDataForXValueEnd.xData;
            options.nearestYValueEnd = options.yValueEnd;
            options.endTopOfthePoint = true;
        }
    }
    var newXEnd = xAxis.toPixels(options.nearestXValueEnd) - x;
    var newYEnd = yAxis.toPixels(options.nearestYValueEnd) - y;
    var ex = options.xValueEnd && newXEnd;
    var ey = options.yValueEnd && newYEnd;

    if (ex !== undefined) {
        if (y < 0) {
            patternPaths.namePosition = { x: (ex) / 2, y: (ey) / 2 + nameAdditionalY };
        } else {
            patternPaths.namePosition = { x: (x + dx) / 2, y: (y + dy) / 2 + nameAdditionalY };
        }
    }

    if(updateNearestValues){
        var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
        if(futureValue >=  nearestDataForXValue.xData){
            options.nearestXValue = nearestDataForXValue.xData;
            var nearestStartValue = this.getNearestYValue(options.yValue, nearestDataForXValue, undefined, options.isSnapTopHighLow);
            options.nearestYValue = nearestStartValue.nearestYValue;
            options.startTopOfthePoint = nearestStartValue.topOfThePoint;
        } else {
            options.nearestXValue = nearestDataForXValue.xData;
            options.nearestYValue = options.yValue;
            options.startTopOfthePoint = true;
        }
    }
    var newX = xAxis.toPixels(options.nearestXValue) - x;
    var newY = yAxis.toPixels(options.nearestYValue) - y;
    patternPaths.oCirclePosition = { x: newX, y: newY };

    patternPaths.positions = {
        pointLabels: {
            o: { x: newX, y: options.startTopOfthePoint ? -25 + newY : 5 + newY, label: waveDegreeSelected.options[0], xValue: options.nearestXValue, yValue: options.nearestYValue, topOfThePoint: options.startTopOfthePoint }
        },
        circles: {
            o: { x: newX, y: newY },
            no1: { x: ax, y: ay },
            no2: { x: bx, y: by },
            no3: { x: cx, y: cy },
            no4: { x: dx, y: dy },
            no5: { x: ex, y: ey }
        }
    };

    patternPaths.positions.axisClips = {};

    patternPaths.values = {
        o: {
            xValue: options.xValue,
            yValue: this.yValue,
            optionXValue: options.xValue,
            optionYValue: options.yValue
        }
    };

    if (ax !== undefined) {
        patternPaths.no1CirclePosition = { x: ax, y: ay };
        patternPaths.positions.pointLabels.no1 = { x: ax, y: intermediate[0].topOfThePoint ? ay - 25 : ay + 5, label: waveDegreeSelected.options[1], xValue: intermediate[0].xValue, yValue: intermediate[0].yValue, topOfThePoint: intermediate[0].topOfThePoint};
        patternPaths.values.no1 = {
            xValue: intermediatePoints[0].xValue,
            yValue: intermediatePointsRaw[0] ? intermediatePointsRaw[0].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[0].yValue),
            optionXValue: intermediatePoints[0].xValue,
            optionYValue: intermediatePoints[0].yValue
        };

    }

    if (bx !== undefined) {
        patternPaths.no2CirclePosition = { x: bx, y: by };
        patternPaths.positions.pointLabels.no2 = { x: bx, y: intermediate[1].topOfThePoint ? by - 25 : by + 5, label: waveDegreeSelected.options[2], xValue: intermediate[1].xValue, yValue: intermediate[1].yValue, topOfThePoint: intermediate[1].topOfThePoint };
        patternPaths.values.no2 = {
            xValue: intermediatePoints[1].xValue,
            yValue: intermediatePointsRaw[1] ? intermediatePointsRaw[1].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[1].yValue),
            optionXValue: intermediatePoints[1].xValue,
            optionYValue: intermediatePoints[1].yValue
        };

    }
    if (cx !== undefined) {
        patternPaths.no3CirclePosition = { x: cx, y: cy };
        patternPaths.positions.pointLabels.no3 = { x: cx, y: intermediate[2].topOfThePoint ? cy - 25 : cy + 5, label: waveDegreeSelected.options[3], xValue: intermediate[2].xValue, yValue: intermediate[2].yValue, topOfThePoint: intermediate[2].topOfThePoint };
        patternPaths.values.no3 = {
            xValue: intermediatePoints[2].xValue,
            yValue: intermediatePointsRaw[2] ? intermediatePointsRaw[2].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[2].yValue),
            optionXValue: intermediatePoints[2].xValue,
            optionYValue: intermediatePoints[2].yValue
        };
    }
    if (dx !== undefined) {
        patternPaths.no4CirclePosition = { x: dx, y: dy };
        patternPaths.positions.pointLabels.no4 = { x: dx, y: intermediate[3].topOfThePoint ? dy - 25 : dy + 5, label: waveDegreeSelected.options[4], xValue: intermediate[3].xValue, yValue: intermediate[3].yValue, topOfThePoint: intermediate[3].topOfThePoint };
        patternPaths.values.no4 = {
            xValue: intermediatePoints[3].xValue,
            yValue: intermediatePointsRaw[3] ? intermediatePointsRaw[3].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[3].yValue),
            optionXValue: intermediatePoints[3].xValue,
            optionYValue: intermediatePoints[3].yValue
        };

    }
    if (ex !== undefined) {
        patternPaths.no5CirclePosition = { x: ex, y: ey };
        patternPaths.positions.pointLabels.no5 = { x: ex, y: options.endTopOfthePoint ? ey - 25 : ey + 5, label: waveDegreeSelected.options[5], xValue: options.nearestXValueEnd, yValue: options.nearestYValueEnd, topOfThePoint: options.endTopOfthePoint };
        patternPaths.values.no5 = {
            xValue: options.xValueEnd,
            yValue: this.yValueEnd !== undefined ? this.yValueEnd : infChart.drawingUtils.common.getBaseYValue.call(this, options.yValueEnd),
            optionXValue: options.xValueEnd,
            optionYValue: options.yValueEnd
        };

    }
    return patternPaths;
};

infChart.elliotImpluseWaveDrawing.prototype.finalizeEachPoint = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        line,
        additionalDrawingsArr = self.additionalDrawings,
        pointNamesArr = ["o", "no1", "no2", "no3", "no4", "no5"];
        var currentColor;

    line = self.getBasePatternLine(true);
    infChart.util.forEach(self.waveDegrees, function(index , value){
        if(self.waveDegrees[index].id === options.currentWaveDegree){
            currentColor = self.waveDegrees[index].color;
        }
    });

    ann.update({
        shape: {
            params: {
                d: line,
                'stroke': options.shape.params.stroke ? options.shape.params.stroke : currentColor,
            }
        }
    });

    var lineShapes = self.getPatternShapes(true);

    lineShapes.namePosition && additionalDrawingsArr.labels["nameLabel"] && additionalDrawingsArr.labels["nameLabel"].attr({
        x: lineShapes.namePosition.x,
        y: lineShapes.namePosition.y
    });

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        var label = additionalDrawingsArr.labels[value + "Label"];
        label && label.attr({ x: labelPosition.x - label.width/2, y: labelPosition.y });
        // circles
        if (additionalDrawingsArr.circles[value]) {
            var circlePositions = lineShapes.positions["circles"][value];
            additionalDrawingsArr.circles[value].attr({ x: circlePositions.x, y: circlePositions.y });
        }
    });
    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId, true);
    if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
        self.getSnappedValues();
        self.calculateAndUpdateInfoLabel(true);
    }
    infChart.drawingUtils.common.saveBaseYValues.call(self, ann.options.yValue, ann.options.yValueEnd, undefined, ann.options.intermediatePoints);
    infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd, ann.options.nearestTrendYValue, ann.options.nearestIntermediatePoints);
};

infChart.elliotImpluseWaveDrawing.prototype.getSettingsPopup = function () {
    var common = infChart.drawingUtils.common;
    return infChart.structureManager.drawingTools.getElliotWaveSettings(infChart.manager.getLabel('label.elliotImpulseWave'), common.baseBorderColor, this.annotation.options.currentWaveDegree, this.waveDegrees, this.fontSize);
};

/**
* Scale function of the tool
*/
infChart.elliotImpluseWaveDrawing.prototype.scale = function (isCalculateNewValueForScale) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        line,
        additionalDrawingsArr = self.additionalDrawings,
        pointNamesArr = ["o", "no1", "no2", "no3", "no4", "no5"];
        var currentColor;

    line = self.getBasePatternLine(isCalculateNewValueForScale);
    infChart.util.forEach(self.waveDegrees, function(index , value){
        if(self.waveDegrees[index].id === options.currentWaveDegree){
            currentColor = self.waveDegrees[index].color;
        }
    });

    ann.update({
        shape: {
            params: {
                d: line,
                'stroke': options.shape.params.stroke ? options.shape.params.stroke : currentColor,
            }
        }
    });

    var lineShapes = self.getPatternShapes(isCalculateNewValueForScale);

    lineShapes.namePosition && additionalDrawingsArr.labels["nameLabel"] && additionalDrawingsArr.labels["nameLabel"].attr({
        x: lineShapes.namePosition.x,
        y: lineShapes.namePosition.y
    });

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        var label = additionalDrawingsArr.labels[value + "Label"];
        label && label.attr({ x: labelPosition.x - label.width/2, y: labelPosition.y });
        // circles
        if (additionalDrawingsArr.circles[value]) {
            var circlePositions = lineShapes.positions["circles"][value];
            additionalDrawingsArr.circles[value].attr({ x: circlePositions.x, y: circlePositions.y });
        }
    });
    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId, isCalculateNewValueForScale);
    if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
        self.calculateAndUpdateInfoLabel(isCalculateNewValueForScale);
    }
};

infChart.elliotImpluseWaveDrawing.prototype.setSelectionMarkers = function () {
    var self = this;
    var ann = self.annotation;
    var lineShapes = self.getPatternShapes();
    var additionalDrawingsArr = self.additionalDrawings;

    if (!ann.selectionMarker.length) {
        infChart.util.forEach(["o", "no1", "no2", "no3", "no4", "no5"], function (index, value) {
            var circlePosition = lineShapes.positions["circles"][value];
            if (circlePosition && circlePosition.x != undefined && circlePosition.y != undefined) {
                additionalDrawingsArr.circles[value] = infChart.drawingUtils.common.addAndBindSelectionMarker.call(self, ann, circlePosition.x, circlePosition.y, self.stepFunction, self.stop, true, undefined, { name: value });
            }
         });

        var clipPosX = lineShapes.positions.axisClips.x;
        var clipPosY = lineShapes.positions.axisClips.y;
        if (clipPosY && !additionalDrawingsArr.rect.y && clipPosX && !additionalDrawingsArr.rect.x) {
            ann.selectionMarker.push(additionalDrawingsArr.rect.x);
            ann.selectionMarker.push(additionalDrawingsArr.rect.y);
        }

    }
};

/**
* Step function
* @param {Event} e event
* @param {boolean} isStartPoint indicate whether the start or not
*/
infChart.elliotImpluseWaveDrawing.prototype.step = function (e, isStartPoint, itemProperties) {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        pointx = xAxis.toValue(e.chartX),
        pointy = yAxis.toValue(e.chartY),
        intermediatePoints = options.intermediatePoints,
        newOtions = {};
    switch (itemProperties.name) {
        case 'no1':
            if (!intermediatePoints[0]) {
                intermediatePoints[0] = {};
            }
            intermediatePoints[0].xValue = pointx;
            intermediatePoints[0].yValue = pointy;
            break;
        case 'no2':
            if (!intermediatePoints[1]) {
                intermediatePoints[1] = {};
            }
            intermediatePoints[1].xValue = pointx;
            intermediatePoints[1].yValue = pointy;
            break;
        case 'no3':
            if (!intermediatePoints[2]) {
                intermediatePoints[2] = {};
            }
            intermediatePoints[2].xValue = pointx;
            intermediatePoints[2].yValue = pointy;
            break;
        case 'no4':
            if (!intermediatePoints[3]) {
                intermediatePoints[3] = {};
            }
            intermediatePoints[3].xValue = pointx;
            intermediatePoints[3].yValue = pointy;
            break;
        case 'no5':
            newOtions.xValueEnd = pointx;
            newOtions.yValueEnd = pointy;
            break;
        case 'o':
            newOtions.xValue = pointx;
            newOtions.yValue = pointy;
            break;
        default:
            break;
    }
    newOtions.intermediatePoints = intermediatePoints;
    ann.update(newOtions);
    this.finalizeEachPoint();
};

/**
 * Stop function
 * @param {Event} e event
 * @param {boolean} isStartPoint indicate whether the start or not
 */
infChart.elliotImpluseWaveDrawing.prototype.stop = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        lineShapes = self.getPatternShapes(true),
        additionalDrawingsArr = self.additionalDrawings;

    // point Labels
    if (!additionalDrawingsArr.labels["no5Label"]) {
        var labelPosition = lineShapes.positions["pointLabels"]["no5"];
        labelPosition && (additionalDrawingsArr.labels["no5Label"] = self.getLabel(labelPosition.label, labelPosition.x, labelPosition.y));
        label = additionalDrawingsArr.labels["no5Label"];
        if(label){
            label.attr({x: labelPosition.x - label.width/2});
        }
    }

    if (!additionalDrawingsArr.infoLabels["no5Label"]) {
        var labelPosition = lineShapes.positions["pointLabels"]["no5"];
        labelPosition && (additionalDrawingsArr.infoLabels["no5Label"] = self.getInfoLabel(labelPosition.label, labelPosition.x, labelPosition.y));
    }
    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId, true);
    self.getSnappedValues();
    self.calculateAndUpdateInfoLabel(true);
    self.select();

    infChart.drawingUtils.common.saveBaseYValues.call(self, ann.options.yValue, ann.options.yValueEnd, undefined, ann.options.intermediatePoints);
    infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd, undefined, ann.options.nearestIntermediatePoints);
    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
};

infChart.elliotImpluseWaveDrawing.prototype.hasMoreIntermediateSteps = function () {
    return !(this.annotation.options.completedSteps === 5);
};

infChart.elliotImpluseWaveDrawing.prototype.calculateAndUpdateInfoLabel = function (isCalculateNewValues) {
    var self = this, 
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        additionalDrawingsArr = self.additionalDrawings,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis];

    var snappedValues = self.getSnappedValues();
    var infoLabelTypes = ["oLabel", "no1Label", "no2Label", "no3Label", "no4Label", "no5Label"];

    var waveDegreeSelected;
    this.waveDegrees.forEach(function(value, index){
        if(value.name === options.currentWaveDegree){
            waveDegreeSelected = value;
        }
    });

    infChart.util.forEach(snappedValues, function (index, value) {       
        var calculatedLabelData = {
            price: snappedValues[index].yValue,
            type: self.type + ', ' + waveDegreeSelected.options[index],
            priceDifference: index !== 0 ?  Math.abs(snappedValues[index-1].yValue - snappedValues[index].yValue) : undefined,
            waveDegree: waveDegreeSelected.id
        };

        calculatedLabelData.pricePercentage = (calculatedLabelData.priceDifference >= 0) ? ((calculatedLabelData.priceDifference /calculatedLabelData.price) * 100): undefined;

        var labelData = self.getLabelData(ann, calculatedLabelData);
        var label = additionalDrawingsArr.infoLabels[infoLabelTypes[index]];
        if(labelData && label){
            if(isCalculateNewValues) {
                label.attr({
                    text: labelData
                });
            }

            var labelParameters = self.additionalDrawings.labels[infoLabelTypes[index]];
            var yLabelPosition = labelParameters.y;
            var xLabelPosition = labelParameters.x;

            var labelYValue = yAxis.toValue(yLabelPosition + yAxis.toPixels(options.yValue));
            if (snappedValues[index].yValue > labelYValue) {
                yLabelPosition = yLabelPosition + self.additionalDrawings.labels[infoLabelTypes[index]].height + 5;
            }
            if (snappedValues[index].yValue < labelYValue) {
                yLabelPosition = yLabelPosition - label.height - 5;
            }

            label.attr({
                x: xLabelPosition,
                y: yLabelPosition
            });
        }
    });
}
window.infChart = window.infChart || {};

infChart.elliotCorrectiveWaveDrawing = function () {
    this.labelDataItems = [
        {id: "price", displayName: "Price", enabled: true},
        {id: "type", displayName: "Type", enabled: true},
        {id: "priceDifference", displayName: "Price Difference", enabled: true},
        {id: "waveDegree", displayName: "Wave Degree", enabled: true}
    ];
    this.waveDegrees = [
        {
            id: "Super Millennium",
            name: "superMillennium",
            label: "label.superMillennium", 
            color: "#78BC61",
            enable: false,
            options:["O", "(((A)))", "(((B)))", "(((C)))"]
        },
        {
            id: "Millennium", 
            name: "millennium",
            label: "label.millennium",
            color: "#EF6351",
            enable: false,
            options:["O", "((A))", "((B))", "((C))"]
        },
        {
            id: "Sub Millennium", 
            name: "subMillennium",
            label: "label.subMillennium",
            color: "#3066BE",
            enable: false,
            options:["O", "(A)", "(B)", "(C)"]
        },
        {
            id: "Grand Super Cycle", 
            name: "grandSuperCycle",
            label: "label.grandSuperCycle",
            color: "#F93943", 
            enable: false,
            options:["O", "(((a)))", "(((b)))", "(((c)))"]
        },
        {
            id: "Super Cycle", 
            name: "superCycle",
            label: "label.superCycle",
            color: "#7E78D2", 
            enable: false,
            options:["O", "((a))", "((b))", "((c))"]
        },
        {
            id: "Cycle", 
            name: "cycle",
            label: "label.cycle",
            color: "#D65780", 
            enable: false,
            options:["O", "(a)", "(b)", "(c)"]
        },
        {
            id: "Primary",
            name: "primary",
            label: "label.primary",
            color: "#6C809A", 
            enable: false,
            options:["O", "{{{A}}}", "{{{B}}}", "{{{C}}}"]
        },
        {
            id: "Intermediate", 
            name: "intermediate",
            label: "label.intermediate",
            color: "#58A4B0", 
            enable: false,
            options:["O", "{{A}}", "{{B}}", "{{C}}"]
        },
        {
            id: "Minor", 
            name: "minor",
            label: "label.minor",
            color: "#5E8C61",
            enable: false, 
            options:["O", "{A}", "{B}", "{C}"]
        },
        {
            id: "Minute", 
            name: "minute",
            label: "label.minute",
            color: "#C89933", 
            enable: false,
            options:["O", "{{{a}}}", "{{{b}}}", "{{{c}}}"]
        },
        {
            id: "Minuette", 
            name: "minuette",
            label: "label.minuette",
            color: "#00A7E1", 
            enable: false,
            options:["O", "{{a}}", "{{b}}", "{{c}}"]
        },
        {
            id: "Sub Minuette", 
            name: "subMinuette",
            label: "label.subMinuette",
            color: "#912F56", 
            enable: false,
            options:["O", "{a}", "{b}", "{c}"]
        },
        {
            id: "Micro", 
            name: "micro",
            label: "label.micro",
            color: "#9D75CB", 
            enable: true,
            options:["O", "[[[A]]]", "[[[B]]]", "[[[C]]]"]
        },
        {
            id: "Sub Micro", 
            name: "subMicro",
            label: "label.subMicro",
            color: "#FE7B72",
            enable: false, 
            options:["O", "[[A]]", "[[B]]", "[[C]]"]
        },
        {
            id: "Nano", 
            name: "nano",
            label: "label.nano",
            color: "#8D818C", 
            enable: false,
            options:["O", "[A]", "[B]", "[C]"]
        },
        {
            id: "Sub Nano",
            name: "subNano",
            label: "label.subNano", 
            color: "#387D7A", 
            enable: false,
            options:["O", "A", "B", "C"]
        }
    ]
    this.labelValueNames = ["oLabel", "aLabel", "bLabel", "cLabel"];
    this.type = "Corrective";
    this.currentWaveDegree = "micro";
    infChart.elliotWaveDrawing.apply(this, arguments);
};

infChart.elliotCorrectiveWaveDrawing.prototype = Object.create(infChart.elliotWaveDrawing.prototype);

/**
* set additional drawings of the tool
*/
infChart.elliotCorrectiveWaveDrawing.prototype.additionalDrawingsFunction = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        yAxis = chart.yAxis[options.yAxis],
        lineShapes = self.getPatternShapes(true),
        additionalDrawingsArr = self.additionalDrawings,
        theme = infChart.drawingUtils.common.getTheme(),
        shapeTheme = theme["elliotCorrectiveWave"],
        pointNamesArr = ["o", "a", "b", "c"];

    additionalDrawingsArr.lines = {};
    additionalDrawingsArr.labels = {};
    additionalDrawingsArr.circles = {};
    additionalDrawingsArr.axisLabels = {};
    additionalDrawingsArr.rect = {};
    additionalDrawingsArr.infoLabels = {};

    ann.selectionMarker = [];
    self.setSelectionMarkers();

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        labelPosition && (additionalDrawingsArr.infoLabels[value + "Label"] = self.getInfoLabel(labelPosition.label, labelPosition.x, labelPosition.y));
    });

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        labelPosition && (additionalDrawingsArr.labels[value + "Label"] = self.getLabel(labelPosition.label, labelPosition.x, labelPosition.y));
        label = additionalDrawingsArr.labels[value + "Label"];
        if(label){
            label.attr({x: labelPosition.x - label.width/2});
        }
    });
};

infChart.elliotCorrectiveWaveDrawing.prototype.getClickValues = function (clickX, clickY) {
    var ann = this.annotation;
    var chart = ann.chart;
    var options = ann.options;
    var xAxis = chart.xAxis[options.xAxis];
    var yAxis = chart.yAxis[options.yAxis];
    var completedSteps = this.annotation.options.completedSteps;
    var coordinates = {
        xValue: options.xValue,
        yValue: options.yValue,
        intermediatePoints: options.intermediatePoints
    };
    switch (completedSteps) {
        case 1:
            coordinates.intermediatePoints[0].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[0].yValue = yAxis.toValue(clickY);
            break;
        case 2:
            coordinates.intermediatePoints[1].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[1].yValue = yAxis.toValue(clickY);
            break;
        case 3:
            coordinates.xValueEnd = xAxis.toValue(clickX);
            coordinates.yValueEnd = yAxis.toValue(clickY);
            break;
    }
    return coordinates;
};

/**
* Returns the config to save
* @returns {{shape: string, borderColor: *, strokeWidth: *, xValue: *, yValue: *, xValueEnd: *, yValueEnd: *, intermediatePoints: Array}} config object
*/
infChart.elliotCorrectiveWaveDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    var intermediatePoints = [];

    infChart.util.forEach(annotation.options.intermediatePoints, function(index , value){
        intermediatePoints.push({
            xValue: value.xValue,
            yValue: value.yValue
        });
    });

    return {
        shape: 'elliotCorrectiveWave',
        borderColor: annotation.options.shape.params.stroke,
        strokeWidth: annotation.options.shape.params['stroke-width'],
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        intermediatePoints: intermediatePoints,
        fillColor: 'none',
        currentWaveDegree: annotation.options.currentWaveDegree,
        nearestXValue: annotation.options.nearestXValue,
        nearestXValueEnd: annotation.options.nearestXValueEnd,
        nearestYValue: annotation.options.nearestYValue,
        nearestYValueEnd: annotation.options.nearestYValueEnd,
        startTopOfthePoint: annotation.options.startTopOfthePoint,
        endTopOfthePoint: annotation.options.endTopOfthePoint,
        nearestIntermediatePoints: annotation.options.nearestIntermediatePoints,
        isSnapTopHighLow: annotation.options.isSnapTopHighLow,
        textFontSize: annotation.options.textFontSize,
    };
};

/**
 * Create a label and add to the group
 * @param {String} name label text
 * @param {number} x x position
 * @param {number} y y position
 * @returns {SVGElement} the generated label
 */
infChart.elliotCorrectiveWaveDrawing.prototype.getLabel = function (name, x, y) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        theme = infChart.drawingUtils.common.getTheme(),
        shapeTheme = theme["elliotCorrectiveWave"];
        var currentColor;

        infChart.util.forEach(self.waveDegrees, function(index , value){
            if(self.waveDegrees[index].name === self.currentWaveDegree){
                currentColor = self.waveDegrees[index].color;
            }
        });

    var labelData = chart.renderer.label(name, x, y).attr({
        'zIndex': 20,
        'r': 3,
        'opacity': shapeTheme && shapeTheme.label && shapeTheme.label.opacity || 1,
        'stroke': options.shape.params.stroke ? options.shape.params.stroke : currentColor,//shapeTheme && shapeTheme.label && shapeTheme.label.stroke || "#858587",
        'stroke-width': 0,
        'hAlign': 'center',
        'class': 'harmonic-lbl',
        'rel': name,
    }).add(ann.group).css(
        {
            color: options.shape.params.stroke ? options.shape.params.stroke : currentColor,//shapeTheme && shapeTheme.label && shapeTheme.label.stroke || "#858587",
            fontSize: options.textFontSize || '16px',
            cursor: 'pointer',
            fontWeight: '700',
            fontStyle: 'normal',
            textDecoration: 'inherit'
        });

    $(labelData.element).mouseover(function (event) {
        event.stopPropagation();
        if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
            var rel = event.currentTarget.getAttribute('rel');
            if(rel === "O"){
                self.additionalDrawings.infoLabels.oLabel.show();
            }
            if(rel === "A"|| rel === "(A)"|| rel === "((A))"|| rel === "(((A)))"|| rel === "(a)"|| rel === "((a))"|| rel === "(((a)))" || rel === "[A]"|| rel === "[[A]]"|| rel === "[[[A]]]"|| rel === "{{{A}}}"|| rel === "{{A}}"|| rel === "{A}"|| rel === "{{{a}}}"|| rel === "{{a}}"|| rel === "{a}"){
                self.additionalDrawings.infoLabels.aLabel.show();
            }
            if(rel === "B"|| rel === "(B)"|| rel === "((B))"|| rel === "(((B)))"|| rel === "(b)"|| rel === "((b))"|| rel === "(((b)))" || rel === "[B]"|| rel === "[[B]]"|| rel === "[[[B]]]"|| rel === "{{{B}}}"|| rel === "{{B}}"|| rel === "{B}"|| rel === "{{{b}}}"|| rel === "{{b}}"|| rel === "{b}"){
                self.additionalDrawings.infoLabels.bLabel.show();
            }
            if(rel === "C"|| rel === "(C)"|| rel === "((C))"|| rel === "(((C)))"|| rel === "(c)"|| rel === "((c))"|| rel === "(((c)))" || rel === "[C]"|| rel === "[[C]]"|| rel === "[[[C]]]"|| rel === "{{{C}}}"|| rel === "{{C}}"|| rel === "{C}"|| rel === "{{{c}}}"|| rel === "{{c}}"|| rel === "{c}"){
                self.additionalDrawings.infoLabels.cLabel.show();
            }
        }
    });

    $(labelData.element).mouseleave(function (event) {
        event.stopPropagation();
        if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
            var rel = event.currentTarget.getAttribute('rel');
            if(rel === "O"){
                self.additionalDrawings.infoLabels.oLabel.hide();
            }
            if(rel === "A"|| rel === "(A)"|| rel === "((A))"|| rel === "(((A)))"|| rel === "(a)"|| rel === "((a))"|| rel === "(((a)))" || rel === "[A]"|| rel === "[[A]]"|| rel === "[[[A]]]"|| rel === "{{{A}}}"|| rel === "{{A}}"|| rel === "{A}"|| rel === "{{{a}}}"|| rel === "{{a}}"|| rel === "{a}"){
                self.additionalDrawings.infoLabels.aLabel.hide();
            }
            if(rel === "B"|| rel === "(B)"|| rel === "((B))"|| rel === "(((B)))"|| rel === "(b)"|| rel === "((b))"|| rel === "(((b)))" || rel === "[B]"|| rel === "[[B]]"|| rel === "[[[B]]]"|| rel === "{{{B}}}"|| rel === "{{B}}"|| rel === "{B}"|| rel === "{{{b}}}"|| rel === "{{b}}"|| rel === "{b}"){
                self.additionalDrawings.infoLabels.bLabel.hide();
            }
            if(rel === "C"|| rel === "(C)"|| rel === "((C))"|| rel === "(((C)))"|| rel === "(c)"|| rel === "((c))"|| rel === "(((c)))" || rel === "[C]"|| rel === "[[C]]"|| rel === "[[[C]]]"|| rel === "{{{C}}}"|| rel === "{{C}}"|| rel === "{C}"|| rel === "{{{c}}}"|| rel === "{{c}}"|| rel === "{c}"){
                self.additionalDrawings.infoLabels.cLabel.hide();
            }
        }
    });
    return labelData;
};

infChart.elliotCorrectiveWaveDrawing.prototype.getNextPointOptions = function () {
    var ann = this.annotation;
    var completedSteps = ann.options.completedSteps;
    var pointOptions = { name: "o" };
    switch (completedSteps) {
        case 1:
            pointOptions.name = "a";
            break;
        case 2:
            pointOptions.name = "b";
            break;
        case 3:
            pointOptions.name = "c";
            break;
    }
    return pointOptions;
};

/**
* Returns the paths, values and positions of the shapes under this drawing
* @returns {object} pattern shapes
*/
infChart.elliotCorrectiveWaveDrawing.prototype.getPatternShapes = function (updateNearestValues) {
    var nameAdditionalY = 25;
    var patternPaths = {};

    var ann = this.annotation;
    var chart = ann.chart;
    var options = ann.options;
    var intermediatePoints = options.intermediatePoints;
    var intermediatePointsRaw = this.intermediatePoints;
    var xAxis = chart.xAxis[options.xAxis];
    var yAxis = chart.yAxis[options.yAxis];

    var waveDegreeSelected;
    this.waveDegrees.forEach(function(value, index){
        if(value.name === options.currentWaveDegree){
            waveDegreeSelected = value;
        }
    });

    var x = xAxis.toPixels(options.xValue);
    var y = yAxis.toPixels(options.yValue);

    var intermediate = this.getIntermediatePointsSnappedValues(updateNearestValues);
    var ax = intermediate && intermediate[0] && intermediate[0].x;
    var ay = intermediate && intermediate[0] && intermediate[0].y;
    var bx = intermediate && intermediate[1] && intermediate[1].x;
    var by = intermediate && intermediate[1] && intermediate[1].y;

    var futureValue = chart.series[0].xData[chart.series[0].xData.length-1];
    if(updateNearestValues){
        var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);
        if(futureValue >=  nearestDataForXValueEnd.xData){
            options.nearestXValueEnd = nearestDataForXValueEnd.xData;
            var nearestEndValue = this.getNearestYValue(options.yValueEnd, nearestDataForXValueEnd, undefined, options.isSnapTopHighLow);
            options.nearestYValueEnd = nearestEndValue.nearestYValue;
            options.endTopOfthePoint = nearestEndValue.topOfThePoint;
        } else {
            options.nearestXValueEnd = nearestDataForXValueEnd.xData;
            options.nearestYValueEnd = options.yValueEnd;
            options.endTopOfthePoint = true;
        }
    }
    var newXEnd = xAxis.toPixels(options.nearestXValueEnd) - x;
    var newYEnd = yAxis.toPixels(options.nearestYValueEnd) - y;
    var cx = options.xValueEnd && newXEnd;
    var cy = options.yValueEnd && newYEnd;

    if (cx !== undefined) {
        if (y < 0) {
            patternPaths.namePosition = { x: (cx) / 2, y: (cy) / 2 + nameAdditionalY };
        } else {
            patternPaths.namePosition = { x: (x + bx) / 2, y: (y + by) / 2 + nameAdditionalY };
        }
    }

    if(updateNearestValues){
        var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
        if(futureValue >=  nearestDataForXValue.xData){
            options.nearestXValue = nearestDataForXValue.xData;
            var nearestStartValue = this.getNearestYValue(options.yValue, nearestDataForXValue, undefined, options.isSnapTopHighLow);
            options.nearestYValue = nearestStartValue.nearestYValue;
            options.startTopOfthePoint = nearestStartValue.topOfThePoint;
        } else {
            options.nearestXValue = nearestDataForXValue.xData;
            options.nearestYValue = options.yValue;
            options.startTopOfthePoint = true;
        }
    }
    var newX = xAxis.toPixels(options.nearestXValue) - x;
    var newY = yAxis.toPixels(options.nearestYValue) - y;
    patternPaths.oCirclePosition = { x: newX, y: newY };

    patternPaths.positions = {
        pointLabels: {
            o: { x: newX, y: options.startTopOfthePoint ? -25 + newY : 5 + newY, label: waveDegreeSelected.options[0],  xValue: options.nearestXValue, yValue: options.nearestYValue, topOfThePoint: options.startTopOfthePoint}
        },
        circles: {
            o: { x: newX, y: newY },
            a: { x: ax, y: ay },
            b: { x: bx, y: by },
            c: { x: cx, y: cy }
        }
    };

    patternPaths.positions.axisClips = {};

    patternPaths.values = {
        o: {
            xValue: options.xValue,
            yValue: this.yValue,
            optionXValue: options.xValue,
            optionYValue: options.yValue
        }
    };

    if (ax !== undefined) {
        patternPaths.aCirclePosition = { x: ax, y: ay };
        patternPaths.positions.pointLabels.a = { x: ax, y: intermediate[0].topOfThePoint ? ay - 25 : ay + 5, label: waveDegreeSelected.options[1], xValue: intermediate[0].xValue, yValue: intermediate[0].yValue, topOfThePoint: intermediate[0].topOfThePoint};
        patternPaths.values.a = {
            xValue: intermediatePoints[0].xValue,
            yValue: intermediatePointsRaw[0] ? intermediatePointsRaw[0].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[0].yValue),
            optionXValue: intermediatePoints[0].xValue,
            optionYValue: intermediatePoints[0].yValue
        };

    }

    if (bx !== undefined) {
        patternPaths.bCirclePosition = { x: bx, y: by };
        patternPaths.positions.pointLabels.b = { x: bx, y: intermediate[1].topOfThePoint ? by - 25 : by + 5, label: waveDegreeSelected.options[2], xValue: intermediate[1].xValue, yValue: intermediate[1].yValue, topOfThePoint: intermediate[1].topOfThePoint };
        patternPaths.values.b = {
            xValue: intermediatePoints[1].xValue,
            yValue: intermediatePointsRaw[1] ? intermediatePointsRaw[1].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[1].yValue),
            optionXValue: intermediatePoints[1].xValue,
            optionYValue: intermediatePoints[1].yValue
        };

    }
    if (cx !== undefined) {
        patternPaths.cCirclePosition = { x: cx, y: cy };
        patternPaths.positions.pointLabels.c = { x: cx, y: options.endTopOfthePoint ? cy - 25 : cy + 5, label: waveDegreeSelected.options[3], xValue: options.nearestXValueEnd, yValue: options.nearestYValueEnd, topOfThePoint: options.endTopOfthePoint };
        patternPaths.values.c = {
            xValue: options.xValueEnd,
            yValue: this.yValueEnd !== undefined ? this.yValueEnd : infChart.drawingUtils.common.getBaseYValue.call(this, options.yValueEnd),
            optionXValue: options.xValueEnd,
            optionYValue: options.yValueEnd
        };

    }
    return patternPaths;
};

infChart.elliotCorrectiveWaveDrawing.prototype.getSettingsPopup = function () {
    var common = infChart.drawingUtils.common;
    return infChart.structureManager.drawingTools.getElliotWaveSettings(infChart.manager.getLabel('label.elliotCorrectiveWave'), common.baseBorderColor, this.annotation.options.currentWaveDegree, this.waveDegrees, this.fontSize);
};

infChart.elliotCorrectiveWaveDrawing.prototype.finalizeEachPoint = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        line,
        additionalDrawingsArr = self.additionalDrawings,
        pointNamesArr = ["o", "a", "b", "c"];
        var currentColor;

    line = self.getBasePatternLine(true);
    infChart.util.forEach(self.waveDegrees, function(index , value){
        if(self.waveDegrees[index].id === options.currentWaveDegree){
            currentColor = self.waveDegrees[index].color;
        }
    });

    ann.update({
        shape: {
            params: {
                d: line,
                'stroke': options.shape.params.stroke ? options.shape.params.stroke : currentColor,
            }
        }
    });

    var lineShapes = self.getPatternShapes(true);

    lineShapes.namePosition && additionalDrawingsArr.labels["nameLabel"] && additionalDrawingsArr.labels["nameLabel"].attr({
        x: lineShapes.namePosition.x,
        y: lineShapes.namePosition.y
    });

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        var label = additionalDrawingsArr.labels[value + "Label"];
        label && label.attr({ x: labelPosition.x - label.width/2, y: labelPosition.y });
        // circles
        if (additionalDrawingsArr.circles[value]) {
            var circlePositions = lineShapes.positions["circles"][value];
            additionalDrawingsArr.circles[value].attr({ x: circlePositions.x, y: circlePositions.y });
        }
    });
    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId, true);
    if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
        self.getSnappedValues();
        self.calculateAndUpdateInfoLabel(true);
    }
    infChart.drawingUtils.common.saveBaseYValues.call(self, ann.options.yValue, ann.options.yValueEnd, undefined, ann.options.intermediatePoints);
    infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd, ann.options.nearestTrendYValue, ann.options.nearestIntermediatePoints);
};

/**
* Scale function of the tool
*/
infChart.elliotCorrectiveWaveDrawing.prototype.scale = function (isCalculateNewValueForScale) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        line,
        additionalDrawingsArr = self.additionalDrawings,
        pointNamesArr = ["o", "a", "b", "c"];
        var currentColor;

    line = self.getBasePatternLine(isCalculateNewValueForScale);
    infChart.util.forEach(self.waveDegrees, function(index , value){
        if(self.waveDegrees[index].id === options.currentWaveDegree){
            currentColor = self.waveDegrees[index].color;
        }
    });

    ann.update({
        shape: {
            params: {
                d: line,
                'stroke': options.shape.params.stroke ? options.shape.params.stroke : currentColor,
            }
        }
    });

    var lineShapes = self.getPatternShapes(isCalculateNewValueForScale);

    lineShapes.namePosition && additionalDrawingsArr.labels["nameLabel"] && additionalDrawingsArr.labels["nameLabel"].attr({
        x: lineShapes.namePosition.x,
        y: lineShapes.namePosition.y
    });

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        var label = additionalDrawingsArr.labels[value + "Label"];
        label && label.attr({ x: labelPosition.x - label.width/2, y: labelPosition.y });
        // circles
        if (additionalDrawingsArr.circles[value]) {
            var circlePositions = lineShapes.positions["circles"][value];
            additionalDrawingsArr.circles[value].attr({ x: circlePositions.x, y: circlePositions.y });
        }
    });
    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId, isCalculateNewValueForScale);
    if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
        self.calculateAndUpdateInfoLabel(isCalculateNewValueForScale);
    }
};

infChart.elliotCorrectiveWaveDrawing.prototype.setSelectionMarkers = function () {
    var self = this;
    var ann = self.annotation;
    var lineShapes = self.getPatternShapes();
    var additionalDrawingsArr = self.additionalDrawings;

    if (!ann.selectionMarker.length) {
        infChart.util.forEach(["o", "a", "b", "c"], function (index, value) {
            var circlePosition = lineShapes.positions["circles"][value];
            if (circlePosition && circlePosition.x != undefined && circlePosition.y != undefined) {
                additionalDrawingsArr.circles[value] = infChart.drawingUtils.common.addAndBindSelectionMarker.call(self, ann, circlePosition.x, circlePosition.y, self.stepFunction, self.stop, true, undefined, { name: value });
            }
         });

        var clipPosX = lineShapes.positions.axisClips.x;
        var clipPosY = lineShapes.positions.axisClips.y;
        if (clipPosY && !additionalDrawingsArr.rect.y && clipPosX && !additionalDrawingsArr.rect.x) {
            ann.selectionMarker.push(additionalDrawingsArr.rect.x);
            ann.selectionMarker.push(additionalDrawingsArr.rect.y);
        }

    }
};

/**
* Step function
* @param {Event} e event
* @param {boolean} isStartPoint indicate whether the start or not
*/
infChart.elliotCorrectiveWaveDrawing.prototype.step = function (e, isStartPoint, itemProperties) {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        pointx = xAxis.toValue(e.chartX),
        pointy = yAxis.toValue(e.chartY),
        intermediatePoints = options.intermediatePoints,
        newOtions = {};
    switch (itemProperties.name) {
        case 'a':
            if (!intermediatePoints[0]) {
                intermediatePoints[0] = {};
            }
            intermediatePoints[0].xValue = pointx;
            intermediatePoints[0].yValue = pointy;
            break;
        case 'b':
            if (!intermediatePoints[1]) {
                intermediatePoints[1] = {};
            }
            intermediatePoints[1].xValue = pointx;
            intermediatePoints[1].yValue = pointy;
            break;
        case 'c':
            newOtions.xValueEnd = pointx;
            newOtions.yValueEnd = pointy;
            break;
        case 'o':
            newOtions.xValue = pointx;
            newOtions.yValue = pointy;
            break;
        default:
            break;
    }
    newOtions.intermediatePoints = intermediatePoints;
    ann.update(newOtions);
    this.finalizeEachPoint();
};

/**
 * Stop function
 * @param {Event} e event
 * @param {boolean} isStartPoint indicate whether the start or not
 */
infChart.elliotCorrectiveWaveDrawing.prototype.stop = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        lineShapes = self.getPatternShapes(true),
        additionalDrawingsArr = self.additionalDrawings;

    // point Labels
    if (!additionalDrawingsArr.labels["cLabel"]) {
        var labelPosition = lineShapes.positions["pointLabels"]["c"];
        labelPosition && (additionalDrawingsArr.labels["cLabel"] = self.getLabel(labelPosition.label, labelPosition.x, labelPosition.y));
        label = additionalDrawingsArr.labels["cLabel"];
        if(label){
            label.attr({x: labelPosition.x - label.width/2});
        }
    }

    if (!additionalDrawingsArr.infoLabels["cLabel"]) {
        var labelPosition = lineShapes.positions["pointLabels"]["c"];
        labelPosition && (additionalDrawingsArr.infoLabels["cLabel"] = self.getInfoLabel(labelPosition.label, labelPosition.x, labelPosition.y));
    }
    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId, true);
    self.getSnappedValues();
    self.calculateAndUpdateInfoLabel(true);
    self.select();

    infChart.drawingUtils.common.saveBaseYValues.call(self, ann.options.yValue, ann.options.yValueEnd, undefined, ann.options.intermediatePoints);
    infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd, undefined, ann.options.nearestIntermediatePoints);
    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
};

infChart.elliotCorrectiveWaveDrawing.prototype.hasMoreIntermediateSteps = function () {
    return !(this.annotation.options.completedSteps === 3);
};

infChart.elliotCorrectiveWaveDrawing.prototype.calculateAndUpdateInfoLabel = function (isCalculateNewValues) {
    var self = this, 
        ann = self.annotation,
        options = ann.options,
        line = ann.shape.d.split(' '),
        chart = ann.chart,
        additionalDrawingsArr = self.additionalDrawings,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis];

    var snappedValues = self.getSnappedValues();
    var infoLabelTypes = ["oLabel", "aLabel", "bLabel", "cLabel"];

    var waveDegreeSelected;
    this.waveDegrees.forEach(function(value, index){
        if(value.name === options.currentWaveDegree){
            waveDegreeSelected = value;
        }
    });

    infChart.util.forEach(snappedValues, function (index, value) {       
        var calculatedLabelData = {
            price: snappedValues[index].yValue,
            type: self.type + ', ' + waveDegreeSelected.options[index],
            priceDifference: index !== 0 ?  Math.abs(snappedValues[index-1].yValue - snappedValues[index].yValue) : undefined,
            waveDegree: waveDegreeSelected.id
        };
        calculatedLabelData.pricePercentage = (calculatedLabelData.priceDifference >= 0) ? ((calculatedLabelData.priceDifference /calculatedLabelData.price) * 100): undefined;

        var labelData = self.getLabelData(ann, calculatedLabelData);
        var label = additionalDrawingsArr.infoLabels[infoLabelTypes[index]];
        if(labelData && label){
            if(isCalculateNewValues) {
                label.attr({
                    text: labelData
                });
            }

            var labelParameters = self.additionalDrawings.labels[infoLabelTypes[index]];
            var yLabelPosition = labelParameters.y;
            var xLabelPosition = labelParameters.x;

            var labelYValue = yAxis.toValue(yLabelPosition + yAxis.toPixels(options.yValue));
            if (snappedValues[index].yValue > labelYValue) {
                yLabelPosition = yLabelPosition + self.additionalDrawings.labels[infoLabelTypes[index]].height + 5;
            }
            if (snappedValues[index].yValue < labelYValue) {
                yLabelPosition = yLabelPosition - label.height - 5;
            }
            label.attr({
                x: xLabelPosition,
                y: yLabelPosition
            });
        }
    });
}
window.infChart = window.infChart || {};

infChart.elliotCorrectiveDoubleWaveDrawing = function () {
    this.labelDataItems = [
        {id: "price", displayName: "Price", enabled: true},
        {id: "type", displayName: "Type", enabled: true},
        {id: "priceDifference", displayName: "Price Difference", enabled: true},
        {id: "waveDegree", displayName: "Wave Degree", enabled: true}
    ];
    this.waveDegrees = [
        {
            id: "Super Millennium",
            name: "superMillennium",
            label: "label.superMillennium", 
            color: "#78BC61",
            enable: false,
            options:["O", "(((W)))", "(((X)))", "(((Y)))"]
        },
        {
            id: "Millennium", 
            name: "millennium",
            label: "label.millennium",
            color: "#EF6351",
            enable: false,
            options:["O", "((W))", "((X))", "((Y))"]
        },
        {
            id: "Sub Millennium", 
            name: "subMillennium",
            label: "label.subMillennium",
            color: "#3066BE",
            enable: false,
            options:["O", "(W)", "(X)", "(Y)"]
        },
        {
            id: "Grand Super Cycle", 
            name: "grandSuperCycle",
            label: "label.grandSuperCycle",
            color: "#F93943", 
            enable: false,
            options:["O", "(((w)))", "(((x)))", "(((y)))"]
        },
        {
            id: "Super Cycle", 
            name: "superCycle",
            label: "label.superCycle",
            color: "#7E78D2", 
            enable: false,
            options:["O", "((w))", "((x))", "((y))"]
        },
        {
            id: "Cycle", 
            name: "cycle",
            label: "label.cycle",
            color: "#D65780", 
            enable: false,
            options:["O", "(w)", "(x)", "(y)"]
        },
        {
            id: "Primary",
            name: "primary",
            label: "label.primary",
            color: "#6C809A", 
            enable: false,
            options:["O", "{{{W}}}", "{{{X}}}", "{{{Y}}}"]
        },
        {
            id: "Intermediate", 
            name: "intermediate",
            label: "label.intermediate",
            color: "#58A4B0", 
            enable: false,
            options:["O", "{{W}}", "{{X}}", "{{Y}}"]
        },
        {
            id: "Minor", 
            name: "minor",
            label: "label.minor",
            color: "#5E8C61",
            enable: false, 
            options:["O", "{W}", "{X}", "{Y}"]
        },
        {
            id: "Minute", 
            name: "minute",
            label: "label.minute",
            color: "#C89933", 
            enable: false,
            options:["O", "{{{w}}}", "{{{x}}}", "{{{y}}}"]
        },
        {
            id: "Minuette", 
            name: "minuette",
            label: "label.minuette",
            color: "#00A7E1", 
            enable: false,
            options:["O", "{{w}}", "{{x}}", "{{y}}"]
        },
        {
            id: "Sub Minuette", 
            name: "subMinuette",
            label: "label.subMinuette",
            color: "#912F56", 
            enable: false,
            options:["O", "{w}", "{x}", "{y}"]
        },
        {
            id: "Micro", 
            name: "micro",
            label: "label.micro",
            color: "#9D75CB", 
            enable: true,
            options:["O", "[[[W]]]", "[[[X]]]", "[[[Y]]]"]
        },
        {
            id: "Sub Micro", 
            name: "subMicro",
            label: "label.subMicro",
            color: "#FE7B72",
            enable: false, 
            options:["O", "[[W]]", "[[X]]", "[[Y]]"]
        },
        {
            id: "Nano", 
            name: "nano",
            label: "label.nano",
            color: "#8D818C", 
            enable: false,
            options:["O", "[W]", "[X]", "[Y]"]
        },
        {
            id: "Sub Nano",
            name: "subNano",
            label: "label.subNano", 
            color: "#387D7A", 
            enable: false,
            options:["O", "W", "X", "Y"]
        }
    ]
    this.labelValueNames = ["oLabel", "wLabel", "xLabel", "yLabel"];
    this.type = "Corrective Double";
    this.currentWaveDegree = "micro";
    infChart.elliotWaveDrawing.apply(this, arguments);
};

infChart.elliotCorrectiveDoubleWaveDrawing.prototype = Object.create(infChart.elliotWaveDrawing.prototype);

/**
* set additional drawings of the tool
*/
infChart.elliotCorrectiveDoubleWaveDrawing.prototype.additionalDrawingsFunction = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        yAxis = chart.yAxis[options.yAxis],
        lineShapes = self.getPatternShapes(true),
        additionalDrawingsArr = self.additionalDrawings,
        theme = infChart.drawingUtils.common.getTheme(),
        shapeTheme = theme["elliotCorrectiveDoubleWave"],
        pointNamesArr = ["o", "w", "x", "y"];

    additionalDrawingsArr.lines = {};
    additionalDrawingsArr.labels = {};
    additionalDrawingsArr.circles = {};
    additionalDrawingsArr.axisLabels = {};
    additionalDrawingsArr.rect = {};
    additionalDrawingsArr.infoLabels = {};

    ann.selectionMarker = [];
    self.setSelectionMarkers();

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        labelPosition && (additionalDrawingsArr.infoLabels[value + "Label"] = self.getInfoLabel(labelPosition.label, labelPosition.x, labelPosition.y));
    });

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        labelPosition && (additionalDrawingsArr.labels[value + "Label"] = self.getLabel(labelPosition.label, labelPosition.x, labelPosition.y));
        label = additionalDrawingsArr.labels[value + "Label"];
        if(label){
            label.attr({x: labelPosition.x - label.width/2});
        }
    });
};

infChart.elliotCorrectiveDoubleWaveDrawing.prototype.getClickValues = function (clickX, clickY) {
    var ann = this.annotation;
    var chart = ann.chart;
    var options = ann.options;
    var xAxis = chart.xAxis[options.xAxis];
    var yAxis = chart.yAxis[options.yAxis];
    var completedSteps = this.annotation.options.completedSteps;
    var coordinates = {
        xValue: options.xValue,
        yValue: options.yValue,
        intermediatePoints: options.intermediatePoints
    };
    switch (completedSteps) {
        case 1:
            coordinates.intermediatePoints[0].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[0].yValue = yAxis.toValue(clickY);
            break;
        case 2:
            coordinates.intermediatePoints[1].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[1].yValue = yAxis.toValue(clickY);
            break;
        case 3:
            coordinates.xValueEnd = xAxis.toValue(clickX);
            coordinates.yValueEnd = yAxis.toValue(clickY);
            break;
    }
    return coordinates;
};

/**
* Returns the config to save
* @returns {{shape: string, borderColor: *, strokeWidth: *, xValue: *, yValue: *, xValueEnd: *, yValueEnd: *, intermediatePoints: Array}} config object
*/
infChart.elliotCorrectiveDoubleWaveDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    var intermediatePoints = [];

    infChart.util.forEach(annotation.options.intermediatePoints, function(index , value){
        intermediatePoints.push({
            xValue: value.xValue,
            yValue: value.yValue
        });
    });

    return {
        shape: 'elliotCorrectiveDoubleWave',
        borderColor: annotation.options.shape.params.stroke,
        strokeWidth: annotation.options.shape.params['stroke-width'],
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        intermediatePoints: intermediatePoints,
        fillColor: 'none',
        currentWaveDegree: annotation.options.currentWaveDegree,
        nearestXValue: annotation.options.nearestXValue,
        nearestXValueEnd: annotation.options.nearestXValueEnd,
        nearestYValue: annotation.options.nearestYValue,
        nearestYValueEnd: annotation.options.nearestYValueEnd,
        startTopOfthePoint: annotation.options.startTopOfthePoint,
        endTopOfthePoint: annotation.options.endTopOfthePoint,
        nearestIntermediatePoints: annotation.options.nearestIntermediatePoints,
        isSnapTopHighLow: annotation.options.isSnapTopHighLow,
        textFontSize: annotation.options.textFontSize,
    };
};

/**
 * Create a label and add to the group
 * @param {String} name label text
 * @param {number} x x position
 * @param {number} y y position
 * @returns {SVGElement} the generated label
 */
infChart.elliotCorrectiveDoubleWaveDrawing.prototype.getLabel = function (name, x, y) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        theme = infChart.drawingUtils.common.getTheme(),
        shapeTheme = theme["elliotCorrectiveDoubleWave"];
        var currentColor;

        infChart.util.forEach(self.waveDegrees, function(index , value){
            if(self.waveDegrees[index].name === options.currentWaveDegree){
                currentColor = self.waveDegrees[index].color;
            }
        });

    var labelData = chart.renderer.label(name, x, y).attr({
        'zIndex': 20,
        'r': 3,
        'opacity': shapeTheme && shapeTheme.label && shapeTheme.label.opacity || 1,
        'stroke': options.shape.params.stroke ? options.shape.params.stroke : currentColor,//shapeTheme && shapeTheme.label && shapeTheme.label.stroke || "#858587",
        'stroke-width': 0,
        'hAlign': 'center',
        'class': 'harmonic-lbl',
        'rel': name,
    }).add(ann.group).css(
        {
            color: options.shape.params.stroke ? options.shape.params.stroke : currentColor,//shapeTheme && shapeTheme.label && shapeTheme.label.stroke || "#858587",
            fontSize: options.textFontSize || '16px',
            cursor: 'pointer',
            fontWeight: '700',
            fontStyle: 'normal',
            textDecoration: 'inherit'
        });

    $(labelData.element).mouseover(function (event) {
        event.stopPropagation();
        if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
            var rel = event.currentTarget.getAttribute('rel');
            if(rel === "O"){
                self.additionalDrawings.infoLabels.oLabel.show();
            }
            if(rel === "W"|| rel === "(W)"|| rel === "((W))"|| rel === "(((W)))"|| rel === "(w)"|| rel === "((w))"|| rel === "(((w)))" || rel === "[W]"|| rel === "[[W]]"|| rel === "[[[W]]]"|| rel === "{{{W}}}"|| rel === "{{W}}"|| rel === "{W}"|| rel === "{{{w}}}"|| rel === "{{w}}"|| rel === "{w}"){
                self.additionalDrawings.infoLabels.wLabel.show();
            }
            if(rel === "X"|| rel === "(X)"|| rel === "((X))"|| rel === "(((X)))"|| rel === "(x)"|| rel === "((x))"|| rel === "(((x)))" || rel === "[X]"|| rel === "[[X]]"|| rel === "[[[X]]]"|| rel === "{{{X}}}"|| rel === "{{X}}"|| rel === "{X}"|| rel === "{{{x}}}"|| rel === "{{x}}"|| rel === "{x}"){
                self.additionalDrawings.infoLabels.xLabel.show();
            }
            if(rel === "Y"|| rel === "(Y)"|| rel === "((Y))"|| rel === "(((Y)))"|| rel === "(y)"|| rel === "((y))"|| rel === "(((y)))" || rel === "[Y]"|| rel === "[[Y]]"|| rel === "[[[Y]]]"|| rel === "{{{Y}}}"|| rel === "{{Y}}"|| rel === "{Y}"|| rel === "{{{y}}}"|| rel === "{{y}}"|| rel === "{y}"){
                self.additionalDrawings.infoLabels.yLabel.show();
            }
        }
    });

    $(labelData.element).mouseleave(function (event) {
        event.stopPropagation();
        if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
            var rel = event.currentTarget.getAttribute('rel');
            if(rel === "O"){
                self.additionalDrawings.infoLabels.oLabel.hide();
            }
            if(rel === "W"|| rel === "(W)"|| rel === "((W))"|| rel === "(((W)))"|| rel === "(w)"|| rel === "((w))"|| rel === "(((w)))" || rel === "[W]"|| rel === "[[W]]"|| rel === "[[[W]]]"|| rel === "{{{W}}}"|| rel === "{{W}}"|| rel === "{W}"|| rel === "{{{w}}}"|| rel === "{{w}}"|| rel === "{w}"){
                self.additionalDrawings.infoLabels.wLabel.hide();
            }
            if(rel === "X"|| rel === "(X)"|| rel === "((X))"|| rel === "(((X)))"|| rel === "(x)"|| rel === "((x))"|| rel === "(((x)))" || rel === "[X]"|| rel === "[[X]]"|| rel === "[[[X]]]"|| rel === "{{{X}}}"|| rel === "{{X}}"|| rel === "{X}"|| rel === "{{{x}}}"|| rel === "{{x}}"|| rel === "{x}"){
                self.additionalDrawings.infoLabels.xLabel.hide();
            }
            if(rel === "Y"|| rel === "(Y)"|| rel === "((Y))"|| rel === "(((Y)))"|| rel === "(y)"|| rel === "((y))"|| rel === "(((y)))" || rel === "[Y]"|| rel === "[[Y]]"|| rel === "[[[Y]]]"|| rel === "{{{Y}}}"|| rel === "{{Y}}"|| rel === "{Y}"|| rel === "{{{y}}}"|| rel === "{{y}}"|| rel === "{y}"){
                self.additionalDrawings.infoLabels.yLabel.hide();
            }
        }
    });
    return labelData;
};

infChart.elliotCorrectiveDoubleWaveDrawing.prototype.getNextPointOptions = function () {
    var ann = this.annotation;
    var completedSteps = ann.options.completedSteps;
    var pointOptions = { name: "o" };
    switch (completedSteps) {
        case 1:
            pointOptions.name = "w";
            break;
        case 2:
            pointOptions.name = "x";
            break;
        case 3:
            pointOptions.name = "y";
            break;
    }
    return pointOptions;
};

/**
* Returns the paths, values and positions of the shapes under this drawing
* @returns {object} pattern shapes
*/
infChart.elliotCorrectiveDoubleWaveDrawing.prototype.getPatternShapes = function (updateNearestValues) {
    var nameAdditionalY = 25;
    var patternPaths = {};

    var ann = this.annotation;
    var chart = ann.chart;
    var options = ann.options;
    var intermediatePoints = options.intermediatePoints;
    var intermediatePointsRaw = this.intermediatePoints;
    var xAxis = chart.xAxis[options.xAxis];
    var yAxis = chart.yAxis[options.yAxis];

    var waveDegreeSelected;
    this.waveDegrees.forEach(function(value, index){
        if(value.name === options.currentWaveDegree){
            waveDegreeSelected = value;
        }
    });

    var x = xAxis.toPixels(options.xValue);
    var y = yAxis.toPixels(options.yValue);

    var intermediate = this.getIntermediatePointsSnappedValues(updateNearestValues);
    var ax = intermediate && intermediate[0] && intermediate[0].x;
    var ay = intermediate && intermediate[0] && intermediate[0].y;
    var bx = intermediate && intermediate[1] && intermediate[1].x;
    var by = intermediate && intermediate[1] && intermediate[1].y;

    var futureValue = chart.series[0].xData[chart.series[0].xData.length-1];
    if(updateNearestValues){
        var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);
        if(futureValue >=  nearestDataForXValueEnd.xData){
            options.nearestXValueEnd = nearestDataForXValueEnd.xData;
            var nearestEndValue = this.getNearestYValue(options.yValueEnd, nearestDataForXValueEnd,undefined, options.isSnapTopHighLow);
            options.nearestYValueEnd = nearestEndValue.nearestYValue;
            options.endTopOfthePoint = nearestEndValue.topOfThePoint;
        } else {
            options.nearestXValueEnd = nearestDataForXValueEnd.xData;
            options.nearestYValueEnd = options.yValueEnd;
            options.endTopOfthePoint = true;
        }
    }
    var newXEnd = xAxis.toPixels(options.nearestXValueEnd) - x;
    var newYEnd = yAxis.toPixels(options.nearestYValueEnd) - y;
    var cx = options.xValueEnd && newXEnd;
    var cy = options.yValueEnd && newYEnd;

    if (cx !== undefined) {
        if (y < 0) {
            patternPaths.namePosition = { x: (cx) / 2, y: (cy) / 2 + nameAdditionalY };
        } else {
            patternPaths.namePosition = { x: (x + bx) / 2, y: (y + by) / 2 + nameAdditionalY };
        }
    }

    if(updateNearestValues){
        var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
        if(futureValue >=  nearestDataForXValue.xData){
            options.nearestXValue = nearestDataForXValue.xData;
            var nearestStartValue = this.getNearestYValue(options.yValue, nearestDataForXValue, undefined,options.isSnapTopHighLow);
            options.nearestYValue = nearestStartValue.nearestYValue;
            options.startTopOfthePoint = nearestStartValue.topOfThePoint;
        } else {
            options.nearestXValue = nearestDataForXValue.xData;
            options.nearestYValue = options.yValue;
            options.startTopOfthePoint = true;
        }
    }
    var newX = xAxis.toPixels(options.nearestXValue) - x;
    var newY = yAxis.toPixels(options.nearestYValue) - y;
    patternPaths.oCirclePosition = { x: newX, y: newY };

    patternPaths.positions = {
        pointLabels: {
            o: { x: newX, y: options.startTopOfthePoint ? -25 + newY : 5 + newY, label: waveDegreeSelected.options[0],  xValue: options.nearestXValue, yValue: options.nearestYValue, topOfThePoint: options.startTopOfthePoin}
        },
        circles: {
            o: { x: newX, y: newY },
            w: { x: ax, y: ay },
            x: { x: bx, y: by },
            y: { x: cx, y: cy }
        }
    };

    patternPaths.positions.axisClips = {};

    patternPaths.values = {
        o: {
            xValue: options.xValue,
            yValue: this.yValue,
            optionXValue: options.xValue,
            optionYValue: options.yValue
        }
    };

    if (ax !== undefined) {
        patternPaths.wCirclePosition = { x: ax, y: ay };
        patternPaths.positions.pointLabels.w = { x: ax, y: intermediate[0].topOfThePoint ? ay - 25 : ay + 5, label: waveDegreeSelected.options[1], xValue: intermediate[0].xValue, yValue: intermediate[0].yValue, topOfThePoint: intermediate[0].topOfThePoint};
        patternPaths.values.w = {
            xValue: intermediatePoints[0].xValue,
            yValue: intermediatePointsRaw[0] ? intermediatePointsRaw[0].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[0].yValue),
            optionXValue: intermediatePoints[0].xValue,
            optionYValue: intermediatePoints[0].yValue
        };

    }

    if (bx !== undefined) {
        patternPaths.xCirclePosition = { x: bx, y: by };
        patternPaths.positions.pointLabels.x = { x: bx, y: intermediate[1].topOfThePoint ? by - 25 : by + 5, label: waveDegreeSelected.options[2], xValue: intermediate[1].xValue, yValue: intermediate[1].yValue, topOfThePoint: intermediate[1].topOfThePoint };
        patternPaths.values.x = {
            xValue: intermediatePoints[1].xValue,
            yValue: intermediatePointsRaw[1] ? intermediatePointsRaw[1].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[1].yValue),
            optionXValue: intermediatePoints[1].xValue,
            optionYValue: intermediatePoints[1].yValue
        };

    }
    if (cx !== undefined) {
        patternPaths.yCirclePosition = { x: cx, y: cy };
        patternPaths.positions.pointLabels.y = { x: cx, y: options.endTopOfthePoint ? cy - 25 : cy + 5, label: waveDegreeSelected.options[3], xValue: options.nearestXValueEnd, yValue: options.nearestYValueEnd, topOfThePoint: options.endTopOfthePoint };
        patternPaths.values.y = {
            xValue: options.xValueEnd,
            yValue: this.yValueEnd !== undefined ? this.yValueEnd : infChart.drawingUtils.common.getBaseYValue.call(this, options.yValueEnd),
            optionXValue: options.xValueEnd,
            optionYValue: options.yValueEnd
        };

    }
    return patternPaths;
};

infChart.elliotCorrectiveDoubleWaveDrawing.prototype.getSettingsPopup = function () {
    var common = infChart.drawingUtils.common;
    return infChart.structureManager.drawingTools.getElliotWaveSettings(infChart.manager.getLabel('label.elliotCorrectiveDoubleWave'), common.baseBorderColor, this.annotation.options.currentWaveDegree, this.waveDegrees, this.fontSize);
};

infChart.elliotCorrectiveDoubleWaveDrawing.prototype.finalizeEachPoint = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        line,
        additionalDrawingsArr = self.additionalDrawings,
        pointNamesArr = ["o", "w", "x", "y"];
        var currentColor;

    line = self.getBasePatternLine(true);
    infChart.util.forEach(self.waveDegrees, function(index , value){
        if(self.waveDegrees[index].id === options.currentWaveDegree){
            currentColor = self.waveDegrees[index].color;
        }
    });

    ann.update({
        shape: {
            params: {
                d: line,
                'stroke': options.shape.params.stroke ? options.shape.params.stroke : currentColor,
            }
        }
    });

    var lineShapes = self.getPatternShapes(true);

    lineShapes.namePosition && additionalDrawingsArr.labels["nameLabel"] && additionalDrawingsArr.labels["nameLabel"].attr({
        x: lineShapes.namePosition.x,
        y: lineShapes.namePosition.y
    });

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        var label = additionalDrawingsArr.labels[value + "Label"];
        label && label.attr({ x: labelPosition.x - label.width/2, y: labelPosition.y });
        // circles
        if (additionalDrawingsArr.circles[value]) {
            var circlePositions = lineShapes.positions["circles"][value];
            additionalDrawingsArr.circles[value].attr({ x: circlePositions.x, y: circlePositions.y });
        }
    });
    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId, true);
    if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
        self.calculateAndUpdateInfoLabel(true);
    }
    infChart.drawingUtils.common.saveBaseYValues.call(self, ann.options.yValue, ann.options.yValueEnd, undefined, ann.options.intermediatePoints);
    infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd, ann.options.nearestTrendYValue, ann.options.nearestIntermediatePoints);
};

/**
* Scale function of the tool
*/
infChart.elliotCorrectiveDoubleWaveDrawing.prototype.scale = function (isCalculateNewValueForScale) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        line,
        additionalDrawingsArr = self.additionalDrawings,
        pointNamesArr = ["o", "w", "x", "y"];
        var currentColor;

    line = self.getBasePatternLine(isCalculateNewValueForScale);
    infChart.util.forEach(self.waveDegrees, function(index , value){
        if(self.waveDegrees[index].id === options.currentWaveDegree){
            currentColor = self.waveDegrees[index].color;
        }
    });

    ann.update({
        shape: {
            params: {
                d: line,
                'stroke': options.shape.params.stroke ? options.shape.params.stroke : currentColor,
            }
        }
    });

    var lineShapes = self.getPatternShapes(isCalculateNewValueForScale);

    lineShapes.namePosition && additionalDrawingsArr.labels["nameLabel"] && additionalDrawingsArr.labels["nameLabel"].attr({
        x: lineShapes.namePosition.x,
        y: lineShapes.namePosition.y
    });

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        var label = additionalDrawingsArr.labels[value + "Label"];
        label && label.attr({ x: labelPosition.x - label.width/2, y: labelPosition.y });
        // circles
        if (additionalDrawingsArr.circles[value]) {
            var circlePositions = lineShapes.positions["circles"][value];
            additionalDrawingsArr.circles[value].attr({ x: circlePositions.x, y: circlePositions.y });
        }
    });
    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId, isCalculateNewValueForScale);
    if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
        self.calculateAndUpdateInfoLabel(isCalculateNewValueForScale);
    }
};

infChart.elliotCorrectiveDoubleWaveDrawing.prototype.setSelectionMarkers = function () {
    var self = this;
    var ann = self.annotation;
    var lineShapes = self.getPatternShapes();
    var additionalDrawingsArr = self.additionalDrawings;

    if (!ann.selectionMarker.length) {
        infChart.util.forEach(["o", "w", "x", "y"], function (index, value) {
            var circlePosition = lineShapes.positions["circles"][value];
            if (circlePosition && circlePosition.x != undefined && circlePosition.y != undefined) {
                additionalDrawingsArr.circles[value] = infChart.drawingUtils.common.addAndBindSelectionMarker.call(self, ann, circlePosition.x, circlePosition.y, self.stepFunction, self.stop, true, undefined, { name: value });
            }
         });

        var clipPosX = lineShapes.positions.axisClips.x;
        var clipPosY = lineShapes.positions.axisClips.y;
        if (clipPosY && !additionalDrawingsArr.rect.y && clipPosX && !additionalDrawingsArr.rect.x) {
            ann.selectionMarker.push(additionalDrawingsArr.rect.x);
            ann.selectionMarker.push(additionalDrawingsArr.rect.y);
        }

    }
};

/**
* Step function
* @param {Event} e event
* @param {boolean} isStartPoint indicate whether the start or not
*/
infChart.elliotCorrectiveDoubleWaveDrawing.prototype.step = function (e, isStartPoint, itemProperties) {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        pointx = xAxis.toValue(e.chartX),
        pointy = yAxis.toValue(e.chartY),
        intermediatePoints = options.intermediatePoints,
        newOtions = {};
    switch (itemProperties.name) {
        case 'w':
            if (!intermediatePoints[0]) {
                intermediatePoints[0] = {};
            }
            intermediatePoints[0].xValue = pointx;
            intermediatePoints[0].yValue = pointy;
            break;
        case 'x':
            if (!intermediatePoints[1]) {
                intermediatePoints[1] = {};
            }
            intermediatePoints[1].xValue = pointx;
            intermediatePoints[1].yValue = pointy;
            break;
        case 'y':
            newOtions.xValueEnd = pointx;
            newOtions.yValueEnd = pointy;
            break;
        case 'o':
            newOtions.xValue = pointx;
            newOtions.yValue = pointy;
            break;
        default:
            break;
    }
    newOtions.intermediatePoints = intermediatePoints;
    ann.update(newOtions);
    this.finalizeEachPoint();
};

/**
 * Stop function
 * @param {Event} e event
 * @param {boolean} isStartPoint indicate whether the start or not
 */
infChart.elliotCorrectiveDoubleWaveDrawing.prototype.stop = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        lineShapes = self.getPatternShapes(true),
        additionalDrawingsArr = self.additionalDrawings;

    // point Labels
    if (!additionalDrawingsArr.labels["yLabel"]) {
        var labelPosition = lineShapes.positions["pointLabels"]["y"];
        labelPosition && (additionalDrawingsArr.labels["yLabel"] = self.getLabel(labelPosition.label, labelPosition.x, labelPosition.y));
        label = additionalDrawingsArr.labels["yLabel"];
        if(label){
            label.attr({x: labelPosition.x - label.width/2});
        }
    }

    if (!additionalDrawingsArr.infoLabels["yLabel"]) {
        var labelPosition = lineShapes.positions["pointLabels"]["y"];
        labelPosition && (additionalDrawingsArr.infoLabels["yLabel"] = self.getInfoLabel(labelPosition.label, labelPosition.x, labelPosition.y));
    }
    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId, true);
    self.getSnappedValues();
    self.calculateAndUpdateInfoLabel(true);
    self.select();

    infChart.drawingUtils.common.saveBaseYValues.call(self, ann.options.yValue, ann.options.yValueEnd, undefined, ann.options.intermediatePoints);
    infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd, undefined, ann.options.nearestIntermediatePoints);
    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
};

infChart.elliotCorrectiveDoubleWaveDrawing.prototype.hasMoreIntermediateSteps = function () {
    return !(this.annotation.options.completedSteps === 3);
};

infChart.elliotCorrectiveDoubleWaveDrawing.prototype.calculateAndUpdateInfoLabel = function (isCalculateNewValues) {
    var self = this, 
        ann = self.annotation,
        options = ann.options,
        line = ann.shape.d.split(' '),
        chart = ann.chart,
        additionalDrawingsArr = self.additionalDrawings,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis];

    var snappedValues = self.getSnappedValues();
    var infoLabelTypes = ["oLabel", "wLabel", "xLabel", "yLabel"];

    var waveDegreeSelected;
    this.waveDegrees.forEach(function(value, index){
        if(value.name === options.currentWaveDegree){
            waveDegreeSelected = value;
        }
    });

    infChart.util.forEach(snappedValues, function (index, value) {       
        var calculatedLabelData = {
            price: snappedValues[index].yValue,
            type: self.type + ', ' + waveDegreeSelected.options[index],
            priceDifference: index !== 0 ?  Math.abs(snappedValues[index-1].yValue - snappedValues[index].yValue) : undefined,
            waveDegree: waveDegreeSelected.id
        };
        calculatedLabelData.pricePercentage = (calculatedLabelData.priceDifference >= 0) ? ((calculatedLabelData.priceDifference /calculatedLabelData.price) * 100): undefined;

        var labelData = self.getLabelData(ann, calculatedLabelData);
        var label = additionalDrawingsArr.infoLabels[infoLabelTypes[index]];

        if(labelData && label){
            if(isCalculateNewValues) {
                label.attr({
                    text: labelData
                });
            }

            var labelParameters = self.additionalDrawings.labels[infoLabelTypes[index]];
            var yLabelPosition = labelParameters.y;
            var xLabelPosition = labelParameters.x;

            var labelYValue = yAxis.toValue(yLabelPosition + yAxis.toPixels(options.yValue));
            if (snappedValues[index].yValue > labelYValue) {
                yLabelPosition = yLabelPosition + self.additionalDrawings.labels[infoLabelTypes[index]].height + 5;
            }
            if (snappedValues[index].yValue < labelYValue) {
                yLabelPosition = yLabelPosition - label.height - 5;
            }

            label.attr({
                x: xLabelPosition,
                y: yLabelPosition
            });
        }
    });
}
window.infChart = window.infChart || {};

infChart.elliotCorrectiveTripleWaveDrawing = function () {
    this.labelDataItems = [
        {id: "price", displayName: "Price", enabled: true},
        {id: "type", displayName: "Type", enabled: true},
        {id: "priceDifference", displayName: "Price Difference", enabled: true},
        {id: "waveDegree", displayName: "Wave Degree", enabled: true}
    ];
    this.waveDegrees = [
        {
            id: "Super Millennium",
            name: "superMillennium",
            label: "label.superMillennium", 
            color: "#78BC61",
            enable: false,
            options:["O", "(((W)))", "(((X)))", "(((Y)))", "(((XX)))", "(((Z)))" ]
        },
        {
            id: "Millennium", 
            name: "millennium",
            label: "label.millennium",
            color: "#EF6351",
            enable: false,
            options:["O", "((W))", "((X))", "((Y))", "((XX))", "((Z))" ]
        },
        {
            id: "Sub Millennium", 
            name: "subMillennium",
            label: "label.subMillennium",
            color: "#3066BE",
            enable: false,
            options:["O", "(W)", "(X)", "(Y)", "(XX)", "(Z)" ]
        },
        {
            id: "Grand Super Cycle", 
            name: "grandSuperCycle",
            label: "label.grandSuperCycle",
            color: "#F93943", 
            enable: false,
            options:["O", "(((w)))", "(((x)))", "(((y)))", "(((xx)))", "(((z)))" ]
        },
        {
            id: "Super Cycle", 
            name: "superCycle",
            label: "label.superCycle",
            color: "#7E78D2", 
            enable: false,
            options:["O", "((w))", "((x))", "((y))", "((xx))", "((z))" ]
        },
        {
            id: "Cycle", 
            name: "cycle",
            label: "label.cycle",
            color: "#D65780", 
            enable: false,
            options:["O", "(w)", "(x)", "(y)", "(xx)", "(z)" ]
        },
        {
            id: "Primary",
            name: "primary",
            label: "label.primary",
            color: "#6C809A", 
            enable: false,
            options:["O", "{{{W}}}", "{{{X}}}", "{{{Y}}}", "{{{XX}}}", "{{{Z}}}" ]
        },
        {
            id: "Intermediate", 
            name: "intermediate",
            label: "label.intermediate",
            color: "#58A4B0", 
            enable: false,
            options:["O", "{{W}}", "{{X}}", "{{Y}}", "{{XX}}", "{{Z}}" ]
        },
        {
            id: "Minor", 
            name: "minor",
            label: "label.minor",
            color: "#5E8C61",
            enable: false, 
            options:["O", "{W}", "{X}", "{Y}", "{XX}", "{Z}" ]
        },
        {
            id: "Minute", 
            name: "minute",
            label: "label.minute",
            color: "#C89933", 
            enable: false,
            options:["O", "{{{w}}}", "{{{x}}}", "{{{y}}}", "{{{xx}}}", "{{{z}}}" ]
        },
        {
            id: "Minuette", 
            name: "minuette",
            label: "label.minuette",
            color: "#00A7E1", 
            enable: false,
            options:["O", "{{w}}", "{{x}}", "{{y}}", "{{xx}}", "{{z}}" ]
        },
        {
            id: "Sub Minuette", 
            name: "subMinuette",
            label: "label.subMinuette",
            color: "#912F56", 
            enable: false,
            options:["O", "{w}", "{x}", "{y}", "{xx}", "{z}" ]
        },
        {
            id: "Micro", 
            name: "micro",
            label: "label.micro",
            color: "#9D75CB", 
            enable: true,
            options:["O", "[[[W]]]", "[[[X]]]", "[[[Y]]]", "[[[XX]]]", "[[[Z]]]" ]
        },
        {
            id: "Sub Micro", 
            name: "subMicro",
            label: "label.subMicro",
            color: "#FE7B72",
            enable: false, 
            options:["O", "[[W]]", "[[X]]", "[[Y]]", "[[XX]]", "[[Z]]" ]
        },
        {
            id: "Nano", 
            name: "nano",
            label: "label.nano",
            color: "#8D818C", 
            enable: false,
            options:["O", "[W]", "[X]", "[Y]", "[XX]", "[Z]" ]
        },
        {
            id: "Sub Nano",
            name: "subNano",
            label: "label.subNano", 
            color: "#387D7A", 
            enable: false,
            options:["O", "W", "X", "Y", "XX", "Z" ]
        }
    ]
    this.labelValueNames = ["oLabel", "wLabel", "xLabel", "yLabel", "xxLabel", "zLabel"];
    this.type = "Corrective Triple";
    this.currentWaveDegree = "micro";
    infChart.elliotWaveDrawing.apply(this, arguments);
};

infChart.elliotCorrectiveTripleWaveDrawing.prototype = Object.create(infChart.elliotWaveDrawing.prototype);

/**
* set additional drawings of the tool
*/
infChart.elliotCorrectiveTripleWaveDrawing.prototype.additionalDrawingsFunction = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        yAxis = chart.yAxis[options.yAxis],
        lineShapes = self.getPatternShapes(true),
        additionalDrawingsArr = self.additionalDrawings,
        theme = infChart.drawingUtils.common.getTheme(),
        shapeTheme = theme["elliotCorrectiveTripleWave"],
        pointNamesArr = ["o", "w", "x", "y", "xx", "z"];

    additionalDrawingsArr.lines = {};
    additionalDrawingsArr.labels = {};
    additionalDrawingsArr.circles = {};
    additionalDrawingsArr.axisLabels = {};
    additionalDrawingsArr.rect = {};
    additionalDrawingsArr.infoLabels = {};

    ann.selectionMarker = [];
    self.setSelectionMarkers();

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        labelPosition && (additionalDrawingsArr.infoLabels[value + "Label"] = self.getInfoLabel(labelPosition.label, labelPosition.x, labelPosition.y));
    });

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        labelPosition && (additionalDrawingsArr.labels[value + "Label"] = self.getLabel(labelPosition.label, labelPosition.x, labelPosition.y));
        label = additionalDrawingsArr.labels[value + "Label"];
        if(label){
            label.attr({x: labelPosition.x - label.width/2});
        }
    });
};

infChart.elliotCorrectiveTripleWaveDrawing.prototype.getClickValues = function (clickX, clickY) {
    var ann = this.annotation;
    var chart = ann.chart;
    var options = ann.options;
    var xAxis = chart.xAxis[options.xAxis];
    var yAxis = chart.yAxis[options.yAxis];
    var completedSteps = this.annotation.options.completedSteps;
    var coordinates = {
        xValue: options.xValue,
        yValue: options.yValue,
        intermediatePoints: options.intermediatePoints
    };
    switch (completedSteps) {
        case 1:
            coordinates.intermediatePoints[0].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[0].yValue = yAxis.toValue(clickY);
            break;
        case 2:
            coordinates.intermediatePoints[1].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[1].yValue = yAxis.toValue(clickY);
            break;
        case 3:
            coordinates.intermediatePoints[2].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[2].yValue = yAxis.toValue(clickY);
            break;
        case 4:
            coordinates.intermediatePoints[3].xValue = xAxis.toValue(clickX);
            coordinates.intermediatePoints[3].yValue = yAxis.toValue(clickY);
            break;
        case 5:
            coordinates.xValueEnd = xAxis.toValue(clickX);
            coordinates.yValueEnd = yAxis.toValue(clickY);
            break;
    }
    return coordinates;
};

/**
* Returns the config to save
* @returns {{shape: string, borderColor: *, strokeWidth: *, xValue: *, yValue: *, xValueEnd: *, yValueEnd: *, intermediatePoints: Array}} config object
*/
infChart.elliotCorrectiveTripleWaveDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    var intermediatePoints = [];

    infChart.util.forEach(annotation.options.intermediatePoints, function(index , value){
        intermediatePoints.push({
            xValue: value.xValue,
            yValue: value.yValue
        });
    });

    return {
        shape: 'correctiveTripleWave',
        borderColor: annotation.options.shape.params.stroke,
        strokeWidth: annotation.options.shape.params['stroke-width'],
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        intermediatePoints: intermediatePoints,
        fillColor: 'none',
        currentWaveDegree: annotation.options.currentWaveDegree,
        nearestXValue: annotation.options.nearestXValue,
        nearestXValueEnd: annotation.options.nearestXValueEnd,
        nearestYValue: annotation.options.nearestYValue,
        nearestYValueEnd: annotation.options.nearestYValueEnd,
        startTopOfthePoint: annotation.options.startTopOfthePoint,
        endTopOfthePoint: annotation.options.endTopOfthePoint,
        nearestIntermediatePoints: annotation.options.nearestIntermediatePoints,
        isSnapTopHighLow: annotation.options.isSnapTopHighLow,
        textFontSize: annotation.options.textFontSize,
    };
};

/**
 * Create a label and add to the group
 * @param {String} name label text
 * @param {number} x x position
 * @param {number} y y position
 * @returns {SVGElement} the generated label
 */
infChart.elliotCorrectiveTripleWaveDrawing.prototype.getLabel = function (name, x, y) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        theme = infChart.drawingUtils.common.getTheme(),
        shapeTheme = theme["elliotCorrectiveTripleWave"];
        var currentColor;

        infChart.util.forEach(self.waveDegrees, function(index , value){
            if(self.waveDegrees[index].name === self.currentWaveDegree){
                currentColor = self.waveDegrees[index].color;
            }
        });

    var labelData = chart.renderer.label(name, x, y).attr({
        'zIndex': 20,
        'r': 3,
        'opacity': shapeTheme && shapeTheme.label && shapeTheme.label.opacity || 1,
        'stroke': options.shape.params.stroke ? options.shape.params.stroke : currentColor,//shapeTheme && shapeTheme.label && shapeTheme.label.stroke || "#858587",
        'stroke-width': 0,
        'hAlign': 'center',
        'class': 'harmonic-lbl',
        'rel': name,
    }).add(ann.group).css(
        {
            color: options.shape.params.stroke ? options.shape.params.stroke : currentColor,//shapeTheme && shapeTheme.label && shapeTheme.label.stroke || "#858587",
            fontSize: options.textFontSize || '16px',
            cursor: 'pointer',
            fontWeight: '700',
            fontStyle: 'normal',
            textDecoration: 'inherit'
        });

    $(labelData.element).mouseover(function (event) {
        event.stopPropagation();
        if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
            var rel = event.currentTarget.getAttribute('rel');
            if(rel === "O"){
                self.additionalDrawings.infoLabels.oLabel.show();
            }
            if(rel === "W"|| rel === "(W)"|| rel === "((W))"|| rel === "(((W)))"|| rel === "(w)"|| rel === "((w))"|| rel === "(((w)))" || rel === "[W]"|| rel === "[[W]]"|| rel === "[[[W]]]"|| rel === "{{{W}}}"|| rel === "{{W}}"|| rel === "{W}"|| rel === "{{{w}}}"|| rel === "{{w}}"|| rel === "{w}"){
                self.additionalDrawings.infoLabels.wLabel.show();
            }
            if(rel === "X"|| rel === "(X)"|| rel === "((X))"|| rel === "(((X)))"|| rel === "(x)"|| rel === "((x))"|| rel === "(((x)))" || rel === "[X]"|| rel === "[[X]]"|| rel === "[[[X]]]"|| rel === "{{{X}}}"|| rel === "{{X}}"|| rel === "{X}"|| rel === "{{{x}}}"|| rel === "{{x}}"|| rel === "{x}"){
                self.additionalDrawings.infoLabels.xLabel.show();
            }
            if(rel === "Y"|| rel === "(Y)"|| rel === "((Y))"|| rel === "(((Y)))"|| rel === "(y)"|| rel === "((y))"|| rel === "(((y)))" || rel === "[Y]"|| rel === "[[Y]]"|| rel === "[[[Y]]]"|| rel === "{{{Y}}}"|| rel === "{{Y}}"|| rel === "{Y}"|| rel === "{{{y}}}"|| rel === "{{y}}"|| rel === "{y}"){
                self.additionalDrawings.infoLabels.yLabel.show();
            }
            if(rel === "XX"|| rel === "(XX)"|| rel === "((XX))"|| rel === "(((XX)))"|| rel === "(xx)"|| rel === "((xx))"|| rel === "(((xx)))" || rel === "[XX]"|| rel === "[[XX]]"|| rel === "[[[XX]]]"|| rel === "{{{XX}}}"|| rel === "{{XX}}"|| rel === "{XX}"|| rel === "{{{xx}}}"|| rel === "{{xx}}"|| rel === "{x}"){
                self.additionalDrawings.infoLabels.xxLabel.show();
            }        
            if(rel === "Z"|| rel === "(Z)"|| rel === "((Z))"|| rel === "(((Z)))"|| rel === "(z)"|| rel === "((z))"|| rel === "(((z)))" || rel === "[Z]"|| rel === "[[Z]]"|| rel === "[[[Z]]]"|| rel === "{{{Z}}}"|| rel === "{{Z}}"|| rel === "{Z}"|| rel === "{{{z}}}"|| rel === "{{z}}"|| rel === "{z}"){
                self.additionalDrawings.infoLabels.zLabel.show();
            }
        }
    });

    $(labelData.element).mouseleave(function (event) {
        event.stopPropagation();
        if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
            var rel = event.currentTarget.getAttribute('rel');
            if(rel === "O"){
                self.additionalDrawings.infoLabels.oLabel.hide();
            }
            if(rel === "W"|| rel === "(W)"|| rel === "((W))"|| rel === "(((W)))"|| rel === "(w)"|| rel === "((w))"|| rel === "(((w)))" || rel === "[W]"|| rel === "[[W]]"|| rel === "[[[W]]]"|| rel === "{{{W}}}"|| rel === "{{W}}"|| rel === "{W}"|| rel === "{{{w}}}"|| rel === "{{w}}"|| rel === "{w}"){
                self.additionalDrawings.infoLabels.wLabel.hide();
            }
            if(rel === "X"|| rel === "(X)"|| rel === "((X))"|| rel === "(((X)))"|| rel === "(x)"|| rel === "((x))"|| rel === "(((x)))" || rel === "[X]"|| rel === "[[X]]"|| rel === "[[[X]]]"|| rel === "{{{X}}}"|| rel === "{{X}}"|| rel === "{X}"|| rel === "{{{x}}}"|| rel === "{{x}}"|| rel === "{x}"){
                self.additionalDrawings.infoLabels.xLabel.hide();
            }
            if(rel === "Y"|| rel === "(Y)"|| rel === "((Y))"|| rel === "(((Y)))"|| rel === "(y)"|| rel === "((y))"|| rel === "(((y)))" || rel === "[Y]"|| rel === "[[Y]]"|| rel === "[[[Y]]]"|| rel === "{{{Y}}}"|| rel === "{{Y}}"|| rel === "{Y}"|| rel === "{{{y}}}"|| rel === "{{y}}"|| rel === "{y}"){
                self.additionalDrawings.infoLabels.yLabel.hide();
            }
            if(rel === "XX"|| rel === "(XX)"|| rel === "((XX))"|| rel === "(((XX)))"|| rel === "(xx)"|| rel === "((xx))"|| rel === "(((xx)))" || rel === "[XX]"|| rel === "[[XX]]"|| rel === "[[[XX]]]"|| rel === "{{{XX}}}"|| rel === "{{XX}}"|| rel === "{XX}"|| rel === "{{{xx}}}"|| rel === "{{xx}}"|| rel === "{x}"){
                self.additionalDrawings.infoLabels.xxLabel.hide();
            }        
            if(rel === "Z"|| rel === "(Z)"|| rel === "((Z))"|| rel === "(((Z)))"|| rel === "(z)"|| rel === "((z))"|| rel === "(((z)))" || rel === "[Z]"|| rel === "[[Z]]"|| rel === "[[[Z]]]"|| rel === "{{{Z}}}"|| rel === "{{Z}}"|| rel === "{Z}"|| rel === "{{{z}}}"|| rel === "{{z}}"|| rel === "{z}"){
                self.additionalDrawings.infoLabels.zLabel.hide();
            }
        }
    });
    return labelData;
};

infChart.elliotCorrectiveTripleWaveDrawing.prototype.getNextPointOptions = function () {
    var ann = this.annotation;
    var completedSteps = ann.options.completedSteps;
    var pointOptions = { name: "o" };
    switch (completedSteps) {
        case 1:
            pointOptions.name = "w";
            break;
        case 2:
            pointOptions.name = "x";
            break;
        case 3:
            pointOptions.name = "y";
            break;
        case 4:
            pointOptions.name = "xx";
            break;
        case 5:
            pointOptions.name = "z";
            break;

    }
    return pointOptions;
};

/**
* Returns the paths, values and positions of the shapes under this drawing
* @returns {object} pattern shapes
*/
infChart.elliotCorrectiveTripleWaveDrawing.prototype.getPatternShapes = function (updateNearestValues) {
    var nameAdditionalY = 25;
    var patternPaths = {};

    var ann = this.annotation;
    var chart = ann.chart;
    var options = ann.options;
    var intermediatePoints = options.intermediatePoints;
    var intermediatePointsRaw = this.intermediatePoints;
    var xAxis = chart.xAxis[options.xAxis];
    var yAxis = chart.yAxis[options.yAxis];

    var waveDegreeSelected;
    this.waveDegrees.forEach(function(value, index){
        if(value.name === options.currentWaveDegree){
            waveDegreeSelected = value;
        }
    });

    var x = xAxis.toPixels(options.xValue);
    var y = yAxis.toPixels(options.yValue);

    var intermediate = this.getIntermediatePointsSnappedValues(updateNearestValues);
    var ax = intermediate && intermediate[0] && intermediate[0].x;
    var ay = intermediate && intermediate[0] && intermediate[0].y;
    var bx = intermediate && intermediate[1] && intermediate[1].x;
    var by = intermediate && intermediate[1] && intermediate[1].y;
    var cx = intermediate && intermediate[2] && intermediate[2].x;
    var cy = intermediate && intermediate[2] && intermediate[2].y;
    var dx = intermediate && intermediate[3] && intermediate[3].x;
    var dy = intermediate && intermediate[3] && intermediate[3].y;

    var futureValue = chart.series[0].xData[chart.series[0].xData.length-1];
    if(updateNearestValues){
        var nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);
        if(futureValue >=  nearestDataForXValueEnd.xData){
            options.nearestXValueEnd = nearestDataForXValueEnd.xData;
            var nearestEndValue = this.getNearestYValue(options.yValueEnd, nearestDataForXValueEnd, undefined, options.isSnapTopHighLow);
            options.nearestYValueEnd = nearestEndValue.nearestYValue;
            options.endTopOfthePoint = nearestEndValue.topOfThePoint;
        } else {
            options.nearestXValueEnd = nearestDataForXValueEnd.xData;
            options.nearestYValueEnd = options.yValueEnd;
            options.endTopOfthePoint = true;
        }
    }
    var newXEnd = xAxis.toPixels(options.nearestXValueEnd) - x;
    var newYEnd = yAxis.toPixels(options.nearestYValueEnd) - y;
    var ex = options.xValueEnd && newXEnd;
    var ey = options.yValueEnd && newYEnd;

    if (ex !== undefined) {
        if (y < 0) {
            patternPaths.namePosition = { x: (ex) / 2, y: (ey) / 2 + nameAdditionalY };
        } else {
            patternPaths.namePosition = { x: (x + dx) / 2, y: (y + dy) / 2 + nameAdditionalY };
        }
    }

    if(updateNearestValues){
        var nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
        if(futureValue >=  nearestDataForXValue.xData){
            options.nearestXValue = nearestDataForXValue.xData;
            var nearestStartValue = this.getNearestYValue(options.yValue, nearestDataForXValue, undefined, options.isSnapTopHighLow);
            options.nearestYValue = nearestStartValue.nearestYValue;
            options.startTopOfthePoint = nearestStartValue.topOfThePoint;
        } else {
            options.nearestXValue = nearestDataForXValue.xData;
            options.nearestYValue = options.yValue;
            options.startTopOfthePoint = true;
        }
    }
    var newX = xAxis.toPixels(options.nearestXValue) - x;
    var newY = yAxis.toPixels(options.nearestYValue) - y;
    patternPaths.oCirclePosition = { x: newX, y: newY };

    patternPaths.positions = {
        pointLabels: {
            o: { x: newX, y: options.startTopOfthePoint ? -25 + newY : 5 + newY, label: waveDegreeSelected.options[0],  xValue: options.nearestXValue, yValue: options.nearestYValue, topOfThePoint: options.startTopOfthePoint}
        },
        circles: {
            o: { x: newX, y: newY },
            w: { x: ax, y: ay },
            x: { x: bx, y: by },
            y: { x: cx, y: cy },
            xx: { x: dx, y: dy },
            z: { x: ex, y: ey }
        }
    };

    patternPaths.positions.axisClips = {};

    patternPaths.values = {
        o: {
            xValue: options.xValue,
            yValue: this.yValue,
            optionXValue: options.xValue,
            optionYValue: options.yValue
        }
    };

    if (ax !== undefined) {
        patternPaths.wCirclePosition = { x: ax, y: ay };
        patternPaths.positions.pointLabels.w = { x: ax, y: intermediate[0].topOfThePoint ? ay - 25 : ay + 5, label: waveDegreeSelected.options[1], xValue: intermediate[0].xValue, yValue: intermediate[0].yValue, topOfThePoint: intermediate[0].topOfThePoint};
        patternPaths.values.w = {
            xValue: intermediatePoints[0].xValue,
            yValue: intermediatePointsRaw[0] ? intermediatePointsRaw[0].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[0].yValue),
            optionXValue: intermediatePoints[0].xValue,
            optionYValue: intermediatePoints[0].yValue
        };

    }

    if (bx !== undefined) {
        patternPaths.xCirclePosition = { x: bx, y: by };
        patternPaths.positions.pointLabels.x = { x: bx, y: intermediate[1].topOfThePoint ? by - 25 : by + 5, label: waveDegreeSelected.options[2], xValue: intermediate[1].xValue, yValue: intermediate[1].yValue, topOfThePoint: intermediate[1].topOfThePoint };
        patternPaths.values.x = {
            xValue: intermediatePoints[1].xValue,
            yValue: intermediatePointsRaw[1] ? intermediatePointsRaw[1].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[1].yValue),
            optionXValue: intermediatePoints[1].xValue,
            optionYValue: intermediatePoints[1].yValue
        };

    }
    if (cx !== undefined) {
        patternPaths.yCirclePosition = { x: cx, y: cy };
        patternPaths.positions.pointLabels.y = { x: cx, y: intermediate[2].topOfThePoint ? cy - 25 : cy + 5, label: waveDegreeSelected.options[3], xValue: intermediate[2].xValue, yValue: intermediate[2].yValue, topOfThePoint: intermediate[2].topOfThePoint };
        patternPaths.values.y = {
            xValue: intermediatePoints[2].xValue,
            yValue: intermediatePointsRaw[2] ? intermediatePointsRaw[2].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[2].yValue),
            optionXValue: intermediatePoints[2].xValue,
            optionYValue: intermediatePoints[2].yValue
        };
    }
    if (dx !== undefined) {
        patternPaths.xxCirclePosition = { x: dx, y: dy };
        patternPaths.positions.pointLabels.xx = { x: dx, y: intermediate[3].topOfThePoint ? dy - 25 : dy + 5, label: waveDegreeSelected.options[4], xValue: intermediate[3].xValue, yValue: intermediate[3].yValue, topOfThePoint: intermediate[3].topOfThePoint };
        patternPaths.values.xx = {
            xValue: intermediatePoints[3].xValue,
            yValue: intermediatePointsRaw[3] ? intermediatePointsRaw[3].yValue : infChart.drawingUtils.common.getBaseYValue.call(this, intermediatePoints[3].yValue),
            optionXValue: intermediatePoints[3].xValue,
            optionYValue: intermediatePoints[3].yValue
        };

    }
    if (ex !== undefined) {
        patternPaths.zCirclePosition = { x: ex, y: ey };
        patternPaths.positions.pointLabels.z = { x: ex, y: options.endTopOfthePoint ? ey - 25 : ey + 5, label: waveDegreeSelected.options[5], xValue: options.nearestXValueEnd, yValue: options.nearestYValueEnd, topOfThePoint: options.endTopOfthePoint };
        patternPaths.values.z = {
            xValue: options.xValueEnd,
            yValue: this.yValueEnd !== undefined ? this.yValueEnd : infChart.drawingUtils.common.getBaseYValue.call(this, options.yValueEnd),
            optionXValue: options.xValueEnd,
            optionYValue: options.yValueEnd
        };

    }
    return patternPaths;
};

infChart.elliotCorrectiveTripleWaveDrawing.prototype.getSettingsPopup = function () {
    var common = infChart.drawingUtils.common;
    return infChart.structureManager.drawingTools.getElliotWaveSettings(infChart.manager.getLabel('label.correctiveTripleWave'), common.baseBorderColor, this.annotation.options.currentWaveDegree, this.waveDegrees, this.fontSize);
};

infChart.elliotCorrectiveTripleWaveDrawing.prototype.finalizeEachPoint = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        line,
        additionalDrawingsArr = self.additionalDrawings,
        pointNamesArr = ["o", "w", "x", "y", "xx", "z"];
        var currentColor;

    line = self.getBasePatternLine(true);
    infChart.util.forEach(self.waveDegrees, function(index , value){
        if(self.waveDegrees[index].id === options.currentWaveDegree){
            currentColor = self.waveDegrees[index].color;
        }
    });

    ann.update({
        shape: {
            params: {
                d: line,
                'stroke': options.shape.params.stroke ? options.shape.params.stroke : currentColor,
            }
        }
    });

    var lineShapes = self.getPatternShapes(true);

    lineShapes.namePosition && additionalDrawingsArr.labels["nameLabel"] && additionalDrawingsArr.labels["nameLabel"].attr({
        x: lineShapes.namePosition.x,
        y: lineShapes.namePosition.y
    });

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        var label = additionalDrawingsArr.labels[value + "Label"];
        label && label.attr({ x: labelPosition.x - label.width/2, y: labelPosition.y });
        // circles
        if (additionalDrawingsArr.circles[value]) {
            var circlePositions = lineShapes.positions["circles"][value];
            additionalDrawingsArr.circles[value].attr({ x: circlePositions.x, y: circlePositions.y });
        }
    });
    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId, true);
    if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
        self.getSnappedValues();
        self.calculateAndUpdateInfoLabel(true);
    }
    infChart.drawingUtils.common.saveBaseYValues.call(self, ann.options.yValue, ann.options.yValueEnd, undefined, ann.options.intermediatePoints);
    infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd, ann.options.nearestTrendYValue, ann.options.nearestIntermediatePoints);
};

/**
* Scale function of the tool
*/
infChart.elliotCorrectiveTripleWaveDrawing.prototype.scale = function (isCalculateNewValueForScale) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        line,
        additionalDrawingsArr = self.additionalDrawings,
        pointNamesArr = ["o", "w", "x", "y", "xx", "z"];
        var currentColor;

    line = self.getBasePatternLine(isCalculateNewValueForScale);
    infChart.util.forEach(self.waveDegrees, function(index , value){
        if(self.waveDegrees[index].id === options.currentWaveDegree){
            currentColor = self.waveDegrees[index].color;
        }
    });

    ann.update({
        shape: {
            params: {
                d: line,
                'stroke': options.shape.params.stroke ? options.shape.params.stroke : currentColor,
            }
        }
    });

    var lineShapes = self.getPatternShapes(isCalculateNewValueForScale);

    lineShapes.namePosition && additionalDrawingsArr.labels["nameLabel"] && additionalDrawingsArr.labels["nameLabel"].attr({
        x: lineShapes.namePosition.x,
        y: lineShapes.namePosition.y
    });

    infChart.util.forEach(pointNamesArr, function (index, value) {
        var labelPosition = lineShapes.positions["pointLabels"][value];
        var label = additionalDrawingsArr.labels[value + "Label"];
        label && label.attr({ x: labelPosition.x - label.width/2, y: labelPosition.y });
        // circles
        if (additionalDrawingsArr.circles[value]) {
            var circlePositions = lineShapes.positions["circles"][value];
            additionalDrawingsArr.circles[value].attr({ x: circlePositions.x, y: circlePositions.y });
        }
    });
    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId, isCalculateNewValueForScale);
    if(!infChart.drawingsManager.getIsActiveDrawingInprogress()){
        self.calculateAndUpdateInfoLabel(isCalculateNewValueForScale);
    }
};

infChart.elliotCorrectiveTripleWaveDrawing.prototype.setSelectionMarkers = function () {
    var self = this;
    var ann = self.annotation;
    var lineShapes = self.getPatternShapes();
    var additionalDrawingsArr = self.additionalDrawings;

    if (!ann.selectionMarker.length) {
        infChart.util.forEach(["o", "w", "x", "y", "xx", "z"], function (index, value) {
            var circlePosition = lineShapes.positions["circles"][value];
            if (circlePosition && circlePosition.x != undefined && circlePosition.y != undefined) {
                additionalDrawingsArr.circles[value] = infChart.drawingUtils.common.addAndBindSelectionMarker.call(self, ann, circlePosition.x, circlePosition.y, self.stepFunction, self.stop, true, undefined, { name: value });
            }
         });

        var clipPosX = lineShapes.positions.axisClips.x;
        var clipPosY = lineShapes.positions.axisClips.y;
        if (clipPosY && !additionalDrawingsArr.rect.y && clipPosX && !additionalDrawingsArr.rect.x) {
            ann.selectionMarker.push(additionalDrawingsArr.rect.x);
            ann.selectionMarker.push(additionalDrawingsArr.rect.y);
        }

    }
};

/**
* Step function
* @param {Event} e event
* @param {boolean} isStartPoint indicate whether the start or not
*/
infChart.elliotCorrectiveTripleWaveDrawing.prototype.step = function (e, isStartPoint, itemProperties) {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        pointx = xAxis.toValue(e.chartX),
        pointy = yAxis.toValue(e.chartY),
        intermediatePoints = options.intermediatePoints,
        newOtions = {};
    switch (itemProperties.name) {
        case 'w':
            if (!intermediatePoints[0]) {
                intermediatePoints[0] = {};
            }
            intermediatePoints[0].xValue = pointx;
            intermediatePoints[0].yValue = pointy;
            break;
        case 'x':
            if (!intermediatePoints[1]) {
                intermediatePoints[1] = {};
            }
            intermediatePoints[1].xValue = pointx;
            intermediatePoints[1].yValue = pointy;
            break;
        case 'y':
            if (!intermediatePoints[2]) {
                intermediatePoints[2] = {};
            }
            intermediatePoints[2].xValue = pointx;
            intermediatePoints[2].yValue = pointy;
            break;
        case 'xx':
            if (!intermediatePoints[3]) {
                intermediatePoints[3] = {};
            }
            intermediatePoints[3].xValue = pointx;
            intermediatePoints[3].yValue = pointy;
            break;
        case 'z':
            newOtions.xValueEnd = pointx;
            newOtions.yValueEnd = pointy;
            break;
        case 'o':
            newOtions.xValue = pointx;
            newOtions.yValue = pointy;
            break;
        default:
            break;
    }
    newOtions.intermediatePoints = intermediatePoints;
    ann.update(newOtions);
    this.finalizeEachPoint();
};

/**
 * Stop function
 * @param {Event} e event
 * @param {boolean} isStartPoint indicate whether the start or not
 */
infChart.elliotCorrectiveTripleWaveDrawing.prototype.stop = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        lineShapes = self.getPatternShapes(true),
        additionalDrawingsArr = self.additionalDrawings;

    // point Labels
    if (!additionalDrawingsArr.labels["zLabel"]) {
        var labelPosition = lineShapes.positions["pointLabels"]["z"];
        labelPosition && (additionalDrawingsArr.labels["zLabel"] = self.getLabel(labelPosition.label, labelPosition.x, labelPosition.y));
        label = additionalDrawingsArr.labels["zLabel"];
        if(label){
            label.attr({x: labelPosition.x - label.width/2});
        }
    }

    if (!additionalDrawingsArr.infoLabels["zLabel"]) {
        var labelPosition = lineShapes.positions["pointLabels"]["z"];
        labelPosition && (additionalDrawingsArr.infoLabels["zLabel"] = self.getInfoLabel(labelPosition.label, labelPosition.x, labelPosition.y));
    }
    var chartId = infChart.drawingsManager.getChartIdFromHighchartInstance(ann.chart);
    infChart.drawingsManager.positionElliotWaveDrawingLabels(chartId, true);
    self.getSnappedValues();
    self.calculateAndUpdateInfoLabel(true);
    self.select();

    infChart.drawingUtils.common.saveBaseYValues.call(self, ann.options.yValue, ann.options.yValueEnd, undefined, ann.options.intermediatePoints);
    infChart.drawingUtils.common.saveNearestBaseYValues.call(this, ann.options.nearestYValue, ann.options.nearestYValueEnd, undefined, ann.options.nearestIntermediatePoints);
    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
};

infChart.elliotCorrectiveTripleWaveDrawing.prototype.hasMoreIntermediateSteps = function () {
    return !(this.annotation.options.completedSteps === 5);
};

infChart.elliotCorrectiveTripleWaveDrawing.prototype.calculateAndUpdateInfoLabel = function (isCalculateNewValues) {
    var self = this, 
        ann = self.annotation,
        options = ann.options,
        line = ann.shape.d.split(' '),
        chart = ann.chart,
        additionalDrawingsArr = self.additionalDrawings,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis];

    var snappedValues = self.getSnappedValues();
    var infoLabelTypes = ["oLabel", "wLabel", "xLabel", "yLabel", "xxLabel", "zLabel"];

    var waveDegreeSelected;
    this.waveDegrees.forEach(function(value, index){
        if(value.name === options.currentWaveDegree){
            waveDegreeSelected = value;
        }
    });

    infChart.util.forEach(snappedValues, function (index, value) {       
        var calculatedLabelData = {
            price: snappedValues[index].yValue,
            type: self.type + ', ' + waveDegreeSelected.options[index],
            priceDifference: index !== 0 ?  Math.abs(snappedValues[index-1].yValue - snappedValues[index].yValue) : undefined,
            waveDegree: waveDegreeSelected.id
        };
        calculatedLabelData.pricePercentage = (calculatedLabelData.priceDifference >= 0) ? ((calculatedLabelData.priceDifference /calculatedLabelData.price) * 100): undefined;

        var labelData = self.getLabelData(ann, calculatedLabelData);
        var label = additionalDrawingsArr.infoLabels[infoLabelTypes[index]];
        if(label && labelData){
            if(isCalculateNewValues) {
                label.attr({
                    text: labelData
                });
            }

            var labelParameters = self.additionalDrawings.labels[infoLabelTypes[index]];
            var yLabelPosition = labelParameters.y;
            var xLabelPosition = labelParameters.x;

            var labelYValue = yAxis.toValue(yLabelPosition + yAxis.toPixels(options.yValue));
            if (snappedValues[index].yValue > labelYValue) {
                yLabelPosition = yLabelPosition + self.additionalDrawings.labels[infoLabelTypes[index]].height + 5;
            }
            if (snappedValues[index].yValue < labelYValue) {
                yLabelPosition = yLabelPosition - label.height - 5;
            }
            label.attr({
                x: xLabelPosition,
                y: yLabelPosition
            });
        }
    });
}
window.infChart = window.infChart || {};

infChart.highLowLabels = function () {
    infChart.drawingObject.apply(this, arguments);
    this.borderColor = '#959595';
    this.labelDataItems = [
        {id: "date", displayName: "Date / Time", enabled: true},
        {id: "price", displayName: "Price", enabled: true},
        {id: "change", displayName: "Change", enabled: true},
        {id: "pChange", displayName: "%Change", enabled: true},
        {id: "bars", displayName: "Bars", enabled: true}
    ];
    this.destroyByStopPropagation = false;
    this.disableQuickSettingPanel = true;
};

infChart.highLowLabels.prototype = Object.create(infChart.drawingObject.prototype);

infChart.highLowLabels.prototype.checkOverlaps = function () {

}

infChart.highLowLabels.prototype.additionalDrawingsFunction = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        labelText = ann.options.isHighLabel? "&#8595;" : "&#8593;";

    self.additionalDrawings.pointerLabel = chart.renderer.createElement('foreignObject').add(ann.group).attr({
        width: '15px',
        height: '30px',
        rel: 'pointerLabel'
    }).css({
        color: ann.options.title.style.color,
        fontSize: '22px'
    }).add(ann.group);
    var labelHtml = "<div>" + labelText + "</div>";
    self.additionalDrawings.pointerLabel.element.innerHTML = labelHtml;
};

infChart.highLowLabels.prototype.bindSettingsEvents = function () {
    var self = this,
        ann = self.annotation;

    function onColorChange(rgb, value) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onColorChange.call(self, rgb, value, isPropertyChange);
    }

    function onLabelItemsChange(labelItemId, value) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onLabelItemsChange.call(self, labelItemId, value, isPropertyChange);
    }

    function onResetToDefault () {
        self.updateSavedDrawingProperties(true);
    }

    infChart.structureManager.drawingTools.bindHighLowLabelsSettings(self.settingsPopup, onColorChange, onLabelItemsChange, onResetToDefault);
};

/**
 * Change the color of the annotation from the given params
 * IMPORTANT :: this method is used in commands.wrappers to set undo/redo actions
 * @param {object} rgb rgb value of the color
 * @param {string} value
 * @param {boolean|undefined} isPropertyChange property change
 */
infChart.highLowLabels.prototype.onColorChange = function (rgb, value, isPropertyChange) {
    var self = this;
    self.annotation.update({
        title: {
            style: {
                color: value
            },
            borderAttributes: {
                stroke: value
            }
        }
    });
    self.additionalDrawings.pointerLabel.css({
        color: value
    });

    isPropertyChange && self.onPropertyChange();

    if (self.settingsPopup) {
        self.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

/**
 * Change the color of the annotation from the given params
 * IMPORTANT :: this method is used in commands.wrappers to set undo/redo actions
 * @param {object} labelItemId changed label item id
 * @param {string} value
 * @param {boolean|undefined} isPropertyChange property change
 */
infChart.highLowLabels.prototype.onLabelItemsChange = function (labelItemId, value, isPropertyChange) {
    var self = this;
    var ann = self.annotation;
    var options = ann.options;

    for(var i = 0; i < options.labelDataItems.length; i++) {
        if(options.labelDataItems[i].id === labelItemId) {
            options.labelDataItems[i].enabled = value;
            break;
        }
    }

    ann.update({
        title: {
            text: infChart.drawingUtils.highLowLabels.getLabelData(ann, self.stockChart, options.calculatedLabelData)
        }
    });

    self.scale.call(self);

    isPropertyChange && self.onPropertyChange();

    if (self.settingsPopup) {
        self.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.highLowLabels.prototype.getConfig = function () {
    var annotation = this.annotation;
    return {
        shape: 'highLowLabels',
        text: annotation.options.title.text,
        color: annotation.options.title.style.color,
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        price: annotation.options.price,
        dataIndex: annotation.options.dataIndex,
        isHighLabel: annotation.options.isHighLabel,
        calculatedLabelData: annotation.options.calculatedLabelData,
        labelDataItems: annotation.options.labelDataItems,
        pointerLabelDimensions: annotation.options.pointerLabelDimensions
    };
};

infChart.highLowLabels.prototype.getOptions = function (properties, chart) {
    var theme = {
        style: {
            color: this.borderColor,
            fontSize: '12px',
            cursor: 'move'
        },
        borderAttributes: {
            stroke: this.borderColor,
            'stroke-width': 1,
            padding: 4,
            r: 0
        }
    };

    if (infChart.drawingUtils.common.theme && infChart.drawingUtils.common.theme.highLowLabels) {
        theme = infChart.util.merge(theme, infChart.drawingUtils.common.theme.highLowLabels);
    }

    var nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, properties.xValue, undefined, true);
    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        nearestXDataPoint: nearestDataPointForXValue.xData,
        allowDragY: false,
        allowDragX: false,
        price: 0,
        labelDataItems: properties.labelDataItems ? properties.labelDataItems : this.labelDataItems,
        title: {
            text: 'Label',
            style: theme.style
        },
        shape: {
            type: null,
            params: null
        },
        disableCopyPaste: true
    };

    if (properties.text) {
        options.title.text = properties.text;
    }
    if (properties.color) {
        options.title.style.color = properties.color;
    }

    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
    }

    if(properties.price) {
        options.price = properties.price;
    }

    if(properties.dataIndex) {
        options.dataIndex = properties.dataIndex;
    }

    if(properties.isHighLabel) {
        options.isHighLabel = properties.isHighLabel;
    }

    if(properties.calculatedLabelData) {
        options.calculatedLabelData = properties.calculatedLabelData;
    }

    if(properties.pointerLabelDimensions) {
        options.pointerLabelDimensions = properties.pointerLabelDimensions;
    }

    return options;
};

infChart.highLowLabels.prototype.getQuickSettingsPopup = function () {
    return infChart.structureManager.drawingTools.getHighLowLabelsQuickSettings();
};

infChart.highLowLabels.prototype.getSettingsPopup = function () {
    return infChart.structureManager.drawingTools.getHighLowLabelsSettings(this.labelDataItems);
};

infChart.highLowLabels.prototype.step = function () { };

infChart.highLowLabels.prototype.stop = function () {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        pointerLabel = this.additionalDrawings['pointerLabel'],
        nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true),
        newX = xAxis.toPixels(nearestDataPointForXValue.xData) - xAxis.toPixels(ann.options.xValue),
        stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart),
        chartInstance = infChart.manager.getChart(stockChartId),
        basicText = "",
        stopPropagation = false;

    var yValue;
    if (!chartInstance.isLog && chartInstance.isCompare) {
        yValue = (infChart.drawingUtils.common.getYValue.call(this, nearestDataPointForXValue.yData[1]) + infChart.drawingUtils.common.getYValue.call(this, nearestDataPointForXValue.yData[2]))/2;
    } else {
        yValue = (nearestDataPointForXValue.yData[1] + nearestDataPointForXValue.yData[2]) / 2;
    }
    var isHighLabel = ann.options.yValue > yValue;

    if(infChart.drawingUtils.highLowLabels.checkOverlaps(ann, nearestDataPointForXValue.xData)) {
        stopPropagation = true;
        this.destroyByStopPropagation = true;
    } else {
        $.each(options.labelDataItems, function (index, labelDataItem) {
            if (labelDataItem.enabled) {
                basicText += (basicText !== "" ? '<br>' : '') + "--";
            }
        });

        ann.update({
            nearestXDataPoint: nearestDataPointForXValue.xData,
            price: isHighLabel ? nearestDataPointForXValue.yData[1] : nearestDataPointForXValue.yData[2],
            dataIndex: nearestDataPointForXValue.dataIndex,
            isHighLabel: isHighLabel,
            pointerLabelDimensions: {
                width: pointerLabel.width,
                height: pointerLabel.height
            },
            title: {
                text: basicText
            }
        });

        var newY = isHighLabel ? 0 - yAxis.toPixels(ann.options.yValue) : yAxis.height - yAxis.toPixels(ann.options.yValue) - ann.title.height;

        ann.title.attr({
            x: newX - (ann.title.width / 2),
            y: newY
        });

        var labelText = isHighLabel ? "&#8595;" : "&#8593;"
        var labelHtml = "<div>" + labelText + "</div>";
        pointerLabel.element.innerHTML = labelHtml;

        pointerLabel.attr({
            x: newX - (pointerLabel.getBBox().width / 2),
            y: isHighLabel ? newY + ann.title.height : newY - pointerLabel.getBBox().height
        });

        infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue);
        infChart.drawingsManager.openSettings(this, !!infChart.settings.config.disableDrawingSettingsPanel);
        infChart.drawingUtils.common.onPropertyChange.call(this);
        infChart.drawingUtils.highLowLabels.updateLabels(ann, this.stockChart);
    }

    return {stopPropagation: stopPropagation};
};

infChart.highLowLabels.prototype.scale = function (isCalculateNewValueForScale) {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        pointerLabel = this.additionalDrawings['pointerLabel'];

    if(isCalculateNewValueForScale){
        var nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true);
        ann.update({
            nearestXDataPoint : nearestDataPointForXValue.xData,
            price: options.isHighLabel ? nearestDataPointForXValue.yData[1] : nearestDataPointForXValue.yData[2],
            dataIndex: nearestDataPointForXValue.dataIndex
        });
    }

    var newX = xAxis.toPixels(this.annotation.options.nearestXDataPoint) - xAxis.toPixels(options.xValue);
    
    if(options.calculatedLabelData) {
        ann.update({
            title: {
                text: infChart.drawingUtils.highLowLabels.getLabelData(ann, this.stockChart, options.calculatedLabelData)
            }
        });
    }

    infChart.drawingUtils.highLowLabels.updateLabels(ann, this.stockChart);

    var newY = options.isHighLabel? 0 - yAxis.toPixels(options.yValue) : yAxis.height - yAxis.toPixels(options.yValue) - ann.title.height;

    ann.title.attr({
        x: newX - (ann.title.width / 2),
        y: newY
    });

    pointerLabel.attr({
        x: newX - (pointerLabel.getBBox().width / 2),
        y: options.isHighLabel? newY + ann.title.height : newY - pointerLabel.getBBox().height
    });
};

infChart.highLowLabels.prototype.translateEnd = function () {
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.highLowLabels.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updateHighLowLabelsSettings(this.settingsPopup, properties.color, properties.labelDataItems);
};

infChart.highLowLabels.prototype.beforeDestroy = function () {
    this.additionalDrawings['pointerLabel'].destroy();

    if(!this.destroyByStopPropagation) {
        infChart.drawingUtils.highLowLabels.updateLabels(this.annotation, this.stockChart);
    }
};

infChart.highLowLabels.prototype.isRequiredProperty = function (propertyId) {
    var isPositionProperty = false;

    switch (propertyId) {
        case "yValue":
        case "yValueEnd":
        case "xValue":
        case "xValueEnd":
        case "price":
        case "dataIndex":
        case "isHighLabel" :
        case "calculatedLabelData" :
        case "pointerLabelDimensions":
        case "isLocked":
            isPositionProperty = true;
            break;
        default :
            break;
    }

    return isPositionProperty;
};


window.infChart = window.infChart || {};

infChart.fib2PointTimeProjection = function () {
    infChart.fibVerRetracementsDrawing.apply(this, arguments);
    this.fibLevels = [
        {
            id: 'level_0',
            value: 0.0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#726a6f',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_1',
            value: 23.6,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#835974',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_2',
            value: 38.2,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#7b6171',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_3',
            value: 50,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f8bce2',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_4',
            value: 61.8,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f075c3',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_5',
            value: 78.6,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#eb40ab',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_6',
            value: 100,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#c71585',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_7',
            value: 127.2,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#800e56',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_8',
            value: 161.8,
            enable: true,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#4b0832',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_9',
            value: 200,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#726a6f',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_10',
            value: 261.8,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#835974',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_11',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#7b6171',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_12',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f8bce2',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        },
        {
            id: 'level_13',
            value: 0,
            enable: false,
            drawingPosX: -41,
            drawingPosY: 7,
            fillColor: '#f075c3',
            lineColor: '#959595',
            lineWidth: 1,
            fontColor: '#959595',
            fontSize: '10',
            fontWeight: 'normal'
        }
    ];
};

infChart.fib2PointTimeProjection.prototype = Object.create(infChart.fibVerRetracementsDrawing.prototype);

infChart.fib2PointTimeProjection.prototype.changeAllFibLines = function (property, propertyValue, isPropertyChange) {
    var self = this;
    var options = self.annotation.options;
    if (isPropertyChange) {
        options.isSingleColor = true;
    }
    var fibLevels = options.fibLevels;
    switch (property) {
        case 'lineColor':
            options.lineColor = propertyValue;
            options.jointLineColor = propertyValue;
            if (self.additionalDrawings && self.additionalDrawings.lines['start']) {
                self.additionalDrawings.lines['start'].attr({
                    'stroke': propertyValue
                });
            }
            if (self.additionalDrawings && self.additionalDrawings.lines['end']) {
                self.additionalDrawings.lines['end'].attr({
                    'stroke': propertyValue
                });
            }
            if(self.additionalDrawings.jointLine){
                self.additionalDrawings.jointLine.attr({
                    'stroke': propertyValue
                });
            }
            break;
        case 'fillColor':
            options.fillColor = propertyValue.fill;
            options.opacity = propertyValue.opacity;
            break;
        case 'lineWidth':
            options.lineWidth = propertyValue;
            if (self.additionalDrawings && self.additionalDrawings.lines['start']) {
                self.additionalDrawings.lines['start'].attr({
                    'stroke-width': propertyValue
                });
            }
            if(self.additionalDrawings.jointLine){
                self.additionalDrawings.jointLine.attr({
                    'stroke-width': propertyValue
                });
            }
            break;
    }

    fibLevels.forEach(function (fibLevel) {
        self.changeFibLine(fibLevel.id, property, propertyValue, true, false);
    });

    if (isPropertyChange) {
        self.onPropertyChange();
    }
};

infChart.fib2PointTimeProjection.prototype.changeFibLine = function (level, property, propertyValue, isAll, isPropertyChange, ignoreSettingsSave) {
    var self = this;
    var options = this.annotation.options;
    var fibLevels, fibLevel, fibIndex = -1;
    if(!isAll) {
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels);
        for (var i = 0; i < fibLevels.length; i++) {
            if (level === fibLevels[i].id) {
                fibLevel = fibLevels[i];
                fibIndex = i;
                break;
            }
        }
    }
    var additionalDrawings = this.additionalDrawings;
    switch (property) {
        case 'enabled':
            fibLevel.enable = propertyValue;
            if (propertyValue) {
                additionalDrawings.lines[level].show();
                additionalDrawings.labels[level].show();
                if (!options.isShort) {
                    additionalDrawings.fill[level].show();
                }
            } else {
                additionalDrawings.lines[level].hide();
                additionalDrawings.labels[level].hide();
                if (!options.isShort) {
                    additionalDrawings.fill[level].hide();
                }
                if(this.isEndLevelEnabled()){
                    additionalDrawings.lines['end'].show();
                    additionalDrawings.labels['end'].show();
                }
            }
            var isFirstLevelDisabled = true, k = fibIndex;
            for (k; k >= 0; k--) {
                if (fibLevels[k].enable) {
                    isFirstLevelDisabled = false;
                    break;
                }
            }
            var currentFibIndex = fibIndex;
            if (isFirstLevelDisabled) {
                for (currentFibIndex; currentFibIndex < fibLevels.length; currentFibIndex++) {
                    if (fibLevels[currentFibIndex].enable) {
                        break;
                    }
                }
                if (options.isShort) {
                    this.updateJointLine(parseFloat(this.additionalDrawings.lines[fibLevels[fibIndex].id].d.split(' ')[4]), fibIndex, fibLevels);
                }
            } else {
                if (options.isShort) {
                    this.updateJointLine(parseFloat(this.additionalDrawings.lines[fibLevels[k].id].d.split(' ')[4]), k, fibLevels);
                } else {
                    this.updateFill(fibLevels[k], k, fibLevels);
                }
            }
            break;
        case 'value':
            fibLevel.value = propertyValue;
            var x = this.updateFibLevel(fibLevel, fibIndex, fibLevels, this.annotation.options.distance, false, true);
            this.updateJointLine(x, fibIndex, fibLevels);
            break;
        case 'lineColor':
            additionalDrawings.lines[level].attr({
                'stroke': propertyValue
            });
            if (!isAll) {
                fibLevel.lineColor = propertyValue;
            }
            if (level === 'level_0' || level === 'level_13' || level === 'level_14' || level === 'level_15') {
                additionalDrawings.lines['end'].attr({
                    'stroke': propertyValue
                });
            }
            break;
        case 'fillColor':
            if (!options.isShort) {
                additionalDrawings.fill[level].attr({
                    'fill': propertyValue.fill,
                    'fill-opacity': propertyValue.opacity
                });
            } else {
                if (propertyValue.opacity === 0) {
                    propertyValue.fill = this.annotation.options.shape.params.fill;
                }
            }
            if (!isAll) {
                fibLevel.fillColor = propertyValue.fill;
                fibLevel.fillOpacity = propertyValue.opacity;
            }
            break;
        case 'lineWidth':
            additionalDrawings.lines[level].attr({
                'stroke-width': propertyValue
            });
            if (!isAll) {
                fibLevel.lineWidth = propertyValue;
            }
            if (level === 'level_0' || level === 'level_13' || level === 'level_14' || level === 'level_15') {
                additionalDrawings.lines['end'].attr({
                    'stroke-width': propertyValue
                });
            }
            break;
    }

    if (isPropertyChange) {
        this.onPropertyChange();
    }
    self.updateEndProperty();
};

infChart.fib2PointTimeProjection.prototype.createAdditionalDrawings = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        dx = options.distance,
        adjustment = options.adjustment,
        fibLevels = options.fibLevels,
        shapeParams = options.shape.params,
        theme = infChart.drawingUtils.common.getTheme.call(this),
        baseFillOpacity = (theme.fibVerRetracements && typeof theme.fibVerRetracements.fillOpacity !== "undefined") ? theme.fibVerRetracements.fillOpacity : infChart.drawingUtils.common.baseFillOpacity,
        baseFontColor = (theme.fibVerRetracements && typeof theme.fibVerRetracements.fontColor !== "undefined") ? theme.fibVerRetracements.fontColor : infChart.drawingUtils.common.baseFontColor,
        baseFontSize = (theme.fibVerRetracements && typeof theme.fibVerRetracements.fontSize !== "undefined") ? theme.fibVerRetracements.fontSize : infChart.drawingUtils.common.baseFontSize,
        baseFontWeight = (theme.fibVerRetracements && typeof theme.fibVerRetracements.fontWeight !== "undefined") ? theme.fibVerRetracements.fontWeight : infChart.drawingUtils.common.baseFontWeight;

    self.additionalDrawings = {
        labels: {},
        lines: {},
        fill: {}
    };

    var drawingFillAttr = {
        'stroke-width': 0,
        'z-index': 2,
        cursor: 'default',
        color: shapeParams.stroke,
        'pointer-events':'none'
    };
    var drawingAttr = {
        'z-index': 2,
        'stroke-width': shapeParams['stroke-width'],
        fill: shapeParams.fill,
        cursor: 'move',
        stroke: shapeParams.stroke
    };
    var labelCssAttr = {
        fontSize: baseFontSize + 'px',
        color: baseFontColor,
        'font-weight' : baseFontWeight
    };
    var labelAttr = {
        'font-color': baseFontColor,
        'font-size': baseFontSize,
        'font-weight' : baseFontWeight,
        'type': 'additionalDrawing',
        cursor: 'move'
    };
    var dateLabelAttr = Object.assign({}, labelAttr);
    var dateLabelCssAttr = Object.assign({}, labelCssAttr);
    var dateDrawingAttr = Object.assign({}, drawingAttr);

    // add fill objects first to avoid overlapping lines with and texts with them
    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);

    var isStartEnabled = false, isEndEnabled = false;
    fibLevels.forEach(function (fibLevel) {
        var distanceMultiplier = parseFloat(fibLevel.value) / 100;
        var x = adjustment + (dx > 0 ? dx : -dx) + (dx > 0 ? dx : -dx) * distanceMultiplier;
        var themeFillColor = theme.fibVerRetracements && theme.fibVerRetracements.fibLevelFillColors && theme.fibVerRetracements.fibLevelFillColors[fibLevel.id];
        var lineWidth = options.isSingleColor ? options.lineWidth : (fibLevel.lineWidth ? fibLevel.lineWidth : shapeParams['stroke-width']);
        var lineColor = options.isSingleColor ? options.lineColor : (fibLevel.lineColor ? fibLevel.lineColor : shapeParams.stroke);
        var opacity = options.isSingleColor ? options.opacity : (fibLevel.fillOpacity ? fibLevel.fillOpacity : baseFillOpacity);
        var fontColor = options.isSingleColor ? options.fontColor : (fibLevel.fontColor ? fibLevel.fontColor : baseFontColor);
        var fontSize = options.isSingleColor ? options.fontSize : (fibLevel.fontSize ? fibLevel.fontSize : baseFontSize);
        var fontWeight = options.isSingleColor ? options.fontWeight : (fibLevel.fontWeight ? fibLevel.fontWeight : baseFontWeight);

        drawingFillAttr.fill = options.isSingleColor ? options.fillColor : (fibLevel.fillColor ? fibLevel.fillColor : themeFillColor);
        drawingFillAttr['fill-opacity'] = opacity;
        drawingFillAttr.stroke = lineColor;
        drawingFillAttr.level = fibLevel.id;

        drawingAttr['stroke-width'] = parseInt(lineWidth, 10);
        drawingAttr.stroke = lineColor;
        drawingAttr.level = fibLevel.id;

        labelCssAttr.color = fontColor;
        labelCssAttr.fontSize = fontSize + 'px';
        labelCssAttr['font-weight'] = fontWeight;

        labelAttr['level'] = fibLevel.id;
        labelAttr['font-color'] = fontColor;
        labelAttr['font-size'] = fontSize;
        labelAttr['font-weight'] = fontWeight;

        var labelValue = self.getLineLabelText(x, fibLevel);
        if (!options.isShort) {
            self.additionalDrawings.fill[fibLevel.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0]).attr(drawingFillAttr).add(ann.group);
        }
        self.additionalDrawings.lines[fibLevel.id] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(drawingAttr).add(ann.group);
        self.additionalDrawings.labels[fibLevel.id] = chart.renderer.label(labelValue, fibLevel.drawingPosX, fibLevel.drawingPosY).css(labelCssAttr).attr(labelAttr).add(ann.group);
        if (!fibLevel.enable) {
            self.additionalDrawings.lines[fibLevel.id].hide();
            self.additionalDrawings.labels[fibLevel.id].hide();
            if (!options.isShort) {
                self.additionalDrawings.fill[fibLevel.id].hide();
            }
        } else {
            if(fibLevel.value === 0){
                isEndEnabled = true;
            }
        }
    });

    if(options.isSingleColor){
        dateLabelAttr = labelAttr;
        dateLabelCssAttr = labelCssAttr;
        dateDrawingAttr = drawingAttr;
        delete dateDrawingAttr['level'];
        delete dateLabelAttr['level'];
    }

    dateDrawingAttr['stroke-width'] = options.jointLineWidth;
    dateDrawingAttr.stroke = options.jointLineColor;

    if (options.isShort) {
        var startValue = self.formatDate(options.nearestXValue, self.stockChart.interval);
        self.additionalDrawings.lines['start'] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(dateDrawingAttr).add(ann.group);
        self.additionalDrawings.labels['start'] = chart.renderer.label(startValue).css(dateLabelCssAttr).attr(dateLabelAttr).add(ann.group);

        var endValue = self.formatDate(options.nearestXValueEnd, self.stockChart.interval);
        self.additionalDrawings.lines['end'] = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr(dateDrawingAttr).add(ann.group);
        self.additionalDrawings.labels['end'] = chart.renderer.label(endValue).css(dateLabelCssAttr).attr(dateLabelAttr).add(ann.group);
        if (!options.trendXValue && isEndEnabled) {
            self.additionalDrawings.lines['end'].hide();
            self.additionalDrawings.labels['end'].hide();
        }

        var jointLineWidth = options.isSingleColor ? options.lineWidth : options.jointLineWidth;
        var jointLineColor = options.isSingleColor ? options.lineColor : options.jointLineColor;

        self.additionalDrawings.jointLine = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr({
            'stroke-width': jointLineWidth,
            fill: ann.options.shape.params.fill,
            stroke: jointLineColor,
            'z-index': 2,
            cursor: 'move'
        }).add(ann.group);

    }
    self.updateEndProperty();
};

infChart.fib2PointTimeProjection.prototype.getConfig = function () {
    var self = this,
        options = self.annotation.options,
        fibLevels = options.fibLevels;
    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels);
    return {
        shape: 'fib2PointTimeProjection',
        fibLevels: fibLevels,
        lineColor: options.lineColor,
        fillColor: options.fillColor,
        opacity: options.opacity,
        lineWidth: options.lineWidth,
        fontColor: options.fontColor,
        fontSize: options.fontSize,
        fontWeight: options.fontWeight,
        xValue: options.xValue,
        xValueDataIndex: options.xValueDataIndex,
        yValue: options.yValue,
        xValueEnd: options.xValueEnd,
        xValueEndDataIndex: options.xValueEndDataIndex,
        yValueEnd: options.yValueEnd,
        isSingleColor: options.isSingleColor,
        isShort: options.isShort,
        borderColor: options.lineColor, //Todo : refactor this check getOptions method
        jointLineValue: options.jointLineValue,
        isTrendLineAlways: options.isTrendLineAlways,
        trendLineColor: options.trendLineColor,
        trendLineOpacity: options.trendLineOpacity,
        trendLineWidth: options.trendLineWidth,
        trendLineStyle: options.trendLineStyle,
        jointLineColor: options.jointLineColor,
        jointLineWidth: options.jointLineWidth
    };
};

infChart.fib2PointTimeProjection.prototype.getContextMenuOptions = function (chartId, drawingId, options, event) {
    var self = this;
    var level = event.target.getAttribute('level');
    if (!level && event.target.parentElement) {
        if (event.target.parentElement.getAttribute('level')) {
            level = event.target.parentElement.getAttribute('level');
        } else if (event.target.parentElement.parentElement && event.target.parentElement.parentElement.getAttribute('level')) {
            level = event.target.parentElement.parentElement.getAttribute('level');
        }
    }
    var contextMenu = {
        "copyToClipboard" : {
            icon : options.copyToClipboard.icon,
            displayText : options.copyToClipboard.displayText,
            action : function () {
                if(level) {
                  infChart.drawingUtils.common.onFibLevelCopy.call(self, level); 
                }
            }
        },
        "eraseThis": {
            icon: options.erase.icon,
            displayText: options.erase.displayText,
            action: function () {
                if (level) {
                    self.eraseFibLevel(level, false, true, true);
                }
            }
        }
    };

    if (level) {
        contextMenu = Object.assign(contextMenu, infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options));
        return infChart.drawingUtils.common.reorderContextMenu(contextMenu);
    } else {
        return infChart.drawingUtils.common.getContextMenuOptions(chartId, drawingId, options)
    }
};

infChart.fib2PointTimeProjection.prototype.eraseFibLevel = function (level, checked, isPropertyChange, ignoreSettingsSave){
    var self = this;
    self.additionalDrawings.lines[level].hide();
    self.additionalDrawings.labels[level].hide();
    if (self.additionalDrawings.fill[level]) {
        self.additionalDrawings.fill[level].hide();
    }
    var propeties = self.getConfig();

    propeties.fibLevels.forEach(function (fibLevel) {
        if (fibLevel.id === level) {
            fibLevel.enable = false;
        }
    });
    if(self.isEndLevelEnabled()){
        self.additionalDrawings.lines['end'].show();
        self.additionalDrawings.labels['end'].show();
    }
    self.changeFibLine(level, 'enabled', checked, false, false, ignoreSettingsSave);
    self.updateJointLine();
};

infChart.fib2PointTimeProjection.prototype.isEndLevelEnabled = function (){
    var self = this,
        ann = self.annotation,
        options = ann.options,
        fibLevels = options.fibLevels;

    fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(fibLevels);
    var isEndEnabled = true;
    fibLevels.forEach(function (fibLevel) {
        if(fibLevel.enable && fibLevel.value === 0){
                isEndEnabled = false;
        }
    });
    return isEndEnabled;
};

infChart.fib2PointTimeProjection.prototype.scale = function (isCalculateNewValueForScale) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        line = ann.shape.d.split(' '),
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];

    if (isCalculateNewValueForScale) {
        nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
        nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate);
        options.nearestXValue = nearestDataForXValue.xData;
        options.nearestXValueEnd = nearestDataForXValueEnd.xData;
    } 
    
    var newX = xAxis.toPixels(options.nearestXValue) - xAxis.toPixels(options.xValue),
        xEnd = xAxis.toPixels(options.nearestXValueEnd) - xAxis.toPixels(options.xValue),
        yEnd = yAxis.toPixels(options.yValueEnd) - yAxis.toPixels(options.yValue);

    line[1] = (!isNaN(newX) && newX) || 0;
    line[4] = (!isNaN(xEnd) && xEnd) || 0;
    line[5] = (!isNaN(yEnd) && yEnd) || 0;

    if (isCalculateNewValueForScale) {
        ann.update({
            xValueDataIndex: nearestDataForXValue.dataIndex,
            xValueEndDataIndex: nearestDataForXValueEnd.dataIndex,
            shape: {
                params: {
                    d: line
                }
            }
        });
        ann.options.distance = nearestDataForXValueEnd.dataIndex - nearestDataForXValue.dataIndex;
    } else {
        ann.update({
            shape: {
                params: {
                    d: line
                }
            }
        });
    }
    
    if (ann.selectionMarker && ann.selectionMarker.length > 1) {
        ann.selectionMarker[1].attr({
            x: line[4],
            y: line[5]
        });
    }

    self.updateAdditionalDrawings(false);
    self.updateJointLine();
    self.setDragSupporters();
};

infChart.fib2PointTimeProjection.prototype.step = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        points = infChart.drawingUtils.common.calculateInitialPoints(e, ann, isStartPoint, 0, 0),
        xValueEnd = xAxis.toValue(xAxis.toPixels(options.xValue) + points.dx),
        yValueEnd = yAxis.toValue(yAxis.toPixels(options.yValue) + points.dy),
        nearestDataForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate),
        nearestDataForXValueEnd = infChart.math.findNearestDataPoint(chart, xValueEnd, undefined, options.useAllXDataToFindNearestPoint, options.useFutureDate),
        nearestXValue = nearestDataForXValue.xData,
        nearestXValueEnd = nearestDataForXValueEnd.xData,
        newX = xAxis.toPixels(nearestXValue) - xAxis.toPixels(ann.options.xValue),
        newXEnd = xAxis.toPixels(nearestXValueEnd) - xAxis.toPixels(ann.options.xValue);

    var y = points.dy;
    var line = ["M", newX, 0, 'L', newXEnd, y];

    ann.update({
        xValueDataIndex: nearestDataForXValue.dataIndex,
        xValueEndDataIndex: nearestDataForXValueEnd.dataIndex,
        nearestXValue: nearestXValue,
        nearestXValueEnd: nearestXValueEnd,
        shape: {
            params: {
                d: line
            }
        }
    });

    ann.options.distance = options.xValueEndDataIndex - options.xValueDataIndex;
    self.updateAdditionalDrawings(false, true);
    self.updateEndProperty();
    self.updateJointLine();
    return line;
};

infChart.fib2PointTimeProjection.prototype.translate = function (event) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];

    if (options.selectedDrawing == "mainDrawing") {
        this.updateAdditionalDrawings(false, true);
        this.scale();
    }
    if (options.selectedDrawing == "additionalDrawing") {
        options.chartY = yAxis.toValue(event.chartY);

        ann.update({
            yValue: options.yValueStore,
            yValueEnd: options.yValueEndStore
        });

        this.updateAdditionalDrawings(false, false);
    }
    this.updateJointLine();
};

infChart.fib2PointTimeProjection.prototype.updateAdditionalDrawings = function (isScale, isMain) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        dx = options.distance,
        adjustment = options.adjustment,
        yAxis = chart.yAxis[options.yAxis],
        xAxis = chart.xAxis[options.xAxis],
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels);

    var fibIndex = 0, fibLevelLength = fibLevels.length, lastX = 0, lastVal = 0, isStartEnabled = false, isEndEnabled = false;
    for (fibIndex; fibIndex < fibLevelLength; fibIndex++) {
        var fibLevel = fibLevels[fibIndex];
        var x = self.updateFibLevel(fibLevel, fibIndex, fibLevels, dx, isScale, false, isMain);
        if (fibLevel.enable) {
            if (fibLevel.value === 0) {
                isStartEnabled = true;
            }
            if (fibLevel.value === 100) {
                isEndEnabled = true;
            }
            lastVal = fibLevel.value;
            if ((dx < 0 && lastX > x) || (dx > 0 && lastX < x)) {
                lastX = x;
            }
        }
    }

    if (options.isShort) {
        var startDrawingLabel = self.additionalDrawings.labels['start'];
        var endDrawingLabel = self.additionalDrawings.labels['end'];
        var startDrawingLine = self.additionalDrawings.lines['start'];
        var endDrawingLine = self.additionalDrawings.lines['end'];
        newX = xAxis.toPixels(options.nearestXValue) - xAxis.toPixels(options.xValue);
        if (!isScale) {
            var startValue = self.formatDate(options.nearestXValue, self.stockChart.interval);
            startDrawingLabel.textSetter(startValue);
            var endValue = self.formatDate(this.calculateFibLevelCandleValue(dx, 0), self.stockChart.interval);
            endDrawingLabel.textSetter(endValue);
        }

        var lineStartPosition = this.calculateLineStartPosition(fibLevel, isMain);
        var lineEndPosition = lineStartPosition + 10;

        startDrawingLabel.attr({
            x: newX - startDrawingLabel.width / 2,
            y: lineEndPosition + 5
        });
        startDrawingLine.attr({
            d: ["M", newX, lineStartPosition, 'L', newX, lineEndPosition]
        });
        var endX = adjustment === 0 ? parseFloat(ann.shape.d.split(' ')[4]) : adjustment;
        endDrawingLabel.attr({
            x: endX - endDrawingLabel.width / 2,
            y: lineEndPosition + 5
        });
        endDrawingLine.attr({
            d: ["M", endX, lineStartPosition, 'L', endX, lineEndPosition]
        });

        self.additionalDrawings.jointLine.attr({
            d: ['M', newX, lineStartPosition, 'L', lastX, lineStartPosition]
        });
    }
};

infChart.fib2PointTimeProjection.prototype.updateEndProperty = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels);

    var fibIndex = 0, fibLevelLength = fibLevels.length, propertyColor, propertyWidth;
    for (fibIndex; fibIndex < fibLevelLength; fibIndex++) {
        var fibLevel = fibLevels[fibIndex];
        if (fibLevel.enable && fibLevel.value === 0) {
                propertyColor = fibLevel.lineColor;
                propertyWidth = fibLevel.lineWidth;
        }
    }
    properties = self.getConfig();

    if (!properties.isSingleColor) {
        if (propertyColor || propertyWidth) {
            if (propertyColor && self.additionalDrawings && self.additionalDrawings.labels['end']) {
                self.additionalDrawings.labels['end'].css({
                    'color': propertyColor
                });
            }
            if (propertyColor && self.additionalDrawings && self.additionalDrawings.lines['end']) {
                self.additionalDrawings.lines['end'].attr({
                    'stroke': propertyColor
                });
            }
            if (propertyWidth && self.additionalDrawings && self.additionalDrawings.lines['end']) {
                self.additionalDrawings.lines['end'].attr({
                    'stroke-width': propertyWidth
                });
            }
            if (self.additionalDrawings && self.additionalDrawings.lines['end']) {
                self.additionalDrawings.lines['end'].hide();
                self.additionalDrawings.labels['end'].hide();
            }
        } else {
            if (self.additionalDrawings && self.additionalDrawings.labels['end']) {
                self.additionalDrawings.labels['end'].css({
                    'color': '#959595'
                });
                self.additionalDrawings.lines['end'].attr({
                    'stroke': '#959595'
                });
            }
            if (self.additionalDrawings && self.additionalDrawings.lines['end']) {
                self.additionalDrawings.labels['end'].show();
                self.additionalDrawings.lines['end'].show();
            }
        }
    }
};

infChart.fib2PointTimeProjection.prototype.updateFibLevel = function (fibLevel, fibIndex, fibLevels, dx, isScale, isValueUpdate, isMain) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        correctionFactor = infChart.drawingUtils.common.correctionFactor,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];

    var x = xAxis.toPixels(this.calculateFibLevelCandleValue(dx, fibLevel.value)) - xAxis.toPixels(options.xValue);

    var previousLineStart = self.calculateLineStartPosition(fibLevel, isMain);
    var y1, y2, lineStartPosition = previousLineStart,
        lineEndPosition;
    if (options.isShort) {
        lineEndPosition = lineStartPosition + 10;
        y1 = lineStartPosition;
        y2 = lineEndPosition;
    } else {
        lineEndPosition = chart.plotHeight + lineStartPosition;
        y1 = lineStartPosition - chart.plotHeight * correctionFactor;
        y2 = lineEndPosition + chart.plotHeight * correctionFactor;
    }

    self.additionalDrawings.lines[fibLevel.id].attr({
        d: ["M", x, y1, 'L', x, y2]
    });

    var drawingLabel = self.additionalDrawings.labels[fibLevel.id];

    if (options.isShort) {
        if (!isScale) {
            drawingLabel.textSetter(self.getLineLabelText(x, fibLevel));
        }
    } else {
        if (isValueUpdate) {
            self.updateFill(fibLevel, fibIndex, fibLevels);
        }
        var isFirstLevel = true;
        fibIndex--;
        for (fibIndex; fibIndex >= 0; fibIndex--) {
            if (fibLevels[fibIndex].enable) {
                isFirstLevel = false;
                break;
            }
        }
        if (!isFirstLevel) {
            self.updateFill(fibLevels[fibIndex], fibIndex, fibLevels);
        }
    }

    drawingLabel.attr({
        x: options.isShort ? x - drawingLabel.width / 2 : x + 5,
        y: options.isShort ? lineEndPosition + 5 : lineEndPosition - 25
    });
    return x;
};

infChart.fib2PointTimeProjection.prototype.updateJointLine = function (x, fibIndex, fibLevels) {
    var self = this, options = self.annotation.options;
    if(!fibLevels){
        fibLevels = infChart.drawingUtils.common.sortFibLevelsByValue(options.fibLevels);
    }
    if (options.isShort) {
        var maxFibLevel, isStartEnabled = false, isEndEnabled = false;
        for (var i = 0; i < fibLevels.length; i++) {
            if (fibLevels[i].enable) {
                if (typeof maxFibLevel === 'undefined') {
                    maxFibLevel = fibLevels[i];
                }
                if (fibLevels[i].value === 0) {
                    isEndEnabled = true;
                }
                if (fibLevels[i].value > maxFibLevel.value) {
                    maxFibLevel = fibLevels[i];
                }
            }
        }

        var jointLineLastX;
        if (typeof maxFibLevel === 'undefined') {
            jointLineLastX = self.additionalDrawings.lines['end'].d.split(' ')[4];
        } else {
            jointLineLastX = self.additionalDrawings.lines[maxFibLevel.id].d.split(' ')[4];
        }
        var jointLine = self.additionalDrawings.jointLine, jointLineArray = jointLine.d.split(' ');
        jointLine.attr({
            d: ['M', jointLineArray[1], jointLineArray[2], 'L', jointLineLastX, jointLineArray[5]]
        });

        if (!options.trendXValue) {
            self.additionalDrawings.labels['start'].show();
            self.additionalDrawings.lines['start'].show();

            if (!isEndEnabled) {
                self.additionalDrawings.labels['end'].show();
                self.additionalDrawings.lines['end'].show();
            } else {
                self.additionalDrawings.labels['end'].hide();
                self.additionalDrawings.lines['end'].hide();
            }
        }
    }
};

infChart.fib2PointTimeProjection.prototype.calculateFibLevelCandleValue = function (dx, fibValue) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        candleValue,
        calculatedCandleIndex,
        seriesXData = chart.series[0].xData,
        distanceMultiplier = parseFloat(fibValue) / 100;

    calculatedCandleIndex = Math.round(dx + (dx) * distanceMultiplier) + options.xValueDataIndex;
    calculatedCandleIndex = calculatedCandleIndex >= 0 ? calculatedCandleIndex : 0;

    if (seriesXData.length > calculatedCandleIndex) {
        candleValue = seriesXData[calculatedCandleIndex];
    } else {
        candleValue = Math.round(infChart.math.getFutureXValueForGivenIndex(chart, calculatedCandleIndex));
    }

    return candleValue;
};

// infChart.fib2PointTimeProjection.prototype.specificCursorChange = function(url){
//     var self = this,
//         ann = self.annotation,
//         options = ann.options,
//         additionalDrawings = self.additionalDrawings;

//         $.each(additionalDrawings.labels, function (key, value) {
//             if(url){
//                 value.css({'cursor': 'url("' + url + '"), default'});
//             } else {
//                 infChart.util.setCursor(value, 'move');
//                 value.css({'cursor': 'move'});
//             }
//         });
// };

window.infChart = window.infChart || {};

infChart.timestampMarkerDrawing = function () {
    this.labelText = '<img style = "width : 41px; height : 40px; text-align:center;" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI2LjUuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1MTIgNTEyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6IzAwQjdGRjt9Cjwvc3R5bGU+CjxnIGlkPSJpY29tb29uLWlnbm9yZSI+CjwvZz4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTI1NiwwQzE2Ny42LDAsOTYsNzEuNiw5NiwxNjBjMCwxNjAsMTYwLDM1MiwxNjAsMzUyczE2MC0xOTIsMTYwLTM1MkM0MTYsNzEuNiwzNDQuNCwwLDI1NiwweiBNMjU2LDI1NgoJYy01MywwLTk2LTQzLTk2LTk2czQzLTk2LDk2LTk2czk2LDQzLDk2LDk2UzMwOSwyNTYsMjU2LDI1NnoiLz4KPC9zdmc+Cg==" alt="Time Stamp Marker" />';
    infChart.drawingObject.apply(this, arguments);
};

infChart.timestampMarkerDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.timestampMarkerDrawing.prototype.additionalDrawingsFunction = function () {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options;

    var theme = infChart.drawingUtils.common.getTheme();
    var shapeTheme = theme["timestampMarker"];
    var firstPointTimeStamp = chart.series[0].xData[0];

    self.additionalDrawings.pointerLabel = chart.renderer.createElement('foreignObject').add(ann.group).attr({
        "zIndex": 1,
        width: '44',
        height: '40'
    });

    var labelHtml = "<div>" + this.labelText + "</div>";
    self.additionalDrawings.pointerLabel.element.innerHTML = labelHtml;

    if (firstPointTimeStamp > options.timestamp) {
        self.additionalDrawings.pointerLabel.hide();
    } else {
        self.additionalDrawings.pointerLabel.show();
    }
};

infChart.timestampMarkerDrawing.prototype.beforeDestroy = function () {
    this.additionalDrawings['pointerLabel'].destroy();
};

infChart.timestampMarkerDrawing.prototype.calculateHeikinAshitypevalues = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        yAxis = chart.yAxis[options.yAxis],
        timestamp = options.timestamp;

    var nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, timestamp, undefined, true);
    var series = chart.series[0].yData;
    if (chart.series[0].prevPoint) {
        var high = chart.series[0].prevPoint[nearestDataPointForXValue.dataIndex].xPoint.high;
    } else {
        var open, close, high, low;
        for (var i = 0; i <= nearestDataPointForXValue.dataIndex; i++) {
            if (i == 0) {
                open = (series[i][0] + series[i][3]) / 2;
                close = (series[i][0] + series[i][3] + series[i][1] + series[i][2]) / 4;
            } else {
                open = (open + close) / 2;
                close = (series[i][0] + series[i][3] + series[i][1] + series[i][2]) / 4;
            }
            high = Math.max(open, close, series[i][1]);
            low = Math.min(open, close, series[i][2]);
        }
    }

    var yValue = high;
    return yValue;
}

infChart.timestampMarkerDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    return {
        shape: 'timestampMarker',
        timestamp: annotation.options.timestamp,
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd    
    };
};

infChart.timestampMarkerDrawing.prototype.getOptions = function (properties, chart) {

    var nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, properties.timestamp, undefined, true);
    var xValue = nearestDataPointForXValue.xData;
    var yValue;

    var options = {
        xValue: xValue,
        yValue: yValue,
        nearestXDataPoint: nearestDataPointForXValue,
        drawingType: infChart.constants.drawingTypes.shape,
        timestamp: properties.timestamp,
        allowDragY: false,
        allowDragX: false,
        disableCopyPaste: true
    };

    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
    }

    return options;
};

infChart.timestampMarkerDrawing.prototype.loadSettingWindow = function (hide, options) { };

infChart.timestampMarkerDrawing.prototype.step = function () { };

infChart.timestampMarkerDrawing.prototype.stop = function () { };

infChart.timestampMarkerDrawing.prototype.scale = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        timestamp = options.timestamp,
        pointerLabel = self.additionalDrawings['pointerLabel'];

    var chartType = chart.series[0].type,
        firstPointTimeStamp = chart.series[0].xData[0],
        nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, timestamp, undefined, true);

    var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart);
    var chartInstance = infChart.manager.getChart(stockChartId);

    var newX = xAxis.toPixels(nearestDataPointForXValue.xData) - xAxis.toPixels(options.xValue);
    var yValue;

    if (chartType == 'area' || chartType == 'line' || chartType == 'column' || chartType == 'step') {
        yValue = nearestDataPointForXValue.yData[3];
    } else if (chartType == 'heikinashi') {
        yValue = self.calculateHeikinAshitypevalues();
    } else {
        yValue = nearestDataPointForXValue.yData[1];
    }

    if (!chartInstance.isLog && chartInstance.isCompare) {
        yValue = infChart.drawingUtils.common.getYValue.call(self, yValue);
    }

    var newY = yAxis.toPixels(yValue) - yAxis.toPixels(options.yValue);
    ann.update(yValue);
    pointerLabel.attr({
        x: newX - (pointerLabel.getBBox().width / 2),
        y: newY - pointerLabel.getBBox().height
    });

    if (firstPointTimeStamp > timestamp) {
        pointerLabel.hide();
    } else {
        pointerLabel.show();
    }
};

infChart.timestampMarkerDrawing.prototype.getContextMenuOptions = function (chartId, drawingId, options , event) {};

window.infChart = window.infChart || {};

infChart.positionsDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
    this.priceDifferenceFactor = 0.01;
    this.defaultCandleCount = 10;
    this.defaultStyles = {
        isCompactStats: false,
        lineColor: '#959595',
        lineWidth: 1,
        lineOpacity: 1,
        stopLossColor: '#F54649',
        stopLossFillOpacity: 0.25,
        takeProfitColor: '#009D90',
        takeProfitFillOpacity: 0.25,
        textColor: '#ffffff',
        textOpacity: 1,
        textFontSize:'16'
    };
    this.settings = {
        accountSize: 1000,
        lotSize: 1,
        entryPrice: null,
        risk: {
            percentage: 25,
            size: null,
            selectedItem: "percentage"
        },
        stopLoss: {
            tickSize: null,
            price: null
        },
        takeProfit: {
            tickSize: null,
            price: null
        },
        pAndL: {
            projectionPrice: null,
            lineStartPrice: null,
            lineStartDate: null,
            lineEndPrice: null,
            lineEndDate: null
        }
    };
    this.additionalDrawingItems = ["takeProfit", "stopLoss", "pAndL"];
};

infChart.positionsDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.positionsDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    return {
        shape: this.shape,
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        isLongPositions: annotation.options.isLongPositions,
        settings: annotation.options.settings,
        styles: annotation.options.styles,
        isLocked : annotation.options.isLocked

    };
};

infChart.positionsDrawing.prototype.getOptions = function (properties, chart) {
    var nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, properties.xValue, undefined, true, true);
    var theme = infChart.drawingUtils.common.getTheme.call(this);
    var shapeTheme = theme[this.shape];
    var lineColor = properties.styles ? properties.styles.lineColor : (shapeTheme && shapeTheme.lineColor) ? shapeTheme.lineColor : this.defaultStyles.lineColor;
    var lineWidth = properties.styles ? properties.styles.lineWidth : (shapeTheme && shapeTheme.lineWidth) ? shapeTheme.lineWidth : this.defaultStyles.lineWidth;
    var lineOpacity = properties.styles ? properties.styles.lineOpacity : (shapeTheme && shapeTheme.lineOpacity) ? shapeTheme.lineOpacity : this.defaultStyles.lineOpacity;
    var stopLossColor = properties.styles ? properties.styles.stopLossColor : (shapeTheme && shapeTheme.stopLossColor) ? shapeTheme.stopLossColor : this.defaultStyles.stopLossColor;
    var stopLossFillOpacity = properties.styles ? properties.styles.stopLossFillOpacity : (shapeTheme && shapeTheme.stopLossFillOpacity) ? shapeTheme.stopLossFillOpacity : this.defaultStyles.stopLossFillOpacity;
    var takeProfitColor = properties.styles ? properties.styles.takeProfitColor : (shapeTheme && shapeTheme.takeProfitColor) ? shapeTheme.takeProfitColor : this.defaultStyles.takeProfitColor;
    var takeProfitFillOpacity = properties.styles ? properties.styles.takeProfitFillOpacity : (shapeTheme && shapeTheme.takeProfitFillOpacity) ? shapeTheme.takeProfitFillOpacity : this.defaultStyles.takeProfitFillOpacity;
    var textColor = properties.styles ? properties.styles.textColor : (shapeTheme && shapeTheme.textColor) ? shapeTheme.textColor : this.defaultStyles.textColor;
    var textOpacity = properties.styles ? properties.styles.textOpacity : (shapeTheme && shapeTheme.textOpacity) ? shapeTheme.textOpacity : this.defaultStyles.textOpacity;
    var isCompactStats = properties.styles ? properties.styles.isCompactStats : this.defaultStyles.isCompactStats;
    var textFontSize =  properties.styles ? properties.styles.textFontSize : '16' ;
    var options = {
        isLongPositions: this.shape === 'longPositions',
        xValue: properties.xValue,
        yValue: properties.yValue,
        nearestXDataPoint: nearestDataPointForXValue.xData,
        startDataPointIndex: nearestDataPointForXValue.dataIndex,
        settings: properties.settings? properties.settings : this.settings,
        styles: {
            isCompactStats: isCompactStats,
            lineColor: lineColor,
            lineWidth: lineWidth,
            lineOpacity: lineOpacity,
            stopLossColor: stopLossColor,
            stopLossFillOpacity: stopLossFillOpacity,
            takeProfitColor: takeProfitColor,
            takeProfitFillOpacity: takeProfitFillOpacity,
            textColor: textColor,
            textOpacity: textOpacity,
            textFontSize: textFontSize
        },
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0],
                dashstyle: 'solid',
                stroke: lineColor,
                'stroke-width': lineWidth,
                opacity: lineOpacity
            }
        }
    };

    if (properties.xValueEnd) {
        options.xValueEnd = properties.xValueEnd;

        var nearestDataPointForXValueEnd = infChart.math.findNearestDataPoint(chart, properties.xValueEnd, undefined, true, true);
        options.endDataPointIndex = nearestDataPointForXValueEnd.dataIndex;
    } else {
        var seriesXData = chart.series[0].xData;
        options.endDataPointIndex = options.startDataPointIndex + this.defaultCandleCount;

        if (seriesXData.length > options.endDataPointIndex) {
            options.xValueEnd = seriesXData[options.endDataPointIndex];
        } else {
            options.xValueEnd = infChart.math.getFutureXValueForGivenIndex(chart, options.endDataPointIndex);
        }
    }

    if (properties.settings) {
        options.settings = properties.settings;
    } else {
        var entryPrice = properties.yValue;
        var yAxis = chart.yAxis[0],
            yAxisExtremes = yAxis.getExtremes(),
            priceFactor = (yAxisExtremes.max - yAxisExtremes.min) / 4;
        options.settings.takeProfit.price = options.isLongPositions ? entryPrice + priceFactor : entryPrice - priceFactor;
        options.settings.stopLoss.price = options.isLongPositions ? entryPrice - priceFactor : entryPrice + priceFactor;
        this.entryPriceChangeCalculation(entryPrice, options);
    }

    options.isRealTimeTranslation = true;
    options.validateTranslationFn = this.validateTranslation;

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.positionsDrawing.prototype.validateTranslation = function (newXValue) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        seriesData = chart.series[0].xData,
        dataMin = seriesData[0],
        xVal = options.xValue,
        xValEnd = options.xValueEnd,
        newXValueEnd = xValEnd - xVal + newXValue,
        totalPoints = infChart.drawingsManager.getTotalPoints(chart),
        dataMax = totalPoints[totalPoints.length - 1];

    return (newXValue >= dataMin && newXValue <= dataMax) && (newXValueEnd >= dataMin && newXValueEnd <= dataMax);
};

infChart.positionsDrawing.prototype.additionalDrawingsFunction = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        styles = options.styles,
        chart = ann.chart,
        additionalDrawings = self.additionalDrawings,
        additionalDrawingItems = self.additionalDrawingItems;

    for (var i = 0; i < additionalDrawingItems.length; i++) {
        var color = additionalDrawingItems[i] === 'takeProfit' ? styles.takeProfitColor : styles.stopLossColor;
        var fillOpacity = additionalDrawingItems[i] === 'takeProfit' ? styles.takeProfitFillOpacity : styles.stopLossFillOpacity;
        var textFillColor = additionalDrawingItems[i] === 'takeProfit' ? styles.takeProfitColor : additionalDrawingItems[i] === 'stopLoss' ? styles.stopLossColor : options.isLongPositions ? styles.stopLossColor : styles.takeProfitColor

        additionalDrawings[additionalDrawingItems[i]] = {
            line: chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr({
                'stroke-width': styles.lineWidth,
                stroke: color,
                opacity: fillOpacity,
                'z-index': 2,
                cursor: 'move'
            }).add(ann.group),
            fill: chart.renderer.path(['M', 0, 0, 'L', 0, 0, 'L', 0, 0, 'L', 0, 0]).attr({
                'stroke-width': 0,
                fill: color,
                'fill-opacity': fillOpacity,
                stroke: ann.options.shape.params.stroke,
                'z-index': 2,
                cursor: 'move'
            }).add(ann.group),
            label: chart.renderer.label("", 0, 0).css({
                'color': styles.textColor,
                fontSize: styles.textFontSize || '16px'
            }).attr({
                stroke: textFillColor,
                opacity: styles.textOpacity,
                'stroke-width': 0,
                padding: 4,
                r: 0,
                fill: textFillColor
            }).add(ann.group)
        };
    }
};

/**
 * Returns the obj of properties to copy
 * @returns {object} properties
 */
infChart.positionsDrawing.prototype.getConfigToCopy = function () {
    var stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(this.annotation.chart);
    var chartInstance = infChart.manager.getChart(stockChartId);
    var xAxis = chartInstance.getMainXAxis();
    var yAxis = chartInstance.getMainYAxis();
    var properties = this.getConfig();
    var shapeTheme = infChart.drawingUtils.common.theme[this.shape];
    var copyDistance = shapeTheme && shapeTheme.copyDistance;
    var defaultCopyDistance = infChart.drawingUtils.common.theme.defaultCopyDistance;
    var copyDistanceX = (copyDistance && (copyDistance.x || copyDistance.x === 0)) ? copyDistance.x : defaultCopyDistance;
    var copyDistanceY = (copyDistance && (copyDistance.y || copyDistance.y === 0)) ? copyDistance.y : defaultCopyDistance;

    properties.yValue = yAxis.toValue(yAxis.toPixels(properties.yValue) + copyDistanceY);
    properties.xValue = xAxis.toValue(xAxis.toPixels(properties.xValue) + copyDistanceX);
    var nearestDataPointForXValue = infChart.math.findNearestDataPoint(chartInstance.chart, properties.xValue, undefined, true, true);
    properties.xValueEnd = nearestDataPointForXValue.xData + (properties.xValueEnd - properties.nearestXDataPoint);

    return properties;
};

infChart.positionsDrawing.prototype.stop = function (e) {
    var ann = this.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];

    this.calculateDrawingData(true);
    this.drawPositionsDrawing();
    this.updateLabels();

    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, ann.options.yValueEnd);
    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.positionsDrawing.prototype.scale = function (isCalculateNewValueForScale) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options;

    if (isCalculateNewValueForScale) {
        var nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
        var seriesXData = chart.series[0].xData;
        var nearestDataPointForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true, true);
        var endDataPointIndex = nearestDataPointForXValue.dataIndex + (nearestDataPointForXValueEnd.dataIndex - nearestDataPointForXValue.dataIndex);
        var newXValueEnd = seriesXData.length > endDataPointIndex? seriesXData[endDataPointIndex]: infChart.math.getFutureXValueForGivenIndex(chart, endDataPointIndex);
        ann.update({
            nearestXDataPoint: nearestDataPointForXValue.xData,
            startDataPointIndex: nearestDataPointForXValue.dataIndex,
            xValueEnd: newXValueEnd,
            endDataPointIndex: endDataPointIndex
        });
    }
        
    this.calculateDrawingData(true);
    this.drawPositionsDrawing();
    this.updateLabels();
};

infChart.positionsDrawing.prototype.translate = function (e) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true),
        seriesXData = chart.series[0].xData,
        endDataPointIndex = nearestDataPointForXValue.dataIndex + (options.endDataPointIndex - options.startDataPointIndex),
        newXValueEnd = seriesXData.length > endDataPointIndex? seriesXData[endDataPointIndex]: infChart.math.getFutureXValueForGivenIndex(chart, endDataPointIndex);

    ann.update({
        nearestXDataPoint: nearestDataPointForXValue.xData,
        startDataPointIndex: nearestDataPointForXValue.dataIndex,
        xValueEnd: newXValueEnd,
        endDataPointIndex: endDataPointIndex
    });

    this.calculateDrawingData(true);
    this.drawPositionsDrawing();
    this.updateLabels();

    // infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    // infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, ["M", line[1], 0, 'L', line[4], line[5]], this.dragSupporters);
};

infChart.positionsDrawing.prototype.translateEnd = function () {
    // this.selectAndBindResize();
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.positionsDrawing.prototype.isRequiredProperty = function (propertyId) {
    var isPositionProperty = false;

    switch (propertyId) {
        case "yValue":
        case "yValueEnd":
        case "xValue":
        case "xValueEnd":
        case "isLongPositions" :
        case "settings" :
        case "isLocked":
            isPositionProperty = true;
            break;
        default :
            break;
    }

    return isPositionProperty;
};

//region Draw positions

infChart.positionsDrawing.prototype.drawPositionsDrawing = function () {
    var ann = this.annotation,
        options = ann.options,
        settings = options.settings,
        styles = options.styles,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        additionalDrawings = this.additionalDrawings,
        xValuePixels = xAxis.toPixels(options.xValue),
        yValuePixels = yAxis.toPixels(options.yValue),
        newX = xAxis.toPixels(options.nearestXDataPoint) - xValuePixels,
        newXEnd = xAxis.toPixels(options.xValueEnd) - xValuePixels,
        line = ["M", newX, 0, 'L', newXEnd, 0],
        takeProfitY = yAxis.toPixels(settings.takeProfit.price) - yValuePixels,
        stopLossY = yAxis.toPixels(settings.stopLoss.price) - yValuePixels,
        takeProfitLine = ["M", newX, takeProfitY, 'L', newXEnd, takeProfitY],
        stopLossLine = ["M", newX, stopLossY, 'L', newXEnd, stopLossY];

    ann.update({
        shape: {
            params: {
                d: line
            }
        }
    });

    additionalDrawings.takeProfit.line.attr({
        d: takeProfitLine
    });

    additionalDrawings.takeProfit.fill.attr({
        d: ['M', takeProfitLine[1], takeProfitLine[2], 'L', takeProfitLine[4], takeProfitLine[5], 'L', line[4], line[5], 'L', line[1], line[2], 'L', takeProfitLine[1], takeProfitLine[2]]
    });

    additionalDrawings.stopLoss.line.attr({
        d: stopLossLine
    });

    additionalDrawings.stopLoss.fill.attr({
        d: ['M', stopLossLine[1], stopLossLine[2], 'L', stopLossLine[4], stopLossLine[5], 'L', line[4], line[5], 'L', line[1], line[2], 'L', stopLossLine[1], stopLossLine[2]]
    });

    if (settings.pAndL.lineStartDate) {
        var pAndLLineX = xAxis.toPixels(settings.pAndL.lineStartDate) - xValuePixels,
            pAndLLineY = yAxis.toPixels(settings.pAndL.lineStartPrice) - yValuePixels,
            pAndLLineXEnd = xAxis.toPixels(settings.pAndL.lineEndDate) - xValuePixels,
            pAndLLineYEnd = yAxis.toPixels(settings.pAndL.lineEndPrice) - yValuePixels,
            pAndLLine = ["M", pAndLLineX, pAndLLineY, 'L', pAndLLineXEnd, pAndLLineYEnd],
            color = options.isLongPositions ? settings.pAndL.lineEndPrice > settings.entryPrice ? styles.takeProfitColor : styles.stopLossColor : settings.pAndL.lineEndPrice < settings.entryPrice ? styles.takeProfitColor : styles.stopLossColor,
            fillOpacity = options.isLongPositions ? settings.pAndL.lineEndPrice > settings.entryPrice ? styles.takeProfitFillOpacity : styles.stopLossFillOpacity : settings.pAndL.lineEndPrice < settings.entryPrice ? styles.takeProfitFillOpacity : styles.stopLossFillOpacity;

        additionalDrawings.pAndL.line.attr({
            d: pAndLLine,
            'stroke-dasharray': "2 2",
            stroke: styles.lineColor,
            opacity: styles.lineOpacity
        }).show();

        additionalDrawings.pAndL.fill.attr({
            d: ['M', pAndLLine[1], pAndLLine[2], 'L', pAndLLine[4], pAndLLine[2], 'L', pAndLLine[4], pAndLLine[5], 'L', pAndLLine[1], pAndLLine[5], 'L', pAndLLine[1], pAndLLine[2]],
            fill: color,
            'fill-opacity': fillOpacity
        }).show();
    } else {
        additionalDrawings.pAndL.line.hide();
        additionalDrawings.pAndL.fill.hide();
    }

    var pAndLLabelColor = options.labelData.pAndL.closedPAndLRawValue > 0 ? styles.takeProfitColor : styles.stopLossColor;
    additionalDrawings.pAndL.label.attr({
        stroke: pAndLLabelColor,
        fill: pAndLLabelColor
    });

    // infChart.drawingUtils.common.removeDragSupporters.call(this, this.dragSupporters);
    // infChart.drawingUtils.common.addDragSupporters.call(this, ann, chart, ["M", line[1], 0, 'L', line[4], line[5]], this.dragSupporters);
    //TODO draw drag supporters
}

infChart.positionsDrawing.prototype.updateLabels = function () {
    var ann = this.annotation,
        options = ann.options,
        settings = options.settings,
        additionalDrawings = this.additionalDrawings,
        mainLine = ann.shape.d.split(' '),
        takeProfitLine = additionalDrawings.takeProfit.line.d.split(' '),
        stopLossLine = additionalDrawings.stopLoss.line.d.split(' ');

    this.setLabel(options.styles.isCompactStats, options.isLongPositions, "takeProfit", additionalDrawings.takeProfit.label, takeProfitLine, options.labelData.takeProfit, settings.takeProfit);
    this.setLabel(options.styles.isCompactStats, options.isLongPositions, "stopLoss", additionalDrawings.stopLoss.label, stopLossLine, options.labelData.stopLoss, settings.stopLoss);
    this.setLabel(options.styles.isCompactStats, options.isLongPositions, "pAndL", additionalDrawings.pAndL.label, mainLine, options.labelData.pAndL);
};

infChart.positionsDrawing.prototype.setLabel = function (isCompactStats, isLongPositions, type, labelObj, line, labelData, settings) {
    var labelText = "",
        labelPosition = 0,
        y = parseFloat(line[2]),
        dx = parseFloat(line[4]);

    switch (type) {
        case "takeProfit":
            labelText = isCompactStats ? labelData.target + " (" + labelData.percentageTarget + "%) " + labelData.amount :
                "Target: " + labelData.target + " (" + labelData.percentageTarget + "%) " + settings.tickSize + ", Amount: " + labelData.amount;
            break;
        case "stopLoss":
            labelText = isCompactStats ? labelData.stop + " (" + labelData.percentageStop + "%) " + labelData.amount :
                "Stop: " + labelData.stop + " (" + labelData.percentageStop + "%) " + settings.tickSize + ", Amount: " + labelData.amount;
            break;
        case "pAndL" :
            labelText = isCompactStats ? labelData.closedPAndL + " ~ " + labelData.qty + "<br>" + labelData.riskRewardRatio :
                "Closed P&L: " + labelData.closedPAndL + ", Qty: " + labelData.qty + "<br>Risk/Reward Ratio: " + labelData.riskRewardRatio;
            break;
    }

    labelObj.textSetter(labelText);

    switch (type) {
        case "takeProfit":
            labelPosition = isLongPositions ? y - labelObj.height - 10 : y + 10;
            break;
        case "stopLoss":
        case "pAndL" :
            labelPosition = isLongPositions ? y + 10 : y - labelObj.height - 10;
            break;
    }

    labelObj.attr({
        x: dx / 2 - labelObj.width / 2,
        y: labelPosition
    });
};

//endregion

//region Calculations

infChart.positionsDrawing.prototype.calculateDrawingData = function (updateSettings) {
    var ann = this.annotation,
        options = ann.options,
        settings = options.settings,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        decimalPoints = this.stockChart.getMainSeries().options.dp,
        takeProfitPriceFactor = settings.takeProfit.tickSize * (1 / Math.pow(10, decimalPoints)),
        stopLossPriceFactor = settings.stopLoss.tickSize * (1 / Math.pow(10, decimalPoints));

    settings.entryPrice = options.yValue;
    settings.takeProfit.price = options.isLongPositions ? settings.entryPrice + takeProfitPriceFactor : settings.entryPrice - takeProfitPriceFactor;
    settings.stopLoss.price = options.isLongPositions ? settings.entryPrice - stopLossPriceFactor : settings.entryPrice + stopLossPriceFactor;
    settings.risk.size = settings.accountSize * (settings.risk.percentage / 100);

    var target = options.isLongPositions ? settings.takeProfit.price - settings.entryPrice : settings.entryPrice - settings.takeProfit.price,
        stop = options.isLongPositions ? settings.entryPrice - settings.stopLoss.price : settings.stopLoss.price - settings.entryPrice,
        qty = (settings.risk.size / (settings.entryPrice - settings.stopLoss.price)) / settings.lotSize;

    this.calculatePAndLBoxPrices();

    var closedPAndL = options.isLongPositions ? settings.pAndL.projectionPrice - settings.entryPrice : settings.entryPrice - settings.pAndL.projectionPrice

    options.labelData = {
        takeProfit: {
            target: infChart.drawingUtils.common.formatValue(target, decimalPoints),
            percentageTarget: infChart.drawingUtils.common.formatValue((target / settings.entryPrice) * 100, 2),
            amount: infChart.drawingUtils.common.formatValue(settings.accountSize + (target * qty), 2)
        },
        stopLoss: {
            stop: infChart.drawingUtils.common.formatValue(stop, decimalPoints),
            percentageStop: infChart.drawingUtils.common.formatValue((stop / settings.entryPrice) * 100, 2),
            amount: infChart.drawingUtils.common.formatValue(settings.accountSize - (stop * qty), 2)
        },
        pAndL: {
            closedPAndLRawValue: closedPAndL,
            closedPAndL: infChart.drawingUtils.common.formatValue(closedPAndL, 2),
            qty: infChart.drawingUtils.common.formatValue(qty, 0),
            riskRewardRatio: infChart.drawingUtils.common.formatValue((settings.takeProfit.price - settings.entryPrice) / (settings.entryPrice - settings.stopLoss.price), 2)
        }
    }

    if (updateSettings) {
        this.updateSettings(options);
    }
};

infChart.positionsDrawing.prototype.calculatePAndLBoxPrices = function () {
    var ann = this.annotation,
        options = ann.options,
        settings = options.settings,
        chart = ann.chart,
        series = chart.series[0],
        seriesXData = series.xData,
        pAndLEntryIndex = -1,
        pAndLData = {
            projectionPrice: null,
            lineStartPrice: null,
            lineStartDate: null,
            lineEndPrice: null,
            lineEndDate: null
        },
        currentCandleData,
        lastCandleIndex = seriesXData.length > options.endDataPointIndex? options.endDataPointIndex : seriesXData.length - 1;

    for (var i = options.startDataPointIndex; i <= lastCandleIndex; i++) {
        currentCandleData = infChart.util.getCandleData(chart, i);

        if (settings.entryPrice >= currentCandleData[2] && settings.entryPrice <= currentCandleData[1]) {
            pAndLData.lineStartPrice = settings.entryPrice;
            pAndLData.lineStartDate = seriesXData[i];
            pAndLEntryIndex = i;
            break;
        }
    }

    if (pAndLEntryIndex !== -1) {
        for (var j = pAndLEntryIndex; j <= lastCandleIndex; j++) {
            currentCandleData = infChart.util.getCandleData(chart, j);

            if (currentCandleData[1] >= settings.stopLoss.price && currentCandleData[2] <= settings.stopLoss.price) {
                pAndLData.lineEndPrice = settings.stopLoss.price;
                pAndLData.lineEndDate = seriesXData[j];
                break;
            } else if (currentCandleData[1] >= settings.takeProfit.price && currentCandleData[2] <= settings.takeProfit.price) {
                pAndLData.lineEndPrice = settings.takeProfit.price;
                pAndLData.lineEndDate = seriesXData[j];
                break;
            } else if ((options.isLongPositions && currentCandleData[1] < settings.stopLoss.price && currentCandleData[2] < settings.stopLoss.price) ||
                (!options.isLongPositions && currentCandleData[1] > settings.stopLoss.price && currentCandleData[2] > settings.stopLoss.price)) {
                pAndLData.lineEndPrice = settings.stopLoss.price;
                pAndLData.lineEndDate = seriesXData[j];
                break;
            } else if ((options.isLongPositions && currentCandleData[1] > settings.takeProfit.price && currentCandleData[2] > settings.takeProfit.price) ||
                (!options.isLongPositions && currentCandleData[1] < settings.takeProfit.price && currentCandleData[2] < settings.takeProfit.price)) {
                pAndLData.lineEndPrice = settings.takeProfit.price;
                pAndLData.lineEndDate = seriesXData[j];
                break;
            } else if (j === lastCandleIndex) {
                if ((options.isLongPositions && ((currentCandleData[3] > settings.entryPrice && currentCandleData[3] <= settings.takeProfit.price) || (currentCandleData[3] < settings.entryPrice && currentCandleData[3] >= settings.stopLoss.price))) ||
                    (!options.isLongPositions && ((currentCandleData[3] < settings.entryPrice && currentCandleData[3] >= settings.takeProfit.price) || (currentCandleData[3] > settings.entryPrice && currentCandleData[3] <= settings.stopLoss.price)))) {
                    pAndLData.lineEndPrice = currentCandleData[3];
                    pAndLData.lineEndDate = seriesXData[j];
                    break;
                }
            }
        }
    }

    if (pAndLData.lineEndPrice) {
        pAndLData.projectionPrice = pAndLData.lineEndPrice;
    } else {
        pAndLData.projectionPrice = infChart.util.getCandleData(chart, lastCandleIndex)[3];
    }

    settings.pAndL = pAndLData;
}

infChart.positionsDrawing.prototype.entryPriceChangeCalculation = function (newEntryPrice, options) {
    var settings = options.settings,
        decimalPoints = this.stockChart.getMainSeries().options.dp,
        priceFactor = Math.pow(10, decimalPoints);

    settings.entryPrice = newEntryPrice;

    if (options.isLongPositions) {
        settings.takeProfit.tickSize = Math.floor((settings.takeProfit.price - settings.entryPrice) * priceFactor);
        settings.stopLoss.tickSize = Math.floor((settings.entryPrice - settings.stopLoss.price) * priceFactor);
    } else {
        settings.takeProfit.tickSize = Math.floor((settings.entryPrice - settings.takeProfit.price) * priceFactor);
        settings.stopLoss.tickSize = Math.floor((settings.stopLoss.price - settings.entryPrice) * priceFactor);
    }
};

infChart.positionsDrawing.prototype.priceChangeCalculation = function (newPrice, isTakeProfit) {
    var ann = this.annotation,
        options = ann.options,
        settings = options.settings,
        decimalPoints = this.stockChart.getMainSeries().options.dp,
        priceFactor = Math.pow(10, decimalPoints);

    if (isTakeProfit) {
        settings.takeProfit.price = newPrice;

        if (options.isLongPositions) {
            settings.takeProfit.tickSize = Math.floor((settings.takeProfit.price - settings.entryPrice) * priceFactor);

        } else {
            settings.takeProfit.tickSize = Math.floor((settings.entryPrice - settings.takeProfit.price) * priceFactor);

        }
    } else {
        settings.stopLoss.price = newPrice;

        if (options.isLongPositions) {
            settings.stopLoss.tickSize = Math.floor((settings.entryPrice - settings.stopLoss.price) * priceFactor);
        } else {
            settings.stopLoss.tickSize = Math.floor((settings.stopLoss.price - settings.entryPrice) * priceFactor);
        }
    }
};

//endregion

//region Select and bind resize

infChart.positionsDrawing.prototype.deselect = function (isMouseOut) {
    infChart.drawingUtils.common.onDeselect.call(this);
    if (isMouseOut) {
        this.additionalDrawings.takeProfit.label.hide();
        this.additionalDrawings.stopLoss.label.hide();
        this.additionalDrawings.pAndL.label.hide();
    }
};

infChart.positionsDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation,
        additionalDrawings = this.additionalDrawings,
        mainLine = ann.shape.d.split(' '),
        takeProfitLine = additionalDrawings.takeProfit.line.d.split(' '),
        stopLossLine = additionalDrawings.stopLoss.line.d.split(' ');

    ann.events.deselect.call(ann);
    additionalDrawings.takeProfit.label.show();
    additionalDrawings.stopLoss.label.show();
    additionalDrawings.pAndL.label.show();
    ann.selectionMarker = [];
    infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, mainLine[1], mainLine[2], this.mainLineStep, this.mainLineStop, true);
    infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, mainLine[4], mainLine[5], this.mainLineStep, this.mainLineStop, false);
    infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, takeProfitLine[1], takeProfitLine[2], this.priceLineStep, this.priceLineStep, true);
    infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, stopLossLine[1], stopLossLine[2], this.priceLineStep, this.priceLineStep, false);
};

infChart.positionsDrawing.prototype.mainLineStep = function (e, isStartPoint) {
    var ann = this.annotation,
        options = ann.options,
        settings = options.settings,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        x = e.chartX,
        y = e.chartY,
        xValue = xAxis.toValue(x),
        yValue = yAxis.toValue(y),
        updatedAttributes = {},
        nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, xValue, undefined, true, true);

    if (isStartPoint) {
        if (options.isLongPositions) {
            updatedAttributes.yValue = settings.takeProfit.price <= yValue ? settings.takeProfit.price - this.priceDifferenceFactor : settings.stopLoss.price >= yValue ? settings.stopLoss.price + this.priceDifferenceFactor : yValue;
        } else {
            updatedAttributes.yValue = settings.stopLoss.price <= yValue ? settings.stopLoss.price - this.priceDifferenceFactor : settings.takeProfit.price >= yValue ? settings.takeProfit.price + this.priceDifferenceFactor : yValue;
        }

        this.entryPriceChangeCalculation(updatedAttributes.yValue, options);

        updatedAttributes.xValue = xValue;
        updatedAttributes.nearestXDataPoint = nearestDataPointForXValue.xData;
        updatedAttributes.startDataPointIndex = nearestDataPointForXValue.dataIndex;
    } else {
        updatedAttributes.xValueEnd = nearestDataPointForXValue.xData;
        updatedAttributes.endDataPointIndex = nearestDataPointForXValue.dataIndex;
    }

    ann.update(updatedAttributes);

    this.calculateDrawingData(true);
    this.drawPositionsDrawing();
    this.updateLabels();

    infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
};

infChart.positionsDrawing.prototype.mainLineStop = function () {
    var ann = this.annotation;

    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, ann.options.yValueEnd);
}

infChart.positionsDrawing.prototype.priceLineStep = function (e, isTakeProfit) {
    var ann = this.annotation,
        options = ann.options,
        settings = options.settings,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        x = e.chartX,
        y = e.chartY,
        xValue = xAxis.toValue(x),
        yValue = yAxis.toValue(y),
        newPrice;

    if (options.isLongPositions) {
        if (isTakeProfit) {
            newPrice = settings.entryPrice <= yValue ? yValue : settings.entryPrice + this.priceDifferenceFactor;
        } else {
            newPrice = settings.entryPrice >= yValue ? yValue : settings.entryPrice - this.priceDifferenceFactor;
        }
    } else {
        if (isTakeProfit) {
            newPrice = settings.entryPrice >= yValue ? yValue : settings.entryPrice - this.priceDifferenceFactor;
        } else {
            newPrice = settings.entryPrice <= yValue ? yValue : settings.entryPrice + this.priceDifferenceFactor;
        }
    }

    this.priceChangeCalculation(newPrice, isTakeProfit);
    this.calculateDrawingData(true);
    this.drawPositionsDrawing();
    this.updateLabels();
};

//endregion

//region Settings

infChart.positionsDrawing.prototype.getQuickSettingsPopup = function () {
    return infChart.structureManager.drawingTools.getPositionsQuickSettings(this.stockChart.symbol.currency, this.annotation.options.styles);
};

infChart.positionsDrawing.prototype.getSettingsPopup = function () {
    return infChart.structureManager.drawingTools.getPositionsSettings(this.stockChart.symbol.currency, this.annotation.options.styles);
};

/**
 * Update the annotations options specific to this tool from the given properties
 * @param options
 */
infChart.positionsDrawing.prototype.updateOptions = function (options) {
    var ann = this.annotation;
    ann && ann.options && (ann.options.nearestXDataPoint = infChart.math.findNearestXDataPoint(ann.chart, options.xValue));
    if (options.settings && options.settings.stopLoss) {
        ann.options.settings.stopLoss = options.settings.stopLoss;
    }
    if (options.settings && options.settings.takeProfit) {
        ann.options.settings.takeProfit = options.settings.takeProfit;
    }
};

infChart.positionsDrawing.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updatePositionsSettings($(this.settingsPopup), properties.settings, properties.styles, this.stockChart.getMainSeries().options.dp);
};

infChart.positionsDrawing.prototype.bindSettingsEvents = function () {
    var self = this,
        ann = self.annotation;

    function onAccountSizeChange(accountSize) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onLabelDataChange.call(self, "accountSize", accountSize, isPropertyChange);
    }

    function onLotSizeChange(lotSize) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onLabelDataChange.call(self, "lotSize", lotSize, isPropertyChange);
    }

    function onRiskChange(riskValue) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }

        self.onRiskChange.call(self, riskValue, isPropertyChange);
    }

    function onEntryPriceChange(entryPrice) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onEntryPriceChange.call(self, entryPrice, isPropertyChange);
    }

    function onTakeProfitTicksChange(ticks) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onPriceTicksChange.call(self, true, ticks, isPropertyChange);
    }

    function onTakeProfitPriceChange(takeProfit) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onPriceChange.call(self, true, takeProfit, isPropertyChange);
    }

    function onStopLossTicksChange(ticks) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onPriceTicksChange.call(self, false, ticks, isPropertyChange);
    }

    function onStopLossPriceChange(stopLoss) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onPriceChange.call(self, false, stopLoss, isPropertyChange);
    }

    function onLineColorChange(rgb, value, opacity) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onLineColorChange.call(self, value, opacity, isPropertyChange);
    }

    function onLineWidthChange(strokeWidth) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onLineWidthChange.call(self, strokeWidth, isPropertyChange);
    }

    function onStopLossColorChange(rgb, value, opacity) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onStopLossColorChange.call(self, value, opacity, isPropertyChange);
    }

    function onTakeProfitColorChange(rgb, value, opacity) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onTakeProfitColorChange.call(self, value, opacity, isPropertyChange);
    }

    function onTextColorChange(rgb, value, opacity) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onTextColorChange.call(self, value, opacity, isPropertyChange);
    }

    function onCompactStatsModeChange(value) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onCompactStatsModeChange.call(self, value, isPropertyChange);
    }

    function onLabelTextSizeChange(newFontSize) {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        infChart.drawingUtils.common.settings.onLabelTextSizeChange.call(self, newFontSize, isPropertyChange);
    }

    function onResetToDefault () {
        self.updateSavedDrawingProperties(true);
    }

    var CallBackFnPositionSettings = {
        onAccountSizeChange: onAccountSizeChange,
        onLotSizeChange:onLotSizeChange,
        onRiskChange:onRiskChange,
        onEntryPriceChange:onEntryPriceChange,
        onTakeProfitTicksChange:onTakeProfitTicksChange,
        onTakeProfitPriceChange:onTakeProfitPriceChange,
        onStopLossTicksChange:onStopLossTicksChange,
        onStopLossPriceChange:onStopLossPriceChange,
        onLineColorChange:onLineColorChange,
        onLineWidthChange:onLineWidthChange,
        onStopLossColorChange:onStopLossColorChange,
        onTakeProfitColorChange:onTakeProfitColorChange,
        onTextColorChange:onTextColorChange,
        onCompactStatsModeChange:onCompactStatsModeChange,
        onLabelTextSizeChange:onLabelTextSizeChange,
        onResetToDefault:onResetToDefault
    }

    infChart.structureManager.drawingTools.bindPositionsSettings(self.settingsPopup, ann, this.priceDifferenceFactor, CallBackFnPositionSettings);
};

infChart.positionsDrawing.prototype.onLabelDataChange = function (type, value, isPropertyChange) {
    this.annotation.options.settings[type] = parseFloat(value);
    this.calculateDrawingData(true);
    this.updateLabels();

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.positionsDrawing.prototype.onRiskChange = function (value, isPropertyChange) {
    var ann = this.annotation,
        settings = ann.options.settings;

    if (settings.risk.selectedItem === "size") {
        settings.risk.size = parseFloat(value);
        settings.risk.percentage = (settings.risk.size / settings.accountSize) * 100;
    } else {
        settings.risk.percentage = parseFloat(value);
    }

    this.calculateDrawingData(true);
    this.updateLabels();

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.positionsDrawing.prototype.onEntryPriceChange = function (entryPrice, isPropertyChange) {
    this.annotation.update({
        yValue: parseFloat(entryPrice)
    });

    this.entryPriceChangeCalculation(this.annotation.options.yValue, this.annotation.options);
    this.calculateDrawingData(true);
    this.drawPositionsDrawing();
    this.updateLabels();

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.positionsDrawing.prototype.onPriceTicksChange = function (isTakeProfit, tickSize, isPropertyChange) {
    this.annotation.options.settings[isTakeProfit ? "takeProfit" : "stopLoss"].tickSize = parseInt(tickSize);
    this.calculateDrawingData(true);
    this.drawPositionsDrawing();
    this.updateLabels();

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.positionsDrawing.prototype.onPriceChange = function (isTakeProfit, price, isPropertyChange) {
    this.priceChangeCalculation(price, isTakeProfit);
    this.calculateDrawingData(true);
    this.drawPositionsDrawing();
    this.updateLabels();

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.positionsDrawing.prototype.onLineColorChange = function (value, opacity, isPropertyChange) {
    this.annotation.update({
        shape: {
            params: {
                stroke: value,
                opacity: opacity
            }
        },
        styles: {
            lineColor: value,
            lineOpacity: opacity
        }
    });
    this.additionalDrawings.pAndL.line.attr({
        stroke: value,
        opacity: opacity
    });

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.positionsDrawing.prototype.onLineWidthChange = function (strokeWidth, isPropertyChange) {
    this.annotation.update({
        shape: {
            params: {
                'stroke-width': strokeWidth
            }
        },
        styles: {
            lineWidth: strokeWidth
        }
    });

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);

    this.selectAndBindResize();
}

infChart.positionsDrawing.prototype.onStopLossColorChange = function (value, opacity, isPropertyChange) {
    var elementType = this.additionalDrawings.stopLoss,
        options = this.annotation.options;

    elementType.line.attr({
        stroke: value,
        opacity: opacity
    });
    elementType.fill.attr({
        fill: value,
        'fill-opacity': opacity
    });
    elementType.label.attr({
        stroke: value,
        fill: value
    });

    options.styles.stopLossColor = value;
    options.styles.stopLossFillOpacity = opacity;

    if (options.labelData && options.labelData.pAndL.closedPAndLRawValue < 0) {
        this.additionalDrawings.pAndL.label.attr({
            stroke: value,
            fill: value
        });
    }

    if (options.settings && options.settings.pAndL.lineStartPrice && options.settings.pAndL.lineEndPrice &&
        ((options.isLongPositions && options.settings.pAndL.lineStartPrice > options.settings.pAndL.lineEndPrice) ||
            (!options.isLongPositions && options.settings.pAndL.lineStartPrice < options.settings.pAndL.lineEndPrice))) {
        this.additionalDrawings.pAndL.fill.attr({
            fill: value,
            'fill-opacity': opacity
        });
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.positionsDrawing.prototype.onTakeProfitColorChange = function (value, opacity, isPropertyChange) {
    var elementType = this.additionalDrawings.takeProfit,
        options = this.annotation.options;

    elementType.line.attr({
        stroke: value,
        opacity: opacity
    });
    elementType.fill.attr({
        fill: value,
        'fill-opacity': opacity
    });
    elementType.label.attr({
        stroke: value,
        fill: value
    });

    options.styles.takeProfitColor = value;
    options.styles.takeProfitFillOpacity = opacity;

    if (options.labelData && options.labelData.pAndL.closedPAndLRawValue > 0) {
        this.additionalDrawings.pAndL.label.attr({
            stroke: value,
            fill: value
        });
    }

    if (options.settings && options.settings.pAndL.lineStartPrice && options.settings.pAndL.lineEndPrice &&
        ((options.isLongPositions && options.settings.pAndL.lineStartPrice < options.settings.pAndL.lineEndPrice) ||
            (!options.isLongPositions && options.settings.pAndL.lineStartPrice > options.settings.pAndL.lineEndPrice))) {
        this.additionalDrawings.pAndL.fill.attr({
            fill: value,
            'fill-opacity': opacity
        });
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.positionsDrawing.prototype.onTextColorChange = function (value, opacity, isPropertyChange) {
    var additionalDrawings = this.additionalDrawings;
    var newColor = {opacity: opacity};
    var css = {color: value};

    additionalDrawings.takeProfit.label.css(css).attr(newColor);
    additionalDrawings.stopLoss.label.css(css).attr(newColor);
    additionalDrawings.pAndL.label.css(css).attr(newColor);

    this.annotation.options.styles.textColor = value;
    this.annotation.options.styles.textOpacity = opacity;

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.positionsDrawing.prototype.onCompactStatsModeChange = function (value, isPropertyChange) {
    this.annotation.options.styles.isCompactStats = value;
    this.updateLabels();

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
};

infChart.positionsDrawing.prototype.specificCursorChange = function(url){
    var self = this,
        ann = self.annotation,
        options = ann.options,
        additionalDrawings = self.additionalDrawings;
    
    if(additionalDrawings.pAndL){
        var pAndL = additionalDrawings.pAndL;
        if(pAndL.fill){
            if(url){
                pAndL.fill.css({'cursor': 'url("' + url + '"), default'});
            } else {
                infChart.util.setCursor(pAndL.fill, 'move');
                pAndL.fill.css({'cursor': 'move'});
            }
        }
        if(pAndL.line){
            if(url){
                pAndL.line.css({'cursor': 'url("' + url + '"), default'});
            } else {
                infChart.util.setCursor(pAndL.line, 'move');
                pAndL.line.css({'cursor': 'move'});
            }
        }
    }

    if(additionalDrawings.stopLoss){
        var stopLoss = additionalDrawings.stopLoss;
        if(stopLoss.fill){
            if(url){
                stopLoss.fill.css({'cursor': 'url("' + url + '"), default'});
            } else {
                infChart.util.setCursor(stopLoss.fill, 'move');
                stopLoss.fill.css({'cursor': 'move'});
            }
        }
        if(stopLoss.line){
            if(url){
                stopLoss.line.css({'cursor': 'url("' + url + '"), default'});
            } else {
                infChart.util.setCursor(stopLoss.line, 'move');
                stopLoss.line.css({'cursor': 'move'});
            }
        }
    }

    if(additionalDrawings.takeProfit){
        var takeProfit = additionalDrawings.takeProfit;
        if(takeProfit.fill){
            if(url){
                takeProfit.fill.css({'cursor': 'url("' + url + '"), default'});
            } else {
                infChart.util.setCursor(takeProfit.fill, 'move');
                takeProfit.fill.css({'cursor': 'move'});
            }
        }
        if(takeProfit.line){
            if(url){
                takeProfit.line.css({'cursor': 'url("' + url + '"), default'});
            } else {
                infChart.util.setCursor(takeProfit.line, 'move');
                takeProfit.line.css({'cursor': 'move'});
            }
        }
    }
};

//endregion



window.infChart = window.infChart || {};

infChart.volumeProfileDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
    this.settingTypes = {
        volume: "v",
        valueAreaVolume: "va",
        barCount: "bc"
    };

    this.defaultStyles = {
        volumeProfileUpVolumeColor: '#0066FF',
        volumeProfileUpVolumeOpacity: 0.25,
        volumeProfileDownVolumeColor: '#FFCC00',
        volumeProfileDownVolumeOpacity: 0.25,
        volumeProfileAreaUpVolumeColor: '#0066FF',
        volumeProfileAreaUpVolumeOpacity: 0.7,
        volumeProfileAreaDownVolumeColor: '#FFCC00',
        volumeProfileAreaDownVolumeOpacity: 0.7,
        valueAreaHighColor: '#33CC00',
        valueAreaHighOpacity: 100,
        valueAreaLowColor: '#FF9933',
        valueAreaLowOpacity: 100,
        pointOfControlColor: '#FF4D4D',
        pointOfControlOpacity: 100,
        valuesColor: '#FFFFFF',
        valuesOpacity: 100,
        histogramBoxColor: '#0099FF',
        histogramBoxOpacity: 0.1
    };
    this.volumeTypes = {
        total: {id: "total", displayName: "Total"},
        upDown: {id: "upDown", displayName: "Up/Down"}
        // ,
        // delta: {id: "delta", displayName: "Delta"}
    };

    this.intervalsArray = ['I_1', 'I_3', 'I_5', 'I_10', 'I_15', 'I_30', 'I_60', 'I_120', 'I_240', 'D', 'W', 'M'];
    this.defaultSettings = {
        barGapPixelWidth: 1,
        minApproximatedPoints: 1000,
        maxApproximatedPoints: 5000
    };

    var theme = infChart.drawingUtils.common.getTheme.call(this);
    var shapeTheme = theme[this.shape];
    this.settings = {
        volume: this.volumeTypes.total.id,
        valueAreaVolume: 70,
        barCount: 10,
        extendToRight: false,
        volumeProfile: {
            enabled: true,
            profileWidth: 50,
            flipChart: false,
            upVolumeColor: (shapeTheme && shapeTheme.upVolumeColor) ? shapeTheme.upVolumeColor : this.defaultStyles.volumeProfileUpVolumeColor,
            upVolumeOpacity: (shapeTheme && shapeTheme.upVolumeOpacity) ? shapeTheme.upVolumeOpacity : this.defaultStyles.volumeProfileUpVolumeOpacity,
            downVolumeColor: (shapeTheme && shapeTheme.downVolumeColor) ? shapeTheme.downVolumeColor : this.defaultStyles.volumeProfileDownVolumeColor,
            downVolumeOpacity: (shapeTheme && shapeTheme.downVolumeOpacity) ? shapeTheme.downVolumeOpacity : this.defaultStyles.volumeProfileDownVolumeOpacity,
            volumeAreaUpColor: (shapeTheme && shapeTheme.volumeAreaUpColor) ? shapeTheme.volumeAreaUpColor : this.defaultStyles.volumeProfileAreaUpVolumeColor,
            volumeAreaUpOpacity: (shapeTheme && shapeTheme.volumeAreaUpOpacity) ? shapeTheme.volumeAreaUpOpacity : this.defaultStyles.volumeProfileAreaUpVolumeOpacity,
            volumeAreaDownColor: (shapeTheme && shapeTheme.volumeAreaDownColor) ? shapeTheme.volumeAreaDownColor : this.defaultStyles.volumeProfileAreaDownVolumeColor,
            volumeAreaDownOpacity: (shapeTheme && shapeTheme.volumeAreaDownOpacity) ? shapeTheme.volumeAreaDownOpacity : this.defaultStyles.volumeProfileAreaDownVolumeOpacity
        },
        valueAreaHigh: {
            enabled: false,
            color: (shapeTheme && shapeTheme.valueAreaHighColor) ? shapeTheme.valueAreaHighColor : this.defaultStyles.valueAreaHighColor,
            opacity: (shapeTheme && shapeTheme.valueAreaHighOpacity) ? shapeTheme.valueAreaHighOpacity : this.defaultStyles.valueAreaHighOpacity,
            lineWidth: 1,
            lineStyle: 'solid'
        },
        valueAreaLow: {
            enabled: false,
            color: (shapeTheme && shapeTheme.valueAreaLowColor) ? shapeTheme.valueAreaLowColor : this.defaultStyles.valueAreaLowColor,
            opacity: (shapeTheme && shapeTheme.valueAreaLowOpacity) ? shapeTheme.valueAreaLowOpacity : this.defaultStyles.valueAreaLowOpacity,
            lineWidth: 1,
            lineStyle: 'solid'
        },
        pointOfControl: {
            enabled: false,
            color: (shapeTheme && shapeTheme.pointOfControlColor) ? shapeTheme.pointOfControlColor : this.defaultStyles.pointOfControlColor,
            opacity: (shapeTheme && shapeTheme.pointOfControlOpacity) ? shapeTheme.pointOfControlOpacity : this.defaultStyles.pointOfControlOpacity,
            lineWidth: 1,
            lineStyle: 'solid'
        },
        values: {
            enabled: false,
            color: (shapeTheme && shapeTheme.valuesColor) ? shapeTheme.valuesColor : this.defaultStyles.valuesColor,
            opacity: (shapeTheme && shapeTheme.valuesOpacity) ? shapeTheme.valuesOpacity : this.defaultStyles.valuesOpacity
        },
        histogramBox: {
            color: (shapeTheme && shapeTheme.histogramBoxColor) ? shapeTheme.histogramBoxColor : this.defaultStyles.histogramBoxColor,
            opacity: (shapeTheme && shapeTheme.histogramBoxOpacity) ? shapeTheme.histogramBoxOpacity : this.defaultStyles.histogramBoxOpacity
        }
    };
};

infChart.volumeProfileDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.volumeProfileDrawing.prototype.getConfig = function () {
    var annotation = this.annotation;
    return {
        shape: 'volumeProfile',
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        settings: annotation.options.settings,
        from: annotation.options.from,
        to: annotation.options.to,
        isLocked : annotation.options.isLocked

    };
};

infChart.volumeProfileDrawing.prototype.getOptions = function (properties, chart) {
    var nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, properties.xValue, undefined, true);
    var options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        allowDragX: false,
        allowDragY: false,
        allowDragByHandle: true,
        settings: properties.settings ? properties.settings : this.settings,
        shape: {
            params: {
                d: ['M', 0, 0, 'L', 0, 0],
                dashstyle: 'solid',
                stroke: '#959595',
                'stroke-width': 1,
                opacity: 100
            }
        },
        disableCopyPaste: true
    };

    if (properties.from) {
        options.from = properties.from;
    }

    if (properties.to) {
        options.to = properties.to;
    }

    if (properties.xValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
    }

    options = infChart.Drawing.prototype.getOptions(properties,options);

    return options;
};

infChart.volumeProfileDrawing.prototype.additionalDrawingsFunction = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        styles = options.styles,
        chart = ann.chart,
        additionalDrawings = self.additionalDrawings

    additionalDrawings.startLine = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr({
        'stroke-width': 1,
        stroke: '#959595',
        opacity: 100,
        'z-index': 2
    }).add(ann.group);

    additionalDrawings.endLine = chart.renderer.path(['M', 0, 0, 'L', 0, 0]).attr({
        'stroke-width': 1,
        stroke: '#959595',
        opacity: 100,
        'z-index': 2
    }).add(ann.group);

    additionalDrawings.volumeProfile = chart.renderer.createElement('foreignObject').add(ann.group).attr({
        "zIndex": 1,
        x: 0,
        y: 0
    });
};

infChart.volumeProfileDrawing.prototype.step = function (e, isStartPoint) {
    var ann = this.annotation,
        points = infChart.drawingUtils.common.calculateInitialPoints(e, ann, isStartPoint, 0, 0),
        options = ann.options,
        chart = ann.chart,
        additionalDrawings = this.additionalDrawings,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[ann.options.yAxis],
        xValueEnd = xAxis.toValue(xAxis.toPixels(options.xValue) + points.dx),
        yValueEnd = yAxis.toValue(yAxis.toPixels(options.yValue) + points.dy),
        nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true),
        nearestDataPointForXValueEnd = infChart.math.findNearestDataPoint(chart, xValueEnd, undefined, true),
        newX = xAxis.toPixels(nearestDataPointForXValue.xData) - xAxis.toPixels(ann.options.xValue),
        newXEnd = xAxis.toPixels(nearestDataPointForXValueEnd.xData) - xAxis.toPixels(ann.options.xValue);

    ann.shape.show();
    additionalDrawings.volumeProfile.css({
        display: 'none'
    });
    additionalDrawings.startLine.show();
    additionalDrawings.endLine.show();

    var line = ["M", newX, 0, 'L', parseInt(newXEnd, 10), parseInt(points.dy, 10)];
    ann.shape.attr({
        d: line
    });

    var newYPositions = this.updateStartAndEndLines(newX, newXEnd);

    return {
        line: line,
        nearestDataPointForXValue: nearestDataPointForXValue,
        nearestDataPointForXValueEnd: nearestDataPointForXValueEnd,
        newY: newYPositions.newY,
        newYEnd: newYPositions.newYEnd
    };
};

infChart.volumeProfileDrawing.prototype.stop = function (e, isStartPoint) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        additionalDrawings = self.additionalDrawings,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        lineData = self.stepFunction(e, isStartPoint),
        line = lineData.line,
        x = xAxis.toValue(line[4] + xAxis.toPixels(ann.options.xValue)),
        y = yAxis.toValue(line[5] + yAxis.toPixels(ann.options.yValue)),
        currentFromData = {
            value: lineData.nearestDataPointForXValue.xData,
            index: lineData.nearestDataPointForXValue.dataIndex
        },
        currentToData = {
            value: lineData.nearestDataPointForXValueEnd.xData,
            index: lineData.nearestDataPointForXValueEnd.dataIndex
        },
        newFromData = currentFromData.index > currentToData.index ? currentToData : currentFromData,
        newToData = currentFromData.index > currentToData.index ? currentFromData : currentToData;

    line[1] = 0;
    line[4] = xAxis.toPixels(lineData.nearestDataPointForXValueEnd.xData) - xAxis.toPixels(lineData.nearestDataPointForXValue.xData);

    ann.update({
        xValue: lineData.nearestDataPointForXValue.xData,
        xValueEnd: lineData.nearestDataPointForXValueEnd.xData,
        yValueEnd: yAxis.toValue(line[5] + yAxis.toPixels(ann.options.yValue)),
        from: newFromData,
        to: newToData,
        shape: {
            params: {
                d: line
            }
        }
    });

    self.updateStartAndEndLines(0, line[4], lineData.newY, lineData.newYEnd);
    infChart.drawingUtils.common.saveBaseYValues.call(this, ann.options.yValue, y);

    this.getDataAndDrawVolumeProfile(function () {
        self.selectAndBindResize();
        chart.selectedAnnotation = ann;
        infChart.drawingUtils.common.fixSelectionMarker.call(self, ann);
        infChart.drawingUtils.common.onPropertyChange.call(self);
    });
};

infChart.volumeProfileDrawing.prototype.scale = function (isCalculateNewValueForScale) {
    var self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        additionalDrawings = self.additionalDrawings, newX, newXEnd,
        yEnd = yAxis.toPixels(options.yValueEnd) - yAxis.toPixels(options.yValue),
        yAxisExtremes, newY, newYEnd;

    if (isCalculateNewValueForScale) {
        var nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true),
            nearestDataPointForXValueEnd = infChart.math.findNearestDataPoint(chart, options.xValueEnd, undefined, true);

        newX = xAxis.toPixels(nearestDataPointForXValue.xData) - xAxis.toPixels(options.xValue);
        newXEnd = xAxis.toPixels(nearestDataPointForXValueEnd.xData) - xAxis.toPixels(options.xValue);

        ann.update({
            xValue: nearestDataPointForXValue.xData,
            xValueEnd: nearestDataPointForXValueEnd.xData,
            from: {
                value: nearestDataPointForXValue.xData,
                index: nearestDataPointForXValue.dataIndex
            },
            to: {
                value: nearestDataPointForXValueEnd.xData,
                index: nearestDataPointForXValueEnd.dataIndex
            },
            shape: {
                params: {
                    d: ["M", newX, 0, 'L', newXEnd, yEnd]
                }
            }
        });

        self.updateStartAndEndLines(newX, newXEnd);
        self.getDataAndDrawVolumeProfile(function () {});

    } else {
        newXEnd = self.getVolumeProfileWidth(options.xValue, options.xValueEnd);//xAxis.toPixels(options.nearestXValueEnd) - xAxis.toPixels(ann.options.xValue);

        ann.update({
            shape: {
                params: {
                    d: ["M", 0, 0, 'L', newXEnd, yEnd]
                }
            }
        });

        if (options.currentDataSet && options.calculatedBars && options.calculatedBars.totalVolume > 0) {
            additionalDrawings.volumeProfile.attr({
                width: newXEnd,
                height: yEnd
            });

            $(additionalDrawings.volumeProfile.element).find("svg").css({
                width: "100%",
                height: "100%",
                display: "block"
            });
        } else {
            self.updateStartAndEndLines(newX, newXEnd);
        }
    }

};

infChart.volumeProfileDrawing.prototype.updateStartAndEndLines = function (newX, newXEnd, newY, newYEnd) {
    var ann = this.annotation,
        chart = ann.chart,
        options = ann.options,
        yAxis = chart.yAxis[options.yAxis],
        additionalDrawings = this.additionalDrawings,
        yAxisExtremes;

    if (!newY && !newYEnd) {
        yAxisExtremes = yAxis.getExtremes();
        newY = yAxis.toPixels(yAxisExtremes.max) - yAxis.toPixels(options.yValue);
        newYEnd = yAxis.toPixels(yAxisExtremes.min) - yAxis.toPixels(options.yValue);
    }

    additionalDrawings.startLine.attr({
        d: ["M", newX, newY, "L", newX, newYEnd]
    });

    additionalDrawings.endLine.attr({
        d: ["M", newXEnd, newY, "L", newXEnd, newYEnd]
    });

    return {newY: newY, newYEnd: newYEnd};
}

infChart.volumeProfileDrawing.prototype.isRequiredProperty = function (propertyId) {
    var isPositionProperty = false;

    switch (propertyId) {
        case "yValue":
        case "yValueEnd":
        case "xValue":
        case "xValueEnd":
        case "from":
        case "to":
        case "isLocked":
            isPositionProperty = true;
            break;
        default :
            break;
    }

    return isPositionProperty;
};

//region Draw Volume Profile


//endregion

//region Request and calculations

infChart.volumeProfileDrawing.prototype.getMinutesOfSelectedInterval = function (interval) {
    var minutes = 0;

    if (interval.indexOf("I") !== -1) {
        minutes = parseInt(interval.split("_")[1], 10);
    } else {
        switch (interval) {
            case 'D':
                minutes = 1440;
                break;
            case 'W':
                minutes = 10080;
                break;
            case 'M':
                minutes = 43200;
                break;
        }
    }

    return minutes;
}

infChart.volumeProfileDrawing.prototype.getRequestInterval = function (currentInterval) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        requestInterval,
        currentIntervalIndex = self.intervalsArray.indexOf(currentInterval),
        rangeCandleCount = options.to.index - options.from.index + 1,
        currentIntervalMinutes = self.getMinutesOfSelectedInterval(currentInterval),
        currenSelectedInterval, selectedIntervalMinutes,
        previousInterval = currentInterval, calculatedCandles;

    if (currentIntervalIndex === 0) {
        requestInterval = currentInterval;
    } else {
        for (var i = currentIntervalIndex - 1; i >= 0; i--) {
            currenSelectedInterval = self.intervalsArray[i];
            selectedIntervalMinutes = self.getMinutesOfSelectedInterval(currenSelectedInterval);
            calculatedCandles = rangeCandleCount * (currentIntervalMinutes / selectedIntervalMinutes);

            if (calculatedCandles > self.defaultSettings.maxApproximatedPoints) {
                requestInterval = previousInterval;
                break;
            } else if (calculatedCandles >= self.defaultSettings.minApproximatedPoints) {
                requestInterval = currenSelectedInterval;
                break;
            } else if (i === 0) {
                requestInterval = currenSelectedInterval;
            }

            previousInterval = currenSelectedInterval;
        }
    }

    return requestInterval;
}

infChart.volumeProfileDrawing.prototype.getDataAndDrawVolumeProfile = function (successFn) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        additionalDrawings = self.additionalDrawings,
        stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart),
        chartInstance = infChart.manager.getChart(stockChartId),
        requestInterval = self.getRequestInterval(chartInstance.interval);

    chartInstance.dataManager.getHistoryData(chartInstance.symbol, requestInterval, new Date(options.from.value), new Date(options.to.value), function (dataObj) {
        if (dataObj.data.length > 0) {
            ann.options.currentDataSet = dataObj.data;
            self.calculatePriceRange();
            self.calculateAndSetNewXAndYValues();
            self.calculateBars(dataObj.data);

            if (ann.options.calculatedBars.totalVolume > 0) {
                self.calculateValueAreaVolumeBars();
                self.drawVolumeProfile();
                additionalDrawings.volumeProfile.css({
                    display: 'block'
                });
            } else {
                ann.shape.show();
                additionalDrawings.volumeProfile.css({
                    display: 'none'
                });
                additionalDrawings.startLine.show();
                additionalDrawings.endLine.show();
            }
        } else {
            ann.options.currentDataSet = null;
            ann.shape.show();
            additionalDrawings.volumeProfile.css({
                display: 'none'
            });
            additionalDrawings.startLine.show();
            additionalDrawings.endLine.show();
        }
        successFn.call(self);
    }, function () {

    }, chartInstance.regularIntervalsOnUpdate, "prcOpen,prcLast,volAcc", true);
};

infChart.volumeProfileDrawing.prototype.calculatePriceRange = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        dataItem, maxPriceItem, minPriceItem,
        yDataOfFromIndex = infChart.util.getCandleData(chart, options.from.index),
        maxPrice = Math.max(...yDataOfFromIndex),
        minPrice = Math.min(...yDataOfFromIndex);

    for (var i = options.from.index; i <= options.to.index; i++) {
        dataItem = infChart.util.getCandleData(chart, i);
        maxPriceItem = Math.max(...dataItem);
        minPriceItem = Math.min(...dataItem);

        if (maxPrice < maxPriceItem) {
            maxPrice = maxPriceItem;
        } else if (minPrice > minPriceItem) {
            minPrice = minPriceItem;
        }
    }

    ann.options.priceRange = {min: minPrice, max: maxPrice};
};

infChart.volumeProfileDrawing.prototype.calculateAndSetNewXAndYValues = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        settings = options.settings,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        additionalDrawings = self.additionalDrawings;

    var newXValue = options.xValue > options.xValueEnd ? options.xValueEnd : options.xValue;
    var newXValueEnd = options.xValue > options.xValueEnd ? options.xValue : options.xValueEnd;
    var newYValue = infChart.drawingUtils.common.getYValue.call(self, options.priceRange.max);
    var newYValueEnd = infChart.drawingUtils.common.getYValue.call(self, options.priceRange.min);
    var newXEnd = xAxis.toPixels(newXValueEnd) - xAxis.toPixels(newXValue);
    var newYEnd = yAxis.toPixels(newYValueEnd) - yAxis.toPixels(newYValue);
    var newLine = ['M', 0, 0, 'L', newXEnd, newYEnd];

    ann.update({
        xValue: newXValue,
        xValueEnd: newXValueEnd,
        yValue: newYValue,
        yValueEnd: newYValueEnd,
        shape: {
            params: {
                d: newLine
            }
        }
    });
    self.updateStartAndEndLines(0, newXEnd);
    ann.shape.hide();
    additionalDrawings.startLine.hide();
    additionalDrawings.endLine.hide();

    infChart.drawingUtils.common.saveBaseYValues.call(self, newYValue, newYValueEnd);
}

infChart.volumeProfileDrawing.prototype.calculateBarIdByPrice = function (barPriceRange, price) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        settings = options.settings,
        barId = "b_",
        rangeMin, rangeMax;

    if (options.priceRange.min === price) {
        rangeMin = price;
        rangeMax = price + barPriceRange;
    } else if (options.priceRange.max === price) {
        rangeMin = (price - barPriceRange);
        rangeMax = price;
    } else {
        rangeMin = options.priceRange.min + Math.floor((price - options.priceRange.min) / barPriceRange) * barPriceRange;
        rangeMax = rangeMin + barPriceRange;
    }

    barId += rangeMin.toFixed(4) + "_" + rangeMax.toFixed(4);

    return {barId: barId, rangeMin: rangeMin, rangeMax: rangeMax};
};

infChart.volumeProfileDrawing.prototype.calculateBars = function (data) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        settings = options.settings,
        chart = ann.chart,
        priceRangeDifference = options.priceRange.max - options.priceRange.min,
        barPriceRange = Math.round((priceRangeDifference / settings.barCount) * 100000000) / 100000000, // rounding to 8 decimal places
        pocBar = {
            rangeMin: 0,
            rangeMax: 0,
            up: 0,
            down: 0,
            total: 0,
            priceArray: []
        },
        bars = {}, totalVolume = 0, openPrice, closePrice, volume, barDetails, currentItem;

    data.forEach(function (dataItem) {
        openPrice = dataItem[1]
        closePrice = dataItem[4];
        volume = dataItem[5];

        if (volume > 0 && options.priceRange.min <= closePrice && options.priceRange.max >= closePrice) {
            barDetails = self.calculateBarIdByPrice(barPriceRange, closePrice);
            currentItem = bars[barDetails.barId];

            if (!currentItem) {
                currentItem = {
                    id: barDetails.barId,
                    rangeMin: barDetails.rangeMin,
                    rangeMax: barDetails.rangeMax,
                    up: 0,
                    down: 0,
                    total: 0,
                    priceArray: []
                };
            }

            currentItem.total += volume;
            totalVolume += volume;
            currentItem.priceArray.push(closePrice);

            if (closePrice > openPrice) {
                currentItem.up += volume;
            } else if (closePrice < openPrice) {
                currentItem.down += volume;
            }

            if (pocBar.total < currentItem.total) {
                pocBar = currentItem;
            }

            bars[barDetails.barId] = currentItem;
        }
    });

    ann.options.calculatedBars = {bars: bars, pocBar: pocBar, totalVolume: totalVolume};
};

infChart.volumeProfileDrawing.prototype.calculateValueAreaVolumeBars = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        settings = options.settings,
        chart = ann.chart,
        bars = options.calculatedBars.bars,
        sortedBarRanges = Object.keys(bars).sort(),
        pocBarIndex = sortedBarRanges.indexOf(options.calculatedBars.pocBar.id),
        valueAreaVolume = options.calculatedBars.totalVolume * (settings.valueAreaVolume / 100),
        cumulativeValueAreaVolume = options.calculatedBars.pocBar.total,
        minBarIndex = pocBarIndex,
        maxBarIndex = pocBarIndex,
        valueAreaBars = {}, estimatedMinBarIndex, estimatedMinBarVolume, estimatedMaxBarIndex, estimatedMaxBarVolume,
        selectedBarIndex, isMinBarSelected;

    valueAreaBars[options.calculatedBars.pocBar.id] = true;

    while (valueAreaVolume > cumulativeValueAreaVolume) {
        estimatedMinBarIndex = minBarIndex > 0 ? minBarIndex - 1 : null;
        estimatedMinBarVolume = estimatedMinBarIndex ? options.calculatedBars.bars[sortedBarRanges[estimatedMinBarIndex]].total : 0;
        estimatedMaxBarIndex = maxBarIndex < sortedBarRanges.length - 1 ? maxBarIndex + 1 : null;
        estimatedMaxBarVolume = estimatedMaxBarIndex ? options.calculatedBars.bars[sortedBarRanges[estimatedMaxBarIndex]].total : 0;

        if (estimatedMinBarIndex !== null && estimatedMaxBarIndex !== null) {
            isMinBarSelected = estimatedMinBarVolume > estimatedMaxBarVolume;
            selectedBarIndex = isMinBarSelected ? estimatedMinBarIndex : estimatedMaxBarIndex;
            cumulativeValueAreaVolume += (selectedBarIndex === estimatedMinBarIndex ? estimatedMinBarVolume : estimatedMaxBarVolume);
        } else if (estimatedMinBarIndex !== null) {
            isMinBarSelected = true;
            selectedBarIndex = estimatedMinBarIndex;
            cumulativeValueAreaVolume += estimatedMinBarVolume;
        } else {
            isMinBarSelected = false;
            selectedBarIndex = estimatedMaxBarIndex;
            cumulativeValueAreaVolume += estimatedMaxBarVolume;
        }

        valueAreaBars[sortedBarRanges[selectedBarIndex]] = true;

        if (isMinBarSelected) {
            minBarIndex = selectedBarIndex;
        } else {
            maxBarIndex = selectedBarIndex;
        }
    }

    ann.options.calculatedBars.valueAreaBars = {
        bars: valueAreaBars,
        minBarId: sortedBarRanges[minBarIndex],
        maxBarId: sortedBarRanges[maxBarIndex]
    };
}

infChart.volumeProfileDrawing.prototype.getVolumeProfileWidth = function (xValue, xValueEnd) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        xAxisExtremes = xAxis.getExtremes(),
        candlePixelDifference,
        volumeProfileWidth;

    if (xValue >= xAxis.min && xValue <= xAxis.max && xValueEnd >= xAxis.min && xValueEnd <= xAxis.max) {
        volumeProfileWidth = xAxis.toPixels(xValueEnd) - xAxis.toPixels(xValue)
    } else {
        volumeProfileWidth = infChart.math.getPixelDistanceBetweenCandles(chart, 0, options.from.index, options.to.index);
    }

    return volumeProfileWidth;
}

infChart.volumeProfileDrawing.prototype.drawVolumeProfile = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        settings = options.settings,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis],
        stockChartId = infChart.drawingsManager.getChartIdFromHighchartInstance(chart),
        volumeProfileElement = document.createElement("div"),
        yValuePixels = yAxis.toPixels(options.yValue),
        newValues, renderer;

    var volumeProfileWidth = self.getVolumeProfileWidth(options.xValue, options.xValueEnd)//xAxis.toPixels(options.xValueEnd) - xAxis.toPixels(options.xValue);
    var volumeProfileHeight = yAxis.toPixels(options.yValueEnd) - yValuePixels;

    self.additionalDrawings.volumeProfile.attr({
        width: volumeProfileWidth,
        height: volumeProfileHeight
    });

    renderer = new Highcharts.Renderer(
        volumeProfileElement,
        volumeProfileWidth,
        volumeProfileHeight
    );

    self.additionalDrawings.histogramBox = renderer.rect(0, 0, volumeProfileWidth, volumeProfileHeight).attr({
        fill: settings.histogramBox.color,
        'stroke-width': 0,
        'fill-opacity': settings.histogramBox.opacity
    }).add();

    self.drawVolumeProfileBars(renderer, volumeProfileWidth, volumeProfileHeight, yValuePixels);
    self.convertAndSetVolumeProfileImage(volumeProfileElement);
    self.setToggleButtonsInitialSettings();
}

infChart.volumeProfileDrawing.prototype.drawVolumeProfileBars = function (renderer, volumeProfileWidth, volumeProfileHeight, yValuePixels) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        settings = options.settings,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];

    var barPixelHeight = volumeProfileHeight / settings.barCount,
        upBarPixelWidth, downBarPixelWidth, barDataObj,
        barStartYPosition, upFillColor, upFillOpacity, downFillColor, downFillOpacity, isValueAreaBar;

    self.additionalDrawings.upBars = {};
    self.additionalDrawings.downBars = {};
    // self.additionalDrawings.deltaBars = {};

    Object.keys(options.calculatedBars.bars).forEach(function (barId) {
        barDataObj = options.calculatedBars.bars[barId];
        upBarPixelWidth = volumeProfileWidth * (settings.volumeProfile.profileWidth / 100) * ((settings.volume === self.volumeTypes.total.id ? barDataObj.total : barDataObj.up) / options.calculatedBars.pocBar.total);
        barStartYPosition = yAxis.toPixels(infChart.drawingUtils.common.getYValue.call(self, barDataObj.rangeMax)) - yValuePixels + (barDataObj.rangeMax !== options.priceRange.max ? 1 : 0);
        isValueAreaBar = options.calculatedBars.valueAreaBars.bars[barId];
        upFillColor = isValueAreaBar ? settings.volumeProfile.volumeAreaUpColor : settings.volumeProfile.upVolumeColor;
        upFillOpacity = isValueAreaBar ? settings.volumeProfile.volumeAreaUpOpacity : settings.volumeProfile.upVolumeOpacity;

        self.additionalDrawings.upBars[barId] = renderer.rect(0, barStartYPosition, upBarPixelWidth, barPixelHeight).attr({
            fill: upFillColor,
            'stroke-width': 0,
            'fill-opacity': upFillOpacity,
            isValueAreaBar: isValueAreaBar
        }).add();

        if (settings.volume === self.volumeTypes.upDown.id) {
            downBarPixelWidth = volumeProfileWidth * (settings.volumeProfile.profileWidth / 100) * (barDataObj.down / options.calculatedBars.pocBar.total);
            downFillColor = isValueAreaBar ? settings.volumeProfile.volumeAreaDownColor : settings.volumeProfile.downVolumeColor;
            downFillOpacity = isValueAreaBar ? settings.volumeProfile.volumeAreaDownOpacity : settings.volumeProfile.downVolumeOpacity;

            self.additionalDrawings.downBars[barId] = renderer.rect(upBarPixelWidth, barStartYPosition, downBarPixelWidth, barPixelHeight).attr({
                fill: downFillColor,
                'stroke-width': 0,
                'fill-opacity': downFillOpacity,
                isValueAreaBar: isValueAreaBar
            }).add();
        }
    });

    self.drawReferenceLines(renderer, volumeProfileWidth, volumeProfileHeight, barPixelHeight, yValuePixels);
}

infChart.volumeProfileDrawing.prototype.drawReferenceLines = function (renderer, volumeProfileWidth, volumeProfileHeight, barPixelHeight, yValuePixels) {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        settings = options.settings,
        chart = ann.chart,
        xAxis = chart.xAxis[options.xAxis],
        yAxis = chart.yAxis[options.yAxis];

    var pocBarStartPosition = yAxis.toPixels(options.calculatedBars.pocBar.rangeMax) - yValuePixels + (options.calculatedBars.pocBar.rangeMax !== options.priceRange.max ? 1 : 0);
    var pocLineYPosition = pocBarStartPosition + barPixelHeight / 2;

    self.additionalDrawings.pointOfControl = renderer.path(['M', 0, pocLineYPosition, 'L', volumeProfileWidth, pocLineYPosition]).attr({
        stroke: settings.pointOfControl.color,
        'stroke-width': settings.pointOfControl.lineWidth,
        dashstyle: settings.pointOfControl.lineStyle
    }).add();

    var maxBarObj = options.calculatedBars.bars[options.calculatedBars.valueAreaBars.maxBarId];
    var vAHBarStartPosition = yAxis.toPixels(maxBarObj.rangeMax) - yValuePixels + (maxBarObj.rangeMax !== options.priceRange.max ? 1 : 0);

    self.additionalDrawings.valueAreaHigh = renderer.path(['M', 0, vAHBarStartPosition, 'L', volumeProfileWidth, vAHBarStartPosition]).attr({
        stroke: settings.valueAreaHigh.color,
        'stroke-width': settings.valueAreaHigh.lineWidth,
        dashstyle: settings.valueAreaHigh.lineStyle
    }).add();

    var minBarObj = options.calculatedBars.bars[options.calculatedBars.valueAreaBars.minBarId];
    var vALBarStartPosition = yAxis.toPixels(minBarObj.rangeMax) - yValuePixels + (minBarObj.rangeMax !== options.priceRange.max ? 1 : 0);
    var vALLineYPosition = vALBarStartPosition + barPixelHeight;

    self.additionalDrawings.valueAreaLow = renderer.path(['M', 0, vALLineYPosition, 'L', volumeProfileWidth, vALLineYPosition]).attr({
        stroke: settings.valueAreaLow.color,
        'stroke-width': settings.valueAreaLow.lineWidth,
        dashstyle: settings.valueAreaLow.lineStyle
    }).add();
}

infChart.volumeProfileDrawing.prototype.setToggleButtonsInitialSettings = function () {
    var self = this,
        ann = self.annotation,
        options = ann.options,
        settings = options.settings;

    if (settings.volumeProfile.enabled) {
        this.onToggleVolumeProfile(true, false);
    } else {
        this.onToggleVolumeProfile(false, false);
    }

    if (settings.pointOfControl.enabled) {
        this.additionalDrawings.pointOfControl.show();
    } else {
        this.additionalDrawings.pointOfControl.hide();
    }

    if (settings.valueAreaHigh.enabled) {
        this.additionalDrawings.valueAreaHigh.show();
    } else {
        this.additionalDrawings.valueAreaHigh.hide();
    }

    if (settings.valueAreaLow.enabled) {
        this.additionalDrawings.valueAreaLow.show();
    } else {
        this.additionalDrawings.valueAreaLow.hide();
    }
}

infChart.volumeProfileDrawing.prototype.convertAndSetVolumeProfileImage = function (volumeProfileElement) {
    var labelHtml = '<div style="height: 100%"></div>';
    this.additionalDrawings.volumeProfile.element.innerHTML = labelHtml;
    var svgElement = volumeProfileElement.getElementsByTagName('svg')[0];
    svgElement.setAttribute("preserveAspectRatio", "none");
    this.additionalDrawings.volumeProfile.element.getElementsByTagName('div')[0].appendChild(svgElement);
}

//endregion

//region Select and bind resize

infChart.volumeProfileDrawing.prototype.deselect = function (isMouseOut) {
    infChart.drawingUtils.common.onDeselect.call(this);
};

infChart.volumeProfileDrawing.prototype.selectAndBindResize = function () {
    var ann = this.annotation,
        pathDefinition = ann.shape.d.split(' ');

    ann.events.deselect.call(ann);
    ann.selectionMarker = [];

    infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, parseFloat(pathDefinition[1]), parseFloat(pathDefinition[2]), this.stepFunction, this.stop, true);
    infChart.drawingUtils.common.addAndBindSelectionMarker.call(this, ann, parseFloat(pathDefinition[4]), parseFloat(pathDefinition[5]), this.stepFunction, this.stop, false);
};

//endregion

//region Settings

infChart.volumeProfileDrawing.prototype.getSettingsPopup = function () {
    return infChart.structureManager.drawingTools.getVolumeProfileSettings(this.volumeTypes, this.annotation.options.settings);
};

/**
 * Update the annotations options specific to this tool from the given properties
 * @param options
 */
// infChart.volumeProfileDrawing.prototype.updateOptions = function (options) {
//     var ann = this.annotation;
//     ann && ann.options && (ann.options.nearestXDataPoint = infChart.math.findNearestXDataPoint(ann.chart, options.xValue));
//     if (options.settings && options.settings.stopLoss) {
//         ann.options.settings.stopLoss = options.settings.stopLoss;
//     }
//     if (options.settings && options.settings.takeProfit) {
//         ann.options.settings.takeProfit = options.settings.takeProfit;
//     }
// };

infChart.volumeProfileDrawing.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updateVolumeProfileSettings($(this.settingsPopup), this.volumeTypes, properties.settings);
};

infChart.volumeProfileDrawing.prototype.bindSettingsEvents = function () {
    var self = this,
        ann = self.annotation;

    function getIsPropertyChange() {
        var isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }

        return isPropertyChange;
    }

    function onVolumeTypeChange(valueAreaVolume) {
        self.onVolumeTypeChange.call(self, valueAreaVolume, getIsPropertyChange());
    }

    function onValueAreaVolumeChange(valueAreaVolume) {
        self.onValueAreaVolumeChange.call(self, valueAreaVolume, getIsPropertyChange());
    }

    function onBarCountChange(barCount) {
        self.onBarCountChange.call(self, barCount, getIsPropertyChange());
    }

    function onProfileWidthChange(profileWidth) {
        self.onProfileWidthChange.call(self, profileWidth, getIsPropertyChange());
    }

    function onUpVolumeColorChange(rgb, value, opacity) {
        self.onUpVolumeColorChange.call(self, value, opacity, getIsPropertyChange());
    }

    function onDownVolumeColorChange(rgb, value, opacity) {
        self.onDownVolumeColorChange.call(self, value, opacity, getIsPropertyChange());
    }

    function onVolumeAreaUpColorChange(rgb, value, opacity) {
        self.onVolumeAreaUpColorChange.call(self, value, opacity, getIsPropertyChange());
    }

    function onVolumeAreaDownColorChange(rgb, value, opacity) {
        self.onVolumeAreaDownColorChange.call(self, value, opacity, getIsPropertyChange());
    }

    function onValueAreaHighColorChange(rgb, value, opacity) {
        self.onValueAreaHighColorChange.call(self, value, opacity, getIsPropertyChange());
    }

    function onValueAreaLowColorChange(rgb, value, opacity) {
        self.onValueAreaLowColorChange.call(self, value, opacity, getIsPropertyChange());
    }

    function onPointOfControlColorChange(rgb, value, opacity) {
        self.onPointOfControlColorChange.call(self, value, opacity, getIsPropertyChange());
    }

    function onValuesColorChange(rgb, value, opacity) {
        self.onValuesColorChange.call(self, value, opacity, getIsPropertyChange());
    }

    function onHistogramBoxColorChange(rgb, value, opacity) {
        self.onHistogramBoxColorChange.call(self, value, opacity, getIsPropertyChange());
    }

    function onValueAreaHighLineWidthChange(lineWidth) {
        self.onValueAreaHighLineWidthChange.call(self, lineWidth, getIsPropertyChange());
    }

    function onValueAreaHighLineStyleChange(lineStyle) {
        self.onValueAreaHighLineStyleChange.call(self, lineStyle, getIsPropertyChange());
    }

    function onValueAreaLowLineWidthChange(lineWidth) {
        self.onValueAreaLowLineWidthChange.call(self, lineWidth, getIsPropertyChange());
    }

    function onValueAreaLowLineStyleChange(lineStyle) {
        self.onValueAreaLowLineStyleChange.call(self, lineStyle, getIsPropertyChange());
    }

    function onPointOfControlLineWidthChange(lineWidth) {
        self.onPointOfControlLineWidthChange.call(self, lineWidth, getIsPropertyChange());
    }

    function onPointOfControlLineStyleChange(lineStyle) {
        self.onPointOfControlLineStyleChange.call(self, lineStyle, getIsPropertyChange());
    }

    function onToggleVolumeProfile(isEnabled) {
        self.onToggleVolumeProfile.call(self, isEnabled, getIsPropertyChange());
    }

    function onToggleFlipChart(isEnabled) {
        self.onToggleFlipChart.call(self, isEnabled, getIsPropertyChange());
    }

    function onToggleValueAreaHigh(isEnabled) {
        self.onToggleValueAreaHigh.call(self, isEnabled, getIsPropertyChange());
    }

    function onToggleValueAreaLow(isEnabled) {
        self.onToggleValueAreaLow.call(self, isEnabled, getIsPropertyChange());
    }

    function onTogglePointOfControl(isEnabled) {
        self.onTogglePointOfControl.call(self, isEnabled, getIsPropertyChange());
    }

    function onResetToDefault() {
        self.updateSavedDrawingProperties(true);
    }

    infChart.structureManager.drawingTools.bindVolumeProfileSettings(self.settingsPopup, {
        onVolumeTypeChange: onVolumeTypeChange,
        onValueAreaVolumeChange: onValueAreaVolumeChange,
        onBarCountChange: onBarCountChange,
        onProfileWidthChange: onProfileWidthChange,
        onUpVolumeColorChange: onUpVolumeColorChange,
        onDownVolumeColorChange: onDownVolumeColorChange,
        onVolumeAreaUpColorChange: onVolumeAreaUpColorChange,
        onVolumeAreaDownColorChange: onVolumeAreaDownColorChange,
        onValueAreaHighColorChange: onValueAreaHighColorChange,
        onValueAreaLowColorChange: onValueAreaLowColorChange,
        onPointOfControlColorChange: onPointOfControlColorChange,
        onValuesColorChange: onValuesColorChange,
        onHistogramBoxColorChange: onHistogramBoxColorChange,
        onValueAreaHighLineWidthChange: onValueAreaHighLineWidthChange,
        onValueAreaHighLineStyleChange: onValueAreaHighLineStyleChange,
        onValueAreaLowLineWidthChange: onValueAreaLowLineWidthChange,
        onValueAreaLowLineStyleChange: onValueAreaLowLineStyleChange,
        onPointOfControlLineWidthChange: onPointOfControlLineWidthChange,
        onPointOfControlLineStyleChange: onPointOfControlLineStyleChange,
        onToggleVolumeProfile: onToggleVolumeProfile,
        onToggleFlipChart: onToggleFlipChart,
        onToggleValueAreaHigh: onToggleValueAreaHigh,
        onToggleValueAreaLow: onToggleValueAreaLow,
        onTogglePointOfControl: onTogglePointOfControl,
        onResetToDefault: onResetToDefault
    });
};

infChart.volumeProfileDrawing.prototype.onVolumeTypeChange = function (volumeType, isPropertyChange) {
    this.annotation.options.settings.volume = volumeType;
    this.drawVolumeProfile();

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onToggleVolumeProfile = function (isEnabled, isPropertyChange) {
    var self = this;
    self.annotation.options.settings.volumeProfile.enabled = isEnabled;

    var upBar, downBar;

    if (self.additionalDrawings.upBars) {
        Object.keys(self.additionalDrawings.upBars).forEach(function (barId) {
            upBar = self.additionalDrawings.upBars[barId];

            if (isEnabled) {
                upBar.show();
            } else {
                upBar.hide();
            }
        });
    }

    if (self.additionalDrawings.downBars) {
        Object.keys(self.additionalDrawings.downBars).forEach(function (barId) {
            downBar = self.additionalDrawings.downBars[barId];

            if (isEnabled) {
                downBar.show();
            } else {
                downBar.hide();
            }
        });
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
};

infChart.volumeProfileDrawing.prototype.onValueAreaVolumeChange = function (valueAreaVolume, isPropertyChange) {
    this.annotation.options.settings.valueAreaVolume = valueAreaVolume;
    this.calculateValueAreaVolumeBars();
    this.drawVolumeProfile();

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onBarCountChange = function (barCount, isPropertyChange) {
    this.annotation.options.settings.barCount = barCount;
    this.calculateBars(this.annotation.options.currentDataSet);

    if (this.annotation.options.calculatedBars.totalVolume > 0) {
        this.calculateValueAreaVolumeBars();
        this.drawVolumeProfile();
    } else {
        this.annotation.shape.show();
        this.additionalDrawings.volumeProfile.css({
            display: 'none'
        });
        this.additionalDrawings.startLine.show();
        this.additionalDrawings.endLine.show();
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onProfileWidthChange = function (profileWidth, isPropertyChange) {
    this.annotation.options.settings.volumeProfile.profileWidth = profileWidth;
    this.drawVolumeProfile();

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onUpVolumeColorChange = function (value, opacity, isPropertyChange) {
    var self = this,
        upBar;

    self.annotation.options.settings.volumeProfile.upVolumeColor = value;
    self.annotation.options.settings.volumeProfile.upVolumeOpacity = opacity;

    if (self.additionalDrawings.upBars) {
        Object.keys(self.additionalDrawings.upBars).forEach(function (barId) {
            upBar = self.additionalDrawings.upBars[barId];

            if (upBar && upBar.attr("isValueAreaBar") !== 'true') {
                upBar.attr({
                    fill: value,
                    'fill-opacity': opacity
                });
            }
        });
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onDownVolumeColorChange = function (value, opacity, isPropertyChange) {
    var self = this,
        downBar;

    self.annotation.options.settings.volumeProfile.downVolumeColor = value;
    self.annotation.options.settings.volumeProfile.downVolumeOpacity = opacity;

    if (self.additionalDrawings.downBars) {
        Object.keys(self.additionalDrawings.downBars).forEach(function (barId) {
            downBar = self.additionalDrawings.downBars[barId];

            if (downBar && downBar.attr("isValueAreaBar") !== 'true') {
                downBar.attr({
                    fill: value,
                    'fill-opacity': opacity
                });
            }
        });
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onVolumeAreaUpColorChange = function (value, opacity, isPropertyChange) {
    var self = this,
        bar;

    self.annotation.options.settings.volumeProfile.volumeAreaUpColor = value;
    self.annotation.options.settings.volumeProfile.volumeAreaUpOpacity = opacity;

    if (self.annotation.options.calculatedBars && self.annotation.options.calculatedBars.valueAreaBars) {
        Object.keys(self.annotation.options.calculatedBars.valueAreaBars.bars).forEach(function (barId) {
            bar = self.additionalDrawings.upBars[barId];

            if (bar) {
                bar.attr({
                    fill: value,
                    'fill-opacity': opacity
                });
            }
        });
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onVolumeAreaDownColorChange = function (value, opacity, isPropertyChange) {
    var self = this,
        bar;

    self.annotation.options.settings.volumeProfile.volumeAreaDownColor = value;
    self.annotation.options.settings.volumeProfile.volumeAreaDownOpacity = opacity;

    if (self.annotation.options.calculatedBars && self.annotation.options.calculatedBars.valueAreaBars) {
        Object.keys(self.annotation.options.calculatedBars.valueAreaBars.bars).forEach(function (barId) {
            bar = self.additionalDrawings.downBars[barId];

            if (bar) {
                bar.attr({
                    fill: value,
                    'fill-opacity': opacity
                });
            }
        });
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onToggleValueAreaHigh = function (isEnabled, isPropertyChange) {
    this.annotation.options.settings.valueAreaHigh.enabled = isEnabled;

    if (this.additionalDrawings.valueAreaHigh) {
        if (isEnabled) {
            this.additionalDrawings.valueAreaHigh.show();
        } else {
            this.additionalDrawings.valueAreaHigh.hide();
        }
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
};

infChart.volumeProfileDrawing.prototype.onValueAreaHighColorChange = function (value, opacity, isPropertyChange) {
    this.annotation.options.settings.valueAreaHigh.color = value;
    this.annotation.options.settings.valueAreaHigh.opacity = opacity;

    if (this.additionalDrawings.valueAreaHigh) {
        this.additionalDrawings.valueAreaHigh.attr({
            stroke: value,
            opacity: opacity
        });
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);

}

infChart.volumeProfileDrawing.prototype.onValueAreaHighLineWidthChange = function (lineWidth, isPropertyChange) {
    this.annotation.options.settings.valueAreaHigh.lineWidth = lineWidth;

    if (this.additionalDrawings.valueAreaHigh) {
        this.additionalDrawings.valueAreaHigh.attr({
            'stroke-width': lineWidth
        });
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onValueAreaHighLineStyleChange = function (lineStyle, isPropertyChange) {
    this.annotation.options.settings.valueAreaHigh.lineStyle = lineStyle;

    if (this.additionalDrawings.valueAreaHigh) {
        this.additionalDrawings.valueAreaHigh.attr({
            dashstyle: lineStyle
        });
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onToggleValueAreaLow = function (isEnabled, isPropertyChange) {
    this.annotation.options.settings.valueAreaLow.enabled = isEnabled;

    if (this.additionalDrawings.valueAreaLow) {
        if (isEnabled) {
            this.additionalDrawings.valueAreaLow.show();
        } else {
            this.additionalDrawings.valueAreaLow.hide();
        }
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
};

infChart.volumeProfileDrawing.prototype.onValueAreaLowColorChange = function (value, opacity, isPropertyChange) {
    this.annotation.options.settings.valueAreaLow.color = value;
    this.annotation.options.settings.valueAreaLow.opacity = opacity;

    if (this.additionalDrawings.valueAreaLow) {
        this.additionalDrawings.valueAreaLow.attr({
            stroke: value,
            opacity: opacity
        });
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onValueAreaLowLineWidthChange = function (lineWidth, isPropertyChange) {
    this.annotation.options.settings.valueAreaLow.lineWidth = lineWidth;

    if (this.additionalDrawings.valueAreaLow) {
        this.additionalDrawings.valueAreaLow.attr({
            'stroke-width': lineWidth
        });
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onValueAreaLowLineStyleChange = function (lineStyle, isPropertyChange) {
    this.annotation.options.settings.valueAreaLow.lineStyle = lineStyle;

    if (this.additionalDrawings.valueAreaLow) {
        this.additionalDrawings.valueAreaLow.attr({
            dashstyle: lineStyle
        });
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onTogglePointOfControl = function (isEnabled, isPropertyChange) {
    this.annotation.options.settings.pointOfControl.enabled = isEnabled;

    if (this.additionalDrawings.pointOfControl) {
        if (isEnabled) {
            this.additionalDrawings.pointOfControl.show();
        } else {
            this.additionalDrawings.pointOfControl.hide();
        }
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
};

infChart.volumeProfileDrawing.prototype.onPointOfControlColorChange = function (value, opacity, isPropertyChange) {
    this.annotation.options.settings.pointOfControl.color = value;
    this.annotation.options.settings.pointOfControl.opacity = opacity;

    if (this.additionalDrawings.pointOfControl) {
        this.additionalDrawings.pointOfControl.attr({
            stroke: value,
            opacity: opacity
        });
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onPointOfControlLineWidthChange = function (lineWidth, isPropertyChange) {
    this.annotation.options.settings.pointOfControl.lineWidth = lineWidth;

    if (this.additionalDrawings.pointOfControl) {
        this.additionalDrawings.pointOfControl.attr({
            'stroke-width': lineWidth
        });
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onPointOfControlLineStyleChange = function (lineStyle, isPropertyChange) {
    this.annotation.options.settings.pointOfControl.lineStyle = lineStyle;

    if (this.additionalDrawings.pointOfControl) {
        this.additionalDrawings.pointOfControl.attr({
            dashstyle: lineStyle
        });
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onValuesColorChange = function (value, opacity, isPropertyChange) {
    this.annotation.options.settings.values.color = value;
    this.annotation.options.settings.values.opacity = opacity;

    //TODO change values color

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onHistogramBoxColorChange = function (value, opacity, isPropertyChange) {
    this.annotation.options.settings.histogramBox.color = value;
    this.annotation.options.settings.histogramBox.opacity = opacity;

    if (this.additionalDrawings.histogramBox) {
        this.additionalDrawings.histogramBox.attr({
            fill: value,
            'fill-opacity': opacity
        });
    }

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
}

infChart.volumeProfileDrawing.prototype.onToggleFlipChart = function (isEnabled, isPropertyChange) {
    this.annotation.options.settings.volumeProfile.flipChart = isEnabled;

    //TODO implement flip chart

    isPropertyChange && this.onPropertyChange();

    if (this.settingsPopup) {
        this.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(this);
};

infChart.volumeProfileDrawing.prototype.specificCursorChange = function(url){
    var self = this,
        ann = self.annotation,
        options = ann.options,
        additionalDrawings = self.additionalDrawings;
    
    if(additionalDrawings.volumeProfile){
        var volumeProfile = additionalDrawings.volumeProfile;
        if(url){
            volumeProfile.css({'cursor': 'url("' + url + '"), default'});
        } else {
            infChart.util.setCursor(volumeProfile, 'move');
            volumeProfile.css({'cursor': 'move'});
        }
    }
};

//endregion



window.infChart = window.infChart || {};

infChart.arrowDrawing = function () {
    infChart.drawingObject.apply(this, arguments);
};

infChart.arrowDrawing.prototype = Object.create(infChart.drawingObject.prototype);

infChart.arrowDrawing.prototype.additionalDrawingsFunction = function () {
    let self = this,
        ann = self.annotation,
        chart = ann.chart,
        arrow = _getArrow(self.shape, chart.renderer.symbols, 40, 40);

    self.additionalDrawings.arrow = chart.renderer.path(arrow).attr({
        'stroke-width': 1,
        stroke: 'transparent',
        opacity: 1,
        'z-index': 2,
        fill: ann.options.shape.params.fill,
        cursor: 'move'
    }).add(ann.group);
    self.additionalDrawings.label = self.getTextLabel();
};

var _getArrow = function(shape, symbols, width, height) {
    if (shape === 'upArrow') {
        return symbols.upArrow(-width/2, 0, width, height);
    } else if (shape === 'downArrow') {
        return symbols.downArrow(-width/2, -height, width, height);
    }
};

var _getLabelYValue = function(shape, arrowHeight, textLabelHeight) {
    if (shape === 'upArrow') {
        return arrowHeight;
    } else if (shape === 'downArrow') {
        return -arrowHeight - textLabelHeight;
    }
};

infChart.arrowDrawing.prototype.getTextLabel = function () {
    let self = this,
        ann = self.annotation,
        options = ann.options,
        chart = ann.chart,
        text = ann.options.label.text,
        formmattedText = text.replace(/\n/g, "<br>"),
        textLabel = "<div rel = 'arrowText'>" + formmattedText + "</div>",
        label = chart.renderer.createElement('foreignObject').add(ann.group).add(ann.group).css({
            color: options.label.fontColor,
            fontSize: options.label.fontSize + 'px' || '12px',
            cursor: 'move',
            fontWeight: '500',
            fontStyle: 'normal',
            textDecoration: 'inherit',
            'line-height': 1,
            'text-align': 'center',
        }),
        textDimension = infChart.drawingUtils.common.getTextDimensionsFromTempNode(formmattedText, label);
        
        label.attr({
            width: textDimension.width,
            height: textDimension.height,
            x: -textDimension.width/2,
            y: _getLabelYValue(self.annotation.options.shape.params.symbol, 40, textDimension.height)
        });
    label.element.innerHTML = textLabel;
    return label;
};

infChart.arrowDrawing.prototype.scale = function (isCalculateNewValueForScale) {
    let self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);

    if (isCalculateNewValueForScale) {
        ann.update({
            xValue: nearestDataPointForXValue.xData
        });
    } else {
        ann.update();
    }
};

infChart.arrowDrawing.prototype.stop = function () {
    let self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
    ann.update({
        xValue: nearestDataPointForXValue.xData
    });
    infChart.drawingUtils.common.saveBaseYValues.call(self, ann.options.yValue);
    infChart.drawingUtils.common.onPropertyChange.call(self);
};

infChart.arrowDrawing.prototype.getConfig = function () {
    let annotation = this.annotation;
    return {
        shape: annotation.options.shape.params.symbol,
        fillColor: infChart.themeManager.getDrawingsFillColor(annotation.options.shape.params.fill, annotation.options.shape.params.symbol),
        strokeWidth: annotation.options.shape.params['stroke-width'],
        xValue: annotation.options.xValue,
        yValue: annotation.options.yValue,
        xValueEnd: annotation.options.xValueEnd,
        yValueEnd: annotation.options.yValueEnd,
        fontText: annotation.options.label.text,
        fontColor: annotation.options.label.fontColor,
        fontSize: annotation.options.label.fontSize,
        isLocked : annotation.options.isLocked
    };
};

infChart.arrowDrawing.prototype.getOptions = function (properties) {
    let arrow = infChart.drawingUtils.common.getTheme()[properties.shape];
    let options = {
        xValue: properties.xValue,
        yValue: properties.yValue,
        shape: {
            type: 'symbol',
            params: {
                width: 0,
                height: 0,
                symbol: properties.shape,
                fill: _getFillDefaultColor(properties.shape),
                stroke: 'none'
            }
        },
        label: {
            text: '',
            fontSize: 12,
            fontColor: arrow && arrow.fontColor? arrow.fontColor: '#999999'
        }
    };

    if (properties.strokeWidth) {
        options.shape.params['stroke-width'] = properties.strokeWidth;
    }
    if (properties.xValueEnd && properties.yValueEnd) {
        options.xValueEnd = properties.xValueEnd;
        options.yValueEnd = properties.yValueEnd;
    }
    if (properties.fillColor) {
        options.shape.params.fill = properties.fillColor;
    }
    if (properties.fontText) {
        options.label.text = properties.fontText;
    }
    if (properties.fontColor) {
        options.label.fontColor = properties.fontColor;
    }
    if (properties.fontSize) {
        options.label.fontSize = properties.fontSize;
    }
    options.validateTranslationFn = this.validateTranslation;

    options = infChart.Drawing.prototype.getOptions(properties,options);
    return options;
};

infChart.arrowDrawing.prototype.translateEnd = function () {
    let self = this,
        ann = self.annotation,
        chart = ann.chart,
        options = ann.options,
        nearestDataPointForXValue = infChart.math.findNearestDataPoint(chart, options.xValue, undefined, true, true);
    ann.update({
        xValue: nearestDataPointForXValue.xData
    });
    infChart.drawingUtils.common.onPropertyChange.call(this);
};

infChart.arrowDrawing.prototype.updateSettings = function (properties) {
    infChart.structureManager.drawingTools.updateArrowSettings(this.settingsPopup, properties.fillColor, properties.fontText);
};

infChart.arrowDrawing.prototype.bindSettingsEvents = function () {
    let self = this;
    function onColorChange(rgb, value, opacity) {
        let isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onFillColorChange(rgb, value, opacity, isPropertyChange);
    }

    function onTextChange(text) {
        let isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onLabelTextChange(text, isPropertyChange);
    }

    function onFontSizeChange(fontSize) {
        let isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onLabelFontSizeChange(fontSize, isPropertyChange);
    }

    function onFontColorChange(fontColor) {
        let isPropertyChange = true;
        if (self.settingsPopup) {
            isPropertyChange = self.isSettingsPropertyChange();
        }
        self.onLabelFontColorChange(fontColor, isPropertyChange);
    }

    function onResetToDefault () {
        self.updateSavedDrawingProperties(true);
    }

    let arowDrawingEvents = {
        onTextChange : onTextChange,
        onFontSizeChange : onFontSizeChange,
        onColorChange : onColorChange,
        onFontColorChange : onFontColorChange,
        onResetToDefault : onResetToDefault
    };

    infChart.structureManager.drawingTools.bindArrowSettings(self.settingsPopup, arowDrawingEvents);
};

infChart.arrowDrawing.prototype.onFillColorChange = function (rgb, value, opacity, isPropertyChange) {
    let self = this;
    self.annotation.update({
        shape: {
            params: {
                fill: value,
                'fill-opacity': opacity
            }
        }
    });
    self.additionalDrawings.arrow.attr({
        opacity: opacity,
        fill: value
    });

    self.annotation.options.fill = value;
    self.annotation.options['fill-opacity'] = opacity;
    
    isPropertyChange && self.onPropertyChange();
    if (self.settingsPopup) {
        self.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.arrowDrawing.prototype.onLabelTextChange = function (text, isPropertyChange) {
    let self = this,
        label = self.additionalDrawings.label,
        formmattedText = text;
        
    formmattedText = text.replace(/\n/g, "<br>");
    let textDimension = infChart.drawingUtils.common.getTextDimensionsFromTempNode(formmattedText, label),
        textLabel = "<div rel = 'arrowText'>" + formmattedText + "</div>";

    self.annotation.update({
        label: {
            text: text
        }
    });
    this.annotation.options.label.text = text;
    
    label.attr({
        width: textDimension.width,
        height: textDimension.height,
        x: -textDimension.width/2,
        y: _getLabelYValue(self.annotation.options.shape.params.symbol, 40, textDimension.height)
    }).css({
        'text-align': 'center'
    });

    label.element.innerHTML = textLabel;

    isPropertyChange && self.onPropertyChange();
    if (self.settingsPopup) {
        self.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.arrowDrawing.prototype.onLabelFontSizeChange = function (fontSize, isPropertyChange) {
    let self = this,
        label = self.additionalDrawings.label,
        formmattedText = self.annotation.options.label.text.replace(/\n/g, "<br>"),
        textLabel = "<div rel = 'arrowText'>" + formmattedText + "</div>";

    self.annotation.update({
        label: {
            fontSize: fontSize
        }
    });

    this.annotation.options.label.fontSize = fontSize;

    label.css({
        'text-align': 'center',
        fontSize: fontSize + 'px'
    })

    let textDimension = infChart.drawingUtils.common.getTextDimensionsFromTempNode(formmattedText, label);

    label.attr({
        width: textDimension.width,
        height: textDimension.height,
        x: -textDimension.width/2,
        y: _getLabelYValue(self.annotation.options.shape.params.symbol, 40, textDimension.height)
    });
    
    label.element.innerHTML = textLabel;

    isPropertyChange && self.onPropertyChange();
    if (self.settingsPopup) {
        self.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.arrowDrawing.prototype.onLabelFontColorChange = function (fontColor, isPropertyChange) {
    let self = this;
    self.annotation.update({
        label: {
            fontColor: fontColor
        }
    });
    self.additionalDrawings.label.css({
        color: fontColor
    });
    this.annotation.options.label.fontColor = fontColor;
   
    isPropertyChange && self.onPropertyChange();
    if (self.settingsPopup) {
        self.settingsPopup.data("infUndoRedo", false);
    }
    infChart.drawingUtils.common.saveDrawingProperties.call(self);
};

infChart.arrowDrawing.prototype.getQuickSettingsPopup = function () {
     let self = this;
        shape = self.shape;
     return infChart.structureManager.drawingTools.getArrowQuickSettings(_getFillDefaultColor(shape));
};

infChart.arrowDrawing.prototype.getSettingsPopup = function () {
    let self = this;
        shape = self.shape;
        label = self.annotation.options.label
    return infChart.drawingUtils.common.getArrowSettings(_getArrowShape(shape), _getFillDefaultColor(shape), 40, label.fontColor, label.fontSize);
};

var _getFillDefaultColor = function(shape) {
    let arrow = infChart.drawingUtils.common.getTheme()[shape];
    return arrow && arrow.fillColor ? arrow.fillColor : _getFillColor(shape);
};

var _getFillColor = function(shape) {
    if (shape === 'upArrow') {
        return '#336699';
    } else if (shape === 'downArrow') {
        return '#FF4D4D';
    }
};

var _getArrowShape = function(shape) {
    if (shape === 'upArrow') {
        return 'Arrow Up';
    } else if (shape === 'downArrow') {
        return 'Arrow Down';
    } 
};
window.infChart = window.infChart || {};

(function (infChart, $) {
    infChart.drawingSettings = infChart.drawingSettings || {
        eventTypes: {
            lineColor: "onLineColorChange",
            lineWidth: "onLineWidthChange",
            lineStyle: "onLineStyleChange",
            fillColor: "onFillColorChange",
            fontColor: "onFontColorChange",
            fontSize: "onFontSizeChange",
            fontStyle: "onFontStyleChange",
            checkBox: "onCheckBoxValueChange",
            value: "onValueChange",
            text: "onTextChange"
        },
        getEventHandler: function (drawingInstance, eventType, settingsParams) {
            return function () {
                let isPropertyChange = true;
                if (drawingInstance.settingsPopup) {
                    isPropertyChange = drawingInstance.isSettingsPropertyChange();
                }
                infChart.drawingSettings.eventHandlers[eventType](drawingInstance, settingsParams, isPropertyChange, ...arguments);
            }
        },
        postEventHandler: function (drawingInstance, isPropertyChange) {
            isPropertyChange && drawingInstance.onPropertyChange();

            if (drawingInstance.settingsPopup) {
                drawingInstance.settingsPopup.data("infUndoRedo", false);
            }

            infChart.drawingUtils.common.saveDrawingProperties.call(drawingInstance);
        }
    };

    infChart.drawingSettings.eventHandlers = {
        onLineColorChange: function (drawingInstance, settingsParams, isPropertyChange, rgb, value, opacity) {
            let annotationParams = {};

            if (settingsParams.isUpdateAnnotationStyles) {
                annotationParams = {
                    shape: {
                        params: {
                            stroke: value,
                            'stroke-opacity': opacity
                        }
                    }
                }
            }

            if (settingsParams.settingsItem) {
                annotationParams.settings = {};
                annotationParams.settings[settingsParams.settingsItem + 'Color'] = value;
                annotationParams.settings[settingsParams.settingsItem + 'Opacity'] = opacity;
            }

            drawingInstance.annotation.update(annotationParams);

            if (settingsParams.otherLineElements) {
                settingsParams.otherLineElements.forEach(function (element) {
                    element.attr({
                        stroke: value,
                        'stroke-opacity': opacity
                    });
                });
            }

            if (settingsParams.otherTextElements) {
                settingsParams.otherTextElements.forEach(function (element) {
                    element.css({
                        color: value,
                        opacity: opacity
                    })
                });
            }

            if (settingsParams.callBackFunction) {
                settingsParams.callBackFunction.call(drawingInstance, settingsParams, isPropertyChange, rgb, value, opacity);
            }

            infChart.drawingSettings.postEventHandler(drawingInstance, isPropertyChange);
        },
        onLineWidthChange: function (drawingInstance, settingsParams, isPropertyChange, strokeWidth) {
            let annotationParams = {};
            if (settingsParams.isUpdateAnnotationStyles) {
                annotationParams = {
                    shape: {
                        params: {
                            'stroke-width': strokeWidth
                        }
                    }
                }
            }

            if (settingsParams.settingsItem) {
                annotationParams.settings = {};
                annotationParams.settings[settingsParams.settingsItem] = strokeWidth;
            }

            drawingInstance.annotation.update(annotationParams);

            if (settingsParams.otherLineElements) {
                settingsParams.otherLineElements.forEach(function (element) {
                    element.attr({
                        'stroke-width': strokeWidth
                    });
                });
            }

            if (settingsParams.callBackFunction) {
                settingsParams.callBackFunction.call(drawingInstance, settingsParams, isPropertyChange, strokeWidth);
            }

            infChart.drawingSettings.postEventHandler(drawingInstance, isPropertyChange);
        },
        onLineStyleChange: function (drawingInstance, settingsParams, isPropertyChange, dashStyle) {
            let annotationParams = {};

            if (settingsParams.isUpdateAnnotationStyles) {
                annotationParams = {
                    shape: {
                        params: {
                            dashstyle: dashStyle
                        }
                    }
                }
            }

            if (settingsParams.settingsItem) {
                annotationParams.settings = {};
                annotationParams.settings[settingsParams.settingsItem] = dashStyle;
            }

            drawingInstance.annotation.update(annotationParams);

            if (settingsParams.otherLineElements) {
                settingsParams.otherLineElements.forEach(function (element) {
                    element.attr({
                        dashstyle: dashStyle
                    });
                });
            }

            if (settingsParams.callBackFunction) {
                settingsParams.callBackFunction.call(drawingInstance, settingsParams, isPropertyChange, dashStyle);
            }

            infChart.drawingSettings.postEventHandler(drawingInstance, isPropertyChange);
        },
        onFillColorChange: function (drawingInstance, settingsParams, isPropertyChange, rgb, value, opacity) {
            let annotationParams = {};

            if (settingsParams.isUpdateAnnotationStyles) {
                annotationParams = {
                    shape: {
                        params: {
                            fill: value,
                            'fill-opacity': opacity
                        }
                    }
                }
            }

            if (settingsParams.settingsItem) {
                annotationParams.settings = {};
                annotationParams.settings[settingsParams.settingsItem + 'Color'] = value;
                annotationParams.settings[settingsParams.settingsItem + 'Opacity'] = opacity;
            }

            drawingInstance.annotation.update(annotationParams);

            if (settingsParams.otherLineElements) {
                settingsParams.otherLineElements.forEach(function (element) {
                    element.attr({
                        fill: value,
                        'fill-opacity': opacity
                    });
                });
            }

            if (settingsParams.otherTextElements) {
                settingsParams.otherTextElements.forEach(function (element) {
                    element.css({
                        color: value,
                        opacity: opacity
                    })
                });
            }

            if (settingsParams.callBackFunction) {
                settingsParams.callBackFunction.call(drawingInstance, settingsParams, isPropertyChange, rgb, value, opacity);
            }

            infChart.drawingSettings.postEventHandler(drawingInstance, isPropertyChange);
        },
        onFontColorChange: function (drawingInstance, settingsParams, isPropertyChange, rgb, value, opacity) {
            let annotationParams = {};

            if (settingsParams.isUpdateAnnotationStyles) {
                annotationParams = {
                    title: {
                        style: {
                            color: value,
                            opacity: opacity
                        }
                    }
                }
            }

            if (settingsParams.settingsItem) {
                annotationParams.settings = {};
                annotationParams.settings[settingsParams.settingsItem + 'Color'] = value;
                annotationParams.settings[settingsParams.settingsItem + 'Opacity'] = opacity;
            }

            drawingInstance.annotation.update(annotationParams);

            if (settingsParams.otherTextElements) {
                settingsParams.otherTextElements.forEach(function (element) {
                    element.css({
                        color: value,
                        opacity: opacity
                    })
                });
            }

            if (settingsParams.callBackFunction) {
                settingsParams.callBackFunction.call(drawingInstance, settingsParams, isPropertyChange, rgb, value, opacity);
            }

            infChart.drawingSettings.postEventHandler(drawingInstance, isPropertyChange);
        },
        onFontSizeChange: function (drawingInstance, settingsParams, isPropertyChange, fontSize) {
            let annotationParams = {};

            if (settingsParams.isUpdateAnnotationStyles) {
                annotationParams = {
                    title: {
                        style: {
                            fontSize: fontSize + 'px'
                        }
                    }
                }
            }

            if (settingsParams.settingsItem) {
                annotationParams.settings = {};
                annotationParams.settings[settingsParams.settingsItem] = fontSize;
            }

            drawingInstance.annotation.update(annotationParams);

            if (settingsParams.otherTextElements) {
                settingsParams.otherTextElements.forEach(function (element) {
                    element.css({
                        fontSize: fontSize + 'px'
                    })
                });
            }

            if (settingsParams.callBackFunction) {
                settingsParams.callBackFunction.call(drawingInstance, settingsParams, isPropertyChange, fontSize);
            }

            infChart.drawingSettings.postEventHandler(drawingInstance, isPropertyChange);
        },
        onFontStyleChange: function (drawingInstance, settingsParams, isPropertyChange, style, isSelected) {
            let annotationParams = { title: { style: {} } };
            let textParams = {};
            const styleTypes = {
                'bold': { style: 'fontWeight', selectedValue: 'bold', deSelectedValue: 'normal' },
                'italic': { style: 'fontStyle', selectedValue: 'italic', deSelectedValue: 'normal' },
                'underline': { style: 'textDecoration', selectedValue: 'underline', deSelectedValue: 'inherit' }
            };
            const currentStyleObject = styleTypes[style];

            if (settingsParams.isUpdateAnnotationStyles) {
                annotationParams.title.style[currentStyleObject.style] = isSelected ? currentStyleObject.selectedValue : currentStyleObject.deSelectedValue;
            }

            if (settingsParams.settingsItem) {
                annotationParams.settings = {};
                annotationParams.settings[settingsParams.settingsItem] = isSelected ? currentStyleObject.selectedValue : currentStyleObject.deSelectedValue;
            }

            drawingInstance.annotation.update(annotationParams);
            textParams[currentStyleObject.style] = isSelected ? currentStyleObject.selectedValue : currentStyleObject.deSelectedValue;

            if (settingsParams.otherTextElements) {
                settingsParams.otherTextElements.forEach(function (element) {
                    element.css(textParams)
                });
            }

            if (settingsParams.callBackFunction) {
                settingsParams.callBackFunction.call(drawingInstance, settingsParams, isPropertyChange, style, isSelected);
            }

            infChart.drawingSettings.postEventHandler(drawingInstance, isPropertyChange);
        },
        onCheckBoxValueChange: function (drawingInstance, settingsParams, isPropertyChange, isChecked) {
            let annotationParams = {};

            if (settingsParams.settingsItem) {
                annotationParams.settings = {};
                annotationParams.settings[settingsParams.settingsItem] = isChecked;
            }
            drawingInstance.annotation.update(annotationParams);

            if (settingsParams.callBackFunction) {
                settingsParams.callBackFunction.call(drawingInstance, settingsParams, isPropertyChange, isChecked);
            }

            infChart.drawingSettings.postEventHandler(drawingInstance, isPropertyChange);
        },
        onTextChange: function (drawingInstance, settingsParams, isPropertyChange, text) {
            let annotationParams = {};

            if (settingsParams.settingsItem) {
                annotationParams[settingsParams.settingsItem] = text;
            }
            drawingInstance.annotation.update(annotationParams);

            if (settingsParams.callBackFunction) {
                settingsParams.callBackFunction.call(drawingInstance, settingsParams, isPropertyChange, text);
            }

            infChart.drawingSettings.postEventHandler(drawingInstance, isPropertyChange);
        },
        onValueChange: function (drawingInstance, settingsParams, isPropertyChange, value) {
            let annotationParams = {};

            if (settingsParams.settingsItem) {
                annotationParams.settings = {};
                annotationParams.settings[settingsParams.settingsItem] = value;
            }
            drawingInstance.annotation.update(annotationParams);

            if (settingsParams.callBackFunction) {
                settingsParams.callBackFunction.call(drawingInstance, settingsParams, isPropertyChange, value);
            }

            infChart.drawingSettings.postEventHandler(drawingInstance, isPropertyChange);
        }
    };
})(infChart, jQuery);
var infChart = window.infChart || {};

(function ($, infChart) {
    /**
     * Returns the chart id of given highchart instance
     * @param {Highcharts} highchartInstance chart
     * @returns {string} chart id
     * @private
     */
    var _getChartIdFromHighchartInstance = function (highchartInstance) {
        return infChart.manager.getContainerIdFromChart(highchartInstance.renderTo.id);
    };

    /**
     * Returns the StockChart object of the given container
     * @param chartContainerId
     * @returns {*}
     * @private
     */
    var _getChartObj = function (chartContainerId) {
        return infChart.manager.getChart(chartContainerId);
    };

    /**
     * Check whether the given annotation is from a undo/redo enabled drawing
     * @param {object} annotation annotation being checked
     * @returns {*|boolean}
     * @private
     */
    var _isTrackHistoryEnabledDrawing = function (annotation) {
        return annotation && annotation.options && (annotation.options.drawingType === infChart.constants.drawingTypes.shape);
    };

    /**
    * Check whether the given annotation is from a undo/redo enabled indicator drawing
    * @param {object} annotation annotation being checked
    * @returns {*|boolean}
    * @private
    */
    var _isIndicatorDrawing = function (annotation) {
        return annotation && annotation.options && (annotation.options.drawingType === infChart.constants.drawingTypes.indicator);
    };

    var _isPropertyChanged = function (shapeId, lastOptions, properties) {
        var isChangeProperty = true;
        switch (shapeId) {
            case 'fibVerRetracements':
            case 'fib2PointTimeProjection':
            case 'fib3PointTimeProjection':
                if (lastOptions.xValue === properties.xValue && lastOptions.yValue === properties.yValue &&
                    lastOptions.xValueEnd === properties.xValueEnd && lastOptions.yValueEnd === properties.yValueEnd &&
                    lastOptions.trendXValue === properties.trendXValue && lastOptions.trendYValue === properties.trendYValue &&
                    lastOptions.jointLineValue === properties.jointLineValue) {
                    isChangeProperty = false;
                }
                break;
            case 'longPositions':
            case 'shortPositions':
                if (lastOptions.xValue === properties.xValue && lastOptions.yValue === properties.yValue &&
                    lastOptions.xValueEnd === properties.xValueEnd && lastOptions.yValueEnd === properties.yValueEnd &&
                    lastOptions.trendXValue === properties.trendXValue && lastOptions.trendYValue === properties.trendYValue &&
                    lastOptions.settings.stopLoss === properties.settings.stopLoss &&
                    lastOptions.settings.takeProfit === properties.settings.takeProfit) {
                    isChangeProperty = false;
                }
                break;
            case 'longLine':
            case 'shortLine':
                if (lastOptions.xValue === properties.xValue && lastOptions.yValue === properties.yValue &&
                    lastOptions.xValueEnd === properties.xValueEnd && lastOptions.yValueEnd === properties.yValueEnd &&
                    lastOptions.trendXValue === properties.trendXValue && lastOptions.trendYValue === properties.trendYValue &&
                    lastOptions.stopLoss[0].yValue === properties.stopLoss[0].yValue &&
                    lastOptions.stopLoss[1].yValue === properties.stopLoss[1].yValue &&
                    lastOptions.stopLoss[2].yValue === properties.stopLoss[2].yValue &&
                    lastOptions.takeProfit[0].yValue === properties.takeProfit[0].yValue &&
                    lastOptions.takeProfit[1].yValue === properties.takeProfit[1].yValue &&
                    lastOptions.takeProfit[2].yValue === properties.takeProfit[2].yValue) {
                    isChangeProperty = false;
                }
                break;
            case 'harmonicPattern':
            case 'abcdPattern':
            case 'polyline':
                if (lastOptions.xValue === properties.xValue && lastOptions.yValue === properties.yValue &&
                    lastOptions.xValueEnd === properties.xValueEnd && lastOptions.yValueEnd === properties.yValueEnd &&
                    lastOptions.trendXValue === properties.trendXValue && lastOptions.trendYValue === properties.trendYValue &&
                    lastOptions.intermediatePoints === properties.intermediatePoints) {
                    isChangeProperty = false;
                }
                break;
            case 'elliotTriangleWave':
            case 'elliotImpulseWave':
            case 'elliotCorrectiveWave':
            case 'correctiveTripleWave':
            case 'elliotCorrectiveDoubleWave':
                if (lastOptions.xValue === properties.xValue && lastOptions.yValue === properties.yValue &&
                    lastOptions.xValueEnd === properties.xValueEnd && lastOptions.yValueEnd === properties.yValueEnd &&
                    lastOptions.trendXValue === properties.trendXValue && lastOptions.trendYValue === properties.trendYValue &&
                    lastOptions.intermediatePoints === properties.intermediatePoints) {
                        isChangeProperty = false;
                    }
                    break;
            default:
                if (lastOptions.xValue === properties.xValue && lastOptions.yValue === properties.yValue &&
                    lastOptions.xValueEnd === properties.xValueEnd && lastOptions.yValueEnd === properties.yValueEnd &&
                    lastOptions.trendXValue === properties.trendXValue && lastOptions.trendYValue === properties.trendYValue) {
                    isChangeProperty = false;
                }
                break;
        }
        return isChangeProperty;
    }

    //region=====================Drawing Wrappers=========================================================

    /**
     * Wrapping up the infChart.Drawing.prototype.wrapFunctionHelper to catch the drawing functions and set the cammands(undo/redo) accordingly
     */
    infChart.util.wrap(infChart.Drawing.prototype, 'wrapFunctionHelper', function (proceed, functionName, func, arguments) {
        var returnVal;
        var drawingObj = this;
        var drawingId = drawingObj.drawingId;
        var ann = drawingObj.annotation;
        var drawingProperties;
        var xChartId = _getChartIdFromHighchartInstance(ann.chart);
        var xChart = _getChartObj(xChartId);

        if (_isTrackHistoryEnabledDrawing(ann)) {
            switch (functionName) {
                case "stopFunction":
                    // to catch the adding new drawing
                    returnVal = proceed.call(this, functionName, func, arguments);
                    drawingProperties = infChart.drawingsManager.getDrawingProperties(ann);
                    var isNewDrawing = arguments[2];

                    if (isNewDrawing === true && !(returnVal && returnVal.stopPropagation)) {
                        infChart.commandsManager.registerCommand(xChart.id, function () {
                            drawingObj = infChart.drawingsManager.drawDrawingFromProperties(drawingObj, xChart.chart, infChart.drawingsManager.getSettingsContainer(xChartId), drawingProperties);
                        }, function () {
                            infChart.drawingsManager.removeDrawing(xChartId, drawingId, false, false);
                        }, undefined, false, 'addDrawing');
                    }
                    break;
                case "translateEndFunction":
                    // to catch the translate end (used in vertical line)
                    returnVal = proceed.call(this, functionName, func, arguments);
                    drawingProperties = infChart.drawingsManager.getDrawingProperties(ann);

                    var lastAction = infChart.commandsManager.getLastAction(xChartId);
                    if (lastAction && lastAction.actionType === 'onAnnotationStore' && !lastAction.releasedAnnotation) {
                        var lastOptions = lastAction.callbackOptions.redoProperties;
                        if (!(lastOptions.xValue === drawingProperties.xValue && lastOptions.xValueEnd === drawingProperties.xValueEnd &&
                            lastOptions.yValue === drawingProperties.yValue && lastOptions.yValueEnd === drawingProperties.yValueEnd)) {
                            lastAction.callbackOptions.redoProperties = drawingProperties;
                        } else {
                            infChart.commandsManager.removeLastAction(xChartId);
                        }
                        lastAction.releasedAnnotation = true;
                    }
                    break;
                default :
                    returnVal = proceed.call(this, functionName, func, arguments);
                    break;
            }
        } else {
            returnVal = proceed.call(this, functionName, func, arguments);
        }
        return returnVal;
    });

    /**
     * Wrapping up the infChart.Drawing.prototype.destroy to catch the deleting drawing  and set the cammands(undo/redo) accordingly
     */
    infChart.util.wrap(infChart.Drawing.prototype, 'destroy', function (proceed, isPropertyChange, drawingProperties) {
        if (_isTrackHistoryEnabledDrawing(this.annotation) && isPropertyChange) {
            var drawingObj = this;
            var drawingId = drawingObj.drawingId;
            var ann = drawingObj.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var xChart = _getChartObj(xChartId);

            infChart.commandsManager.registerCommand(xChart.id, function () {
                infChart.drawingsManager.removeDrawing(xChartId, drawingId, false, false);
            }, function () {
                var settingsContainer = infChart.drawingsManager.getSettingsContainer(xChartId);
                var quickSettingsContainer = infChart.drawingsManager.getQuickSettingsContainer(xChartId);
                var drawingObject = infChart.drawingsManager.createDrawing(xChart.chart, drawingProperties.shape, settingsContainer, quickSettingsContainer, drawingId);
                drawingObj = infChart.drawingsManager.drawDrawingFromProperties(drawingObject, xChart.chart, settingsContainer, drawingProperties, drawingObject.drawingId);
            }, undefined, false, 'removeDrawing');
        }
        return proceed.call(this, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.drawingsManager.pasteNewItem to catch the paste drawing which is copied and set the cammands(undo/redo) accordingly
     */
    infChart.util.wrap(infChart.drawingsManager, 'pasteNewItem', function (proceed, annotation) {
        var returnVal = proceed.call(this, annotation);
        if (_isTrackHistoryEnabledDrawing(annotation)) {
            var xChartId = _getChartIdFromHighchartInstance(annotation.chart);
            var xChart = _getChartObj(xChartId);
            var drawingObj = returnVal;
            var drawingId = drawingObj.drawingId;
            var ann = drawingObj.annotation;
            var drawingProperties = infChart.drawingsManager.getDrawingProperties(ann);

            infChart.commandsManager.registerCommand(xChart.id, function () {
                var settingsContainer = infChart.drawingsManager.getSettingsContainer(xChartId);
                var quickSettingsContainer = infChart.drawingsManager.getQuickSettingsContainer(xChartId);
                var drawingObject = infChart.drawingsManager.createDrawing(xChart.chart, drawingProperties.shape, settingsContainer, quickSettingsContainer, drawingId);
                drawingObj = infChart.drawingsManager.drawDrawingFromProperties(drawingObject, xChart.chart,settingsContainer, drawingProperties, drawingObj.drawingId);
                drawingObj.annotation.events.deselect.call(drawingObj.annotation);
            }, function () {
                infChart.drawingsManager.removeDrawing(xChartId, drawingId, false, false);
            }, undefined, false, 'pasteDrawing');
        }
        return returnVal;
    });

    /**
     * Wrapping up the infChart.drawingsManager.resetDrawing to catch the resetting drawing  and set the cammands(undo/redo) accordingly
     */
    infChart.util.wrap(infChart.drawingsManager, 'resetDrawing', function (proceed, chartId, drawingId, currentDrawingProperties) {
        var drawingObject = infChart.drawingsManager.getDrawingObject(chartId, drawingId);
        var annotation = drawingObject.annotation;
        var previousDrawingProperties, newDrawingProperties;
        if (_isTrackHistoryEnabledDrawing(annotation)) {
            previousDrawingProperties = infChart.drawingsManager.getDrawingProperties(annotation);
            newDrawingProperties = proceed.call(this, chartId, drawingId, currentDrawingProperties);
            function undoRedo (properties) {
                infChart.drawingsManager.removeDrawing(chartId, drawingId);
                var settingsContainer = infChart.drawingsManager.getSettingsContainer(chartId);
                var quickSettingsContainer = infChart.drawingsManager.getQuickSettingsContainer(chartId);
                var drawingObject = infChart.drawingsManager.createDrawing(_getChartObj(chartId).chart, properties.shape, settingsContainer, quickSettingsContainer, drawingId);
                infChart.drawingsManager.drawDrawingFromProperties(drawingObject, _getChartObj(chartId).chart, settingsContainer, properties, drawingObject.drawingId);
            }
            infChart.commandsManager.registerCommand(chartId, function () {
                undoRedo(newDrawingProperties);
            }, function () {
                undoRedo(previousDrawingProperties);
            }, undefined, false, 'resetDrawing');
        } else {
            newDrawingProperties = proceed.call(this, chartId, drawingId, currentDrawingProperties);
        }
        return newDrawingProperties;
    });

    /**
     * Wrapping up the infChart.drawingsManager.applyTemplateProperties to catch the applyTemplateProperties and set the cammands(undo/redo) accordingly
     */
    infChart.util.wrap(infChart.drawingsManager, 'applyTemplateProperties', function (proceed, chartId, drawingId, currentDrawingProperties, templateProperties) {
        var drawingObject = infChart.drawingsManager.getDrawingObject(chartId, drawingId);
        var annotation = drawingObject.annotation;
        var previousDrawingProperties, newDrawingProperties;
        if (_isTrackHistoryEnabledDrawing(annotation)) {
            previousDrawingProperties = infChart.drawingsManager.getDrawingProperties(annotation);
            newDrawingProperties = proceed.call(this, chartId, drawingId, currentDrawingProperties, templateProperties);
            function undoRedo (properties) {
                infChart.drawingsManager.removeDrawing(chartId, drawingId);
                var settingsContainer = infChart.drawingsManager.getSettingsContainer(chartId);
                var quickSettingsContainer = infChart.drawingsManager.getQuickSettingsContainer(chartId);
                var drawingObject = infChart.drawingsManager.createDrawing(_getChartObj(chartId).chart, properties.shape, settingsContainer, quickSettingsContainer, drawingId);
                infChart.drawingsManager.drawDrawingFromProperties(drawingObject, _getChartObj(chartId).chart, settingsContainer, properties, drawingObject.drawingId);
            }
            infChart.commandsManager.registerCommand(chartId, function () {
                undoRedo(newDrawingProperties);
            }, function () {
                undoRedo(previousDrawingProperties);
            }, undefined, false, 'applyTemplateProperties');
        } else {
            newDrawingProperties = proceed.call(this, chartId, drawingId, currentDrawingProperties);
        }
        return newDrawingProperties;
    });

    /**
     * Wrapping up the infChart.drawingsManager.onAnnotationStore to catch the paste drawing which is going to be dragged or resized
     */
    infChart.util.wrap(infChart.drawingsManager, 'onAnnotationStore', function (proceed, annotation) {
        if (_isTrackHistoryEnabledDrawing(annotation)) {
            var xChartId = _getChartIdFromHighchartInstance(annotation.chart);
            var xChart = _getChartObj(xChartId);
            var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, annotation.options.id);
            var drawingId = drawingObj.drawingId;
            var firstDrawingProperties = infChart.drawingsManager.getDrawingProperties(annotation);
            var redoProperties = JSON.parse(JSON.stringify(firstDrawingProperties));

            infChart.commandsManager.registerCommand(xChart.id, function (options) {
                infChart.drawingsManager.updateDrawingProperties(xChartId, drawingId, options.redoProperties);
                infChart.drawingUtils.common.onPropertyChange.call(drawingObj);
            }, function () {
                infChart.drawingsManager.updateDrawingProperties(xChartId, drawingId, redoProperties);
                infChart.drawingUtils.common.onPropertyChange.call(drawingObj);
            }, undefined, false, 'onAnnotationStore', {redoProperties: redoProperties});
        }
        return proceed.call(this, annotation);
    });

    /**
     * Wrapping up the infChart.drawingsManager.onAnnotationRelease to catch the paste drawing which is dragged or resized
     */
    infChart.util.wrap(infChart.drawingsManager, 'onAnnotationRelease', function (proceed, annotation) {
        var xChartId = _getChartIdFromHighchartInstance(annotation.chart);
        var returnVal = proceed.call(this, annotation);
        if (_isTrackHistoryEnabledDrawing(annotation)) {
            var drawingProperties = infChart.drawingsManager.getDrawingProperties(annotation);
            var lastAction = infChart.commandsManager.getLastAction(xChartId);
            var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, annotation.options.id);

            if (lastAction && lastAction.actionType === 'onAnnotationStore' && !lastAction.releasedAnnotation) { // && !drawingObj.translateEnd
                var lastOptions = lastAction.callbackOptions.redoProperties;
                if (_isPropertyChanged(drawingObj.shape, lastOptions, drawingProperties)) {
                    lastAction.callbackOptions.redoProperties = drawingProperties;
                } else {
                    infChart.commandsManager.removeLastAction(xChartId);
                }
                lastAction.releasedAnnotation = true;
            }
        }
        return returnVal;
    });

    //region Drawing settings

    /**
     * Wrapping up the infChart.drawingUtils.common.settings.onLineWidthChange to catch the line width changes
     */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onLineWidthChange', function (proceed, strokeWidth, isPropertyChange) {
        var ann = this.annotation;
        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentWidth = ann.options.shape.params["stroke-width"];

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new width to set
             */
            function undoRedo(newSize) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var sizeSelectorElm = settingPanel.find("[inf-ctrl=lineWidth][inf-size=" + newSize + "]");
                    if (sizeSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        sizeSelectorElm.trigger('click');
                    } else {
                        proceed.call(drawingObj, newSize);
                    }
                } else {
                    proceed.call(drawingObj, newSize);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(strokeWidth);
            }, function () {
                undoRedo(currentWidth);
            }, undefined, false, 'onLineWidthChange');
        }
        proceed.call(this, strokeWidth, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.drawingUtils.common.settings.onLineStyleChange to catch the settings change od dash style
     */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onLineStyleChange', function (proceed, dashStyle, isPropertyChange) {
        var ann = this.annotation;
        if (_isTrackHistoryEnabledDrawing(ann) && isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentDashStyle = ann.options.shape.params["dashstyle"];

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newDashStyle new style to set
             */
            function undoRedo(newDashStyle) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var lineStyleSelectorElm = settingPanel.find("[inf-ctrl=lineStyle][inf-style=" + newDashStyle + "]");
                    if (lineStyleSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        lineStyleSelectorElm.trigger('click');
                    } else {
                        proceed.call(drawingObj, newDashStyle);
                    }
                } else {
                    proceed.call(drawingObj, newDashStyle);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(dashStyle);
            }, function () {
                undoRedo(currentDashStyle);
            }, undefined, false, 'onLineStyleChange');
        }
        proceed.call(this, dashStyle, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.drawingUtils.common.settings.onLineColorChange to catch the color settings change
     */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onLineColorChange', function (proceed, rgb, color, isPropertyChange, colorPickerRef) {
        var ann = this.annotation;
        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.shape.params["stroke"];
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             */
            function undoRedo(newColor) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var lineColorSelectorElm = settingPanel.find(colorPickerRef || "[inf-ctrl=colorPicker]");
                    if (lineColorSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        lineColorSelectorElm.mainColorPanel("value", {color: newColor})
                    } else {
                        proceed.call(drawingObj, rgb, newColor, false, colorPickerRef);
                    }
                } else {
                    proceed.call(drawingObj, rgb, newColor, false, colorPickerRef);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onLineColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color);
                }, function () {
                    undoRedo(currentColor);
                }, undefined, false, 'onLineColorChange');
            }
        }
        proceed.call(this, rgb, color, isPropertyChange);
    });


    /**
     * Wrapping up the infChart.labelDrawing.prototype.onTextChange to catch the line text changes
     */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onTextChange', function (proceed, text, isPropertyChange) {
        var drawingId = this.drawingId;
        var ann = this.annotation;
        var xChartId = _getChartIdFromHighchartInstance(ann.chart);
        var shape = this.shape;
        var currentText;
        switch (shape) {
            case 'line':
                currentText = ann.options.lineText;
                updateSettings = infChart.structureManager.drawingTools.updateLineSettings;
                break;
            case 'rectangle':
                currentText = ann.options.rectText;
                updateSettings = infChart.structureManager.drawingTools.updateBasicDrawingSettings;
                break;
            case 'ellipse':
                currentText = ann.options.ellipseText;
                updateSettings = infChart.structureManager.drawingTools.updateBasicDrawingSettings;
                break;
        }

        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            /**
             * Execute the undo/redo with the new properties
             * @param {string} newText new text being set
             */
            function undoRedo(newText) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;

                proceed.call(drawingObj, newText, false);
                if (settingPanel) {
                    newText = newText.replace(/<br\s*\/?>/gi, "");
                    updateSettings(settingPanel, undefined, undefined, undefined, undefined, newText, true, undefined, undefined, shape) ;
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(text);
            }, function () {
                undoRedo(currentText);
            }, undefined, false, 'onTextChange_label');

        }
        return proceed.call(this, text, isPropertyChange);

    });

    /**
     * Wrapping up the infChart.fibRetracementsDrawing.prototype.onToggleText to catch the fib level value change
     */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onToggleText', function (proceed, checked, isPropertyChange, ignoreSettingsSave) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var self = this;
            var ann = self.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentMode = !checked;

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean} checked - mode chaned
             */
            function undoRedo(checked) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                proceed.call(self, checked, false);
                self.onPropertyChange();
                if (settingPanel) {
                    settingPanel.find('input[inf-ctrl="textToggle"]').prop('checked', checked);
                    if (drawingObj.shape === "line") {
                        settingPanel.find('input[inf-ctrl="line-text"]').focus();
                    } else {
                        textRef =  drawingObj.shape === "rectangle" ? 'rect-text' : 'ellipse-text';
                        settingPanel.find('textarea[inf-ctrl=' + textRef +']').focus();
                    }
                }
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(checked);
            }, function () {
                undoRedo(currentMode);
            }, undefined, false, 'onToggleText');
        }
        proceed.call(this, checked, isPropertyChange, ignoreSettingsSave);
    });

    

    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onVerticalPositionSelect', function (proceed, position, isPropertyChange, ignoreSettingsSave) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var self = this;
            var ann = self.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentPosition = ann.options.verticalPosition;

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean} checked - mode chaned
             */
            function undoRedo(position) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                proceed.call(drawingObj, position, false);
                drawingObj.onPropertyChange();
                if (settingPanel) {
                    settingPanel.find("div[inf-ctrl=verticalType]").find("span[rel=selectItem]").text(position);
                }
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(position);
            }, function () {
                undoRedo(currentPosition);
            }, undefined, false, 'onVerticalPositionSelect');
        }
        proceed.call(this, position, isPropertyChange, ignoreSettingsSave);
    });


    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onHorizontalPositionSelect', function (proceed, position, isPropertyChange, ignoreSettingsSave) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var self = this;
            var ann = self.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentPosition = ann.options.horizontalPosition;

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean} checked - mode chaned
             */
            function undoRedo(position) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                proceed.call(drawingObj, position, false);
                drawingObj.onPropertyChange();
                if (settingPanel) {
                    settingPanel.find("div[inf-ctrl=horizontalType]").find("span[rel=selectItem]").text(position);
                }
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(position);
            }, function () {
                undoRedo(currentPosition);
            }, undefined, false, 'onHorizontalPositionSelect');
        }
        proceed.call(this, position, isPropertyChange, ignoreSettingsSave);
    });

    /**
     * Wrapping up the infChart.rectangleDrawing.prototype.onExtendToRight to catch the color settings change
     */
    infChart.util.wrap(infChart.rectangleDrawing.prototype, 'onExtendToRight', function (proceed, extended, isPropertyChange) {
        var self = this;
        if (isPropertyChange) {
            var drawingId = self.drawingId;
            var ann = self.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentExtend = ann.options.isExtendToRight;

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean} checked - mode chaned
             */
            function undoRedo(currentExtend) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var borderColorEnabledElm = settingPanel.find("[inf-ctrl=extendToRight]");
                    if (borderColorEnabledElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        borderColorEnabledElm.trigger("click");
                    } else {
                        proceed.call(drawingObj, currentExtend ,false);
                    }
                } else {
                    proceed.call(drawingObj, currentExtend ,false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(extended);
            }, function () {
                undoRedo(currentExtend);
            }, undefined, false, 'onExtendToRight');
        }
        proceed.call(self, extended, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.rectangleDrawing.prototype.onExtendToLeft to catch the color settings change
     */
    infChart.util.wrap(infChart.rectangleDrawing.prototype, 'onExtendToLeft', function (proceed, extended, isPropertyChange) {
        var self = this;
        if (isPropertyChange) {
            var drawingId = self.drawingId;
            var ann = self.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentExtend = ann.options.isExtendToLeft;

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean} checked - mode chaned
             */
            function undoRedo(currentExtend) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var borderColorEnabledElm = settingPanel.find("[inf-ctrl=extendToLeft]");
                    if (borderColorEnabledElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        borderColorEnabledElm.trigger("click");
                    } else {
                        proceed.call(drawingObj, currentExtend ,false);
                    }
                } else {
                    proceed.call(drawingObj, currentExtend ,false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(extended);
            }, function () {
                undoRedo(currentExtend);
            }, undefined, false, 'onExtendToLeft');
        }
        proceed.call(self, extended, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.drawingUtils.common.settings.onLineColorChange to catch the color settings change
     */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onFillColorChange', function (proceed, rgb, color, opacity, isPropertyChange, colorPickerRef) {
        var ann = this.annotation;
        if (_isTrackHistoryEnabledDrawing(ann) && isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.shape.params["fill"];
            var currentOpacity = ann.options.shape.params["fill-opacity"];
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             * @param {float} newOpacity opacity
             */
            function undoRedo(newColor, newOpacity) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var fillColorSelectorElm = settingPanel.find(colorPickerRef || "[inf-ctrl=colorPicker]");
                    if (fillColorSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fillColorSelectorElm.mainColorPanel("value", {
                            color: newColor,
                            opacity: newOpacity
                        });
                    } else {
                        proceed.call(drawingObj, rgb, newColor, newOpacity, false, colorPickerRef);
                    }
                } else {
                    proceed.call(drawingObj, rgb, newColor, newOpacity, false, colorPickerRef);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onFillColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color, opacity);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color, opacity);
                }, function () {
                    undoRedo(currentColor, currentOpacity);
                }, undefined, false, 'onFillColorChange');
            }
        }
        proceed.call(this, rgb, color, opacity, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.drawingUtils.common.settings.onFibApplyAllButtonClick to catch apply now to all level button click
     */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onFibApplyAllButtonClick', function(proceed, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, isPropertyChange) {
        var self = this;
        var ann = self.annotation;
        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange) {
            var fibLevels = self.annotation.options.fibLevels;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentOptions = prevOptions;

            function undoRedo(isSingleColor, newOptions) {
                fibLevels.forEach(function (fibLevel) {
                    fibLevel.fillColor = isSingleColor ? fillColor : newOptions[fibLevel.id].fillColor;
                    fibLevel.fillOpacity = isSingleColor ? fillOpacity : newOptions[fibLevel.id].fillOpacity;
                    fibLevel.lineColor = isSingleColor ? lineColor : newOptions[fibLevel.id].lineColor;
                    fibLevel.lineWidth = isSingleColor ? lineWidth : newOptions[fibLevel.id].lineWidth;
                    fibLevel.fontColor = isSingleColor ? fontColor : newOptions[fibLevel.id].fontColor;
                    fibLevel.fontSize = isSingleColor ? fontSize : newOptions[fibLevel.id].fontSize;
                    fibLevel.fontWeight = isSingleColor ? fontWeight : newOptions[fibLevel.id].fontWeight;
                });
                self.updateSettings(self.getConfig());
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(true);
            }, function () {
                undoRedo(false, currentOptions);
            }, undefined, false, 'onFibApplyAllButtonClick');
        }
        proceed.call(this, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.regressionChannelDrawing.prototype.onFillColorChange to catch the color settings change
     */
    infChart.util.wrap(infChart.regressionChannelDrawing.prototype, 'onFillColorChange', function (proceed, rgb, color, opacity, level, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var levelShape = this.additionalDrawings.fill[level];
            var currentColor = levelShape.element.getAttribute("fill");
            var currentOpacity = levelShape.element.getAttribute("fill-opacity");
            var lastAction = infChart.commandsManager.getLastAction(xChartId);
            var colorPickerRef = "[inf-ctrl=fillColorPicker][inf-ctrl-val=" + level + "]";

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             * @param {float} newOpacity opacity
             */
            function undoRedo(newColor, newOpacity) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var fillColorSelectorElm = settingPanel.find(colorPickerRef);
                    if (fillColorSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fillColorSelectorElm.mainColorPanel("value", {color: newColor, opacity: newOpacity});
                    } else {
                        proceed.call(drawingObj, rgb, newColor, newOpacity, level, false, colorPickerRef);
                    }
                } else {
                    proceed.call(drawingObj, rgb, newColor, newOpacity, level, false, colorPickerRef);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onFillColorChange_regressionChannel' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color, opacity);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color, opacity);
                }, function () {
                    undoRedo(currentColor, currentOpacity);
                }, undefined, false, 'onFillColorChange_regressionChannel');
            }
        }
        proceed.call(this, rgb, color, opacity, level, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.andrewsPitchforkDrawing.prototype.onLineColorChange to catch the color settings change
     */
    infChart.util.wrap(infChart.andrewsPitchforkDrawing.prototype, 'onLineColorChange', function (proceed, rgb, color, isPropertyChange, colorPickerRef) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.shape.params["stroke"];
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             */
            function undoRedo(newColor) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var lineColorSelectorElm = settingPanel.find(colorPickerRef || "[inf-ctrl=lineColorPicker]");
                    if (lineColorSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        lineColorSelectorElm.mainColorPanel("value", {color: newColor})
                    } else {
                        proceed.call(drawingObj, rgb, newColor, false, colorPickerRef);
                    }
                } else {
                    proceed.call(drawingObj, rgb, newColor, false, colorPickerRef);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onLineColorChange_andrewsPitchfork' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color);
                }, function () {
                    undoRedo(currentColor);
                }, undefined, false, 'onLineColorChange_andrewsPitchfork');
            }
        }
        proceed.call(this, rgb, color, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.andrewsPitchforkDrawing.prototype.onFillColorChange to catch the color settings change
     */
    infChart.util.wrap(infChart.andrewsPitchforkDrawing.prototype, 'onFillColorChange', function (proceed, rgb, color, opacity, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.shape.params["fill"];
            var currentOpacity = ann.options.shape.params["fill-opacity"];
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             * @param {float} newOpacity opacity
             */
            function undoRedo(newColor, newOpacity) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var fillColorSelectorElm = settingPanel.find("[inf-ctrl=fillColorPicker]");
                    if (fillColorSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fillColorSelectorElm.mainColorPanel("value", {
                            color: newColor,
                            opacity: newOpacity
                        })
                    } else {
                        proceed.call(drawingObj, rgb, newColor, newOpacity, false);
                    }
                } else {
                    proceed.call(drawingObj, rgb, newColor, newOpacity, false);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onFillColorChange_andrewsPitchfork' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color, opacity);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color, opacity);
                }, function () {
                    undoRedo(currentColor, currentOpacity);
                }, undefined, false, 'onFillColorChange_andrewsPitchfork');
            }
        }
        proceed.call(this, rgb, color, opacity, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.andrewsPitchforkDrawing.prototype.onLineWidthChange to catch the line width changes
     */
    infChart.util.wrap(infChart.andrewsPitchforkDrawing.prototype, 'onLineWidthChange', function (proceed, strokeWidth, isPropertyChange) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentWidth = ann.options.shape.params["stroke-width"];

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize width to set
             */
            function undoRedo(newSize) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var lineWidthSelectorElm = settingPanel.find("[inf-ctrl=lineWidth][inf-size=" + newSize + "]");
                    if (lineWidthSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        lineWidthSelectorElm.trigger('click');
                    } else {
                        proceed.call(drawingObj, newSize);
                    }
                } else {
                    proceed.call(drawingObj, newSize);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(strokeWidth);
            }, function () {
                undoRedo(currentWidth);
            }, undefined, false, 'onLineWidthChange_andrewsPitchfork');
        }
        proceed.call(this, strokeWidth, isPropertyChange);
    });

    /**
     * Wrapping up all fib level changes in andrews Pitchfork Drawing
     */
    infChart.util.wrap(infChart.andrewsPitchforkDrawing.prototype, 'applyAllToFibLines', function (proceed, enabled, fillColor, fillOpacity, lineColor, lineWidth, prevOptions, isPropertyChange) {
        if (isPropertyChange) {
            let self = this;
            let drawingId = self.drawingId;
            let chartId = self.stockChartId;
            let fibLevels = self.annotation.options.fibLevels;
            let currentVisibility = !enabled;
            let currentFibOption = [];

            let currentFillColor = self.annotation.options.fillColor;
            let currentFillOpacity = self.annotation.options.fillOpacity;
            let currentLineColor = self.annotation.options.lineColor;
            let currentLineWidth = self.annotation.options.lineWidth;

            fibLevels.forEach(function (fibLevel) {
                if (typeof fibLevel === 'object' && fibLevel.hasOwnProperty('id')) {
                    var fibId = fibLevel.id;
                    currentFibOption.push({
                        id: fibId,
                        fillColor: fibLevel.fillColor,
                        fillOpacity: fibLevel.fillOpacity,
                        lineColor: fibLevel.lineColor,
                        lineWidth: fibLevel.lineWidth,
                        fontColor: fibLevel.fontColor,
                        fontSize: fibLevel.fontSize,
                        fontWeight: fibLevel.fontWeight
                    });
                }
            });

            function undoRedo(isSingleOptionEnabled, newFillColor, newFillOpacity, newLineColor, newLineWidth, newPrevOptions) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(chartId, drawingId);
                if (isSingleOptionEnabled) {
                    proceed.call(drawingObj, isSingleOptionEnabled, newFillColor, newFillOpacity, newLineColor, newLineWidth, newPrevOptions, false);
                } else {
                    proceed.call(drawingObj, isSingleOptionEnabled, newFillColor, newFillOpacity, newLineColor, newLineWidth, newPrevOptions, false);
                }
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    settingPanel.data("infUndoRedo", true);
                    drawingObj.updateSettings(drawingObj.getConfig());
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(chartId, function () {
                undoRedo(enabled, fillColor, fillOpacity, lineColor, lineWidth, prevOptions);
            }, function () {
                undoRedo(currentVisibility, currentFillColor, currentFillOpacity, currentLineColor, currentLineWidth, currentFibOption);
            }, undefined, false, 'applyAllToFibLines');

        }
        proceed.call(this, enabled, fillColor, fillOpacity, lineColor, lineWidth, prevOptions, isPropertyChange);
    });

    /**
     * Wrapping up fib level changes in andrews Pitchfork Drawing
     */
    infChart.util.wrap(infChart.andrewsPitchforkDrawing.prototype, 'onChangeFibLines', function (proceed, fibLevel, property, propertyValue, isPropertyChange) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = this.stockChartId;
            var lastAction = infChart.commandsManager.getLastAction(xChartId);
            var currentValue = property === 'fillColor' ? { fill: fibLevel['fillColor'], opacity: fibLevel['fillOpacity'] } : fibLevel[property];

            /**
             * Execute the undo/redo with the new properties
             * @param {string} property update property name
             * @param {*} propertyValue value of updated property
             */
            function undoRedo(fibLevel, property, propertyValue) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                proceed.call(drawingObj, fibLevel, property, propertyValue, false);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    drawingObj.updateSettings(drawingObj.getConfig());
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'changeAllFibLines' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(fibLevel, property, currentValue);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(fibLevel, property, propertyValue);
                }, function () {
                    undoRedo(fibLevel, property, currentValue);
                }, undefined, false, 'changeAllFibLines');
            }
        }
        proceed.call(this, fibLevel, property, propertyValue, isPropertyChange);
    });

    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onPriceLineStyleChange', function (proceed, type, lineStyle, isPropertyChange) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var options= ann.options;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var isStopLoss = (type === 'sl1' || type === 'sl2' || type === 'sl3');
            var additionalDrawingList = isStopLoss ? options.stopLoss : options.takeProfit;
            var level = additionalDrawingList.find(function (level) {
                if (level.id === type) {
                    return level;
                }
            });

            var currentLineStyle = level.lineStyle;
            var currentType = type;

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean|undefined} newVisibility indicate the visibility of the level
             */
            function undoRedo(type, lineStyle) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var LevelElm = settingPanel.find("[inf-ctrl=priceLineLevelSelectedLineStyle][inf-ctrl-val='" + type + "']");
                    if (LevelElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        var dropDownItem = LevelElm.parent().parent();
                        $(dropDownItem).find("li[inf-ctrl=lineStyle][inf-style='" + lineStyle + "']").trigger("click");
                    } else {
                        proceed.call(drawingObj, type, lineStyle, false);
                    }
                } else {
                    proceed.call(drawingObj, type, lineStyle, false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(type, lineStyle);
            }, function () {
                undoRedo(currentType, currentLineStyle);
            }, undefined, false, 'onPriceLineStyleChange');
        }
        proceed.call(this, type, lineStyle, isPropertyChange);
    });

    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onPriceLineWidthChange', function (proceed, type, strokeWidth, isPropertyChange) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var options= ann.options;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var isStopLoss = (type === 'sl1' || type === 'sl2' || type === 'sl3');
            var priceline;
        
            var additionalDrawingList = isStopLoss ? options.stopLoss : options.takeProfit;
            var level = additionalDrawingList.find(function (level) {
                if (level.id === type) {
                    return level;
                }
            });
            
            if (isStopLoss) {
                priceline = this.additionalDrawings.slPriceLines[level.id];
            } else {
                priceline = this.additionalDrawings.tpPriceLines[level.id];
            }

            var currentLineWidth = priceline.attr('stroke-width');
            var currentType = type;

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean|undefined} newVisibility indicate the visibility of the level
             */
            function undoRedo(type, strokeWidth) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var LevelElm = settingPanel.find("[inf-ctrl=priceLineLevelSelectedLineWidth][inf-ctrl-val='" + type + "']");
                    if (LevelElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        var dropDownItem = LevelElm.parent().parent();
                        $(dropDownItem).find("li[inf-ctrl=lineWidth][inf-size='" + strokeWidth + "']").trigger("click");
                    } else {
                        proceed.call(drawingObj, type, strokeWidth, false);
                    }
                } else {
                    proceed.call(drawingObj, type, strokeWidth, false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(type, strokeWidth);
            }, function () {
                undoRedo(currentType, currentLineWidth);
            }, undefined, false, 'onPriceLineStyleChange');
        }
        proceed.call(this, type, strokeWidth, isPropertyChange);
    });

    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onEntryValueChange', function (proceed, element, value, isPropertyChange) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var options= ann.options;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentValue = options.yValue;

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean|undefined} newVisibility indicate the visibility of the level
             */
            function undoRedo(element, value) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                    proceed.call(drawingObj, element, value, false);
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(element, value);
            }, function () {
                undoRedo(element, currentValue);
            }, undefined, false, 'onEntryValueChange');
        }
        proceed.call(this, element, value, isPropertyChange);
    });

    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onPriceValueChange', function (proceed, element, priceValue, type, isPropertyChange) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var options= ann.options;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var isStopLoss = (type === 'sl1' || type === 'sl2' || type === 'sl3');
            var additionalDrawingList = isStopLoss ? options.stopLoss : options.takeProfit;
            var level = additionalDrawingList.find(function (level) {
                if (level.id === type) {
                    return level;
                }
            });

            var currentValue = level.yValue;

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean|undefined} newVisibility indicate the visibility of the level
             */
            function undoRedo(element, priceValue, type) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                    proceed.call(drawingObj, element, priceValue, type, false);
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(element, priceValue, type);
            }, function () {
                undoRedo(element, currentValue, type);
            }, undefined, false, 'onPriceValueChange');
        }
        proceed.call(this, element, priceValue, type, isPropertyChange);
    });


    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onApplyLine', function (proceed, checked, lineType, isPropertyChange) {

        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var lastAction = infChart.commandsManager.getLastAction(xChartId);
            var currentCheck = !checked;

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor new color to set
             */
            function undoRedo(checked, lineType) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var levelEnabledElm = settingPanel.find("[inf-ctrl=applyPriceLine][inf-value=" + lineType + "]");
                    if (levelEnabledElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        levelEnabledElm.trigger("click");
                    } else {
                        proceed.call(drawingObj, checked, lineType, false);
                    }
                } else {
                    proceed.call(drawingObj, checked, lineType, false);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onApplyLine' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(checked, lineType);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(checked, lineType);
                }, function () {
                    undoRedo(currentCheck, lineType);
                }, undefined, false, 'onApplyLine');
            }
        }

        proceed.call(this, checked, lineType, isPropertyChange);
    });

    //region----------------------Fibonacci settings--------------------------------------------------------------------

    /**
     * Wrapping up the infChart.drawingUtils.common.settings.onFibLevelChange to catch the level changes
     */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onFibLevelChange', function (proceed, currentLevel, checked, isPropertyChange, ignoreSettingsSave) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentVisibility = !checked;

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean|undefined} newVisibility indicate the visibility of the level
             */
            function undoRedo(newVisibility) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var fibLevelElm = settingPanel.find("[inf-ctrl=fibLevel][data-value='" + currentLevel + "']");
                    if (fibLevelElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fibLevelElm.trigger('click');
                    } else {
                        proceed.call(drawingObj, currentLevel, newVisibility);
                    }
                } else {
                    proceed.call(drawingObj, currentLevel, newVisibility);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(checked);
            }, function () {
                undoRedo(currentVisibility);
            }, undefined, false, 'onFibLevelChange');
        }
        proceed.call(this, currentLevel, checked, isPropertyChange, ignoreSettingsSave);
    });

    /**
     * Wrapping up the infChart.fibArcsDrawing.prototype.onFibArcsLevelChange to catch the level changes
     */
    infChart.util.wrap(infChart.fibArcsDrawing.prototype, 'onFibArcsLevelChange', function (proceed, currentLevel, checked, isPropertyChange, ignoreSettingsSave) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentVisibility = !checked;

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean|undefined} newVisibility indicate the visibility of level
             */
            function undoRedo(newVisibility) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var fibLevelElm = settingPanel.find("[inf-ctrl=fibLevel][data-value='" + currentLevel + "']");
                    if (fibLevelElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fibLevelElm.trigger('click');
                    } else {
                        proceed.call(drawingObj, currentLevel, newVisibility);
                    }
                } else {
                    proceed.call(drawingObj, currentLevel, newVisibility);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(checked);
            }, function () {
                undoRedo(currentVisibility);
            }, undefined, false, 'onFibArcsLevelChange');
        }
        proceed.call(this, currentLevel, checked, isPropertyChange, ignoreSettingsSave);
    });

    /**
     * Wrapping up the infChart.fibFansDrawing.prototype.onFibFansLevelChange to catch the level  changes
     */
    infChart.util.wrap(infChart.fibFansDrawing.prototype, 'onFibFansLevelChange', function (proceed, currentLevel, checked, isPropertyChange, ignoreSettingsSave) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentVisibility = !checked;

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean|undefined} newVisibility indicate the visibility of level
             */
            function undoRedo(newVisibility) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var fibLevelElm = settingPanel.find("[inf-ctrl=fibLevel][data-value='" + currentLevel + "']");
                    if (fibLevelElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fibLevelElm.trigger('click');
                    } else {
                        proceed.call(drawingObj, currentLevel, newVisibility);
                    }
                } else {
                    proceed.call(drawingObj, currentLevel, newVisibility);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(checked);
            }, function () {
                undoRedo(currentVisibility);
            }, undefined, false, 'onFibFansLevelChange');
        }
        proceed.call(this, currentLevel, checked, isPropertyChange, ignoreSettingsSave);
    });

    /**
     * Wrapping up the infChart.drawingUtils.common.settings.onFibLineColorChange to catch the color settings change
     */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onFibFillColorChange', function (proceed, rgb, color, opacity, fibLevel, isAll, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var fibonacciDrawingsFill = this.fibonacciDrawings.fill[fibLevel.id];
            var currentColor = fibonacciDrawingsFill.element.getAttribute("fill");
            var currentOpacity = fibonacciDrawingsFill.element.getAttribute("fill-opacity");
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             * @param {float} newOpacity opacity
             */
            function undoRedo(newColor, newOpacity) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var fibColorChangeElm = settingPanel.find("[inf-ctrl=fibLevelFillColorPicker][inf-ctrl-val='" + fibLevel.id + "']");
                    if (fibColorChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fibColorChangeElm.mainColorPanel("value", {
                            color: newColor,
                            opacity: newOpacity
                        });
                    } else {
                        proceed.call(drawingObj, rgb, newColor, newOpacity, fibLevel, isAll, false);
                    }
                } else {
                    proceed.call(drawingObj, rgb, newColor, newOpacity, fibLevel, isAll, false);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onFibFillColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color, opacity);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color, opacity);
                }, function () {
                    undoRedo(currentColor, currentOpacity);
                }, undefined, false, 'onFibFillColorChange');
            }
        }
        proceed.call(this, rgb, color, opacity, fibLevel, isAll, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.drawingUtils.common.settings.onFibLevelLineColorChange to catch the color settings change
     */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onFibLevelLineColorChange', function (proceed, rgb, color, fibLevelId, isAll, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var self = this;
            var ann = self.annotation;
            var fibonacciDrawingsLines = self.additionalDrawings.lines[fibLevelId];
            var currentLineColor = fibonacciDrawingsLines.element.getAttribute("stroke");
            var lastAction = infChart.commandsManager.getLastAction(self.stockChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             */
            function undoRedo(newColor) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibLineColorChangeElm = settingPanel.find("[inf-ctrl=fibLevelLineColorPicker][inf-ctrl-val='" + fibLevelId + "']");
                    if (fibLineColorChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fibLineColorChangeElm.mainColorPanel("value", {
                            color: newColor
                        });
                    } else {
                        proceed.call(self, rgb, newColor, fibLevelId, isAll, false);
                    }
                } else {
                    proceed.call(self, rgb, newColor, fibLevelId, isAll, false);
                }
                self.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onFibLevelLineColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color);
                }
            } else {
                infChart.commandsManager.registerCommand(self.stockChartId, function () {
                    undoRedo(color);
                }, function () {
                    undoRedo(currentLineColor);
                }, undefined, false, 'onFibLevelLineColorChange');
            }
        }
        proceed.call(this, rgb, color, fibLevelId, isAll, isPropertyChange);
    });

    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onFibLevelFontColorChange', function (proceed, rgb, color, fibLevel, isAll, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var self = this;
            var ann = self.annotation;
            var fibLevelId = fibLevel && fibLevel.id;
            var fibonacciDrawingsLabel = self.fibonacciDrawings.lines[fibLevelId];
            var currentFontColor = fibonacciDrawingsLabel.element.getAttribute("font-color");
            var lastAction = infChart.commandsManager.getLastAction(self.stockChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             */
             function undoRedo(newColor) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibFontColorChangeElm = settingPanel.find("[inf-ctrl=fibLevelFontColorPicker][inf-ctrl-val='" + fibLevelId + "']");
                    if (fibFontColorChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fibFontColorChangeElm.mainColorPanel("value", {
                            color: newColor
                        });
                    } else {
                        proceed.call(self, rgb, newColor, fibLevel, isAll, false);
                    }
                } else {
                    proceed.call(self, rgb, newColor, fibLevel, isAll, false);
                }
                self.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onFibLevelFontColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color);
                }
            } else {
                infChart.commandsManager.registerCommand(self.stockChartId, function () {
                    undoRedo(color);
                }, function () {
                    undoRedo(currentFontColor);
                }, undefined, false, 'onFibLevelFontColorChange');
            }
        }
        proceed.call(this, rgb, color, fibLevel, isAll, isPropertyChange);
    });

    /**
    * Wrapping up the infChart.drawingUtils.common.settings.onFibSingleFontSizeChange to catch the all fib level font size change
    */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onFibSingleFontSizeChange', function (proceed, fontSize, isSingleColor, fibLevelFontSizes, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            var ann = self.annotation;
            var currentType = ann.options.isSingleColor;
            var currentFontSize = ann.options.fontSize;

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new font size to set
             */
            function undoRedo(newSize, isSingleColor) {
                var settingPanel = self.settingsPopup;

                if (settingPanel) {
                    var fibFontSizeChangeDropdownElm = $(settingPanel.find("span[inf-ctrl=singleSelectedFontSize][inf-ctrl-val=P_all]"));
                    if (fibFontSizeChangeDropdownElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        var dropDownItem = fibFontSizeChangeDropdownElm.parent().parent();
                        $(dropDownItem).find("li[inf-ctrl=fontSize][inf-size='" + newSize + "']").trigger("click");
                    } else {
                        proceed.call(self, newSize, isSingleColor, fibLevelFontSizes, false);
                    }
                } else {
                    proceed.call(self, newSize, isSingleColor, fibLevelFontSizes, false);
                }
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(fontSize, isSingleColor);
            }, function () {
                undoRedo(currentFontSize, currentType);
            }, undefined, false, 'onFibSingleFontSizeChange');
        }
        proceed.call(this, fontSize, isSingleColor, fibLevelFontSizes, isPropertyChange);
    });

    /**
    * Wrapping up the infChart.drawingUtils.common.settings.onFibSingleLineWidthChange to catch the all fib level line width change
    */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onFibSingleLineWidthChange', function (proceed, strokeWidth, isSingleColor, fibLevelWidths, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            var ann = self.annotation;
            var currentType = ann.options.isSingleColor;
            var currentLineWidth = ann.options.lineWidth;

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new width to set
             */
            function undoRedo(newSize, isSingleColor) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibLineWidthChangeDropdownElm = $(settingPanel.find("span[inf-ctrl=singleSelectedLineWidth][inf-ctrl-val=P_all]"));
                    if (fibLineWidthChangeDropdownElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        var dropDownItem = fibLineWidthChangeDropdownElm.parent().parent();
                        $(dropDownItem).find("li[inf-ctrl=lineWidth][inf-size='" + newSize + "']").trigger("click");
                    } else {
                        proceed.call(self, newSize, isSingleColor, fibLevelWidths, false);
                    }
                } else {
                    proceed.call(self, newSize, isSingleColor, fibLevelWidths, false);
                }
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(strokeWidth, isSingleColor);
            }, function () {
                undoRedo(currentLineWidth, currentType);
            }, undefined, false, 'onFibSingleLineWidthChange');
        }
        proceed.call(this, strokeWidth, isSingleColor, fibLevelWidths, isPropertyChange);
    });

    /**
    * Wrapping up the infChart.drawingUtils.common.settings.onFibSingleFontColorChange to catch the all fib level font color change
    */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onFibSingleFontColorChange', function (proceed, rgb, value, isSingleColor, fibLevelFontColors, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var self = this;
            var ann = self.annotation;
            var currentType = ann.options.isSingleColor;
            var currentFontColor = ann.options.fontColor;
            var lastAction = infChart.commandsManager.getLastAction(self.stockChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newColor new color to set
             */
            function undoRedo(rgb, newColor, isSingleColor) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibFontColorChangeElm = settingPanel.find("[inf-ctrl=singleFontColorPicker][inf-ctrl-val=P_all]");
                    if (fibFontColorChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fibFontColorChangeElm.mainColorPanel("value", {
                            color: newColor
                        });
                    } else {
                        proceed.call(self, rgb, newColor, isSingleColor, fibLevelFontColors, false);
                    }
                } else {
                    proceed.call(self, rgb, newColor, isSingleColor, fibLevelFontColors, false);
                }
                self.onPropertyChange();
            }
            if (lastAction && lastAction.actionType === 'onFibSingleFontColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(rgb, value, isSingleColor);
                }
            } else {
                infChart.commandsManager.registerCommand(self.stockChartId, function () {
                    undoRedo(rgb, value, isSingleColor);
                }, function () {
                    undoRedo(rgb, currentFontColor, currentType);
                }, undefined, false, 'onFibSingleFontColorChange');
            }
        }
        proceed.call(this, rgb, value, isSingleColor, fibLevelFontColors, isPropertyChange);
    });

    /**
    * Wrapping up the infChart.drawingUtils.common.settings.onFibSingleLineColorChange to catch the all fib level line color change
    */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onFibSingleLineColorChange', function (proceed, rgb, value, isSingleColor, fibLevelLineColors, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var self = this;
            var ann = self.annotation;
            var currentLineColor = ann.options.lineColor;
            var currentType = ann.options.isSingleColor;
            var lastAction = infChart.commandsManager.getLastAction(self.stockChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             */
            function undoRedo(rgb, newColor, isSingleColor) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibLineColorChangeElm = settingPanel.find("[inf-ctrl=singleLineColorPicker][inf-ctrl-val=P_all]");
                    if (fibLineColorChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fibLineColorChangeElm.mainColorPanel("value", {
                            color: newColor
                        });
                    } else {
                        proceed.call(self, rgb, newColor, isSingleColor, fibLevelLineColors, false);
                    }
                } else {
                    proceed.call(self, rgb, newColor, isSingleColor, fibLevelLineColors, false);
                }
                self.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onFibSingleLineColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(rgb, value, isSingleColor);
                }
            } else {
                infChart.commandsManager.registerCommand(self.stockChartId, function () {
                    undoRedo(rgb, value, isSingleColor);
                }, function () {
                    undoRedo(rgb, currentLineColor, currentType);
                }, undefined, false, 'onFibSingleLineColorChange');
            }
        }
        proceed.call(this, rgb, value, isSingleColor, fibLevelLineColors, isPropertyChange);
    });

    /**
    * Wrapping up the infChart.drawingUtils.common.settings.onFibSingleFontWeightChange to catch the all fib level font weight change
    */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onFibSingleFontWeightChange', function (proceed, value, isSingleColor, fibLevelOptions, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            var ann = self.annotation;
            var currentFontWeight = ann.options.fontWeight;
            var currentType = ann.options.isSingleColor;

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new weight to set
             */
            function undoRedo(newWeight, isSingleColor) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibFontWeightChangeElm = settingPanel.find("button[inf-ctrl=singleToggleFontWeight][inf-ctrl-val=P_all]");
                    if (fibFontWeightChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        $(fibFontWeightChangeElm).trigger("click");
                    } else {
                        proceed.call(self, newWeight, isSingleColor, fibLevelOptions, false);
                    }
                } else {
                    proceed.call(self, newWeight, isSingleColor, fibLevelOptions, false);
                }
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(value, isSingleColor);
            }, function () {
                undoRedo(currentFontWeight, currentType);
            }, undefined, false, 'onFibSingleFontWeightChange');
        }
        proceed.call(this, value, isSingleColor, fibLevelOptions, isPropertyChange);
    });

    /**
    * Wrapping up the infChart.drawingUtils.common.settings.onFibSingleFillColorChange to catch the all fib level fill color change
    */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onFibSingleFillColorChange', function (proceed, rgb, value, opacity, isSingleColor, fibLevelColors, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var self = this;
            var ann = self.annotation;
            var currentFillColor = ann.options.fillColor;
            var currentFillOpacity = ann.options.fillOpacity;
            var currentType = ann.options.isSingleColor;
            var lastAction = infChart.commandsManager.getLastAction(self.stockChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             * @param {float} newOpacity opacity
             */
            function undoRedo(rgb, newColor, newOpacity, isSingleColor) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibColorChangeElm = settingPanel.find("[inf-ctrl=singleFillColorPicker][inf-ctrl-val=P_all]");
                    if (fibColorChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fibColorChangeElm.mainColorPanel("value", {
                            color: newColor,
                            opacity: newOpacity
                        });
                    } else {
                        proceed.call(self, rgb, newColor, newOpacity, isSingleColor, fibLevelColors, false);
                    }
                } else {
                    proceed.call(self, rgb, newColor, newOpacity, isSingleColor, fibLevelColors, false);
                }
                self.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onFibSingleFillColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(rgb, value, isSingleColor);
                }
            } else {
                infChart.commandsManager.registerCommand(self.stockChartId, function () {
                    undoRedo(rgb, value, opacity, isSingleColor);
                }, function () {
                    undoRedo(rgb, currentFillColor, currentFillOpacity, currentType);
                }, undefined, false, 'onFibSingleFillColorChange');
            }
        }
        proceed.call(this, rgb, value, opacity, isSingleColor, fibLevelColors, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.drawingUtils.common.settings.onFibSingleOptionChange to catch the color settings change
     */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onFibSingleOptionChange', function (proceed, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, isSingleColor, prevOptions, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var self = this;
            var drawingId = self.drawingId;
            var ann = self.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentType = self.annotation.options.isSingleColor;
            var lastAction = infChart.commandsManager.getLastAction(self.stockChartId);

            var currentFillColor = self.annotation.options.fillColor;
            var currentFillOpacity = self.annotation.options.fillOpacity;
            var currentLineColor = self.annotation.options.lineColor;
            var currentLineWidth = self.annotation.options.lineWidth;
            var currentFontColor = self.annotation.options.fontColor;
            var currentFontSize = self.annotation.options.fontSize;
            var currentFontWeight = self.annotation.options.fontWeight;

            var currentFibLevelOptions = {};
            var fibLevels = self.annotation.options.fibLevels;
            fibLevels.forEach(function (fibLevel) {
                if (typeof fibLevel === 'object' && fibLevel.hasOwnProperty('id')) {
                    var fibId = fibLevel.id;
                    currentFibLevelOptions[fibId] = {
                        fillColor: fibLevel.fillColor,
                        fillOpacity: fibLevel.fillOpacity,
                        lineColor: fibLevel.lineColor,
                        lineWidth: fibLevel.lineWidth,
                        fontColor: fibLevel.fontColor,
                        fontSize: fibLevel.fontSize,
                        fontWeight: fibLevel.fontWeight
                    };
                }
            });

            /**
             * Execute the undo/redo with the new properties
             * @param isSingleOptionEnabled
             * @param newFillColor
             * @param newFillOpacity
             * @param newLineColor
             * @param newLineWidth
             * @param newFontColor
             * @param newFontSize
             * @param newFontWeight
             * @param newFibLevelOptions
             */
            function undoRedo(isSingleOptionEnabled, newFillColor, newFillOpacity, newLineColor, newLineWidth, newFontColor, newFontSize, newFontWeight, newFibLevelOptions) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if(settingPanel){
                    settingPanel.data("infUndoRedo", true);
                }
                if (isSingleOptionEnabled) {
                    proceed.call(drawingObj, newFillColor, newFillOpacity, newLineColor, newLineWidth, newFontColor, newFontSize, newFontWeight, isSingleOptionEnabled, newFibLevelOptions, false);
                } else {
                    proceed.call(drawingObj, newFillColor, newFillOpacity, newLineColor, newLineWidth, newFontColor, newFontSize, newFontWeight, true, newFibLevelOptions, false);
                    proceed.call(drawingObj, newFillColor, newFillOpacity, newLineColor, newLineWidth, newFontColor, newFontSize, newFontWeight, isSingleOptionEnabled, newFibLevelOptions, false);
                }
                if (settingPanel) {
                    drawingObj.updateSettings(drawingObj.getConfig());
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onFibSingleFillColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(isSingleColor, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(isSingleColor, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions);
                }, function () {
                    undoRedo(currentType, currentFillColor, currentFillOpacity, currentLineColor, currentLineWidth, currentFontColor, currentFontSize, currentFontWeight, currentFibLevelOptions);
                }, undefined, false, 'onFibSingleFillColorChange');
            }
        }
        proceed.call(this, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, isSingleColor, prevOptions, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.drawingUtils.common.settings.onFibLineWidthChange to catch the line width changes
     */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onFibLineWidthChange', function (proceed, strokeWidth, fibLevelId, isAll, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            var fibLevel = self.additionalDrawings.lines[fibLevelId];
            var currentWidth = fibLevel.element.getAttribute("stroke-width");

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new width to set
             */
            function undoRedo(newSize, fibLevelId) {
                // var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibLineWidthChangeDropdownElm = $(settingPanel.find("span[inf-ctrl=fibLevelSelectedLineWidth][inf-ctrl-val='" + fibLevelId + "']"));
                    if (fibLineWidthChangeDropdownElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        var dropDownItem = fibLineWidthChangeDropdownElm.parent().parent();
                        $(dropDownItem).find("li[inf-ctrl=lineWidth][inf-size='" + newSize + "']").trigger("click");
                    } else {
                        proceed.call(self, newSize, fibLevelId, isAll);
                    }
                } else {
                    proceed.call(self, newSize, fibLevelId, isAll);
                }
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(strokeWidth, fibLevelId);
            }, function () {
                undoRedo(currentWidth, fibLevelId);
            }, undefined, false, 'onFibLineWidthChange');
        }
        proceed.call(this, strokeWidth, fibLevelId, isAll, isPropertyChange);
    });

    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onFibLevelFontSizeChange', function (proceed, fontSize, fibLevelId, isAll, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            var fibLevel = self.fibonacciDrawings.lines[fibLevelId];
            var currentFontSize = fibLevel.element.getAttribute("font-size");

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new width to set
             */
            function undoRedo(newSize, fibLevelId) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibFontSizeChangeDropdownElm = $(settingPanel.find("span[inf-ctrl=fibLevelSelectedFontSize][inf-ctrl-val='" + fibLevelId + "']"));
                    if (fibFontSizeChangeDropdownElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        var dropDownItem = fibFontSizeChangeDropdownElm.parent().parent();
                        $(dropDownItem).find("li[inf-ctrl=fontSize][inf-size='" + newSize + "']").trigger("click");
                    } else {
                        proceed.call(self, newSize, fibLevelId, isAll);
                    }
                } else {
                    proceed.call(self, newSize, fibLevelId, isAll);
                }
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(fontSize, fibLevelId);
            }, function () {
                undoRedo(currentFontSize, fibLevelId);
            }, undefined, false, 'onFibLineWidthChange');
        }
        proceed.call(this, fontSize, fibLevelId, isAll, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.drawingUtils.common.settings.onFibLevelFontWeightChange to catch the fib level font size change change
     */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onFibLevelFontWeightChange', function (proceed, fontWeight, fibLevelId, isAll, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            var fibLevel = self.fibonacciDrawings.lines[fibLevelId];
            var currentFontWeight = fibLevel.element.getAttribute("font-weight");

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new width to set
             */
            function undoRedo(newSize, fibLevelId) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibFontWeightChangeElm = settingPanel.find("button[inf-ctrl=fibLevelToggleFontWeight][inf-ctrl-val='" + fibLevelId + "']");
                    if (fibFontWeightChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        $(fibFontWeightChangeElm).trigger("click");
                    } else {
                        proceed.call(self, newSize, fibLevelId, isAll);
                    }
                } else {
                    proceed.call(self, newSize, fibLevelId, isAll);
                }
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(fontWeight, fibLevelId);
            }, function () {
                undoRedo(currentFontWeight, fibLevelId);
            }, undefined, false, 'onFibLevelFontWeightChange');
        }
        proceed.call(this, fontWeight, fibLevelId, isAll, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.drawingUtils.common.settings.onFibLevelValueChange to catch the fib level value change
     */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onFibLevelValueChange', function (proceed, currentLevel, value, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            var ann = self.annotation;
            var options = ann.options;
            var fibLevel = options.fibLevels.find(function (level) {
                return level.id === currentLevel;
            });
            var currentValue = fibLevel.value;

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                proceed.call(self, currentLevel, value, false);
                self.onPropertyChange();
            }, function () {
                proceed.call(self, currentLevel, currentValue, false);
                self.onPropertyChange();
            }, undefined, false, 'onFibLevelValueChange');
        }
        proceed.call(self, currentLevel, value, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.fibRetracementsDrawing.prototype.onFibModeChange to catch the fib level value change
     */
    infChart.util.wrap(infChart.fibRetracementsDrawing.prototype, 'onFibModeChange', function (proceed, checked, isPropertyChange, ignoreSettingsSave) {
        if (isPropertyChange) {
            var self = this;
            var ann = self.annotation;
            var currentMode = !checked;

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean} checked - mode chaned
             */
            function undoRedo(checked) {
                proceed.call(self, checked, false);
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(checked);
            }, function () {
                undoRedo(currentMode);
            }, undefined, false, 'onFibModeChange');
        }
        proceed.call(this, checked, isPropertyChange, ignoreSettingsSave);
    });

    /**
     * Wrapping up the infChart.fibRetracementsDrawing.prototype.onChangeSnapToHighLow to catch the fib level value change
     */
    infChart.util.wrap(infChart.fibRetracementsDrawing.prototype, 'onChangeSnapToHighLow', function (proceed, checked, isPropertyChange, ignoreSettingsSave) {
        if (isPropertyChange) {
            var self = this;
            var ann = self.annotation;
            var options = ann.options;
            var currentMode = !checked;

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean} checked - mode chaned
             */
            function undoRedo(checked) {
                proceed.call(self, checked, false);
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(checked);
            }, function () {
                undoRedo(currentMode);
            }, undefined, false, 'onChangeSnapToHighLow');
        }
        proceed.call(this, checked, isPropertyChange, ignoreSettingsSave);
    });

    /**
     * Wrapping up the infChart.fibRetracementsDrawing.prototype.onTrendLineToggleShow to catch the trend line always show
     */
    infChart.util.wrap(infChart.fibRetracementsDrawing.prototype, 'onTrendLineToggleShow', function (proceed, checked, isPropertyChange) {
        var self = this;
        if (isPropertyChange) {
            var ann = self.annotation;
            var options = ann.options;
            var currentMode = !checked;
            var drawingId = self.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean} checked - mode chaned
             */
            function undoRedo(checked) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var toggleTrendLineAlwaysElm = settingPanel.find("[inf-ctrl=showTrendLineAlways]");
                    if (toggleTrendLineAlwaysElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        toggleTrendLineAlwaysElm.trigger("click");
                    } else {
                        proceed.call(drawingObj, checked, false);
                    }
                } else {
                    proceed.call(drawingObj, checked, false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(checked);
            }, function () {
                undoRedo(currentMode);
            }, undefined, false, 'onTrendLineToggleShow_fibRetracementsDrawing');
        }
        proceed.call(self, checked, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.fib3PointPriceProjectionDrawing.prototype.onTrendLineToggleShow to catch the trend line always show
     */
    infChart.util.wrap(infChart.fib3PointPriceProjectionDrawing.prototype, 'onTrendLineToggleShow', function (proceed, checked, isPropertyChange) {
        var self = this;
        if (isPropertyChange) {
            var ann = self.annotation;
            var options = ann.options;
            var currentMode = !checked;
            var drawingId = self.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean} checked - mode chaned
             */
            function undoRedo(checked) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var toggleTrendLineAlwaysElm = settingPanel.find("[inf-ctrl=showTrendLineAlways]");
                    if (toggleTrendLineAlwaysElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        toggleTrendLineAlwaysElm.trigger("click");
                    } else {
                        proceed.call(drawingObj, checked, false);
                    }
                } else {
                    proceed.call(drawingObj, checked, false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(checked);
            }, function () {
                undoRedo(currentMode);
            }, undefined, false, 'onTrendLineToggleShow_fib3PointPriceProjectionDrawing');
        }
        proceed.call(self, checked, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.fib3PointPriceProjectionGenericDrawing.prototype.onTrendLineToggleShow to catch the trend line always show
     */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onTrendLineToggleShow', function (proceed, checked, isPropertyChange) {
        var self = this;
        if (isPropertyChange) {
            var ann = self.annotation;
            var options = ann.options;
            var currentMode = !checked;
            var drawingId = self.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean} checked - mode chaned
             */
            function undoRedo(checked) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var toggleTrendLineAlwaysElm = settingPanel.find("[inf-ctrl=showTrendLineAlways]");
                    if (toggleTrendLineAlwaysElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        toggleTrendLineAlwaysElm.trigger("click");
                    } else {
                        proceed.call(drawingObj, checked, false);
                    }
                } else {
                    proceed.call(drawingObj, checked, false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(checked);
            }, function () {
                undoRedo(currentMode);
            }, undefined, false, 'onTrendLineToggleShow_fib3PointPriceProjectionGenericDrawing');
        }
        proceed.call(self, checked, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.fibVerRetracementsDrawing.prototype.onTrendLineToggleShow to catch the trend line always show
     */
    infChart.util.wrap(infChart.fibVerRetracementsDrawing.prototype, 'onTrendLineToggleShow', function (proceed, checked, isPropertyChange) {
        var self = this;
        if (isPropertyChange) {
            var ann = self.annotation;
            var options = ann.options;
            var currentMode = !checked;
            var drawingId = self.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean} checked - mode chaned
             */
            function undoRedo(checked) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var toggleTrendLineAlwaysElm = settingPanel.find("[inf-ctrl=showTrendLineAlways]");
                    if (toggleTrendLineAlwaysElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        toggleTrendLineAlwaysElm.trigger("click");
                    } else {
                        proceed.call(drawingObj, checked, false);
                    }
                } else {
                    proceed.call(drawingObj, checked, false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(checked);
            }, function () {
                undoRedo(currentMode);
            }, undefined, false, 'onTrendLineToggleShow_fibVerRetracementsDrawing');
        }
        proceed.call(self, checked, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.fib3PointTimeProjection.prototype.onTrendLineToggleShow to catch the trend line always show
     */
    infChart.util.wrap(infChart.fib3PointTimeProjection.prototype, 'onTrendLineToggleShow', function (proceed, checked, isPropertyChange) {
        var self = this;
        if (isPropertyChange) {
            var ann = self.annotation;
            var options = ann.options;
            var currentMode = !checked;
            var drawingId = self.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean} checked - mode chaned
             */
            function undoRedo(checked) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var toggleTrendLineAlwaysElm = settingPanel.find("[inf-ctrl=showTrendLineAlways]");
                    if (toggleTrendLineAlwaysElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        toggleTrendLineAlwaysElm.trigger("click");
                    } else {
                        proceed.call(drawingObj, checked, false);
                    }
                } else {
                    proceed.call(drawingObj, checked, false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(checked);
            }, function () {
                undoRedo(currentMode);
            }, undefined, false, 'onTrendLineToggleShow_fib3PointTimeProjection');
        }
        proceed.call(self, checked, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibFillColorChange to catch the color settings change
     */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onFibFillColorChange', function (proceed, rgb, value, opacity, level, isAll, subType, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            if(subType == "fibExtention"){
                var fibonacciDrawingsFill = this.fibonacciDrawings.fill[level.id];
            }
            if(subType == "fibRetracement"){
                var fibonacciDrawingsFill = this.fibRetrancementAdditionalDrawing.fill[level.id];
            }
            var currentColor = fibonacciDrawingsFill.element.getAttribute("fill");
            var currentOpacity = fibonacciDrawingsFill.element.getAttribute("fill-opacity");
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             * @param {float} newOpacity opacity
             */
            function undoRedo(newColor, newOpacity, subType) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var fibColorChangeElm = settingPanel.find("[inf-ctrl=fibLevelFillColorPicker][inf-ctrl-val='" + level.id + "'][sub-type='" + subType + "']");
                    if (fibColorChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fibColorChangeElm.mainColorPanel("value", {
                            color: newColor,
                            opacity: newOpacity
                        });
                    } else {
                        proceed.call(drawingObj, rgb, newColor, newOpacity, fibLevel, isAll, subType, false);
                    }
                } else {
                    proceed.call(drawingObj, rgb, newColor, newOpacity, fibLevel, isAll, subType, false);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'genericTool_onFibFillColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(value, opacity);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(value, opacity, subType);
                }, function () {
                    undoRedo(currentColor, currentOpacity, subType);
                }, undefined, false, 'genericTool_onFibFillColorChange');
            }
        }
        proceed.call(this, rgb, value, opacity, level, isAll, subType, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibLevelLineColorChange to catch the color settings change
     */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onFibLevelLineColorChange', function (proceed, rgb, value, fibLevelId, isAll, subType, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var self = this;
            var ann = self.annotation;
            if(subType == "fibExtention"){
                var fibonacciDrawingsLines = this.fibonacciDrawings.lines[fibLevelId];
            }
            if(subType == "fibRetracement"){
                var fibonacciDrawingsLines = this.fibRetrancementAdditionalDrawing.lines[fibLevelId];
            }
            var currentLineColor = fibonacciDrawingsLines.element.getAttribute("stroke");
            var lastAction = infChart.commandsManager.getLastAction(self.stockChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             */
            function undoRedo(newColor, subType) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibLineColorChangeElm = settingPanel.find("[inf-ctrl=fibLevelLineColorPicker][inf-ctrl-val='" + fibLevelId + "'][sub-type='" + subType + "']");
                    if (fibLineColorChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fibLineColorChangeElm.mainColorPanel("value", {
                            color: newColor
                        });
                    } else {
                        proceed.call(self, rgb, newColor, fibLevelId, isAll, subType, false);
                    }
                } else {
                    proceed.call(self, rgb, newColor, fibLevelId, isAll, subType, false);
                }
                self.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'genericTool_onFibLevelLineColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(value, subType);
                }
            } else {
                infChart.commandsManager.registerCommand(self.stockChartId, function () {
                    undoRedo(value, subType);
                }, function () {
                    undoRedo(currentLineColor, subType);
                }, undefined, false, 'genericTool_onFibLevelLineColorChange');
            }
        }
        proceed.call(this, rgb, value, fibLevelId, isAll, subType, isPropertyChange);
    });
    
    /**
     * Wrapping up the infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibLevelFontColorChange to catch the color settings change
     */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onFibLevelFontColorChange', function (proceed, rgb, value, fibLevel, isAll, subType, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var self = this;
            var ann = self.annotation;
            var fibLevelId = fibLevel && fibLevel.id;
            if(subType == "fibExtention"){
                var fibonacciDrawingsLabel = this.fibonacciDrawings.labels[fibLevelId];
            }
            if(subType == "fibRetracement"){
                var fibonacciDrawingsLabel = this.fibRetrancementAdditionalDrawing.labels[fibLevelId];
            }
            var currentFontColor = fibonacciDrawingsLabel.element.getAttribute("font-color");
            var lastAction = infChart.commandsManager.getLastAction(self.stockChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             */
             function undoRedo(newColor, subType) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibFontColorChangeElm = settingPanel.find("[inf-ctrl=fibLevelFontColorPicker][inf-ctrl-val='" + fibLevelId + "'][subType='" + subType + "']");
                    if (fibFontColorChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fibFontColorChangeElm.mainColorPanel("value", {
                            color: newColor
                        });
                    } else {
                        proceed.call(self, rgb, newColor, fibLevel, isAll, subType, false);
                    }
                } else {
                    proceed.call(self, rgb, newColor, fibLevel, isAll, subType, false);
                }
                self.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'genericTool_onFibLevelFontColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(value, subType);
                }
            } else {
                infChart.commandsManager.registerCommand(self.stockChartId, function () {
                    undoRedo(value, subType);
                }, function () {
                    undoRedo(currentFontColor, subType);
                }, undefined, false, 'genericTool_onFibLevelFontColorChange');
            }
        }
        proceed.call(this, rgb, value, fibLevel, isAll, subType, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibLevelFontSizeChange to catch the color settings change
     */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onFibLevelFontSizeChange', function (proceed, fontSize, fibLevelId, isAll, subType, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            if(subType == "fibExtention"){
                var fibLevel = this.fibonacciDrawings.labels[fibLevelId];
            }
            if(subType == "fibRetracement"){
                var fibLevel = this.fibRetrancementAdditionalDrawing.labels[fibLevelId];
            }
            var currentFontSize = fibLevel.element.getAttribute("font-size");

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new width to set
             */
            function undoRedo(newSize, fibLevelId, subType) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibFontSizeChangeDropdownElm = $(settingPanel.find("span[inf-ctrl=fibLevelSelectedFontSize][inf-ctrl-val='" + fibLevelId + "'][sub-type='" + subType + "']"));
                    if (fibFontSizeChangeDropdownElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        var dropDownItem = fibFontSizeChangeDropdownElm.parent().parent();
                        $(dropDownItem).find("li[inf-ctrl=fontSize][inf-size='" + newSize + "']").trigger("click");
                    } else {
                        proceed.call(self, newSize, fibLevelId, isAll, subType, false);
                    }
                } else {
                    proceed.call(self, newSize, fibLevelId, isAll, subType, false);
                }
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(fontSize, fibLevelId, subType);
            }, function () {
                undoRedo(currentFontSize, fibLevelId, subType);
            }, undefined, false, 'genericTool_onFibLevelFontSizeChange');
        }
        proceed.call(this, fontSize, fibLevelId, isAll, subType, isPropertyChange);
    });
    
    /**
     * Wrapping up the infChart.drawingUtils.common.settings.onFibLineWidthChange to catch the line width changes
     */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onFibLineWidthChange', function (proceed, strokeWidth, fibLevelId, isAll, subType, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            if(subType == "fibExtention"){
                var fibLevel = this.fibonacciDrawings.lines[fibLevelId];
            }
            if(subType == "fibRetracement"){
                var fibLevel = this.fibRetrancementAdditionalDrawing.lines[fibLevelId];
            }
            var currentWidth = fibLevel.element.getAttribute("stroke-width");

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new width to set
             */
            function undoRedo(newSize, fibLevelId, subType) {
                // var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibLineWidthChangeDropdownElm = $(settingPanel.find("span[inf-ctrl=fibLevelSelectedLineWidth][inf-ctrl-val='" + fibLevelId + "'][sub-type='" + subType + "']"));
                    if (fibLineWidthChangeDropdownElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        var dropDownItem = fibLineWidthChangeDropdownElm.parent().parent();
                        $(dropDownItem).find("li[inf-ctrl=lineWidth][inf-size='" + newSize + "']").trigger("click");
                    } else {
                        proceed.call(self, newSize, fibLevelId, isAll, subType, false);
                    }
                } else {
                    proceed.call(self, newSize, fibLevelId, isAll, subType, false);
                }
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(strokeWidth, fibLevelId, subType);
            }, function () {
                undoRedo(currentWidth, fibLevelId, subType);
            }, undefined, false, 'genericTool_onFibLineWidthChange');
        }
        proceed.call(this, strokeWidth, fibLevelId, isAll, subType, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibLevelFontWeightChange to catch the fib level font size change change
     */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onFibLevelFontWeightChange', function (proceed, fontWeight, fibLevelId, isAll, subType, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            if(subType == "fibExtention"){
                var fibLevel = this.fibonacciDrawings.labels[fibLevelId];
            }
            if(subType == "fibRetracement"){
                var fibLevel = this.fibRetrancementAdditionalDrawing.labels[fibLevelId];
            }
            var currentFontWeight = fibLevel.element.getAttribute("font-weight");

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new width to set
             */
            function undoRedo(newSize, fibLevelId, subType) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibFontWeightChangeElm = settingPanel.find("button[inf-ctrl=fibLevelToggleFontWeight][inf-ctrl-val='" + fibLevelId + "'][sub-type='" + subType + "']");
                    if (fibFontWeightChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        $(fibFontWeightChangeElm).trigger("click");
                    } else {
                        proceed.call(self, newSize, fibLevelId, isAll, subType);
                    }
                } else {
                    proceed.call(self, newSize, fibLevelId, isAll, subType);
                }
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(fontWeight, fibLevelId, subType);
            }, function () {
                undoRedo(currentFontWeight, fibLevelId, subType);
            }, undefined, false, 'genericTool_onFibLevelFontWeightChange');
        }
        proceed.call(this, fontWeight, fibLevelId, isAll, subType, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibLevelValueChange to catch the fib level value change
     */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onFibLevelValueChange', function (proceed, currentLevel, value, subType, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            var ann = self.annotation;
            var options = ann.options;
            if(subType == "fibExtention"){
                var fibLevel = options.fibExtentionLevels.find(function (level) {
                    return level.id === currentLevel;
                });
            }
            if(subType == "fibRetracement"){
                var fibLevel = options.fibRetrancementLevels.find(function (level) {
                    return level.id === currentLevel;
                });
            }
            var currentValue = fibLevel.value;

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                proceed.call(self, currentLevel, value, subType, false);
                self.onPropertyChange();
            }, function () {
                proceed.call(self, currentLevel, currentValue, subType, false);
                self.onPropertyChange();
            }, undefined, false, 'genericTool_onFibLevelValueChange');
        }
        proceed.call(self, currentLevel, value, subType, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibLevelChange to catch the level changes
     */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onFibLevelChange', function (proceed, currentLevel, checked, subType, isPropertyChange, ignoreSettingsSave) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentVisibility = !checked;

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean|undefined} newVisibility indicate the visibility of the level
             */
            function undoRedo(newVisibility, subType) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var fibLevelElm = settingPanel.find("[inf-ctrl=fibLevel][data-value='" + currentLevel + "'][sub-type='" + subType + "']");
                    if (fibLevelElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fibLevelElm.trigger('click');
                    } else {
                        proceed.call(drawingObj, currentLevel, newVisibility, subType);
                    }
                } else {
                    proceed.call(drawingObj, currentLevel, newVisibility, subType);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(checked, subType);
            }, function () {
                undoRedo(currentVisibility, subType);
            }, undefined, false, 'genericTool_onFibLevelChange');
        }
        proceed.call(this, currentLevel, checked, subType, isPropertyChange, ignoreSettingsSave);
    });

    /**
    * Wrapping up the infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibSingleLineColorChange to catch the all fib level line color change
    */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onFibSingleLineColorChange', function (proceed, rgb, value, isSingleColor, fibLevelLineColors, subType, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var self = this;
            var ann = self.annotation;
            if(subType == "fibExtention"){
                var currentLineColor = ann.options.extentionLineColor;
                var currentType = ann.options.isSingleColorExtention;
            }
            if(subType == "fibRetracement"){
                var currentLineColor = ann.options.retrancementLineColor;
                var currentType = ann.options.isSingleColorRetracement;
            }
            var lastAction = infChart.commandsManager.getLastAction(self.stockChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             */
            function undoRedo(rgb, newColor, isSingleColor, subType) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibLineColorChangeElm = settingPanel.find("[inf-ctrl=singleLineColorPicker][inf-ctrl-val=P_all][sub-type='" + subType + "']");
                    if (fibLineColorChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fibLineColorChangeElm.mainColorPanel("value", {
                            color: newColor
                        });
                    } else {
                        proceed.call(self, rgb, newColor, isSingleColor, fibLevelLineColors, subType, false);
                    }
                } else {
                    proceed.call(self, rgb, newColor, isSingleColor, fibLevelLineColors, subType, false);
                }
                self.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'genericTool_onFibSingleLineColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(rgb, value, isSingleColor, subType);
                }
            } else {
                infChart.commandsManager.registerCommand(self.stockChartId, function () {
                    undoRedo(rgb, value, isSingleColor, subType);
                }, function () {
                    undoRedo(rgb, currentLineColor, currentType, subType);
                }, undefined, false, 'genericTool_onFibSingleLineColorChange');
            }
        }
        proceed.call(this, rgb, value, isSingleColor, fibLevelLineColors, subType, isPropertyChange);
    });

    /**
    * Wrapping up the infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibSingleFillColorChange to catch the all fib level fill color change
    */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onFibSingleFillColorChange', function (proceed, rgb, value, opacity, isSingleColor, fibLevelColors, subType, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var self = this;
            var ann = self.annotation;
            if(subType == "fibExtention"){
                var currentFillColor = ann.options.extentionFillColor;
                var currentFillOpacity = ann.options.extentionFillOpacity;
                var currentType = ann.options.isSingleColorExtention;
            }
            if(subType == "fibRetracement"){
                var currentFillColor = ann.options.retrancementFillColor ;
                var currentFillOpacity = ann.options.retrancementFillOpacity;
                var currentType = ann.options.isSingleColorRetracement;
            }
            var lastAction = infChart.commandsManager.getLastAction(self.stockChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             * @param {float} newOpacity opacity
             */
            function undoRedo(rgb, newColor, newOpacity, isSingleColor, subType) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibColorChangeElm = settingPanel.find("[inf-ctrl=singleFillColorPicker][inf-ctrl-val=P_all][sub-type='" + subType + "']");
                    if (fibColorChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fibColorChangeElm.mainColorPanel("value", {
                            color: newColor,
                            opacity: newOpacity
                        });
                    } else {
                        proceed.call(self, rgb, newColor, newOpacity, isSingleColor, fibLevelColors, subType, false);
                    }
                } else {
                    proceed.call(self, rgb, newColor, newOpacity, isSingleColor, fibLevelColors, subType, false);
                }
                self.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'genericTool_onFibSingleFillColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(rgb, value, opacity, isSingleColor, subType);
                }
            } else {
                infChart.commandsManager.registerCommand(self.stockChartId, function () {
                    undoRedo(rgb, value, opacity, isSingleColor, subType);
                }, function () {
                    undoRedo(rgb, currentFillColor, currentFillOpacity, currentType, subType);
                }, undefined, false, 'genericTool_onFibSingleFillColorChange');
            }
        }
        proceed.call(this, rgb, value, opacity, isSingleColor, fibLevelColors, subType, isPropertyChange);
    });

    /**
    * Wrapping up the infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibSingleFontColorChange to catch the all fib level font color change
    */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onFibSingleFontColorChange', function (proceed, rgb, value, isSingleColor, fibLevelFontColors, subType, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var self = this;
            var ann = self.annotation;
            var currentFontColor = ann.options.fontColor;
            if(subType == "fibExtention"){
                var currentFontColor = ann.options.extentionFontColor;
                var currentType = ann.options.isSingleColorExtention;
            }
            if(subType == "fibRetracement"){
                var currentFontColor = ann.options.retrancementFontColor;
                var currentType = ann.options.isSingleColorRetracement;
            }
            var lastAction = infChart.commandsManager.getLastAction(self.stockChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newColor new color to set
             */
            function undoRedo(rgb, newColor, isSingleColor, subType) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibFontColorChangeElm = settingPanel.find("[inf-ctrl=singleFontColorPicker][inf-ctrl-val=P_all][sub-type='" + subType + "']");
                    if (fibFontColorChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fibFontColorChangeElm.mainColorPanel("value", {
                            color: newColor
                        });
                    } else {
                        proceed.call(self, rgb, newColor, isSingleColor, fibLevelFontColors, subType, false);
                    }
                } else {
                    proceed.call(self, rgb, newColor, isSingleColor, fibLevelFontColors, subType, false);
                }
                self.onPropertyChange();
            }
            if (lastAction && lastAction.actionType === 'genericTool_onFibSingleFontColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(rgb, value, isSingleColor);
                }
            } else {
                infChart.commandsManager.registerCommand(self.stockChartId, function () {
                    undoRedo(rgb, value, isSingleColor, subType);
                }, function () {
                    undoRedo(rgb, currentFontColor, currentType, subType);
                }, undefined, false, 'genericTool_onFibSingleFontColorChange');
            }
        }
        proceed.call(this, rgb, value, isSingleColor, fibLevelFontColors, subType, isPropertyChange);
    });

    /**
    * Wrapping up the infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibSingleLineWidthChange to catch the all fib level line width change
    */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onFibSingleLineWidthChange', function (proceed, strokeWidth, isSingleColor, fibLevelWidths, subType, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            var ann = self.annotation;
            if(subType == "fibExtention"){
                var currentLineWidth = ann.options.extentionLineWidth;
                var currentType = ann.options.isSingleColorExtention;
            }
            if(subType == "fibRetracement"){
                var currentLineWidth = ann.options.retrancementLineWidth;
                var currentType = ann.options.isSingleColorRetracement;
            }

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new width to set
             */
            function undoRedo(newSize, isSingleColor, subType) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibLineWidthChangeDropdownElm = $(settingPanel.find("span[inf-ctrl=singleSelectedLineWidth][inf-ctrl-val=P_all][sub-type='" + subType + "']"));
                    if (fibLineWidthChangeDropdownElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        var dropDownItem = fibLineWidthChangeDropdownElm.parent().parent();
                        $(dropDownItem).find("li[inf-ctrl=lineWidth][inf-size='" + newSize + "']").trigger("click");
                    } else {
                        proceed.call(self, newSize, isSingleColor, fibLevelWidths, subType, false);
                    }
                } else {
                    proceed.call(self, newSize, isSingleColor, fibLevelWidths, subType, false);
                }
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(strokeWidth, isSingleColor, subType);
            }, function () {
                undoRedo(currentLineWidth, currentType, subType);
            }, undefined, false, 'genericTool_onFibSingleLineWidthChange');
        }
        proceed.call(this, strokeWidth, isSingleColor, fibLevelWidths, subType, isPropertyChange);
    });

    /**
    * Wrapping up the infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibSingleFontSizeChange to catch the all fib level font size change
    */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onFibSingleFontSizeChange', function (proceed, fontSize, isSingleColor, fibLevelFontSizes, subType, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            var ann = self.annotation;
            if(subType == "fibExtention"){
                var currentFontSize = ann.options.extentionFontSize;
                var currentType = ann.options.isSingleColorExtention;
            }
            if(subType == "fibRetracement"){
                var currentFontSize = ann.options.retrancementFontSize;
                var currentType = ann.options.isSingleColorRetracement;
            }

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new font size to set
             */
            function undoRedo(newSize, isSingleColor, subType) {
                var settingPanel = self.settingsPopup;

                if (settingPanel) {
                    var fibFontSizeChangeDropdownElm = $(settingPanel.find("span[inf-ctrl=singleSelectedFontSize][inf-ctrl-val=P_all][sub-type='" + subType + "']"));
                    if (fibFontSizeChangeDropdownElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        var dropDownItem = fibFontSizeChangeDropdownElm.parent().parent();
                        $(dropDownItem).find("li[inf-ctrl=fontSize][inf-size='" + newSize + "']").trigger("click");
                    } else {
                        proceed.call(self, newSize, isSingleColor, fibLevelFontSizes, subType, false);
                    }
                } else {
                    proceed.call(self, newSize, isSingleColor, fibLevelFontSizes, subType, false);
                }
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(fontSize, isSingleColor, subType);
            }, function () {
                undoRedo(currentFontSize, currentType, subType);
            }, undefined, false, 'genericTool_onFibSingleFontSizeChange');
        }
        proceed.call(this, fontSize, isSingleColor, fibLevelFontSizes, subType, isPropertyChange);
    });

        /**
    * Wrapping up the infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibSingleFontWeightChange to catch the all fib level font weight change
    */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onFibSingleFontWeightChange', function (proceed, value, isSingleColor, fibLevelOptions, subType, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            var ann = self.annotation;
            if(subType == "fibExtention"){
                var currentFontWeight = ann.options.extentionFontWeight;
                var currentType = ann.options.isSingleColorExtention;
            }
            if(subType == "fibRetracement"){
                var currentFontWeight = ann.options.retrancementFontWeight;
                var currentType = ann.options.isSingleColorRetracement;
            }

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new weight to set
             */
            function undoRedo(newWeight, isSingleColor, subType) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var fibFontWeightChangeElm = settingPanel.find("button[inf-ctrl=singleToggleFontWeight][inf-ctrl-val=P_all][sub-type='" + subType + "']");
                    if (fibFontWeightChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        $(fibFontWeightChangeElm).trigger("click");
                    } else {
                        proceed.call(self, newWeight, isSingleColor, fibLevelOptions, subType, false);
                    }
                } else {
                    proceed.call(self, newWeight, isSingleColor, fibLevelOptions, subType, false);
                }
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(value, isSingleColor, subType);
            }, function () {
                undoRedo(currentFontWeight, currentType, subType);
            }, undefined, false, 'genericTool_onFibSingleFontWeightChange');
        }
        proceed.call(this, value, isSingleColor, fibLevelOptions, subType, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibSingleOptionChange to catch the color settings change
     */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onFibSingleOptionChange', function (proceed, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, isSingleColor, prevOptions, subType, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var self = this;
            var drawingId = self.drawingId;
            var ann = self.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            //var currentType = self.annotation.options.isSingleColor;
            var lastAction = infChart.commandsManager.getLastAction(self.stockChartId);

            if(subType == "fibExtention"){
                var currentType = ann.options.isSingleColorExtention;
                var currentFontWeight = ann.options.extentionFontWeight;
                var currentFontSize = ann.options.extentionFontSize;
                var currentFontColor = ann.options.extentionFontColor; 
                var currentFillColor = ann.options.extentionFillColor;
                var currentFillOpacity = ann.options.extentionFillOpacity;
                var currentLineColor = ann.options.extentionLineColor;
                var currentLineWidth = ann.options.extentionLineWidth;
                var fibLevels = self.annotation.options.fibExtentionLevels;
            }
            if(subType == "fibRetracement"){
                var currentType = ann.options.isSingleColorRetracement;
                var currentFontWeight = ann.options.retrancementFontWeight;
                var currentFontSize = ann.options.retrancementFontSize;
                var currentFontColor = ann.options.retrancementFontColor; 
                var currentFillColor = ann.options.retrancementFillColor;
                var currentFillOpacity = ann.options.retrancementFillOpacity;
                var currentLineColor = ann.options.retrancementLineColor;
                var currentLineWidth = ann.options.retrancementLineWidth;
                var fibLevels = self.annotation.options.fibRetrancementLevels;
            }

            var currentFibLevelOptions = {};
            fibLevels.forEach(function (fibLevel) {
                if (typeof fibLevel === 'object' && fibLevel.hasOwnProperty('id')) {
                    var fibId = fibLevel.id;
                    currentFibLevelOptions[fibId] = {
                        fillColor: fibLevel.fillColor,
                        fillOpacity: fibLevel.fillOpacity,
                        lineColor: fibLevel.lineColor,
                        lineWidth: fibLevel.lineWidth,
                        fontColor: fibLevel.fontColor,
                        fontSize: fibLevel.fontSize,
                        fontWeight: fibLevel.fontWeight
                    };
                }
            });

            /**
             * Execute the undo/redo with the new properties
             * @param isSingleOptionEnabled
             * @param newFillColor
             * @param newFillOpacity
             * @param newLineColor
             * @param newLineWidth
             * @param newFontColor
             * @param newFontSize
             * @param newFontWeight
             * @param newFibLevelOptions
             */
            function undoRedo(isSingleOptionEnabled, newFillColor, newFillOpacity, newLineColor, newLineWidth, newFontColor, newFontSize, newFontWeight, newFibLevelOptions, subType) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if(settingPanel){
                    settingPanel.data("infUndoRedo", true);
                }
                if (isSingleOptionEnabled) {
                    proceed.call(drawingObj, newFillColor, newFillOpacity, newLineColor, newLineWidth, newFontColor, newFontSize, newFontWeight, isSingleOptionEnabled, newFibLevelOptions, subType, false);
                } else {
                    proceed.call(drawingObj, newFillColor, newFillOpacity, newLineColor, newLineWidth, newFontColor, newFontSize, newFontWeight, true, newFibLevelOptions, subType, false);
                    proceed.call(drawingObj, newFillColor, newFillOpacity, newLineColor, newLineWidth, newFontColor, newFontSize, newFontWeight, isSingleOptionEnabled, newFibLevelOptions, subType, false);
                }
                if (settingPanel) {
                    drawingObj.updateSettings(drawingObj.getConfig());
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'genericTool_onFibSingleOptionChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(isSingleColor, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, subType);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(isSingleColor, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, subType);
                }, function () {
                    undoRedo(currentType, currentFillColor, currentFillOpacity, currentLineColor, currentLineWidth, currentFontColor, currentFontSize, currentFontWeight, currentFibLevelOptions, subType);
                }, undefined, false, 'genericTool_onFibSingleOptionChange');
            }
        }
        proceed.call(this, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, isSingleColor, prevOptions, subType, isPropertyChange);
    });

        /**
     * Wrapping up the infChart.fib3PointPriceProjectionGenericDrawing.prototype.onFibApplyAllButtonClick to catch apply now to all level button click
     */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onFibApplyAllButtonClick', function(proceed, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, subType, isPropertyChange) {
        var self = this;
        var ann = self.annotation;
        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange) {
            if(subType == "fibExtention"){
                var fibLevels = self.annotation.options.fibExtentionLevels;
            }
            if(subType == "fibRetracement"){
                var fibLevels = self.annotation.options.fibRetrancementLevels;
            }
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentOptions = prevOptions;

            function undoRedo(isSingleColor, newOptions, subType) {
                fibLevels.forEach(function (fibLevel) {
                    fibLevel.fillColor = isSingleColor ? fillColor : newOptions[fibLevel.id].fillColor;
                    fibLevel.fillOpacity = isSingleColor ? fillOpacity : newOptions[fibLevel.id].fillOpacity;
                    fibLevel.lineColor = isSingleColor ? lineColor : newOptions[fibLevel.id].lineColor;
                    fibLevel.lineWidth = isSingleColor ? lineWidth : newOptions[fibLevel.id].lineWidth;
                    fibLevel.fontColor = isSingleColor ? fontColor : newOptions[fibLevel.id].fontColor;
                    fibLevel.fontSize = isSingleColor ? fontSize : newOptions[fibLevel.id].fontSize;
                    fibLevel.fontWeight = isSingleColor ? fontWeight : newOptions[fibLevel.id].fontWeight;
                });
                self.updateSettings(self.getConfig());
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(true, undefined, subType);
            }, function () {
                undoRedo(false, currentOptions, subType);
            }, undefined, false, 'genericTool_onFibApplyAllButtonClick');
        }
        proceed.call(this, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, subType, isPropertyChange);
    });
    
    /**
    * Wrapping up the infChart.fib3PointPriceProjectionGenericDrawing.prototype.onAlignStyleChange to catch the all fib level font size change
    */
    infChart.util.wrap(infChart.fib3PointPriceProjectionGenericDrawing.prototype, 'onAlignStyleChange', function (proceed, linePosition, subType, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            var ann = self.annotation;
            if(subType == "fibExtention"){
                var currentLabelPosition = ann.options.extentionLabelPosition;
            }
            if(subType == "fibRetracement"){
                var currentLabelPosition = ann.options.retracementLabelPosition;
            }

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new font size to set
             */
            function undoRedo(linePosition, subType) {
                var settingPanel = self.settingsPopup;

                if (settingPanel) {
                    if(subType == "fibExtention"){
                        var selectAlignStyleElm = $(settingPanel.find("ul[inf-ctrl=fibExtentionAlign]"));
                    }
                    if(subType == "fibRetracement"){
                        var selectAlignStyleElm = $(settingPanel.find("ul[inf-ctrl=fibRetracementAlign]"));
                    }
                    if (selectAlignStyleElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        var highlightedItem = selectAlignStyleElm.find("li[inf-ctrl=alignStyle][inf-style=" + linePosition + "]");
                        $(highlightedItem).trigger("click");
                    } else {
                        proceed.call(self, linePosition, subType, false);
                    }
                } else {
                    proceed.call(self, linePosition, subType, false);
                }
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(linePosition, subType);
            }, function () {
                undoRedo(currentLabelPosition, subType);
            }, undefined, false, 'genericTool_onAlignStyleChange');
        }
        proceed.call(this, linePosition, subType, isPropertyChange);
    });

    infChart.util.wrap(infChart.fib3PointPriceProjectionDrawing.prototype, 'onChangeSnapToHighLow', function (proceed, checked, isPropertyChange, ignoreSettingsSave) {
        if (isPropertyChange) {
            var self = this;
            var ann = self.annotation;
            var options = ann.options;
            var currentMode = !checked;

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean} checked - mode chaned
             */
            function undoRedo(checked) {
                proceed.call(self, checked, false);
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(checked);
            }, function () {
                undoRedo(currentMode);
            }, undefined, false, 'onChangeSnapToHighLow');
        }
        proceed.call(this, checked, isPropertyChange, ignoreSettingsSave);
    });

    infChart.util.wrap(infChart.elliotWaveDrawing.prototype, 'onChangeSnapToHighLow', function (proceed, checked, isPropertyChange, ignoreSettingsSave) {
        if (isPropertyChange) {
            var self = this;
            var ann = self.annotation;
            var options = ann.options;
            var currentMode = !checked;

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean} checked - mode chaned
             */
            function undoRedo(checked) {
                proceed.call(self, checked, false);
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(checked);
            }, function () {
                undoRedo(currentMode);
            }, undefined, false, 'onChangeSnapToHighLow');
        }
        proceed.call(this, checked, isPropertyChange, ignoreSettingsSave);
    });
    /**
     * Wrapping up apply one style in fibonacci vertical retracements
     */
    infChart.util.wrap(infChart.fibVerRetracementsDrawing.prototype, 'applyAllToFibLines', function (proceed, enabled, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            var drawingId = self.drawingId;
            var xChartId = self.stockChartId;
            var currentVisibility = !enabled;

            var currentFillColor = self.annotation.options.fillColor;
            var currentFillOpacity = self.annotation.options.fillOpacity;
            var currentLineColor = self.annotation.options.lineColor;
            var currentLineWidth = self.annotation.options.lineWidth;
            var currentFontColor = self.annotation.options.fontColor;
            var currentFontSize = self.annotation.options.fontSize;
            var currentFontWeight = self.annotation.options.fontWeight;

            var currentFibOption = {};
            var fibLevels = self.annotation.options.fibLevels;
            fibLevels.forEach(function (fibLevel) {
                if (typeof fibLevel === 'object' && fibLevel.hasOwnProperty('id')) {
                    var fibId = fibLevel.id;
                    currentFibOption[fibId] = {
                        fillColor: fibLevel.fillColor,
                        fillOpacity: fibLevel.fillOpacity,
                        lineColor: fibLevel.lineColor,
                        lineWidth: fibLevel.lineWidth,
                        fontColor: fibLevel.fontColor,
                        fontSize: fibLevel.fontSize,
                        fontWeight: fibLevel.fontWeight
                    };
                }
            });

            /**
             * Execute the undo/redo with the new properties
             * @param newType
             * @param newFillColor
             * @param newFillOpacity
             * @param newLineColor
             * @param newLineWidth
             * @param newFontColor
             * @param newFontSize
             * @param newFontWeight
             * @param newFibLevelOptions
             */
            function undoRedo(isSingleOptionEnabled, newFillColor, newFillOpacity, newLineColor, newLineWidth, newFontColor, newFontSize, newFontWeight, newFibLevelOptions) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                if (isSingleOptionEnabled) {
                    proceed.call(drawingObj, isSingleOptionEnabled, newFillColor, newFillOpacity, newLineColor, newLineWidth, newFontColor, newFontSize, newFontWeight, newFibLevelOptions, false);
                } else {
                    proceed.call(drawingObj, true, newFillColor, newFillOpacity, newLineColor, newLineWidth, newFontColor, newFontSize, newFontWeight, newFibLevelOptions, false);
                    proceed.call(drawingObj, isSingleOptionEnabled, newFillColor, newFillOpacity, newLineColor, newLineWidth, newFontColor, newFontSize, newFontWeight, newFibLevelOptions, false);
                }
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    settingPanel.data("infUndoRedo", true);
                    drawingObj.updateSettings(drawingObj.getConfig());
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(enabled, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions);
            }, function () {
                undoRedo(currentVisibility, currentFillColor, currentFillOpacity, currentLineColor, currentLineWidth, currentFontColor, currentFontSize, currentFontWeight, currentFibOption);
            }, undefined, false, 'applyAllToFibLines');
        }
        proceed.call(this, enabled, fillColor, fillOpacity, lineColor, lineWidth, fontColor, fontSize, fontWeight, prevOptions, isPropertyChange);
    });

    /**
     * Wrapping up all fib level changes in fibonacci vertical retracements
     */
    infChart.util.wrap(infChart.fibVerRetracementsDrawing.prototype, 'changeAllFibLines', function (proceed, property, propertyValue, isPropertyChange) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = this.stockChartId;
            var lastAction = infChart.commandsManager.getLastAction(xChartId);
            var currentValue = this.getCurrentPropertyValue(undefined, property, true);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} property update property name
             * @param {*} propertyValue value of updated property
             */
            function undoRedo(property, propertyValue) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                proceed.call(drawingObj, property, propertyValue, false);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    drawingObj.updateSettings(drawingObj.getConfig());
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'changeAllFibLines' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(property, currentValue);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(property, propertyValue);
                }, function () {
                    undoRedo(property, currentValue);
                }, undefined, false, 'changeAllFibLines');
            }
        }
        proceed.call(this, property, propertyValue, isPropertyChange);
    });

    /**
    * Wrapping up all fib level changes in fibonacci vertical retracements
    */
    infChart.util.wrap(infChart.fib2PointTimeProjection.prototype, 'changeAllFibLines', function (proceed, property, propertyValue, isPropertyChange) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = this.stockChartId;
            var lastAction = infChart.commandsManager.getLastAction(xChartId);
            var currentValue = this.getCurrentPropertyValue(undefined, property, true);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} property update property name
             * @param {*} propertyValue value of updated property
             */
            function undoRedo(property, propertyValue) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                proceed.call(drawingObj, property, propertyValue, false);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    drawingObj.updateSettings(drawingObj.getConfig());
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'changeAllFibLines' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(property, currentValue);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(property, propertyValue);
                }, function () {
                    undoRedo(property, currentValue);
                }, undefined, false, 'changeAllFibLines');
            }
        }
        proceed.call(this, property, propertyValue, isPropertyChange);
    });

    /**
     * Wrapping up fib level changes in fibonacci vertical retracements
     */
    infChart.util.wrap(infChart.fibVerRetracementsDrawing.prototype, 'changeFibLine', function (proceed, level, property, propertyValue, isAll, isPropertyChange) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = this.stockChartId;
            var lastAction = infChart.commandsManager.getLastAction(xChartId);
            var currentValue = this.getCurrentPropertyValue(level, property, false);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} level id of fib level
             * @param {string} property update property name
             * @param {*} propertyValue value of updated property
             */
            function undoRedo(level, property, propertyValue) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                proceed.call(drawingObj, level, property, propertyValue, isAll, false);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    drawingObj.updateSettings(drawingObj.getConfig());
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'changeFibLine' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(level, property, currentValue);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(level, property, propertyValue);
                }, function () {
                    undoRedo(level, property, currentValue);
                }, undefined, false, 'changeFibLine');
            }
        }
        proceed.call(this, level, property, propertyValue, isAll, isPropertyChange);
    });

    /**
     * Wrapping up fib level changes in fibonacci 3 point time projection tool
     */
    infChart.util.wrap(infChart.fib3PointTimeProjection.prototype, 'changeFibLine', function (proceed, level, property, propertyValue, isAll, isPropertyChange) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = this.stockChartId;
            var lastAction = infChart.commandsManager.getLastAction(xChartId);
            var currentValue = this.getCurrentPropertyValue(level, property, false);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} level id of fib level
             * @param {string} property update property name
             * @param {*} propertyValue value of updated property
             */
            function undoRedo(level, property, propertyValue) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                proceed.call(drawingObj, level, property, propertyValue, isAll, false);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    drawingObj.updateSettings(drawingObj.getConfig());
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'changeFibLine' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(level, property, currentValue);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(level, property, propertyValue);
                }, function () {
                    undoRedo(level, property, currentValue);
                }, undefined, false, 'changeFibLine');
            }
        }
        proceed.call(this, level, property, propertyValue, isAll, isPropertyChange);
    });

    /**
     * Wrapping up fib level changes in fibonacci 2 point time projection tool
     */
    infChart.util.wrap(infChart.fib2PointTimeProjection.prototype, 'changeFibLine', function (proceed, level, property, propertyValue, isAll, isPropertyChange) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = this.stockChartId;
            var lastAction = infChart.commandsManager.getLastAction(xChartId);
            var currentValue = this.getCurrentPropertyValue(level, property, false);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} level id of fib level
             * @param {string} property update property name
             * @param {*} propertyValue value of updated property
             */
            function undoRedo(level, property, propertyValue) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                proceed.call(drawingObj, level, property, propertyValue, isAll, false);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    drawingObj.updateSettings(drawingObj.getConfig());
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'changeFibLine' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(level, property, currentValue);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(level, property, propertyValue);
                }, function () {
                    undoRedo(level, property, currentValue);
                }, undefined, false, 'changeFibLine');
            }
        }
        proceed.call(this, level, property, propertyValue, isAll, isPropertyChange);
    });

    /**
     * Wrapping up mode change in fibonacci vertical retracements
     */
    infChart.util.wrap(infChart.fibVerRetracementsDrawing.prototype, 'changeMode', function (proceed, enabled, isPropertyChange) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = this.stockChartId;
            var currentVisibility = !enabled;

            function undoRedo(newVisibility) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                proceed.call(drawingObj, newVisibility, false);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    drawingObj.updateSettings(drawingObj.getConfig());
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(enabled);
            }, function () {
                undoRedo(currentVisibility);
            }, undefined, false, 'changeMode');
        }
        proceed.call(this, enabled, isPropertyChange);
    });

    infChart.util.wrap(infChart.fibVerRetracementsDrawing.prototype, 'changeAllFibLabels', function (proceed, property, propertyValue, isPropertyChange) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = this.stockChartId;
            var lastAction = infChart.commandsManager.getLastAction(xChartId);
            var currentValue = this.getCurrentPropertyValue(undefined, property, true);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} property update property name
             * @param {*} propertyValue value of updated property
             */
             function undoRedo(property, propertyValue) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                proceed.call(drawingObj, property, propertyValue, false);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    drawingObj.updateSettings(drawingObj.getConfig());
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'changeAllFibLabels' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(property, currentValue);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(property, propertyValue);
                }, function () {
                    undoRedo(property, currentValue);
                }, undefined, false, 'changeAllFibLabels');
            }
        }
        proceed.call(this, property, propertyValue, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.fibVerRetracementsDrawing.prototype.eraseFibLevel to catch the fib level erase
     */
    infChart.util.wrap(infChart.fibVerRetracementsDrawing.prototype, 'eraseFibLevel', function (proceed, level, checked, isPropertyChange, ignoreSettingsSave) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = this.stockChartId;
            var lastAction = infChart.commandsManager.getLastAction(xChartId);
            var lastLevel = level;
            var lastchecked = !checked;

            /**
             * Execute the undo/redo with the new properties
             * @param {string} level id of fib level
             * @param {boolean} the checkbox value
             * @param {*} ignoreSettingsSave - ignore setting save
             */
            function undoRedo(level, checked, ignoreSettingsSave) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                proceed.call(drawingObj, level, checked, false, ignoreSettingsSave);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    drawingObj.updateSettings(drawingObj.getConfig());
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'eraseFibLevel_fibVerRetrancement' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(level, checked, ignoreSettingsSave);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(level, checked, ignoreSettingsSave);
                }, function () {
                    undoRedo(lastLevel, lastchecked, ignoreSettingsSave);
                }, undefined, false, 'eraseFibLevel_fibVerRetrancement');
            }
        }
        proceed.call(this, level, checked, isPropertyChange, ignoreSettingsSave);
    });

    /**
     * Wrapping up the infChart.fib2PointTimeProjection.prototype.eraseFibLevel to catch the fib level erase
     */
    infChart.util.wrap(infChart.fib2PointTimeProjection.prototype, 'eraseFibLevel', function (proceed, level, checked, isPropertyChange, ignoreSettingsSave) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = this.stockChartId;
            var lastAction = infChart.commandsManager.getLastAction(xChartId);
            var lastLevel = level;
            var lastchecked = !checked;

            /**
             * Execute the undo/redo with the new properties
             * @param {string} level id of fib level
             * @param {boolean} the checkbox value
             * @param {*} ignoreSettingsSave - ignore setting save
             */
            function undoRedo(level, checked, ignoreSettingsSave) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                proceed.call(drawingObj, level, checked, false, ignoreSettingsSave);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    drawingObj.updateSettings(drawingObj.getConfig());
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'eraseFibLevel_fib2PointTimeProjection' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(level, checked, ignoreSettingsSave);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(level, checked, ignoreSettingsSave);
                }, function () {
                    undoRedo(lastLevel, lastchecked, ignoreSettingsSave);
                }, undefined, false, 'eraseFibLevel_fib2PointTimeProjection');
            }
        }
        proceed.call(this, level, checked, isPropertyChange, ignoreSettingsSave);
    });

    /**
     * Wrapping up the infChart.fib3PointTimeProjection.prototype.eraseFibLevel to catch the fib level erase
     */
    infChart.util.wrap(infChart.fib3PointTimeProjection.prototype, 'eraseFibLevel', function (proceed, level, checked, isPropertyChange, ignoreSettingsSave) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = this.stockChartId;
            var lastAction = infChart.commandsManager.getLastAction(xChartId);
            var lastLevel = level;
            var lastchecked = !checked;

            /**
             * Execute the undo/redo with the new properties
             * @param {string} level id of fib level
             * @param {boolean} the checkbox value
             * @param {*} ignoreSettingsSave - ignore setting save
             */
            function undoRedo(level, checked, ignoreSettingsSave) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                proceed.call(drawingObj, level, checked, false, ignoreSettingsSave);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    drawingObj.updateSettings(drawingObj.getConfig());
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'eraseFibLevel_fib3PointTimeProjection' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(level, checked, ignoreSettingsSave);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(level, checked, ignoreSettingsSave);
                }, function () {
                    undoRedo(lastLevel, lastchecked, ignoreSettingsSave);
                }, undefined, false, 'eraseFibLevel_fib3PointTimeProjection');
            }
        }
        proceed.call(this, level, checked, isPropertyChange, ignoreSettingsSave);
    });

    infChart.util.wrap(infChart.fibVerRetracementsDrawing.prototype, 'changeFibLabel', function (proceed, level, property, propertyValue, isAll, isPropertyChange) {
        if (isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = this.stockChartId;
            var lastAction = infChart.commandsManager.getLastAction(xChartId);
            var currentValue = this.getCurrentPropertyValue(level, property, false);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} level id of fib level
             * @param {string} property update property name
             * @param {*} propertyValue value of updated property
             */
            function undoRedo(level, property, propertyValue) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                proceed.call(drawingObj, level, property, propertyValue, isAll, false);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    drawingObj.updateSettings(drawingObj.getConfig());
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'changeFibLabel' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(level, property, currentValue);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(level, property, propertyValue);
                }, function () {
                    undoRedo(level, property, currentValue);
                }, undefined, false, 'changeFibLabel');
            }
        }
        proceed.call(this, level, property, propertyValue, isAll, isPropertyChange);
    });

    //endregion---------------end of Fibonacci settings-----------------------------------------------------------------

    //region label settings
    /**
     * Wrapping up the infChart.drawingUtils.common.settings.onColorChange to catch the line width changes
     */
    infChart.util.wrap(infChart.labelDrawing.prototype, 'onColorChange', function (proceed, rgb, color, isPropertyChange) {

        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.title.style["color"];
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor new color to set
             */
            function undoRedo(newColor) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var colorSelectorElm = settingPanel.find("[inf-ctrl=colorPicker]");
                    if (colorSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        colorSelectorElm.mainColorPanel("value", {color: newColor})
                    } else {
                        proceed.call(drawingObj, rgb, newColor, false);
                    }
                } else {
                    proceed.call(drawingObj, rgb, newColor, false);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onColorChange_label' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color);
                }, function () {
                    undoRedo(currentColor);
                }, undefined, false, 'onColorChange_label');
            }
        }

        proceed.call(this, rgb, color, isPropertyChange);
    });

    infChart.util.wrap(infChart.labelDrawing.prototype, 'onBorderColorChange', function (proceed, rgb, color, opacity, checked, isPropertyChange) {

        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.title.borderAttributes["stroke"];
            var lastChecked = checked;
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor new color to set
             */
            function undoRedo(newColor, checked) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var borderColorSelectorElm = settingPanel.find("[inf-ctrl=borderColorPicker]");
                    if (borderColorSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        borderColorSelectorElm.mainColorPanel("value", {color: newColor})
                    } else {
                        proceed.call(drawingObj, rgb, newColor, opacity, checked, false);
                    }
                } else {
                    proceed.call(drawingObj, rgb, newColor, opacity, checked, false);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onBorderColorChange_label' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color, checked);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color, checked);
                }, function () {
                    undoRedo(currentColor, lastChecked);
                }, undefined, false, 'onBorderColorChange_label');
            }
        }

        proceed.call(this, rgb, color, opacity, checked, isPropertyChange);
    });

    infChart.util.wrap(infChart.labelDrawing.prototype, 'onBackgroundColorChange', function (proceed, rgb, color, opacity, checked, isPropertyChange) {

        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.title.borderAttributes["fill"];
            var lastChecked = checked;
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor new color to set
             */
            function undoRedo(newColor, checked) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var backgroundColorSelectorElm = settingPanel.find("[inf-ctrl=backgroundColorPicker]");
                    if (backgroundColorSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        backgroundColorSelectorElm.mainColorPanel("value", {color: newColor})
                    } else {
                        proceed.call(drawingObj, rgb, newColor, opacity, checked, false);
                    }
                } else {
                    proceed.call(drawingObj, rgb, newColor, opacity, checked, false);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onBackgroundColorChange_label' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color, checked);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color, checked);
                }, function () {
                    undoRedo(currentColor, lastChecked);
                }, undefined, false, 'onBackgroundColorChange_label');
            }
        }

        proceed.call(this, rgb, color, opacity, checked, isPropertyChange);
    });

    infChart.util.wrap(infChart.labelDrawing.prototype, 'onApplyBorderColor', function (proceed, propertyValue, color, isPropertyChange) {

        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.title.borderAttributes["stroke"];
            var currentProperty = !propertyValue;
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor new color to set
             */
            function undoRedo(newPropertyValue ,newColor) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var borderColorEnabledElm = settingPanel.find("[inf-ctrl=borderColorEnabled]");
                    if (borderColorEnabledElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        borderColorEnabledElm.trigger("click");
                    } else {
                        proceed.call(drawingObj, newPropertyValue ,newColor, false);
                    }
                } else {
                    proceed.call(drawingObj, newPropertyValue ,newColor, false);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onApplyBorderColor_label' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(propertyValue, color);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(propertyValue, color);
                }, function () {
                    undoRedo(currentProperty, currentColor);
                }, undefined, false, 'onApplyBorderColor_label');
            }
        }

        proceed.call(this, propertyValue, color, isPropertyChange);
    });

    infChart.util.wrap(infChart.labelDrawing.prototype, 'onApplyBackgroundColor', function (proceed, propertyValue, color, isPropertyChange) {

        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.title.borderAttributes["fill"];
            var currentProperty = !propertyValue;
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor new color to set
             */
            function undoRedo(newPropertyValue, newColor) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var backgroundColorEnableElm = settingPanel.find("[inf-ctrl=backgroundColorEnabled]");
                    if (backgroundColorEnableElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        backgroundColorEnableElm.trigger("click");
                    } else {
                        proceed.call(drawingObj, newPropertyValue, newColor, false);
                    }
                } else {
                    proceed.call(drawingObj, newPropertyValue, newColor, false);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onApplyBackgroundColor_label' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(propertyValue, color);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(propertyValue, color);
                }, function () {
                    undoRedo(currentProperty, currentColor);
                }, undefined, false, 'onApplyBackgroundColor_label');
            }
        }

        proceed.call(this, propertyValue, color, isPropertyChange);
    });

    /**
     * Wrapping up the infChart.labelDrawing.prototype.onFibLineWidthChange to catch the line width changes
     */
     infChart.util.wrap(infChart.labelDrawing.prototype, 'onFontSizeChange', function (proceed, fontSize, isPropertyChange) {

        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentFontSize = this.fontSize;

            /**
             * Execute the undo/redo with the new properties
             * @param {string} control expression to find the related control
             * @param {number} newFontSize indicate new font size
             */
            function undoRedo(fontSize) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var fontSizeSelectorElm = settingPanel.find("[inf-ctrl=fontSize][inf-size='" + fontSize + "']");
                    if (fontSizeSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fontSizeSelectorElm.trigger("click")
                    } else {
                        proceed.call(drawingObj, fontSize, false);
                    }
                } else {
                    proceed.call(drawingObj, fontSize, false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(fontSize);
            }, function () {
                undoRedo(currentFontSize);
            }, undefined, false, 'onFontSizeChange_label');
        }

        proceed.call(this, fontSize, isPropertyChange);

    });

        /**
     * Wrapping up the infChart.drawingUtils.common.settings.onLabelTextColorChange to catch the line width changes
     */
        infChart.util.wrap(infChart.drawingUtils.common.settings, "onLabelTextColorChange", function (proceed, rgb, value, isPropertyChange) {
            if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
                var drawingId = this.drawingId;
                var ann = this.annotation;
                var xChartId = _getChartIdFromHighchartInstance(ann.chart);
                var currentTextColor = ann.options.textColor;
                var lastAction = infChart.commandsManager.getLastAction(xChartId);

                function undoRedo(rgb, newColor) {
                    var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                    var settingsPanel = drawingObj.settingsPopup;
                    if (settingsPanel) {
                        var textColorChangeElm = settingsPanel.find("[inf-ctrl=textColorPicker]");
                        if (textColorChangeElm.length > 0) {
                            settingsPanel.data("infUndoRedo", true);
                            settingsPanel.find("[inf-ctrl=textColorPicker]").mainColorPanel("value", {
                                color: newColor
                            });
                        } else {
                            proceed.call(drawingObj, rgb, newColor, false);
                        }
                    } else {
                        proceed.call(drawingObj, rgb, newColor, false);
                    }
                    drawingObj.onPropertyChange();
                }

                if (lastAction && lastAction.actionType === 'onLabelTextColorChange' && !lastAction.freezeUpdatingSame) {
                    lastAction.action = function () {
                        undoRedo(value);
                    }
                } else {
                    infChart.commandsManager.registerCommand(xChartId, function () {
                        undoRedo(rgb, value);
                    }, function () {
                        undoRedo(rgb, currentTextColor);
                    }, undefined, false, "onLabelTextColorChange");
                }
            }
            proceed.call(this, rgb, value, isPropertyChange);
        });

        /**
     * Wrapping up the infChart.drawingUtils.common.settings.onLabelTextSizeChange to catch the line width changes
     */
        infChart.util.wrap(infChart.drawingUtils.common.settings, 'onLabelTextSizeChange', function (proceed, fontSize, isPropertyChange) {

            if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
                var drawingId = this.drawingId;
                var ann = this.annotation;
                var xChartId = _getChartIdFromHighchartInstance(ann.chart);
                var currentFontSize = ann.options.textFontSize;

                /**
                 * Execute the undo/redo with the new properties
                 * @param {string} control expression to find the related control
                 * @param {number} newFontSize indicate new font size
                 */
                function undoRedo(fontSize) {
                    var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                    var settingPanel = drawingObj.settingsPopup;
                    if (settingPanel) {
                        var fontSizeSelectorElm = settingPanel.find("[inf-ctrl=fontSize][inf-size='" + fontSize + "']");
                        if (fontSizeSelectorElm.length > 0) {
                            settingPanel.data("infUndoRedo", true);
                            fontSizeSelectorElm.trigger("click")
                        } else {
                            proceed.call(drawingObj, fontSize, false);
                        }
                    } else {
                        proceed.call(drawingObj, fontSize, false);
                    }
                    drawingObj.onPropertyChange();
                }

                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(fontSize);
                }, function () {
                    undoRedo(currentFontSize);
                }, undefined, false, 'onLabelTextSizeChange');
            }

            proceed.call(this, fontSize, isPropertyChange);

        });

        /**
     * Wrapping up the infChart.drawingUtils.common.settings.onTextSizeChange to catch the line width changes
     */
        infChart.util.wrap(infChart.drawingUtils.common.settings, 'onTextSizeChange', function (proceed, fontSize, isPropertyChange) {

            if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
                var drawingId = this.drawingId;
                var ann = this.annotation;
                var xChartId = _getChartIdFromHighchartInstance(ann.chart);
                var currentFontSize = ann.options.textFontSize;

                /**
                 * Execute the undo/redo with the new properties
                 * @param {string} control expression to find the related control
                 * @param {number} newFontSize indicate new font size
                 */
                function undoRedo(fontSize) {
                    var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                    var settingPanel = drawingObj.settingsPopup;
                    if (settingPanel) {
                        var fontSizeSelectorElm = settingPanel.find("[inf-ctrl=fontSize][inf-size='" + fontSize + "']");
                        if (fontSizeSelectorElm.length > 0) {
                            settingPanel.data("infUndoRedo", true);
                            fontSizeSelectorElm.trigger("click")
                        } else {
                            proceed.call(drawingObj, fontSize, false);
                        }
                    } else {
                        proceed.call(drawingObj, fontSize, false);
                    }
                    drawingObj.onPropertyChange();
                }

                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(fontSize);
                }, function () {
                    undoRedo(currentFontSize);
                }, undefined, false, 'onTextSizeChange_basic');
            }

            proceed.call(this, fontSize, isPropertyChange);

        });

        /**
     * Wrapping up the infChart.drawingUtils.common.settings.onTextColorChange to catch the line width changes
     */
        infChart.util.wrap(infChart.drawingUtils.common.settings, "onTextColorChange", function (proceed, rgb, value, isPropertyChange) {
            if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
                var drawingId = this.drawingId;
                var ann = this.annotation;
                var xChartId = _getChartIdFromHighchartInstance(ann.chart);
                var currentTextColor = ann.options.textColor;
                var lastAction = infChart.commandsManager.getLastAction(xChartId);

                function undoRedo(rgb, newColor) {
                    var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                    var settingsPanel = drawingObj.settingsPopup;
                    if (settingsPanel) {
                        var textColorChangeElm = settingsPanel.find("[inf-ctrl=textColorPicker]");
                        if (textColorChangeElm.length > 0) {
                            settingsPanel.data("infUndoRedo", true);
                            settingsPanel.find("[inf-ctrl=textColorPicker]").mainColorPanel("value", {
                                color: newColor
                            });
                        } else {
                            proceed.call(drawingObj, rgb, newColor, false);
                        }
                    } else {
                        proceed.call(drawingObj, rgb, newColor, false);
                    }
                    drawingObj.onPropertyChange();
                }

                if (lastAction && lastAction.actionType === 'onTextColorChange_basic' && !lastAction.freezeUpdatingSame) {
                    lastAction.action = function () {
                        undoRedo(rgb, value);
                    }
                } else {
                    infChart.commandsManager.registerCommand(xChartId, function () {
                        undoRedo(rgb, value);
                    }, function () {
                        undoRedo(rgb, currentTextColor);
                    }, undefined, false, "onTextColorChange_basic");
                }
            }
            proceed.call(this, rgb, value, isPropertyChange);
        });

    /**
     * Wrapping up the infChart.labelDrawing.prototype.onFontStyleChange to catch the line width changes
     */
    infChart.util.wrap(infChart.labelDrawing.prototype, 'onFontStyleChange', function (proceed, style, isSelected, isPropertyChange) {
        proceed.call(this, style, isSelected, isPropertyChange);
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);

            /**
             * Execute the undo/redo with the new properties
             * @param {boolean} newIsSelected if font type is selected or not
             */
            function undoRedo(newIsSelected) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var fontStyleSelectorElm = settingPanel.find("[inf-ctrl=fontStyle][inf-style='" + style + "']");
                    if (fontStyleSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fontStyleSelectorElm.trigger("click");
                    } else {
                        proceed.call(drawingObj, style, newIsSelected, false);
                    }
                } else {
                    proceed.call(drawingObj, style, newIsSelected, false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(isSelected);
            }, function () {
                undoRedo(!isSelected);
            }, undefined, false, 'onFontStyleChange_label');

        }

    });

    /**
     * Wrapping up the infChart.labelDrawing.prototype.onFontStyleChange to catch the line width changes
     */
    infChart.util.wrap(infChart.labelDrawing.prototype, 'onSettingsTextChange', function (proceed, text, isPropertyChange) {
        var drawingId = this.drawingId;
        var ann = this.annotation;
        var xChartId = _getChartIdFromHighchartInstance(ann.chart);
        var currentText = ann.options.textValue;
        isPropertyChange = text !== "" && currentText !== text;
        
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            /**
             * Execute the undo/redo with the new properties
             * @param {string} newText new text being set
             */
            function undoRedo(newText) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;

                proceed.call(drawingObj, newText, false);
                if (settingPanel) {
                    infChart.structureManager.drawingTools.updateLabelSettings(settingPanel, undefined, newText, undefined, undefined, undefined, undefined, undefined, true);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(text);
            }, function () {
                undoRedo(currentText);
            }, undefined, false, 'onTextChange_label');

        }
        return proceed.call(this, text, isPropertyChange);

    });
    //endregion

    //region high low labels settings
    /**
     * Wrapping up the infChart.drawingUtils.common.settings.onColorChange to catch the line width changes
     */
    infChart.util.wrap(infChart.highLowLabels.prototype, 'onColorChange', function (proceed, rgb, color, isPropertyChange) {

        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.title.style["color"];
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor new color to set
             */
            function undoRedo(newColor) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var colorSelectorElm = settingPanel.find("[inf-ctrl=colorPicker]");
                    if (colorSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        colorSelectorElm.mainColorPanel("value", {color: newColor})
                    } else {
                        proceed.call(drawingObj, rgb, newColor, false);
                    }
                } else {
                    proceed.call(drawingObj, rgb, newColor, false);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onColorChange_label' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color);
                }, function () {
                    undoRedo(currentColor);
                }, undefined, false, 'onColorChange_label');
            }
        }

        proceed.call(this, rgb, color, isPropertyChange);
    });

    infChart.util.wrap(infChart.highLowLabels.prototype, 'onLabelItemsChange', function (proceed, labelItemId, value, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            var ann = self.annotation;
            var options = ann.options;
            var labelDataItem = options.labelDataItems.find(function (labelDataItem) {
                return labelDataItem.id === labelItemId;
            });
            var currentValue = labelDataItem.enabled;

            /**
             * Execute the undo/redo with the new properties
             * @param {string} labelItemId label id
             * @param {string} value 
             */
            function undoRedo(labelItemId, value) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var labelEnabledElm = settingPanel.find("[inf-ctrl=labelDataItem][data-value=" + labelItemId + "]");
                    if (labelEnabledElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        labelEnabledElm.trigger("click");
                    } else {
                        proceed.call(self, labelItemId, value, false);
                    }
                } else {
                    proceed.call(self, labelItemId, value, false);
                }
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(labelItemId, value);
            }, function () {
                undoRedo(labelItemId, currentValue);
            }, undefined, false, 'onLabelItemsChange');
        }
        proceed.call(this, labelItemId, value, isPropertyChange);
    });

    //endregion

    //endregion end of Drawing settings


    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onXabcdLineWidthChange', function (proceed, strokeWidth, isPropertyChange) {
        var ann = this.annotation;
        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentWidth = ann.options.shape.params["stroke-width"];

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new width to set
             */
            function undoRedo(newSize) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var lineWidthChangeElm = settingPanel.find("[inf-ctrl=lineWidth][inf-size=" + newSize + "]");
                    if (lineWidthChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        lineWidthChangeElm.trigger('click');
                    } else {
                        proceed.call(drawingObj, newSize);
                    }
                } else {
                    proceed.call(drawingObj, newSize);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(strokeWidth);
            }, function () {
                undoRedo(currentWidth);
            }, undefined, false, 'onXabcdLineWidthChange');
        }
        proceed.call(this, strokeWidth, isPropertyChange);
    });

    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onXabcdFillColorChange', function (proceed, color, opacity, isPropertyChange, colorPickerRef) {
        var ann = this.annotation;
        if (_isTrackHistoryEnabledDrawing(ann) && isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.shape.params["fill"];
            var currentOpacity = ann.options.shape.params["fill-opacity"];
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             * @param {float} newOpacity opacity
             */
            function undoRedo(newColor, newOpacity) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var fillColorChangeElm = settingPanel.find(colorPickerRef || "[inf-ctrl=fillColorPicker]");
                    if (fillColorChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fillColorChangeElm.mainColorPanel("value", {
                            color: newColor,
                            opacity: newOpacity
                        });
                    } else {
                        proceed.call(drawingObj, newColor, newOpacity, false, colorPickerRef);
                    }
                } else {
                    proceed.call(drawingObj, newColor, newOpacity, false, colorPickerRef);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onXabcdFillColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color, opacity);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color, opacity);
                }, function () {
                    undoRedo(currentColor, currentOpacity);
                }, undefined, false, 'onXabcdFillColorChange');
            }
        }
        proceed.call(this, color, opacity, isPropertyChange);
    });

    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onXabcdLineColorChange', function (proceed, color, isPropertyChange, colorPickerRef) {
        var ann = this.annotation;
        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.shape.params["stroke"];
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             */
            function undoRedo(newColor) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var lineColorChangeElm = settingPanel.find(colorPickerRef || "[inf-ctrl=colorPicker]");
                    if (lineColorChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        lineColorChangeElm.mainColorPanel("value", {color: newColor});
                    } else {
                        proceed.call(drawingObj, newColor, false, colorPickerRef);
                    }
                } else {
                    proceed.call(drawingObj, newColor, false, colorPickerRef);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onXabcdLineColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color);
                }, function () {
                    undoRedo(currentColor);
                }, undefined, false, 'onXabcdLineColorChange');
            }
        }
        proceed.call(this, color, isPropertyChange);
    });

    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onAbcdLineWidthChange', function (proceed, strokeWidth, isPropertyChange) {
        var ann = this.annotation;
        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentWidth = ann.options.shape.params["stroke-width"];

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new width to set
             */
            function undoRedo(newSize) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var lineWidthChangeElm = settingPanel.find("[inf-ctrl=lineWidth][inf-size=" + newSize + "]");
                    if (lineWidthChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        lineWidthChangeElm.trigger('click');
                    } else {
                        proceed.call(drawingObj, newSize);
                    }
                } else {
                    proceed.call(drawingObj, newSize);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(strokeWidth);
            }, function () {
                undoRedo(currentWidth);
            }, undefined, false, 'onAbcdLineWidthChange');
        }
        proceed.call(this, strokeWidth, isPropertyChange);
    });

    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onAbcdLineColorChange', function (proceed, color, isPropertyChange, colorPickerRef) {
        var ann = this.annotation;
        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.shape.params["stroke"];
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             */
            function undoRedo(newColor) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var lineColorPickerElm = settingPanel.find(colorPickerRef || "[inf-ctrl=colorPicker]");
                    if (lineColorPickerElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        lineColorPickerElm.mainColorPanel("value", {color: newColor});
                    } else {
                        proceed.call(drawingObj, newColor, false, colorPickerRef);
                    }
                } else {
                    proceed.call(drawingObj, newColor, false, colorPickerRef);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onAbcdLineColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color);
                }, function () {
                    undoRedo(currentColor);
                }, undefined, false, 'onAbcdLineColorChange');
            }
        }
        proceed.call(this, color, isPropertyChange);
    });

    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onPolylineColorChange', function (proceed, color, isPropertyChange, colorPickerRef) {
        var ann = this.annotation;
        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.shape.params["stroke"];
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             */
            function undoRedo(newColor) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var lineColorPickerElm = settingPanel.find(colorPickerRef || "[inf-ctrl=colorPicker]");
                    if (lineColorPickerElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        lineColorPickerElm.mainColorPanel("value", {color: newColor});
                    } else {
                        proceed.call(drawingObj, newColor, false, colorPickerRef);
                    }
                } else {
                    proceed.call(drawingObj, newColor, false, colorPickerRef);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onPolylineColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color);
                }, function () {
                    undoRedo(currentColor);
                }, undefined, false, 'onPolylineColorChange');
            }
        }
        proceed.call(this, color, isPropertyChange);
    });

    /**
    * Wrapping up the infChart.drawingUtils.common.settings.onLineStyleChange to catch the settings change od dash style
    */
    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onPolylineStyleChange', function (proceed, dashStyle, isPropertyChange) {
        var ann = this.annotation;
        if (_isTrackHistoryEnabledDrawing(ann) && isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentDashStyle = ann.options.shape.params["dashstyle"];

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newDashStyle new style to set
             */
            function undoRedo(newDashStyle) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var lineStyleSelectorElm = settingPanel.find("[inf-ctrl=lineStyle][inf-style=" + newDashStyle + "]");
                    if (lineStyleSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        lineStyleSelectorElm.trigger('click');
                    } else {
                        proceed.call(drawingObj, newDashStyle);
                    }
                } else {
                    proceed.call(drawingObj, newDashStyle);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(dashStyle);
            }, function () {
                undoRedo(currentDashStyle);
            }, undefined, false, 'onLineStyleChange');
        }
        proceed.call(this, dashStyle, isPropertyChange);
    });

    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onPolylineWidthChange', function (proceed, strokeWidth, isPropertyChange) {
        var ann = this.annotation;
        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentWidth = ann.options.shape.params["stroke-width"];

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new width to set
             */
            function undoRedo(newSize) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var lineWidthChangeElm = settingPanel.find("[inf-ctrl=lineWidth][inf-size=" + newSize + "]");
                    if (lineWidthChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        lineWidthChangeElm.trigger('click');
                    } else {
                        proceed.call(drawingObj, newSize);
                    }
                } else {
                    proceed.call(drawingObj, newSize);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(strokeWidth);
            }, function () {
                undoRedo(currentWidth);
            }, undefined, false, 'onPolylineWidthChange');
        }
        proceed.call(this, strokeWidth, isPropertyChange);
    });

    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onPolylineFillColorChange', function (proceed, rgb, color, opacity, isPropertyChange, colorPickerRef) {
        var ann = this.annotation;
        if (_isTrackHistoryEnabledDrawing(ann) && isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.shape.params["fill"];
            var currentOpacity = ann.options.shape.params["fill-opacity"];
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             * @param {float} newOpacity opacity
             */
            function undoRedo(rgb, newColor, newOpacity) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var fillColorChangeElm = settingPanel.find(colorPickerRef || "[inf-ctrl=fillColorPicker]");
                    if (fillColorChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fillColorChangeElm.mainColorPanel("value", {
                            color: newColor,
                            opacity: newOpacity
                        });
                    } else {
                        proceed.call(drawingObj, rgb, newColor, newOpacity, false, colorPickerRef);
                    }
                } else {
                    proceed.call(drawingObj, rgb, newColor, newOpacity, false, colorPickerRef);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onPolylineFillColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(rgb, color, opacity);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(rgb, color, opacity);
                }, function () {
                    undoRedo(rgb, currentColor, currentOpacity);
                }, undefined, false, 'onPolylineFillColorChange');
            }
        }
        proceed.call(this, rgb, color, opacity, isPropertyChange);
    });

    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onElliotWaveLineWidthChange', function (proceed, strokeWidth, isPropertyChange) {
        var ann = this.annotation;
        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentWidth = ann.options.shape.params["stroke-width"];

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new width to set
             */
            function undoRedo(newSize) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var lineWidthChangeElm = settingPanel.find("[inf-ctrl=lineWidth][inf-size=" + newSize + "]");
                    if (lineWidthChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        lineWidthChangeElm.trigger('click');
                    } else {
                        proceed.call(drawingObj, newSize);
                    }
                } else {
                    proceed.call(drawingObj, newSize);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(strokeWidth);
            }, function () {
                undoRedo(currentWidth);
            }, undefined, false, 'onElliotWaveLineWidthChange');
        }
        proceed.call(this, strokeWidth, isPropertyChange);
    });

    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onElliotWaveLineColorChange', function (proceed, color, isPropertyChange, colorPickerRef) {
        var ann = this.annotation;
        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.shape.params["stroke"];
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             */
            function undoRedo(newColor) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var lineColorPickerElm = settingPanel.find(colorPickerRef || "[inf-ctrl=colorPicker]");
                    if (lineColorPickerElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        lineColorPickerElm.mainColorPanel("value", {color: newColor});
                    } else {
                        proceed.call(drawingObj, newColor, false, colorPickerRef);
                    }
                } else {
                    proceed.call(drawingObj, newColor, false, colorPickerRef);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onElliotWaveLineColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color);
                }, function () {
                    undoRedo(currentColor);
                }, undefined, false, 'onElliotWaveLineColorChange');
            }
        }
        proceed.call(this, color, isPropertyChange);
    });

    infChart.util.wrap(infChart.drawingUtils.common.settings, 'onElliotWaveDegreeChange', function (proceed, waveDegree, element, isPropertyChange) {
        var ann = this.annotation;
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var options = ann.options;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentWaveDegree = ann.options.currentWaveDegree;

            /**
             * Execute the undo/redo with the new properties
             * @param {string} control expression to find the related control
             * @param {number} newFontSize indicate new font size
             */
            function undoRedo(waveDegree) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var fontSizeSelectorElm = settingPanel.find("[inf-ctrl= waveDegree][inf-type='" + waveDegree + "']");
                    var lastActiveElement = settingPanel.find("[inf-ctrl= waveDegree][inf-type='" + options.currentWaveDegree + "']");
                    if (fontSizeSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fontSizeSelectorElm.trigger("click")
                    } else {
                        proceed.call(drawingObj, waveDegree, lastActiveElement, false);
                    }
                } else {
                    proceed.call(drawingObj, waveDegree, lastActiveElement, false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(waveDegree);
            }, function () {
                undoRedo(currentWaveDegree);
            }, undefined, false, 'onElliotWaveDegreeChange');
        }
        proceed.call(this, waveDegree, element, isPropertyChange);
    });

    infChart.util.wrap(infChart.lineDrawing.prototype, 'onLabelItemsChange', function (proceed, labelItemId, value, isPropertyChange) {
        var self = this;
        if (isPropertyChange) {
            var ann = self.annotation;
            var options = ann.options;
            var labelDataItem = options.labelDataItems.find(function (labelDataItem) {
                return labelDataItem.id === labelItemId;
            });
            var currentValue = labelDataItem.enabled;

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor new color to set
             */
            function undoRedo(labelItemId, value) {
                var settingPanel = self.settingsPopup;
                if (settingPanel) {
                    var labelEnabledElm = settingPanel.find("[inf-ctrl=labelDataItem][data-value=" + labelItemId + "]");
                    if (labelEnabledElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        labelEnabledElm.trigger("click");
                    } else {
                        proceed.call(self, labelItemId, value, false);
                    }
                } else {
                    proceed.call(self, labelItemId, value, false);
                }
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(labelItemId, value);
            }, function () {
                undoRedo(labelItemId, currentValue);
            }, undefined, false, 'onLabelItemsChange');
        }
        proceed.call(self, labelItemId, value, isPropertyChange);
    });

    //endregion=====================end of Drawing Wrappers=========================================================

    //region ---------- start of positions drawing wrappers ----------
    infChart.util.wrap(infChart.positionsDrawing.prototype, "onLabelDataChange", function (proceed, type, value, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentValue = ann.options.settings[type];

            function undoRedo(newType, newValue) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingsPanel = drawingObj.settingsPopup;
                if (settingsPanel) {
                    var labelElm = settingsPanel.find("input[inf-ctrl=" + newType + "]");
                    if (labelElm.length > 0) {
                        settingsPanel.data("infUndoRedo", true);
                        labelElm.val(newValue).trigger("blur");
                    } else {
                        proceed.call(drawingObj, newType, newValue, false);
                    }
                } else {
                    proceed.call(drawingObj, newType, newValue, false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(type, value);
            }, function () {
                undoRedo(type, currentValue);
            }, undefined, false, "onLabelDataChange");
        }
        proceed.call(this, type, value, isPropertyChange);
    });

    infChart.util.wrap(infChart.positionsDrawing.prototype, "onRiskChange", function (proceed, value, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentRiskType = ann.options.settings.risk['selectedItem'];
            var currentRiskValue = currentRiskType === "size" ? ann.options.settings.risk["size"] : ann.options.settings.risk["percentage"];

            function undoRedo(newValue) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingsPanel = drawingObj.settingsPopup;
                if (settingsPanel) {
                    var riskChangeElm = settingsPanel.find("input[inf-ctrl=risk]");
                    if (riskChangeElm.length > 0) {
                        settingsPanel.data("infUndoRedo", true);
                        riskChangeElm.val(newValue).trigger("blur");
                    } else {
                        proceed.call(drawingObj, newValue, false);
                    }
                } else {
                    proceed.call(drawingObj, newValue, false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(value);
            }, function () {
                undoRedo(currentRiskValue);
            }, undefined, false, "onRiskChange");
        }
        proceed.call(this, value, isPropertyChange);
    });

    infChart.util.wrap(infChart.positionsDrawing.prototype, "onEntryPriceChange", function (proceed, entryPrice, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentEntryPrice = ann.options.settings["entryPrice"];

            function undoRedo(newEntryPrice) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingsPanel = drawingObj.settingsPopup;
                if (settingsPanel) {
                    var entryPriceChangeElm = settingsPanel.find("input[inf-ctrl=entryPrice]");
                    if (entryPriceChangeElm.length > 0) {
                        settingsPanel.data("infUndoRedo", true);
                        settingsPanel.find("input[inf-ctrl=entryPrice]").val(newEntryPrice).trigger("blur");
                    } else {
                        proceed.call(drawingObj, newEntryPrice, false);
                    }
                } else {
                    proceed.call(drawingObj, newEntryPrice, false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(entryPrice);
            }, function () {
                undoRedo(currentEntryPrice);
            }, undefined, false, "onPriceTicksChange");
        }
        proceed.call(this, entryPrice, isPropertyChange);
    });

    infChart.util.wrap(infChart.positionsDrawing.prototype, "onPriceTicksChange", function (proceed, isTakeProfit, tickSize, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentTickSize = isTakeProfit ? ann.options.settings.takeProfit['tickSize'] : ann.options.settings.stopLoss['tickSize'];
            var currentCtrlName = isTakeProfit ? "takeProfitTicks" : "stopLossTicks";

            function undoRedo(ctrlName, newTickSize) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingsPanel = drawingObj.settingsPopup;
                if (settingsPanel) {
                    var priceTickElm = settingsPanel.find("input[inf-ctrl=" + ctrlName + "]");
                    if (priceTickElm.length > 0) {
                        settingsPanel.data("infUndoRedo", true);
                        priceTickElm.val(newTickSize).trigger("blur");
                    } else {
                        proceed.call(drawingObj, (ctrlName === "takeProfitTicks"), newTickSize, false);
                    }
                } else {
                    proceed.call(drawingObj, (ctrlName === "takeProfitTicks"), newTickSize, false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(isTakeProfit ? "takeProfitTicks" : "stopLossTicks", tickSize);
            }, function () {
                undoRedo(currentCtrlName, currentTickSize);
            }, undefined, false, "onPriceTicksChange");
        }
        proceed.call(this, isTakeProfit, tickSize, isPropertyChange);
    });

    infChart.util.wrap(infChart.positionsDrawing.prototype, "onPriceChange", function (proceed, isTakeProfit, price, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentPrice = isTakeProfit ? ann.options.settings.takeProfit['price'] : ann.options.settings.stopLoss['price'];
            var currentCtrlName = isTakeProfit ? "takeProfitPrice" : "stopLossPrice";

            function undoRedo(ctrlName, newPrice) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingsPanel = drawingObj.settingsPopup;
                if (settingsPanel) {
                    var priceChangeElm = settingsPanel.find("input[inf-ctrl=" + ctrlName + "]");
                    if (priceChangeElm.length > 0) {
                        settingsPanel.data("infUndoRedo", true);
                        settingsPanel.find("input[inf-ctrl=" + ctrlName + "]").val(newPrice).trigger("blur");
                    } else {
                        proceed.call(drawingObj, (ctrlName === "takeProfitPrice"), newPrice, false);
                    }
                } else {
                    proceed.call(drawingObj, (ctrlName === "takeProfitPrice"), newPrice, false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(isTakeProfit ? "takeProfitPrice" : "stopLossPrice", price);
            }, function () {
                undoRedo(currentCtrlName, currentPrice);
            }, undefined, false, "onPriceChange");
        }
        proceed.call(this, isTakeProfit, price, isPropertyChange);
    });

    infChart.util.wrap(infChart.positionsDrawing.prototype, "onLineColorChange", function (proceed, value, opacity, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentLineColor = ann.options.styles['lineColor'];
            var currentLineOpacity = ann.options.styles['lineOpacity'];
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            function undoRedo(newLineColor, newLineOpacity) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingsPanel = drawingObj.settingsPopup;
                if (settingsPanel) {
                    var lineColorChangeElm = settingsPanel.find("[inf-ctrl=lineColorPicker]");
                    if (lineColorChangeElm.length > 0) {
                        settingsPanel.data("infUndoRedo", true);
                        lineColorChangeElm.mainColorPanel("value", {color: newLineColor, opacity: newLineOpacity});
                    } else {
                        proceed.call(drawingObj, newLineColor, newLineOpacity, false);
                    }
                } else {
                    proceed.call(drawingObj, newLineColor, newLineOpacity, false);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onLineColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(value, opacity);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(value, opacity);
                }, function () {
                    undoRedo(currentLineColor, currentLineOpacity);
                }, undefined, false, "onLineColorChange");
            }

        }
        proceed.call(this, value, opacity, isPropertyChange);
    });

    infChart.util.wrap(infChart.positionsDrawing.prototype, "onLineWidthChange", function (proceed, strokeWidth, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentStrokeWidth = ann.options.styles['lineWidth'];

            function undoRedo(newStrokeWidth) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingsPanel = drawingObj.settingsPopup;
                if (settingsPanel) {
                    var lineWidthChangeElm = settingsPanel.find("[inf-ctrl=lineWidth][inf-size=" + newStrokeWidth + "]");
                    if (lineWidthChangeElm.length > 0) {
                        settingsPanel.data("infUndoRedo", true);
                        lineWidthChangeElm.trigger('click');
                    } else {
                        proceed.call(drawingObj, newStrokeWidth, false);
                    }
                } else {
                    proceed.call(drawingObj, newStrokeWidth, false);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(strokeWidth);
            }, function () {
                undoRedo(currentStrokeWidth);
            }, undefined, false, "onLineWidthChange");

        }
        proceed.call(this, strokeWidth, isPropertyChange);
    });

    infChart.util.wrap(infChart.positionsDrawing.prototype, "onStopLossColorChange", function (proceed, value, opacity, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentLineColor = ann.options.styles['stopLossColor'];
            var currentFillOpacity = ann.options.styles['stopLossFillOpacity'];
            var lastAction = infChart.commandsManager.getLastAction(xChartId);


            function undoRedo(newLineColor, newLineOpacity) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingsPanel = drawingObj.settingsPopup;
                if (settingsPanel) {
                    var slColorChangeElm = settingsPanel.find("[inf-ctrl=stopLossColorPicker]");
                    if (slColorChangeElm.length > 0) {
                        settingsPanel.data("infUndoRedo", true);
                        slColorChangeElm.mainColorPanel("value", {color: newLineColor, opacity: newLineOpacity});
                    } else {
                        proceed.call(drawingObj, newLineColor, newLineOpacity, false);
                    }
                } else {
                    proceed.call(drawingObj, newLineColor, newLineOpacity, false);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onStopLossColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(value, opacity);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(value, opacity);
                }, function () {
                    undoRedo(currentLineColor, currentFillOpacity);
                }, undefined, false, "onStopLossColorChange");
            }

        }
        proceed.call(this, value, opacity, isPropertyChange);
    });

    infChart.util.wrap(infChart.positionsDrawing.prototype, "onTakeProfitColorChange", function (proceed, value, opacity, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentLineColor = ann.options.styles['takeProfitColor'];
            var currentFillOpacity = ann.options.styles['takeProfitFillOpacity'];
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            function undoRedo(newLineColor, newLineOpacity) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingsPanel = drawingObj.settingsPopup;
                if (settingsPanel) {
                    var tpColorChangeElm = settingsPanel.find("[inf-ctrl=takeProfitColorPicker]");
                    if (tpColorChangeElm.length > 0) {
                        settingsPanel.data("infUndoRedo", true);
                        tpColorChangeElm.mainColorPanel("value", {color: newLineColor, opacity: newLineOpacity});
                    } else {
                        proceed.call(drawingObj, newLineColor, newLineOpacity, false);
                    }
                } else {
                    proceed.call(drawingObj, newLineColor, newLineOpacity, false);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onTakeProfitColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(value, opacity);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(value, opacity);
                }, function () {
                    undoRedo(currentLineColor, currentFillOpacity);
                }, undefined, false, "onTakeProfitColorChange");
            }

        }

        proceed.call(this, value, opacity, isPropertyChange);
    });

    infChart.util.wrap(infChart.positionsDrawing.prototype, "onTextColorChange", function (proceed, value, opacity, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var ann = this.annotation;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentTextColor = ann.options.styles['textColor'];
            var currentTextOpacity = ann.options.styles['textOpacity'];
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            function undoRedo(newColor, newOpacity) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingsPanel = drawingObj.settingsPopup;
                if (settingsPanel) {
                    var textColorChangeElm = settingsPanel.find("[inf-ctrl=textColorPicker]");
                    if (textColorChangeElm.length > 0) {
                        settingsPanel.data("infUndoRedo", true);
                        settingsPanel.find("[inf-ctrl=textColorPicker]").mainColorPanel("value", {
                            color: newColor,
                            opacity: newOpacity
                        });
                    } else {
                        proceed.call(drawingObj, newColor, newOpacity, false);
                    }
                } else {
                    proceed.call(drawingObj, newColor, newOpacity, false);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onTextColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(value, opacity);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(value, opacity);
                }, function () {
                    undoRedo(currentTextColor, currentTextOpacity);
                }, undefined, false, "onTextColorChange");
            }
        }
        proceed.call(this, value, opacity, isPropertyChange);
    });

    infChart.util.wrap(infChart.positionsDrawing.prototype, "onCompactStatsModeChange", function (proceed, value, isPropertyChange) {
        if (isPropertyChange) {
            var self = this;
            var ann = self.annotation;
            var options = ann.options;
            var currentValue = ann.options.styles['isCompactStats'];

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                proceed.call(self, value, false);
                self.onPropertyChange();
            }, function () {
                proceed.call(self, currentValue, false);
                self.onPropertyChange();
            }, undefined, false, 'onFibLevelValueChange');
        }
        proceed.call(self, value, isPropertyChange);
    });

    //endregion ---------- end of positions drawing wrappers ----------

    //-----------region start of trend channel drawing wrappers--------

    infChart.util.wrap(infChart.trendChannelDrawing.prototype, 'onFillColorChange', function (proceed, rgb, color, opacity, isPropertyChange) {
        var ann = this.annotation;
        if (_isTrackHistoryEnabledDrawing(ann) && isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.shape.params["fill"];
            var currentOpacity = ann.options.shape.params["fill-opacity"];
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             * @param {float} newOpacity opacity
             */
            function undoRedo(newColor, newOpacity) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var fillColorChangeElm = settingPanel.find("[inf-ctrl=fillColorPicker]");
                    if (fillColorChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fillColorChangeElm.mainColorPanel("value", {
                            color: newColor,
                            opacity: newOpacity
                        });
                    } else {
                        proceed.call(drawingObj, rgb, newColor, newOpacity, false);
                    }
                } else {
                    proceed.call(drawingObj, rgb, newColor, newOpacity, false);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onFillColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color, opacity);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color, opacity);
                }, function () {
                    undoRedo(currentColor, currentOpacity);
                }, undefined, false, 'onFillColorChange');
            }
        }
        proceed.call(this, rgb, color, opacity, isPropertyChange);
    });

    infChart.util.wrap(infChart.trendChannelDrawing.prototype, 'onMiddleLineColorChange', function (proceed, rgb, color, isPropertyChange) {
        var ann = this.annotation;
        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentColor = ann.options.middleLineColor;
            var lastAction = infChart.commandsManager.getLastAction(xChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             */
            function undoRedo(newColor) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var lineColorSelectorElm = settingPanel.find("input[inf-ctrl=middleLineColorPicker]");
                    if (lineColorSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        lineColorSelectorElm.mainColorPanel("value", {color: newColor})
                    } else {
                        proceed.call(drawingObj, rgb, newColor, false);
                    }
                } else {
                    proceed.call(drawingObj, rgb, newColor, false);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onMiddleLineColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color);
                }, function () {
                    undoRedo(currentColor);
                }, undefined, false, 'onMiddleLineColorChange');
            }
        }
        proceed.call(this, rgb, color, isPropertyChange);
    });

    infChart.util.wrap(infChart.trendChannelDrawing.prototype, 'onMiddleLineWidthChange', function (proceed, strokeWidth, isPropertyChange) {
        var ann = this.annotation;
        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentWidth = ann.options.middleLineWidth;

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new width to set
             */
            function undoRedo(newSize) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var lineWidthChangeElm = settingPanel.find(".middle-line-styles").find("[inf-ctrl=lineWidth][inf-size=" + newSize + "]");
                    if (lineWidthChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        lineWidthChangeElm.trigger('click');
                    } else {
                        proceed.call(drawingObj, newSize);
                    }
                } else {
                    proceed.call(drawingObj, newSize);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(strokeWidth);
            }, function () {
                undoRedo(currentWidth);
            }, undefined, false, 'onMiddleLineWidthChange');
        }
        proceed.call(this, strokeWidth, isPropertyChange);
    });

    infChart.util.wrap(infChart.trendChannelDrawing.prototype, 'onMiddleLineStyleChange', function (proceed, dashStyle, isPropertyChange) {
        var ann = this.annotation;
        if (_isTrackHistoryEnabledDrawing(ann) && isPropertyChange) {
            var drawingId = this.drawingId;
            var xChartId = _getChartIdFromHighchartInstance(ann.chart);
            var currentDashStyle = ann.options.middleLineStyle;

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newDashStyle new style to set
             */
            function undoRedo(newDashStyle) {
                var drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                var settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    var lineStyleSelectorElm = settingPanel.find(".middle-line-styles").find("[inf-ctrl=lineStyle][inf-style=" + newDashStyle + "]");
                    if (lineStyleSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        lineStyleSelectorElm.trigger('click');
                    } else {
                        proceed.call(drawingObj, newDashStyle);
                    }
                } else {
                    proceed.call(drawingObj, newDashStyle);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(dashStyle);
            }, function () {
                undoRedo(currentDashStyle);
            }, undefined, false, 'onMiddleLineStyleChange');
        }
        proceed.call(this, dashStyle, isPropertyChange);
    });

    /**
     * region start of arrow drawing wrapper
     */
    infChart.util.wrap(infChart.arrowDrawing.prototype, 'onFillColorChange', function(proceed, rgb, color, opacity, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            let ann = this.annotation;
                drawingId = this.drawingId,
                xChartId = _getChartIdFromHighchartInstance(ann.chart),
                currentColor = ann.options.shape.params.fill,
                lastAction = infChart.commandsManager.getLastAction(xChartId),
                colorPickerRef = "[inf-ctrl=colorPicker]";
            
            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             */
            function undoRedo(newColor) {
                let drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId);
                let settingPanel = drawingObj.settingsPopup;
                if (settingPanel) {
                    let arrowColorSelectorElm = settingPanel.find(colorPickerRef);
                    if (arrowColorSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        arrowColorSelectorElm.minicolors("value", {color: newColor})
                    } else {
                        proceed.call(drawingObj, rgb, newColor, false, colorPickerRef);
                    }
                } else {
                    proceed.call(drawingObj, rgb, newColor, false, colorPickerRef);
                }
                drawingObj.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(color);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(color);
                }, function () {
                    undoRedo(currentColor);
                }, undefined, false, 'onColorChange');
            }
        }
        proceed.call(this, rgb, color, opacity, isPropertyChange);
    });

    infChart.util.wrap(infChart.arrowDrawing.prototype, 'onLabelTextChange', function(proceed, text, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            let self = this,
                ann = self.annotation,
                drawingId = self.drawingId,
                xChartId = _getChartIdFromHighchartInstance(ann.chart),
                currentText = ann.options.label.text;

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             */
            function undoRedo(newText) {
                let drawingObj = infChart.drawingsManager.getDrawingObject(xChartId, drawingId),
                    settingPanel = drawingObj.settingsPopup;

                proceed.call(drawingObj, newText, false);
                if (settingPanel) {
                    newText = newText.replace(/<br\s*\/?>/gi, "");
                    drawingObj.updateSettings(settingPanel, undefined, newText);
                }
                drawingObj.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(text);
            }, function () {
                undoRedo(currentText);
            }, undefined, false, 'onTextChange_arrow');
        }
        proceed.call(this, text, isPropertyChange);
    });

    infChart.util.wrap(infChart.arrowDrawing.prototype, 'onLabelFontSizeChange', function(proceed, fontSize, isPropertyChange) {
        if (isPropertyChange) {
            let self = this,
                currentFontSize = self.annotation.options.label.fontSize;

             /**
              * Execute the undo/redo with the new properties
              * @param {number} newSize new font size to set
              */
            function undoRedo(newSize) {
                let settingPanel = self.settingsPopup;

                if (settingPanel) {
                    let fontSizeChangeDropdownElm = $(settingPanel.find("span[inf-ctrl=singleSelectedFontSize][inf-ctrl-val=P_all]"));
                    if (fontSizeChangeDropdownElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        var dropDownItem = fontSizeChangeDropdownElm.parent().parent();
                        $(dropDownItem).find("li[inf-ctrl=fontSize][inf-size='" + newSize + "']").trigger("click");
                    } else {
                        proceed.call(self, newSize, false);
                    }
                } else {
                    proceed.call(self, newSize, false);
                }
                self.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(self.stockChartId, function () {
                undoRedo(fontSize);
            }, function () {
                undoRedo(currentFontSize);
            }, undefined, false, 'onArrowLabelFontSizeChange');
        }
        proceed.call(this, fontSize, isPropertyChange);
    });

    infChart.util.wrap(infChart.arrowDrawing.prototype, 'onLabelFontColorChange', function(proceed, fontColor, isPropertyChange) {
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            let self = this;
                currentFontColor = self.annotation.options.label.fontColor,
                lastAction = infChart.commandsManager.getLastAction(self.stockChartId);

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newColor color code
             */
             function undoRedo(newColor) {
                let settingPanel = self.settingsPopup;
                if (settingPanel) {
                    let fontColorChangeElm = settingPanel.find("[inf-ctrl=textColorPicker]");
                    if (fontColorChangeElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fontColorChangeElm.minicolors("value", {
                            color: newColor
                        });
                    } else {
                        proceed.call(self, newColor, false);
                    }
                } else {
                    proceed.call(self, newColor, false);
                }
                self.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onArrowLabelFontColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(fontColor);
                }
            } else {
                infChart.commandsManager.registerCommand(self.stockChartId, function () {
                    undoRedo(fontColor);
                }, function () {
                    undoRedo(currentFontColor);
                }, undefined, false, 'onArrowLabelFontColorChange');
            }
        }
        proceed.call(this, fontColor, isPropertyChange);
    });
    //endregion

    //region ------------------------Start of common settings wrappers -----------------------------------------
    infChart.util.wrap(infChart.drawingSettings.eventHandlers, "onLineColorChange", function (proceed, drawingInstance, settingsParams, isPropertyChange, rgb, value, opacity) {
        const ann = drawingInstance.annotation;

        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            const xChartId = _getChartIdFromHighchartInstance(ann.chart);
            const currentLineColor = ann.options.settings[settingsParams.settingsItem + 'Color'];
            const currentLineOpacity = ann.options.settings[settingsParams.settingsItem + 'Opacity'];
            const lastAction = infChart.commandsManager.getLastAction(xChartId);

            function undoRedo(rgb, newLineColor, newLineOpacity) {
                const settingsPanel = drawingInstance.settingsPopup;
                if (settingsPanel) {
                    const lineColorChangeElm = settingsPanel.find(settingsParams.ctrlSelector? settingsParams.ctrlSelector: "[inf-ctrl=lineColorPicker]");
                    if (lineColorChangeElm.length > 0) {
                        settingsPanel.data("infUndoRedo", true);
                        lineColorChangeElm.mainColorPanel("value", {color: newLineColor, opacity: newLineOpacity});
                    } else {
                        proceed(drawingInstance, settingsParams, isPropertyChange, rgb, newLineColor, newLineOpacity);
                    }
                } else {
                    proceed(drawingInstance, settingsParams, isPropertyChange, rgb, newLineColor, newLineOpacity);
                }
                drawingInstance.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onLineColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(rgb, value, opacity);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(rgb, value, opacity);
                }, function () {
                    undoRedo(rgb, currentLineColor, currentLineOpacity);
                }, undefined, false, "onLineColorChange");
            }

        }
        proceed(drawingInstance, settingsParams, isPropertyChange, rgb, value, opacity);
    });

    infChart.util.wrap(infChart.drawingSettings.eventHandlers, 'onLineWidthChange', function (proceed, drawingInstance, settingsParams, isPropertyChange, strokeWidth) {
        const ann = drawingInstance.annotation;
        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange) {
            const xChartId = _getChartIdFromHighchartInstance(ann.chart);
            const currentWidth = ann.options.settings[settingsParams.settingsItem];

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new width to set
             */
            function undoRedo(newSize) {
                const settingPanel = drawingInstance.settingsPopup;
                if (settingPanel) {
                    const sizeSelectorElm = settingPanel.find((settingsParams.ctrlSelector? settingsParams.ctrlSelector: "[inf-ctrl=lineWidth]") + "[inf-size=" + newSize + "]");
                    if (sizeSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        sizeSelectorElm.trigger('click');
                    } else {
                        proceed(drawingInstance, settingsParams, isPropertyChange, newSize);
                    }
                } else {
                    proceed(drawingInstance, settingsParams, isPropertyChange, newSize);
                }
                drawingInstance.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(strokeWidth);
            }, function () {
                undoRedo(currentWidth);
            }, undefined, false, 'onLineWidthChange');
        }
        proceed(drawingInstance, settingsParams, isPropertyChange, strokeWidth);
    });

    infChart.util.wrap(infChart.drawingSettings.eventHandlers, 'onLineStyleChange', function (proceed, drawingInstance, settingsParams, isPropertyChange, dashStyle) {
        const ann = drawingInstance.annotation;
        if (_isTrackHistoryEnabledDrawing(ann) && isPropertyChange) {
            const xChartId = _getChartIdFromHighchartInstance(ann.chart);
            const currentDashStyle = ann.options.settings[settingsParams.settingsItem];

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newDashStyle new style to set
             */
            function undoRedo(newDashStyle) {
                const settingPanel = drawingInstance.settingsPopup;
                if (settingPanel) {
                    const lineStyleSelectorElm = settingPanel.find((settingsParams.ctrlSelector? settingsParams.ctrlSelector: "[inf-ctrl=lineStyle]") + "[inf-style=" + newDashStyle + "]");
                    if (lineStyleSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        lineStyleSelectorElm.trigger('click');
                    } else {
                        proceed(drawingInstance, settingsParams, isPropertyChange, newDashStyle);
                    }
                } else {
                    proceed(drawingInstance, settingsParams, isPropertyChange, newDashStyle);
                }
                drawingInstance.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(dashStyle);
            }, function () {
                undoRedo(currentDashStyle);
            }, undefined, false, 'onLineStyleChange');
        }
        proceed(drawingInstance, settingsParams, isPropertyChange, dashStyle);
    });

    /**
     * Wrapping up the infChart.drawingSettings.eventHandlers.onFillColorChange to catch the color settings change
     */
    infChart.util.wrap(infChart.drawingSettings.eventHandlers, 'onFillColorChange', function (proceed, drawingInstance, settingsParams, isPropertyChange, rgb, value, opacity) {
        const ann = drawingInstance.annotation;

        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            const xChartId = _getChartIdFromHighchartInstance(ann.chart);
            const currentFillColor = ann.options.settings[settingsParams.settingsItem + 'Color'];
            const currentFillOpacity = ann.options.settings[settingsParams.settingsItem + 'Opacity'];
            const lastAction = infChart.commandsManager.getLastAction(xChartId);

            function undoRedo(rgb, newFillColor, newFillOpacity) {
                const settingsPanel = drawingInstance.settingsPopup;
                if (settingsPanel) {
                    const fillColorChangeElm = settingsPanel.find(settingsParams.ctrlSelector? settingsParams.ctrlSelector: "[inf-ctrl=fillColorPicker]");
                    if (fillColorChangeElm.length > 0) {
                        settingsPanel.data("infUndoRedo", true);
                        fillColorChangeElm.mainColorPanel("value", {color: newFillColor, opacity: newFillOpacity});
                    } else {
                        proceed(drawingInstance, settingsParams, isPropertyChange, rgb, newFillColor, newFillOpacity);
                    }
                } else {
                    proceed(drawingInstance, settingsParams, isPropertyChange, rgb, newFillColor, newFillOpacity);
                }
                drawingInstance.onPropertyChange();
            }

            if (lastAction && lastAction.actionType === 'onFillColorChange' && !lastAction.freezeUpdatingSame) {
                lastAction.action = function () {
                    undoRedo(rgb, value, opacity);
                }
            } else {
                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(rgb, value, opacity);
                }, function () {
                    undoRedo(rgb, currentFillColor, currentFillOpacity);
                }, undefined, false, "onFillColorChange");
            }

        }
        proceed(drawingInstance, settingsParams, isPropertyChange, rgb, value, opacity);
    });

    /**
     * Wrapping up the infChart.drawingSettings.eventHandlers.onFillColorChange to catch the color settings change
     */
    infChart.util.wrap(infChart.drawingSettings.eventHandlers, 'onFontColorChange', function (proceed, drawingInstance, settingsParams, isPropertyChange, rgb, value, opacity) {
        const ann = drawingInstance.annotation;
            if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
                const xChartId = _getChartIdFromHighchartInstance(ann.chart);
                const currentFontColor = ann.options.settings[settingsParams.settingsItem + 'Color'];
                const currentFontOpacity = ann.options.settings[settingsParams.settingsItem + 'Opacity'];
                const lastAction = infChart.commandsManager.getLastAction(xChartId);

                function undoRedo(rgb, newFontColor, newFontOpacity) {
                    const settingsPanel = drawingInstance.settingsPopup;
                    if (settingsPanel) {
                        const fontColorChangeElm = settingsPanel.find(settingsParams.ctrlSelector? settingsParams.ctrlSelector: "[inf-ctrl=fontColorPicker]");
                        if (fontColorChangeElm.length > 0) {
                            settingsPanel.data("infUndoRedo", true);
                            fontColorChangeElm.mainColorPanel("value", {color: newFontColor, opacity: newFontOpacity});
                        } else {
                            proceed(drawingInstance, settingsParams, isPropertyChange, rgb, newFontColor, newFontOpacity);
                        }
                    } else {
                        proceed(drawingInstance, settingsParams, isPropertyChange, rgb, newFontColor, newFontOpacity);
                    }
                    drawingInstance.onPropertyChange();
                }

                if (lastAction && lastAction.actionType === 'onFontColorChange' && !lastAction.freezeUpdatingSame) {
                    lastAction.action = function () {
                        undoRedo(rgb, value, opacity);
                    }
                } else {
                    infChart.commandsManager.registerCommand(xChartId, function () {
                        undoRedo(rgb, value, opacity);
                    }, function () {
                        undoRedo(rgb, currentFontColor, currentFontOpacity);
                    }, undefined, false, "onFontColorChange");
                }

            }
            proceed(drawingInstance, settingsParams, isPropertyChange, rgb, value, opacity);
        });

    /**
     * Wrapping up the infChart.drawingSettings.eventHandlers.onFontSizeChange to catch the line width changes
     */
    infChart.util.wrap(infChart.drawingSettings.eventHandlers, 'onFontSizeChange', function (proceed, drawingInstance, settingsParams, isPropertyChange, fontSize) {
        const ann = drawingInstance.annotation;
        if ((_isTrackHistoryEnabledDrawing(ann) || _isIndicatorDrawing(ann)) && isPropertyChange) {
            const xChartId = _getChartIdFromHighchartInstance(ann.chart);
            const currentFontSize = ann.options.settings[settingsParams.settingsItem];

            /**
             * Execute the undo/redo with the new properties
             * @param {number} newSize new width to set
             */
            function undoRedo(fontSize) {
                const settingPanel = drawingInstance.settingsPopup;
                if (settingPanel) {
                    const sizeSelectorElm = settingPanel.find((settingsParams.ctrlSelector? settingsParams.ctrlSelector: "[inf-ctrl=fontSize]") + "[inf-size=" + fontSize + "]");
                    if (sizeSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        sizeSelectorElm.trigger('click');
                    } else {
                        proceed(drawingInstance, settingsParams, isPropertyChange, fontSize);
                    }
                } else {
                    proceed(drawingInstance, settingsParams, isPropertyChange, fontSize);
                }
                drawingInstance.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(fontSize);
            }, function () {
                undoRedo(currentFontSize);
            }, undefined, false, 'onFontSizeChange');
        }
        proceed(drawingInstance, settingsParams, isPropertyChange, fontSize);

    });

    infChart.util.wrap(infChart.drawingSettings.eventHandlers, 'onFontStyleChange', function (proceed, drawingInstance, settingsParams, isPropertyChange, style, isSelected) {
        const ann = drawingInstance.annotation;
        if (_isTrackHistoryEnabledDrawing(ann) && isPropertyChange) {
            const xChartId = _getChartIdFromHighchartInstance(ann.chart);
            const currentIsSelected = !isSelected;

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newDashStyle new style to set
             */
            function undoRedo(style, isSelected) {
                const settingPanel = drawingInstance.settingsPopup;
                if (settingPanel) {
                    const fontStyleSelectorElm = settingPanel.find((settingsParams.ctrlSelector? settingsParams.ctrlSelector: "[inf-ctrl=fontStyle]") + "[inf-style=" + style + "]");
                    if (fontStyleSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        fontStyleSelectorElm.trigger('click');
                    } else {
                        proceed(drawingInstance, settingsParams, isPropertyChange, style, isSelected);
                    }
                } else {
                    proceed(drawingInstance, settingsParams, isPropertyChange, style, isSelected);
                }
                drawingInstance.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(style, isSelected);
            }, function () {
                undoRedo(style, currentIsSelected);
            }, undefined, false, 'onFontStyleChange');
        }
        proceed(drawingInstance, settingsParams, isPropertyChange, style, isSelected);
    });

    infChart.util.wrap(infChart.drawingSettings.eventHandlers, 'onValueChange', function (proceed, drawingInstance, settingsParams, isPropertyChange, value) {
        const ann = drawingInstance.annotation;
        if (_isTrackHistoryEnabledDrawing(ann) && isPropertyChange) {
            const xChartId = _getChartIdFromHighchartInstance(ann.chart);
            const currentValue = ann.options.settings[settingsParams.settingsItem];

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newDashStyle new style to set
             */
            function undoRedo(value) {
                const settingPanel = drawingInstance.settingsPopup;
                if (settingPanel) {
                    const valueSelectorElm = settingPanel.find((settingsParams.ctrlSelector? settingsParams.ctrlSelector: "[inf-ctrl = value]") + "[inf-ctrl-val=" + value + "]");
                    if (valueSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        valueSelectorElm.trigger('click');
                    } else {
                        proceed(drawingInstance, settingsParams, isPropertyChange, value);
                    }
                } else {
                    proceed(drawingInstance, settingsParams, isPropertyChange, value);
                }
                drawingInstance.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(value);
            }, function () {
                undoRedo(currentValue);
            }, undefined, false, 'onValueChange');
        }
        proceed(drawingInstance, settingsParams, isPropertyChange, value);
    });

    infChart.util.wrap(infChart.drawingSettings.eventHandlers, 'onCheckBoxValueChange', function (proceed, drawingInstance, settingsParams, isPropertyChange, value) {
        const ann = drawingInstance.annotation;
        if (_isTrackHistoryEnabledDrawing(ann) && isPropertyChange) {
            const xChartId = _getChartIdFromHighchartInstance(ann.chart);
            const currentValue = ann.options.settings[settingsParams.settingsItem];

            /**
             * Execute the undo/redo with the new properties
             * @param {string} newDashStyle new style to set
             */
            function undoRedo(value) {
                const settingPanel = drawingInstance.settingsPopup;
                if (settingPanel) {
                    const valueSelectorElm = settingPanel.find((settingsParams.ctrlSelector? settingsParams.ctrlSelector: "[inf-ctrl=value]"));
                    if (valueSelectorElm.length > 0) {
                        settingPanel.data("infUndoRedo", true);
                        valueSelectorElm.trigger('click');
                    } else {
                        proceed(drawingInstance, settingsParams, isPropertyChange, value);
                    }
                } else {
                    proceed(drawingInstance, settingsParams, isPropertyChange, value);
                }
                drawingInstance.onPropertyChange();
            }

            infChart.commandsManager.registerCommand(xChartId, function () {
                undoRedo(value);
            }, function () {
                undoRedo(currentValue);
            }, undefined, false, 'onCheckBoxValueChange');
        }
        proceed(drawingInstance, settingsParams, isPropertyChange, value);
    });

    /**
     * Wrapping up the infChart.drawingSettings.eventHandlers.onTextChange to catch the line text changes
     */
    infChart.util.wrap(infChart.drawingSettings.eventHandlers, 'onTextChange', function (proceed, drawingInstance, settingsParams, isPropertyChange, text) {
        const ann = drawingInstance.annotation;
        if (isPropertyChange && !infChart.drawingsManager.getIsActiveDrawingInprogress()) {
            const xChartId = _getChartIdFromHighchartInstance(ann.chart);
            const currentText = ann.options[settingsParams.settingsItem];
            const isAddToStack = text !== "" && currentText !== text;
            /**
             * Execute the undo/redo with the new properties
             * @param {string} newText new text being set
             */
            if(isAddToStack){
                function undoRedo(newText) {
                    var settingPanel = drawingInstance.settingsPopup;

                    proceed(drawingInstance, settingsParams, isPropertyChange, newText);
                    if (settingPanel) {
                        newText = newText.replace(/<br\s*\/?>/gi, "");
                        const textChangeElm = settingPanel.find((settingsParams.ctrlSelector? settingsParams.ctrlSelector: "[inf-ctrl=text]"));
                        textChangeElm.val(newText);
                    }
                    drawingInstance.onPropertyChange();
                }

                infChart.commandsManager.registerCommand(xChartId, function () {
                    undoRedo(text);
                }, function () {
                    undoRedo(currentText);
                }, undefined, false, 'onTextChange');
            }

        }
        return proceed(drawingInstance, settingsParams, isPropertyChange, text);

    });
    //endregion
})(jQuery, infChart);

infChart.drawingDataProvider = function(vendor){};

infChart.drawingDataProvider.prototype.saveDrawingTemplates = function(data){};

infChart.drawingDataProvider.prototype.getSavedDrawingTemplates = function(onSuccess){};

(function(infChart, $){

    infChart.mockDrawingDataProvider = function () {
        infChart.drawingDataProvider.apply(this, arguments);
    };

    infChart.util.extend(infChart.drawingDataProvider, infChart.mockDrawingDataProvider);

    infChart.mockDrawingDataProvider.prototype.saveDrawingTemplates = function(data){
        infChart.util.saveData(infChart.util.getUserName() + "_" + "custom-drawing-templates", data);
    };

    infChart.mockDrawingDataProvider.prototype.getSavedDrawingTemplates = function(onSuccess){
        var drawingTemplates = infChart.util.getData(infChart.util.getUserName() + "_" + "custom-drawing-templates");
        onSuccess(drawingTemplates);
    };

    infChart.mockDrawingDataProvider.prototype.saveDefaultDrawingTemplates = function(data){
        infChart.util.saveData(infChart.util.getUserName() + "_" + "default-drawing-templates", data);
    };

    infChart.mockDrawingDataProvider.prototype.getDefaultSavedDrawingTemplates = function(onSuccess){
        var drawingTemplates = infChart.util.getData(infChart.util.getUserName() + "_" + "default-drawing-templates");
        onSuccess(drawingTemplates);
    };

})(infChart, jQuery);
/**
 * Management of context menu of the chart goes here
 * @type {*|{}}
 */
var infChart = window.infChart || {};

infChart.mobileDrawingSettingsManager = (function ($, infChart) {

    var _getConfigForDrawing = function (chartId, type, data) {
        let options = {};
        switch (type) {
            case infChart.constants.contextMenuTypes.drawing:
                if (typeof infChart.mobileDrawingSettingsManager !== 'undefined') {
                    options = infChart.mobileDrawingSettingsManager.getDrawingSettingsOptions(chartId, data.drawingId);
                }
                break;
            case infChart.constants.contextMenuTypes.indicator:
                if (typeof infChart.indicatorMgr !== 'undefined') {
                    options = infChart.indicatorMgr.getContextMenuOptions(chartId, data, event);
                }
                break;
            case infChart.constants.contextMenuTypes.favoriteDrawing:
                if (typeof infChart.drawingsManager !== 'undefined') {
                    options = infChart.drawingsManager.getFavoriteDrawingContextMenuOptions(chartId, data);
                }
                break;
            case infChart.constants.contextMenuTypes.colorPalette :
                options = infChart.manager.getCustomContextMenuOptions(event);
                break;
            case infChart.constants.contextMenuTypes.xAxis :
                options = infChart.manager.getXAxisContextMenuOptions(chartId, event);
                break;
            case infChart.constants.contextMenuTypes.yAxis :
                options = infChart.manager.getYAxisContextMenuOptions(chartId, event);
                break;
            default:
                options = infChart.manager.getDefaultContextMenuOptions(chartId, event);
                break;
        }

        return options;
    };

    var _getDrawingSettingsOptions = function(chartId, drawingId){
        var drawingObj = infChart.drawingsManager.getDrawingObject(chartId, drawingId);
        var config = infChart.settings.drawingSettingsPanel[drawingObj.shape];
        var shape = drawingObj.shape;
        var updatedSettings = drawingObj.updateConfigFromSettings(drawingObj, config);

        return updatedSettings;
    };

    var _setDrawingProperties = function(chartId, drawingId, methodName, value){
        var drawingObj = infChart.drawingsManager.getDrawingObject(chartId, drawingId);
        drawingObj[methodName](value);
    };

    return {
        getConfigForDrawing: _getConfigForDrawing,
        getDrawingSettingsOptions: _getDrawingSettingsOptions,
        setDrawingProperties: _setDrawingProperties
    };
})(jQuery, infChart);
