/**
 * Created by dushani on 8/26/15.
 * This section contains the utility methods which are used by chart
 */

window.infChart = window.infChart || {};

infChart.util = (function ($, Highcharts, infChart) {

    Array.prototype.infMin = function (key) {
        var hasKey = key != undefined;
        var i, min = hasKey ? this[0][key] : this[0];
        for (i = 0; i < this.length; i++) {
            var value = hasKey ? this[i][key] : this[i];
            min = ( min < value ) ? min : value;
        }
        return min;
    };

    Array.prototype.infMax = function (key) {
        var hasKey = key != undefined;
        var i, max = hasKey ? this[0][key] : this[0];
        for (i = 0; i < this.length; i++) {

            var value = hasKey ? this[i][key] : this[i];
            max = ( max > value ) ? max : value;
        }
        return max;
    };

    // Removes an element from an array.
    // String value: the value to search and remove.
    // return: an array with the removed element; false otherwise.
    Array.prototype.infRemove = function (value) {
        var idx = this.indexOf(value);
        if (idx != -1) {
            return this.splice(idx, 1); // The second parameter is the number of elements to remove.
        }
        return false;
    };

    // Check whether given search values contains the elements of the array
    // String value: the value to search.
    // return:
    Array.prototype.infContainsItemsIn = function (value) {
        var i;
        for (i = 0; i < this.length; i++) {
            if( (typeof this[i] == "string") && value.indexOf(this[i])>=0){
                return true;
            }
        }
        return false
    };

    /**
     * Define isArray on array object if not defined
     */
    if (!Array.isArray) {
        Array.isArray = function (arg) {
            return Object.prototype.toString.call(arg) === '[object Array]';
        };
    }

    if (!String.replaceAll) {
        String.prototype.replaceAll = function (search, replacement) {
            var target = this;
            return target.replace(new RegExp(search, 'g'), replacement);
        };
    }

    if (!Array.xPush) {
        Array.prototype.xPush = function (element) {
            this[this.length] = element;
        };
    }

    //region extending Element.prototype

    if (!Element.xAppend) {
        Element.prototype.xAppend = function (html) {
            this.innerHTML += html;
        }
    }

    if (!Element.xRemoveChild) {
        Element.prototype.xRemoveChild = function (element) {
            element && this.removeChild(element);
        }
    }

    if (!Element.xHtml) {
        Element.prototype.xHtml = function (html) {
            this.innerHTML = html;
        }
    }
    if (!Element.xAddClass) {
        Element.prototype.xAddClass = function (cls) {
            var clsArr = this.className.split(" "),
                newClsArr = cls && cls.split(" ");

            if(newClsArr.length) {
                for(var i= 0, iLen = newClsArr.length; i < iLen; i++) {
                    if(clsArr.indexOf(newClsArr[i]) === -1 ) {
                        this.className += " " + newClsArr[i];
                    }
                }
            }
        }
    }
    if (!Element.xRemoveClass) {
        Element.prototype.xRemoveClass = function (cls) {
            var clsArr = this.className.split(" ");
            clsArr.infRemove(cls);
            this.className = clsArr.join(" ");
        }
    }

    if (!Element.xIsTextField) {
        /**
         * Determine whether the element is a text input
         * @returns {boolean} text input or not
         */
        Element.prototype.xIsTextField = function () {
            return (this.tagName === 'INPUT' && this.type === 'text');
        };
    }

    if (!Element.xGetSelectedText) {
        /**
         * Returns the selected text of a text input
         * @returns {string} selected text
         */
        Element.prototype.xGetSelectedText = function () {
            if (this.xIsTextField() && this.selectionStart != this.selectionEnd) {
                return this.value.substr(this.selectionStart, this.selectionEnd - this.selectionStart);
            }
        };
    }


    //endregion

    // region common utility methods

    /**
     * Check whether givin object is empty
     * @param str
     * @returns {boolean}
     * @private
     */
    var _isEmpty = function (str) {
        var empty = false;
        if(typeof str === 'undefined' || str === null){
            empty = true;
        }else{
            if(typeof str === 'object' && Object.keys(str).length === 0){
                empty = true;
            }else if(typeof str === 'array' && str.length === 0){
                empty = true;
            }else if(typeof str === 'string' && str.length === 0){
                empty = true;
            }
        }
        return empty;
    };

    /**
     * Log Exceptions
     * @param exception
     * @private
     */
    var _handleException = function (exception) {
        _console.error(exception);
    };

    var _extend = function (parent, child) {
        child.prototype = new parent();
        child.constructor = child;
    };

    /**
     * Iterate over an array or object using a for loop but it behaves like a foreEach
     * @param array
     * @param callback
     * @private
     */
    var _forEach = function (array, callback, startIdx) {
        var i,
            iLen;

        startIdx = startIdx || 0;

        if (Array.isArray(array)) {
            for (i = startIdx, iLen = array.length; i < iLen; i++) {
                if(callback.call(array, i, array[i])){
                    break;
                }
            }
        } else if (typeof array === 'object') {
            var keys = Object.keys(array),
                kLen = keys.length;
            for (i = 0; i < kLen; i++) {
                if(callback.call(array, keys[i], array[keys[i]])){
                    break;
                }
            }
        }
    };

    /**
     * check whether series should be displayed in legend
     * @param options series options
     * @returns {boolean|*}
     * @private
     */
    var _isLegendAvailable = function (options) {
        return !options.hideLegend && (
                options.id === 'c0' || options.infType === 'compare' || (options.infType === 'indicator' && _isSeriesInBaseAxis(options.yAxis))
            );
    };

    /**
     * check whether indicator is drawn in the same axis as base symbol
     * @param yAxisId y axis name
     * @returns {boolean}
     * @private
     */
    var _isSeriesInBaseAxis = function (yAxisId) {
        return ( yAxisId === '#0' || yAxisId === '#1');
    };

    /**
     * check whether indicator is drawn in the parallel axis as base symbol
     * @param yAxis y axis
     * @returns {boolean}
     * @private
     */
    var _isSeriesParallelToBaseAxis = function (yAxis) {
        return (yAxis && yAxis.options.infType == "parallelToBase");
    };

    ///**
    // * get description to show in legend
    // * @param options series options
    // * @returns {*}
    // * @private
    // */
    //var _getLegendTitle = function (options) {
    //    var title;
    //    if (options.infType === 'indicator') {
    //        title = infChart.util.getIndicatorDescLabel(options.name);
    //    } else {
    //        title = options.title;
    //    }
    //    return title;
    //};

    /**
     * calculates change pct with regard to 1st point
     * @param dataArray
     * @returns {Array}
     * @private
     */
    var _calculateChange = function (dataArray) {
        var chgArray = [], prev;
        _forEach(dataArray, function (index, val) {
            if (prev) {
                chgArray.xPush((val / prev - 1) * 100);
                //prev = val;
            } else {
                prev = val;
                chgArray.xPush(0);
            }
        });
        return chgArray;
    };

    // Converts an RGB string to a hex string
    var _rgbString2hex = function (rgb, opacity) {
        var colorString = rgb,
            colorsOnly = colorString && colorString.substring(colorString.indexOf('(') + 1, colorString.lastIndexOf(')')).split(/,\s*/),
            components = {};
        if (colorsOnly && colorsOnly.length >= 2) {
            components.red = colorsOnly[0];
            components.green = colorsOnly[1];
            components.blue = colorsOnly[2];
            components.opacity = colorsOnly[3] ? colorsOnly[3] : opacity ? opacity : 1;
            components.hex = '#' +
                ('0' + parseInt(components.red, 10).toString(16)).slice(-2) +
                ('0' + parseInt(components.green, 10).toString(16)).slice(-2) +
                ('0' + parseInt(components.blue, 10).toString(16)).slice(-2);
        } else {
            components.hex = rgb;
            components.opacity = opacity ? opacity : 1;
        }
        return components;
    };

    /**
     * bind color picker
     * @param targetEls
     * @param {string} color default color
     * @param {function} onSubmit
     * @param {HTMLDOMElement} container element of color palette witch is using for view port calculations
     * @private
     */
    var _bindColorPicker = function (targetEls, color, onSubmit, container) {
        var defaultColor = color;
        $.each(targetEls, function (i, el) {
            var _slef = this;
            var colorPickEl = $(el);
            defaultColor = (colorPickEl.val().trim() != "") ? colorPickEl.val() : defaultColor;
            var opacityEnabled = colorPickEl.attr("opacity") != "false";
            defaultColor = _rgbString2hex(defaultColor, colorPickEl.attr("data-opacity"));
            colorPickEl.val(defaultColor.hex);

            if (defaultColor.opacity) {
                colorPickEl.attr("data-opacity", defaultColor.opacity);
            }

            var position = colorPickEl.data('position');

            if(!position) {
                position = 'bottom left';
                colorPickEl.data('position', position);
            }

            colorPickEl.minicolors({
                control: 'hue',
                defaultValue: defaultColor.hex,
                format: 'hex',
                position: position,
                opacity: opacityEnabled,
                showSpeed: 0,
                change: function (value, opacity) {
                    if ($(this).data('minicolors-initialized')) {
                        onSubmit.call(this, $(this).minicolors('rgbaString'), value, opacity);
                        $(this).parent().find(".minicolors-hex-input").val(value);
                    }
                },
                show: function() {
                    container = container? container : $(this).closest("[color-picker-container]");
                    var colorPaletteWrapper = $(this).closest("div.minicolors");
                    var colorPanel = colorPaletteWrapper.find("div.minicolors-panel");
                    var currentPosition = $(this).data("position");
                    var currentVerticalPosition = currentPosition.split(" ")[0];
                    var currentHorizontalPosition = currentPosition.split(" ")[1];
                    var isDisableDrawingSettingsPanel = $(this).closest("div[data-inf-drawing-settings-pop-up]").length > 0;
                    var isQuickSettingsPanel = $(this).closest("div[data-inf-quick-drawing-settings-pop-up]").length > 0;

                    if(!isDisableDrawingSettingsPanel && container.length > 0 && !_isWithinElement(container, colorPanel)) {
                        var newVerticalPosition = currentVerticalPosition === "top" ? "bottom" : "top";

                        if(!(newVerticalPosition === "top" && container.offset().top > (colorPaletteWrapper.offset().top - colorPanel.height()))) { // check whether new top is greater than container top
                            colorPaletteWrapper.removeClass("minicolors-position-" + currentVerticalPosition).addClass("minicolors-position-" + newVerticalPosition);
                            $(this).data("position", currentPosition.replace(currentVerticalPosition, newVerticalPosition));
                        }
                    }

                    var hexInput = '<div class="minicolors-hex-input-wrapper"><input type="text" style="width:100%" class="minicolors-hex-input" value="'
                    + colorPickEl.val() + '"></input><div>';
                    $(this).parent().find(".minicolors-panel").append(hexInput);

                    if (isDisableDrawingSettingsPanel || isQuickSettingsPanel) {
                        var elementOffset = isQuickSettingsPanel ? $(this).parent().closest('li').offset() : $(this).parent().offset();
                        var elementWidth = isQuickSettingsPanel ? $(this).parent().closest('li').outerWidth() : $(this).parent().outerWidth();
                        var elementHeight = isQuickSettingsPanel ? $(this).parent().closest('li').outerHeight() : $(this).parent().outerHeight();
                        var chartContainer = $(this).closest('div[inf-container=highchartContainer]');

                        if (currentVerticalPosition === "top") {
                            elementOffset.top = isQuickSettingsPanel ? elementOffset.top + elementHeight : elementOffset.top - $(colorPanel).outerHeight() + elementHeight;
                        } else {
                            elementOffset.top = elementOffset.top + elementHeight;
                        }
                        if (currentHorizontalPosition === "right") {
                            elementOffset.left = elementOffset.left - $(colorPanel).outerWidth();
                        } else {
                            elementOffset.left = isQuickSettingsPanel ? elementOffset.left : elementOffset.left + elementWidth;
                        }

                        if (elementOffset.left + $(colorPanel).outerWidth(true)  > chartContainer.offset().left + chartContainer.outerWidth(true)) {
                            elementOffset.left = $(this).parent().offset().left - $(colorPanel).outerWidth(true);
                        }

                        if (elementOffset.top + $(colorPanel).outerHeight(true)  > chartContainer.offset().top + chartContainer.outerHeight(true)) { 
                            elementOffset.top = elementOffset.top - $(colorPanel).outerHeight(true) - elementHeight;
                        }

                        $(this).parent().find(".minicolors-panel").css({position: "fixed"}).offset(elementOffset);

                    }

                    var hexInputElement = $(this).parent().find(".minicolors-hex-input");
                    var settings = colorPickEl.data('minicolors-settings');
                    var ctrlKey = 17;
                    var cmdKey = 91;
                    var enterKey = 13;
                    var vKey = 86;
                    var ctrlDown = false;
                    var value = colorPickEl.val();
                    hexInputElement.val(value.startsWith("rgb") ? rgb2hex(value) : value);
                    hexInputElement.on('keydown', event => {
                        var keyCode = event.which || event.keyCode;
                        if (keyCode == ctrlKey || keyCode == cmdKey) {
                            ctrlDown = true;
                        }
                        if ((ctrlDown && keyCode === vKey)) {
                            setTimeout(function () {
                                _changeMiniColor(hexInputElement, settings, colorPickEl, onSubmit, _slef);
                            }, 100);
                        } else if (keyCode === enterKey) {
                            _changeMiniColor(hexInputElement, settings, colorPickEl, onSubmit, _slef);
                        }
                    });

                    hexInputElement.on('click', event => {
                        ctrlDown = false;
                        hexInputElement.select();
                    });

                    hexInputElement.on('keyup', event => {
                        var keyCode = event.which || event.keyCode;
                        if (keyCode == ctrlKey || keyCode == cmdKey) {
                            ctrlDown = false;
                        }
                    });
                },
                hide: function () {
                    var hexInputElementWrapper = $(this).parent().find(".minicolors-hex-input-wrapper");
                    var hexInputElement = $(this).parent().find(".minicolors-hex-input");
                    hexInputElement.off('keydown');
                    hexInputElement.off('keyup');
                    hexInputElement.off('click');
                    hexInputElementWrapper.remove();
                },
                theme: 'default'
            });
        });
    };

    /**
     * 
     * @param {*} hexInputElement - Hex input elemet
     * @param {*} settings - colour picker settings
     * @param {*} colorPickEl - colour picker element
     * @param {*} onSubmit  onSubmit function
     * @param {*} context - context
     */
    var _changeMiniColor = function (hexInputElement, settings, colorPickEl, onSubmit, context) {
        let value = hexInputElement.val();
        value = value ? value : settings.defaultValue;
        colorPickEl.find('.minicolors-input').val(value);
        colorPickEl.minicolors('value', value);
       // onSubmit.call(context, colorPickEl.minicolors('rgbaString'), value, colorPickEl.data('opacity'));
    }

    //Function to convert hex format to a rgb color
    function rgb2hex(rgb){
        rgb = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
        return (rgb && rgb.length === 4) ? "#" +
        ("0" + parseInt(rgb[1],10).toString(16)).slice(-2) +
        ("0" + parseInt(rgb[2],10).toString(16)).slice(-2) +
        ("0" + parseInt(rgb[3],10).toString(16)).slice(-2) : '';
    }

    /**
     * hide open color pickers
     * @param {object} container - popup container
     */
    var _hideColorPicker = function (container) {
        var openMiniColors = $(container).find("div.minicolors-focus");
        if(openMiniColors.length > 0) {
            $.each(openMiniColors, function (k, colorPanel) {
                $(colorPanel).find('input.minicolors-input').minicolors("hide");
            });
        }
    };

    /**
     * Checks whether the subject element is within the container element
     * @param containerElement the element that contains subject
     * @param subjectElement the element that need to show inside container
     * @returns {boolean} is subject element within container element
     * @private
     */
    var _isWithinElement = function (containerElement, subjectElement) {
        var elementTop = subjectElement.offset().top;
        var elementBottom = elementTop + subjectElement.outerHeight();

        var viewportTop = containerElement.offset().top;
        var viewportBottom = viewportTop + containerElement.height();

        return elementTop > viewportTop && elementBottom < viewportBottom;
    };

    var _binaryIndexOf = function (arr, searchValueKey, searchValue) {

        var minIndex = 0;
        var maxIndex = arr.length - 1;
        var currentIndex;
        var currentElement;
        var resultIndex,
            searchValTemp;

        while (minIndex <= maxIndex) {
            resultIndex = currentIndex = (minIndex + maxIndex) / 2 | 0;
            currentElement = arr[currentIndex];
            searchValTemp = searchValueKey != undefined && searchValueKey != null? currentElement[searchValueKey] : currentElement;

            if (searchValTemp < searchValue) {
                minIndex = currentIndex + 1;
            } else if (searchValTemp > searchValue) {
                maxIndex = currentIndex - 1;
            } else {
                return currentIndex;
            }
        }

        return ~maxIndex;
    };

    //
    //var _binarySearch = function (arr, searchValueKey, searchValue) {
    //
    //    var minIndex = 0;
    //    var maxIndex = arr.length - 1;
    //    var currentIndex;
    //    var currentElement;
    //    var resultIndex;
    //
    //    while (minIndex <= maxIndex) {
    //        resultIndex = currentIndex = (minIndex + maxIndex) / 2 | 0;
    //        currentElement = arr[currentIndex];
    //
    //        if (currentElement[searchValueKey] < searchValue) {
    //            minIndex = currentIndex + 1;
    //        }
    //        else if (currentElement[searchValueKey] > searchValue) {
    //            maxIndex = currentIndex - 1;
    //        }
    //        else {
    //            return currentIndex;
    //        }
    //    }
    //
    //    return ~maxIndex;
    //};

    var _getDateStringFromTime = function (utcTime, lastUnit) {
        var date = new Date(utcTime),
            month = date.getUTCMonth() + 1,
            day = date.getUTCDate(),
            hour = date.getUTCHours(),
            min = date.getUTCMinutes();

        switch (lastUnit) {
            case 'h' :
                return (date.getFullYear() + "-" + ((month < 10) ? "0" + month : month) + "-" + ((day < 10) ? "0" + day : day)) + "-" +
                    ((hour < 10) ? "0" + hour : hour) + "-00-00";

            case 'm':
                return (date.getFullYear() + "-" + ((month < 10) ? "0" + month : month) + "-" + ((day < 10) ? "0" + day : day)) + "-" +
                    ((hour < 10) ? "0" + hour : hour) + "-" + ((min < 10) ? "0" + min : min) + "-00";

            case 'd':
            default :
                return (date.getFullYear() + "-" + ((month < 10) ? "0" + month : month) + "-" + ((day < 10) ? "0" + day : day)) + "-" +
                    "00-00-00";

        }
    };

    var _getDateAndTimeStringFromTime = function (utcTime) {
        var date = new Date(utcTime);
        var month = date.getUTCMonth() + 1;
        var day = date.getUTCDate();
        var hour = date.getUTCHours();
        var min = date.getUTCMinutes();
        var sec = date.getUTCSeconds();

        return (date.getFullYear() + "-" + ((month < 10) ? "0" + month : month) + "-" + ((day < 10) ? "0" + day : day)) +
            ((hour < 10) ? "0" + hour : hour) + ((min < 10) ? "0" + min : min) + ((sec < 10) ? "0" + sec : sec);
    };

    var _bindDragEvents = function (chart, dragItem, stepFunction, stop, dragFunction) {
        var self = this;

        function drag(e) {
            if (e.button !== 2) {   // ignore right click - cannot use an event since mousedown event is fired first
                e.preventDefault();
                e.stopPropagation();

                // $(document).bind({
                //     'mousemove.dragItem touchmove.dragItem': step,
                //     'mouseup.dragItem touchend.dragItem': drop
                // });

                if(dragFunction){
                    chart.pointer.normalize(e);
                    dragFunction(e);
                }

                _bindEvent(chart.container, 'mousemove', step);
                _bindEvent(chart.container, 'mouseup', drop);
            }
        }

        function step(e) {
            if (stepFunction) {
                chart.pointer.normalize(e);
                stepFunction(e);
            }
        }

        function drop(e) {
            if (stop) {
                chart.pointer.normalize(e);
                stop(e);
            }
            _unbindEvent(chart.container, 'mousemove', step);
            _unbindEvent(chart.container, 'mouseup', drop);
            // $(document).unbind('.dragItem');
        }
        _bindEvent(dragItem.element, 'mousedown', drag);
        // dragItem.on('touchstart', drag);
    };

    var _dragFix = function (chart, event, ui) {
        var zoomScale = chart.settings.registeredMethods.afterCssScaling ? chart.settings.registeredMethods.afterCssScaling().scaleX: 1;
        var changeLeft = ui.position.left - ui.originalPosition.left; // find change in left
        var newLeft = ui.originalPosition.left + changeLeft / zoomScale; // adjust new left by our zoomScale
        var changeTop = ui.position.top - ui.originalPosition.top; // find change in top
        var newTop = ui.originalPosition.top + changeTop / zoomScale; // adjust new top by our zoomScale
        ui.position.left = newLeft;
        ui.position.top = newTop;
    };

    // endregion

    //region authentication

    /**
     * Athenticate User
     * @param user
     * @param password
     * @returns {string}
     * @private
     */
    var _authenticate = function (user, password) {
        // TODO :: should do a proper authentication and return the token
        var tok = user + ':' + password;
        return btoa(tok);
    };

    var _generateUUID = function () {
        var d = new Date().getTime();
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = (d + Math.random() * 16) % 16 | 0;
            d = Math.floor(d / 16);
            return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
        });
    };

    var _getUserName = function () {
        return 'USER';
    };

    // endregion

    // region language

    ///**
    // * get indicator description using indicator type
    // * todo :: use _getLabel
    // * @param type
    // * @returns {*}
    // * @private
    // */
    //var _getIndicatorDescLabel = function (type) {
    //    return "label.indicatorDesc." + type;
    //};

    var _getThousandSeparator = function () {
        var langOpt = Highcharts.getOptions().lang;
        return langOpt && langOpt.thousandsSep ? langOpt.thousandsSep : ",";
    };

    /**
     * Returns the reference name for the legend value element
     * @param series
     * @returns {string}
     * @private
     */
    var _legendReference = function (series) {
        if (series && series.options && series.options.id) {
            return 'lg-val-' + series.options.id;
        }
    };

    //endregion

    //region storage

    var cachedData = {};

    var _saveData = function (key, value) {
        cachedData[key] = value;
        console.log("#### chart save local storage data");
        try {
            localStorage.setItem(key, JSON.stringify(value));
        }
        catch (ex) {
            console.warn(ex);
        }
    };

    var _getData = function (key) {
        var value = cachedData[key];
        try {
            if (!value) {
                console.log("#### chart get local storage data");
                value = JSON.parse(localStorage.getItem(key));
                cachedData[key] = value;
            }
        }
        catch (ex) {
            console.warn(ex);
        }
        return value;
    };

    var _hasAllPatterns = function (key, ptn) {
        var foundPattern = false;
        if (Array.isArray(ptn)) {
            for (var k = 0; k < ptn.length; k++) {
                if (key.indexOf(ptn) < 0) {
                    foundPattern = false;
                    break;
                } else {
                    foundPattern = true;
                }
            }
        } else {
            foundPattern = key.indexOf(ptn) >= 0;
        }
        return foundPattern;
    };

    var _hasPattern = function (key, ptn) {
        var foundPattern = false;
        if (Array.isArray(ptn)) {
            for (var k = 0; k < ptn.length; k++) {
                if (key.indexOf(ptn) >= 0) {
                    foundPattern = true;
                    break;
                }
            }
        } else {
            foundPattern = key.indexOf(ptn) >= 0;
        }
        return foundPattern;
    };

    var _removeData = function (pattern, patternToIgnore) {

        for (var i = localStorage.length - 1; i >= 0; i--) {
            var key = localStorage.key(i);
            if (_hasAllPatterns(key, pattern) && (!patternToIgnore || (patternToIgnore && !_hasPattern(key, patternToIgnore) ))) {
                if (cachedData[key]) {
                    delete cachedData[key];
                }
                localStorage.removeItem(key);
            }

        }
    };

    var _removeDataByKey = function (key) {

        if (cachedData[key]) {
            delete cachedData[key];
        }

        localStorage.removeItem(key);
    };

    //endregion

    var colorIndexMap = {};

    var _getColorGradients = function(){
        return Highcharts.theme && Highcharts.theme.colorGradients;
    };

    var _getDefaultDownColor = function(){
        return Highcharts.theme && Highcharts.theme.red && Highcharts.theme.red[0] || '#f00';
    };

    var _getDefaultUpColor = function(){
        return Highcharts.theme && Highcharts.theme.green && Highcharts.theme.green[0] || '#0f0';
    };

    var _getSeriesColors = function(){
        return Highcharts.theme && Highcharts.theme.seriesColorMap || ["#fbf201", "#00aeff", "#ff15af", "#8aff00", "#9f37ff", "#FFA519"];
    };

    var _getNextSeriesColor = function(chartId){
        if(!colorIndexMap.hasOwnProperty(chartId)){
            colorIndexMap[chartId] = 0;
        }
        var colors = _getSeriesColors();

        var colorMapLength = colors.length;
        var indexOfColorMap = colorIndexMap[chartId] % colorMapLength;
        colorIndexMap[chartId]++;
        return colors[indexOfColorMap];
    };

    var _sendAjax = function (url, dataType, onSuccess, onError, scope) {
        $.ajax({
            url: url,
            dataType: dataType,
            context: scope,
            beforeSend: function (xhr) {
                if (window.keycloak) {
                    xhr.setRequestHeader('Authorization', 'Bearer ' + window.keycloak.token);
                }
            },
            success: function (dataObj) {
                onSuccess.call(scope, dataObj);
            },
            error: function (xhr, ajaxOptions, thrownError) {
                _console.log('error : ' + thrownError);
                onError.call(scope, []);
            }
        });
    };

    var _num2Log = function (num) {
        if (num !== 0) {
            return Math.log(num) / Math.LN10;
        }
        return 0;
    };

    var _log2Num = function (num) {
        return Math.pow(10, num);
    };

    var _isDOMNode = function (v) {
        if (v === null) return false;
        if (typeof v !== 'object') return false;
        if (!('nodeName' in v)) return false;
        var nn = v.nodeName;
        try {
            v.nodeName = 'is readonly?';
        }
        catch (e) {
            return true;
        }
        if (v.nodeName === nn) return true;
        v.nodeName = nn;
        return false;
    };
    /* TODO :: find out a proper way of implementing a common method to do merge and $.extend in one method
     var _mergeWrapping = function( dst, propetry, dstFunction, mergeListener){
     dst[propetry] = function() {
     var result = dstFunction.call(this, arguments);
     return mergeListener.call(this, arguments, result);
     }
     };

     var _merge = function () {
     // _mergeRecursive does the actual job with two arguments.
     var _mergeRecursive = function (dst, src) {
     if (_isDOMNode(src) || typeof src !== 'object' || src === null) {
     return dst;
     }

     for (var p in src) {

     ////my added bit here - [SB]
     //        if ($.isArray(src[p])){
     //            $.merge(dst[p],src[p]);
     //            var dupes = {},
     //                singles = [];
     //            $.each(  dst[p], function(i, el) {
     //                if ((dupes[el.name] > -1) &&  (el.name)) {
     //                    $.extend(singles[dupes[el.name]],el);
     //                }else{
     //                    if (el.name ){
     //                        dupes[el.name] = i;
     //                    }
     //                    singles.push(el);
     //                }
     //            });
     //            dst[p] = singles;
     //            continue;
     //        }


     //the rest is original - [SB]

     if (!src.hasOwnProperty(p)) continue;
     if (src[p] === undefined) continue;
     if (p == "infmerge") continue;

     if ( typeof src[p] !== 'object' || src[p] === null || src[p].constructor === Array ) {
     if ( ( !dst.infmerge || !dst.infmerge.avoidReplace || dst.infmerge.avoidReplace.indexOf(p) < 0) /!*&& src.skipWrap && src.skipWrap.indexOf(p)>=0*!/){
     dst[p] = src[p]
     } else if(typeof dst[p] == 'function'){
     if( typeof src[p] == "function"){
     if(!dst.infmerge){
     dst["result"] = { };
     }

     if(!dst.infmerge.listeners) {
     dst.infmerge.listeners = src[p];
     _mergeWrapping(dst, p, dst[p], src[p]);
     } else {
     dst.infmerge.listeners = src[p];
     }

     } else {
     dst[p] = src[p];
     }

     }
     }
     else if (typeof dst[p] !== 'object' || dst[p] === null) {
     dst[p] = _mergeRecursive(src[p].constructor === Array ? [] : {}, src[p]);
     } else {
     _mergeRecursive(dst[p], src[p]);
     }
     };
     return dst;
     };

     // Loop through arguments and merge them into the first argument.
     var out = arguments[0];
     if (typeof out !== 'object' || out === null) return out;
     for (var i = 1, il = arguments.length; i < il; i++) {
     _mergeRecursive(out, arguments[i]);
     }
     return out;
     };*/

    var _merge = function () {
        // _mergeRecursive does the actual job with two arguments.
        var _mergeRecursive = function (dst, src) {
            if (_isDOMNode(src) || typeof src !== 'object' || src === null) {
                return dst;
            }

            for (var p in src) {

                ////my added bit here - [SB]
                //        if ($.isArray(src[p])){
                //            $.merge(dst[p],src[p]);
                //            var dupes = {},
                //                singles = [];
                //            $.each(  dst[p], function(i, el) {
                //                if ((dupes[el.name] > -1) &&  (el.name)) {
                //                    $.extend(singles[dupes[el.name]],el);
                //                }else{
                //                    if (el.name ){
                //                        dupes[el.name] = i;
                //                    }
                //                    singles.push(el);
                //                }
                //            });
                //            dst[p] = singles;
                //            continue;
                //        }


                //the rest is original - [SB]


                if (!src.hasOwnProperty(p)) continue;
                if (src[p] === undefined) continue;
                if (typeof src[p] !== 'object' || src[p] === null || src[p].constructor === Array) {
                    dst[p] = src[p];
                }
                else if (typeof dst[p] !== 'object' || dst[p] === null) {
                    dst[p] = _mergeRecursive(src[p].constructor === Array ? [] : {}, src[p]);
                } else if (dst[p].constructor === Array && src[p].constructor !== Array) {
                    dst[p] = src[p];
                } else {
                    _mergeRecursive(dst[p], src[p]);
                }
            }

            return dst;
        };

        // Loop through arguments and merge them into the first argument.
        var out = arguments[0];
        if (typeof out !== 'object' || out === null) return out;
        for (var i = 1, il = arguments.length; i < il; i++) {
            _mergeRecursive(out, arguments[i]);
        }
        return out;
    };

    var _isToday = function (dateTime) {
        var today = new Date();
        return (dateTime && dateTime.getFullYear() == today.getFullYear() && dateTime.getMonth() == today.getMonth() && dateTime.getDate() == today.getDate());
    };

    var _getLastDayOfWeek = function (time, onlyPastOrCurrentTime) {
        var date = new Date(time);
        var first = date.getDate() - date.getDay();
        /* First day is the day of the month - the day of the week */
        var last = first + 6;
        /* last day is the first day + 6 */

        date.setDate(last);
        var currentDate = new Date();
        if (onlyPastOrCurrentTime && date.getTime() > currentDate.getTime()) {
            date = currentDate;
        }
        return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);
    };

    var _getFirstDayOfWeek = function (time) {
        var date = new Date(time);
        var first = date.getDate() - date.getDay() + 1;
        date.setDate(first);
        return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);
    };

    var _getLastDayOfMonth = function (time, onlyPastOrCurrentTime) {
        var date = new Date(time);
        date.setDate(1);
        date.setMonth(date.getMonth() + 1);
        date.setDate(date.getDate() - 1);
        var currentDate = new Date();
        if (onlyPastOrCurrentTime && date.getTime() > currentDate.getTime()) {
            date = currentDate;
        }
        return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);
    };

    var _getFirstDayOfMonth = function (time) {
        var date = new Date(time);
        date.setDate(1);
        date.setMonth(date.getMonth());
        return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);
    };

    var _getLastDayOfYear = function (time, onlyPastOrCurrentTime) {
        var date = new Date(time);
        date.setMonth(11);
        date.setDate(31);
        var currentDate = new Date();
        if ( onlyPastOrCurrentTime && date.getTime() > currentDate.getTime()) {
            date = currentDate;
        }
        return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);
    };

    var _getFirstDayOfYear = function (time) {
        var date = new Date(time);
        date.setMonth(0);
        date.setDate(1);
        return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);
    };

    var _setPopupLocation = function (popup, position) {

        var left = position.left;
        var top = position.top;
        popup.attr('top', top);
        popup.attr('left', left);

    };

    var _getPopupLocation = function (chartContainerId, popup) {
        var top = popup.attr('top');
        var left = popup.attr('left');
        var container = $("#" + chartContainerId);
        if ((top == undefined || left == undefined) && container) {
            var popupWidth = popup.width();
            var popupHeight = popup.width();
            var containerWidth = container.width();
            var containerHeight = container.height();
            left = (left == undefined) ? (containerWidth - popupWidth) > 200 ? 200 : (containerWidth - popupWidth) / 2 : left;
            top = (top == undefined) ? (containerHeight - popupHeight) > 200 ? 200 : (containerHeight - popupHeight) / 2 : top;

        } else {
            top = (top == undefined ) ? 200 : parseInt(top);
            left = (left == undefined ) ? 200 : parseInt(left);
        }

        return {
            'top': top,
            'left': left
        }
    };

    var _console = {

        log: function (msg) {
            if (typeof console != "undefined" && (typeof window.logMode === 'undefined' || window.logMode == "debug")) {
                console.log(msg);
            }
        },
        error: function (msg, ex) {
            if (typeof console != "undefined" && (typeof window.logMode === 'undefined' || window.logMode == "debug")) {
                console.error(msg);
                if (ex) {
                    console.error(ex);
                }
            }
        },
        info: function (msg) {
            if (typeof console != "undefined" && (typeof window.logMode === 'undefined' || window.logMode == "debug")) {
                console.info(msg);
            }
        },
        debug: function (proto, msg) {
            console.debug(((proto.name && proto.name()) || "") + ">" + msg);
        }
    };

    var _getNavigatorHeight = function (chartHeight, config) {
        var navH = config.navigator.height,
            scrollH = (navH && navH > config.navigator.infMinHeight && navH < config.navigator.infMaxHeight) ? navH : chartHeight * 0.1;
        scrollH = Math.min(scrollH, config.navigator.infMaxHeight);
        scrollH = Math.max(scrollH, config.navigator.infMinHeight);
        return scrollH;
    };

    var _getColorFromColorObj = function (colorObj, type) {
        return (colorObj && colorObj.stops && colorObj.stops.length > 1) ? colorObj.stops[type == "up" ? 0 : 1][1] : colorObj;
    };

    /**
     * @ngdoc function
     * @name isIEBelow10
     * @description Checks whether current browser is IE and of version below 10
     */
    var _isIEBelow10 = function () {
        var myNav = navigator.userAgent.toLowerCase();
        return (myNav.indexOf('msie') != -1) ? parseInt(myNav.split('msie')[1]) < 10 : false;
    };

    /**
     * @ngdoc function
     * @name isIEBelow10
     * @description Checks whether current browser is IE and of version below 10
     */
    var _isIE = function () {
        var myNav = navigator.userAgent.toLowerCase();
        return (myNav.indexOf('msie') != -1 || (navigator.appName == "Netscape" && (!!navigator.userAgent.match(/Trident.*rv\:11\./) || (!!navigator.userAgent.match(/Edge/)))));
    };

    /**
     * @ngdoc function
     * @name isSafari
     * @description Checks whether current browser is Safari
     */
    var _isSafari = function () {
        var myNav = navigator.userAgent.toLowerCase();
        return (myNav.indexOf('safari') != -1 && myNav.indexOf('chrome') == -1);
    };

    /**
     * @ngdoc function
     * @name getIEVersion
     * @description Returns the version of IE browser
     * @returns {number}
     */
    var _getIEVersion = function () {
        var rv = -1; // Return value assumes failure.
        var myNav = navigator.userAgent.toLowerCase();
        if (myNav.indexOf('msie') != -1) {

            var ua = navigator.userAgent,
                re = new RegExp("msie ([0-9]{1,}[\\.0-9]{0,})");

            if (re.exec(ua) !== null) {
                rv = parseFloat(RegExp.$1);
            }
        }
        else if (navigator.appName == "Netscape" && !!navigator.userAgent.match(/Trident.*rv\:11\./)) {
            /// in IE 11 the navigator.appVersion says 'trident'
            /// in Edge the navigator.appVersion does not say trident
            if (navigator.appVersion.indexOf('Trident') === -1) rv = 12;
            else rv = 11;
        }

        return rv;
    };

    /**
     * Save given canvas as a blob
     * @param canvas
     * @param type
     * @private
     */
    var _saveCanvasAsBlob = function (canvas, type) {
        window.BlobBuilder = window.BlobBuilder || window.MSBlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        canvas.toBlob = canvas.toBlob || canvas.msToBlob;
        window.navigator.saveBlob = window.navigator.saveBlob || window.navigator.msSaveBlob;

        if (window.BlobBuilder && canvas.toBlob && window.navigator.saveBlob) {
            var extensionlessFilename = "chart";
            var filename = extensionlessFilename + "." + type;
            var blobBuilderObject = new BlobBuilder(); // Create a blob builder object so that we can append content to it.

            blobBuilderObject.append(canvas.toBlob()); // Append the user's drawing in PNG format to the builder object.
            window.navigator.saveBlob(blobBuilderObject.getBlob(), filename); // Move the builder object content to a blob and save it to a file.
        }
    };

    ///**
    // * Check whether chart is in fullscreen mode or not
    // * @returns {*}
    // * @private
    // */
    //var _isFullscreenMode = function () {
    //    return window.fullScrn;//todo : remove this global variable
    //};

    /**
     * todo : refactor & move to structure
     * Display given message
     * @param chartId
     * @param msg
     * @param timeout
     * @private
     */
    var _showMessage = function (chartId, msg, timeout, title, width) {
        /*   var container = $('#' + chart.id).find("div[inf-container=msg_container]");
         var html = '<div id="myModal" class="modal fade" role="dialog">' +
         '<div class="modal-dialog">' +
         '<div class="modal-content chart-message-pop-up">' +
         '<div class="modal-header">' +
         '<button type="button" class="close" data-dismiss="modal">&times;</button>' +
         '<h4 class="modal-title">Message</h4>' +
         '</div>' +
         '<div class="drawing_popup_row">' +
         '<ol class="o_list ui-selectable">'+'</ol>' +
         '</div>' +
         '<div class="modal-body">' +
         '<p>'+msg+'</p>' +
         '</div>' +
         '<div class="modal-footer">' +
         '<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>' +
         '</div>' +
         '</div>' +
         '</div>' +
         '</div>';
         var fileActionPopup = $(html).appendTo(container);
         fileActionPopup.modal({'show': true, 'backdrop' : true});*/
        _createDialog(chartId + "_msg", '<p>' + msg + '</p>', true, true, title ? title : 'Message', true, true, true,
            ['<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>'], timeout, "", width);
    };

    /**
     * Create a dialog with given options
     * todo : refactor & move to structure
     * @param id
     * @param body
     * @param header
     * @param footer
     * @param title
     * @param close
     * @param backdrop
     * @param show
     * @param btns
     * @param timeout
     * @param wrapperCls
     * @param width
     * @param bodyCls
     * @private
     */
    var _createDialog = function (id, body, header, footer, title, close, backdrop, show, btns, timeout, wrapperCls, width, bodyCls) {
        var container = $(document.body);// $('#' + chart.id).find("div[inf-container=msg_container]");
        var popup = $('#' + id);
        if (popup && popup.length > 0) {
            popup.remove();
        }

        wrapperCls = wrapperCls ? wrapperCls : '';
        width = width ? 'width:' + width + 'px;' : '';
        bodyCls = bodyCls ? bodyCls : '';
        var html = '<div id="' + id + '" class="modal mobile-popup fade in solid-modal" role="dialog">' +
            '<div class="modal-dialog modal-sm"  style="' + width + '"> <div class="modal-content chart-message-pop-up' + wrapperCls + '">';
        if (header && typeof header != "string") {
            html += '<div class="modal-header">' +
                (close ? '<button type="button" class="close" data-dismiss="modal"><i class="icon ico-close"></i></button>' : '') +
                '<h4 class="modal-title">' + title + '</h4>' +
                '</div>';
        } else if (header) {
            html += '<div class="modal-header">' +
                header +
                '</div>';
        }
        html += '<div class="modal-body ' + bodyCls + '">' +
            body +
            '</div>';
        if (footer && typeof footer != "string") {
            html += '<div class="modal-footer">';
            if (btns && btns.length > 0) {
                btns.forEach(function (val) {
                    html += val;
                });
            }
            html += '</div>';
        } else if (footer) {
            html += '<div class="modal-footer">' +
                footer + '</div>';
        }

        html += '</div>' + '</div>' +
            '</div>';

        var fileActionPopup = $(html).appendTo(container);

        if (timeout && !isNaN(timeout)) {
            fileActionPopup.on('shown.bs.modal', function () {
                window.setTimeout(function () {
                    fileActionPopup.modal("hide");
                }, timeout);
            });
        }
        fileActionPopup.modal({'show': !!show, 'backdrop': !!backdrop});

        return fileActionPopup;
    };

    var _setCursor = function (container, cursorType) {
        $(container).removeClass(function (index, className) {
            if (className) {
                return (className.match(/(^|\s)cursor-\S+/g) || []).join(' ');
            } else {
                return ' ';
            }
        });
        var cls = 'cursor-default';
        switch (cursorType) {
            case 'block' :
                cls = 'cursor-block';
                break;
            case 'move' :
                cls = 'cursor-move';
                break;
            case 'del' :
                cls = 'cursor-del';
                break;
            default :
                break;
        }
        $(container).addClass(cls);
    };

    var _escapeSpecialCharacters = function (text) {
        return text.replace(/[!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
    };

    var _getRawValue = function (value) {
        value = value + "";
        if (value.indexOf('M') > 0) {
            returnVal = parseFloat(value.replaceAll(',', '')) * 1000000;
        } else {
            returnVal = value.replaceAll(',', '');
        }
        return returnVal = parseFloat(returnVal);
    };

    /**
     * search array of objects/arrays for given search value using binary search algorithm
     * @param arr
     * @param searchValue
     * @param objectKey
     * @returns {*}
     * @private
     */
    var _binarySearch = function (arr, searchValue, objectKey) {
        var mid = Math.floor(arr.length / 2);

        if (arr.length == 1) {
            return {
                val: arr[0],
                direction: arr[mid][objectKey] === searchValue ? 0 : arr[mid][objectKey] < searchValue ? +1 : -1
            };
        } else if (arr[mid][objectKey] === searchValue) {
            return {
                val: arr[mid],
                direction: arr[mid][objectKey] === searchValue ? 0 : arr[mid][objectKey] < searchValue ? +1 : -1
            };
        } else if (arr[mid][objectKey] < searchValue && arr.length > 1) {
            return _binarySearch(arr.slice(mid, Number.MAX_VALUE), searchValue, objectKey);
        } else if (arr[mid][objectKey] > searchValue && arr.length > 1) {
            return _binarySearch(arr.slice(0, mid), searchValue, objectKey);
        } else {
            return {direction: -1};
        }

    };

    var _getSeriesPointByTime = function (series, time) {
        return _binarySearch(series.points, time, "x").val;
    };

    var _getEventPositions = function (e) {
        // iOS (#2757)
        return e.touches ? (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;
    };

    //removed as this is overridden by the method below
    //var _bindEvent = function (eventType, element, callback, touchAndMouse) {
    //    var H = Highcharts,
    //        removeEvents = [],
    //        addDefault = false;
    //
    //    if (Highcharts.hasTouch) {
    //        switch (eventType) {
    //            case 'click':
    //                removeEvents.push(H.addEvent(element, 'touchstart', callback));
    //                break;
    //            case 'mousedown' :
    //                removeEvents.push(H.addEvent(element, 'touchstart', callback));
    //                break;
    //            case 'mouseup' :
    //                removeEvents.push(H.addEvent(element, 'touchend', callback));
    //                break;
    //            case 'mousemove' :
    //                removeEvents.push(H.addEvent(element, 'touchmove', callback));
    //                break;
    //            default :
    //                addDefault = true;
    //                break;
    //        }
    //
    //    }
    //
    //    if (addDefault || touchAndMouse) {
    //        removeEvents.push(H.addEvent(eventType, callback));
    //    }
    //    if (!element.infRemoveEvents) {
    //        element.infRemoveEvents = [];
    //    }
    //    element.infRemoveEvents = element.infRemoveEvents.concat(removeEvents);
    //    return removeEvents;
    //};

    var _getTouchEvent = function (eventType) {

        var touchEvent;

        switch (eventType) {
            case 'click':
                touchEvent = 'touchstart';
                break;
            case 'mousedown' :
                touchEvent = 'touchstart';
                break;
            case 'mouseup' :
                touchEvent = 'touchend';
                break;
            case 'mousemove' :
                touchEvent = 'touchmove';
                break;
            default :
                break;
        }
        return touchEvent;
    };

    var _bindEvent = function (element, eventType, callback, touchAndMouse, unbindPrevious) {
        var H = Highcharts,
            removeEvents = [],
            touchEvent;

            H.hasTouch = false;
        if (H.hasTouch) {
            touchEvent = _getTouchEvent(eventType);
            if (touchEvent) {
                if (!element.length) {
                    if (unbindPrevious) {
                        H.removeEvent(element, touchEvent);
                    }
                    removeEvents.xPush(H.addEvent(element, touchEvent, callback));
                } else {
                    element.off(touchEvent);
                    element.on(touchEvent, callback);
                }
            }
        }

        if (!touchEvent || touchAndMouse) {
            if (!element.length) {
                if (unbindPrevious) {
                    H.removeEvent(element, eventType);
                }
                removeEvents.xPush(H.addEvent(element, eventType, callback));
            } else {
                element.off(eventType);
                element.on(eventType, callback);
            }
        }
        return removeEvents;
    };

    var _unbindEvent = function (element, eventType, callback) {
        var H = Highcharts;

        if (H.hasTouch) {
            switch (eventType) {
                case 'click':
                    H.removeEvent(element, 'touchstart', callback);
                    break;
                case 'mousedown' :
                    H.removeEvent(element, 'touchstart', callback);
                    break;
                case 'mouseup' :
                    H.removeEvent(element, 'touchend', callback);
                    break;
                case 'mousemove' :
                    H.removeEvent(element, 'touchmove', callback);
                    break;
                default :
                    break;
            }

        }

        H.removeEvent(element, eventType, callback);
    };

    var _precisionRound = function (number, precision) {
        var factor;
        if (precision > 0) {
            //factor = Math.pow(10, Math.abs(Math.log10(precision)));
            var power = Math.floor(Math.log(precision) / Math.LN10);


            factor = Math.pow(10, Math.floor(Math.log(precision) / Math.LN10));
            var val = Math.round(number / factor) * factor;
            if (power < 0) {
                val = parseFloat(val).toFixed(Math.abs(power));
            } else {
                val = parseFloat(val).toFixed(0);
            }
            return +val;

        } else {
            factor = Math.pow(10, Math.floor(Math.log(precision) / Math.LN10));
            return Math.round(number * factor) / factor;

        }
    };

    var _getDerivedDate = function (time) {
        var dt = Highcharts.dateFormat('%Y-%m-%d-%H-%M-%S-%L', time).split('-');
        return {
            year: +dt[0],
            month: +dt[1] - 1,
            day: +dt[2],
            hour: +dt[3],
            minute: +dt[4],
            second: +dt[5],
            milliSecond: +dt[6]
        };
    };

    var _getDummySeriesConfig = function (type) {
        switch (type) {
            case infChart.constants.dummySeries.forwardId:
            case infChart.constants.dummySeries.backwardId:
                return {
                    data: [],
                    'id': type,
                    'type': 'line',
                    'name': type,
                    'infType': "dummy",
                    'showInNavigator': false,
                    'showInLegend': true
                };
            default :
                return {
                    'data': [],
                    'id': type,
                    'type': 'line',
                    'name': "Empty",
                    'infType': "dummy",
                    'showInNavigator': false,
                    'showInLegend': true
                };
        }
    };

    var _getOpacityFromRGBA = function (rgba) {
        var obj = rgba && rgba.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+(\.\d{1,2})?|\.\d{1,2})[\s+]?/i);
        return obj && obj[4];
    };

    var _getLoadingMessage = function(){
        var fn =  infChart.settings && infChart.settings.registeredMethods && infChart.settings.registeredMethods.loadingMessage || function(){
                return "<div class='loading-icon'><div class='loader'></div></div>";
            };
        return fn.call(this);
    };

    var _formatNumber = function(val, dp){
        return Highcharts.numberFormat(val, dp);
    };

    var _formatDate = function(val, pattern){
        return Highcharts.dateFormat(pattern, val);
    };

    var _getBaseURL = function(){
        var H = Highcharts,
            newUrl = (H.isFirefox || H.isWebKit) && H.doc.getElementsByTagName('base').length ?
            H.win.location.href
                .replace(/#.*?$/, '') // remove the hash
                .replace(/<[^>]*>/g, '') // wing cut HTML
                .replace(/([\('\)])/g, '\\$1') // escape parantheses and quotes
                .replace(/ /g, '%20') : // replace spaces (needed for Safari only)
            '';
        return newUrl;
    };

    /**
     * Return the list of class classes and its contents which contains one or more given values
     * @param classNames [Array]
     * @returns {{}}
     * @private
     */
     var _getStylesWithCls = function(classNames) {
        var styleSheets = document.styleSheets,
            classes,
            clsMap = {};

        if(Array.isArray(classNames)) {
            for (var i = 0; i < styleSheets.length; i++) {
                if(!styleSheets[i].href || styleSheets[i].href.startsWith(window.location.origin)) {
                    classes = styleSheets[i].rules || styleSheets[i].cssRules;

                    for (var x = 0; x < classes.length; x++) {
                        if (classes[x].selectorText && classNames.infContainsItemsIn(classes[x].selectorText)) {
                            clsMap[classes[x].selectorText] = classes[x].cssText || classes[x].style.cssText;
                        }
                    }
                }
            }
        }
        return clsMap;
    };

    /**
     * Apply numeric symbols if applicable
     * @param retVal
     * @param dp
     * @returns {*}
     * @private
     */
    var _formatWithNumericSymbols = function(retVal, dp){
        var numericSymbols = ['k', 'M', 'G', 'T', 'P', 'E'],
            hasNumeric = false;
        // Decide whether we should add a numeric symbol like k (thousands) or M (millions).
        // If we are to enable this in tooltip or other places as well, we can move this
        // logic to the numberFormatter and enable it by a parameter.
        var i = numericSymbols.length, ret, multi;
        while (i-- && ret === undefined) {
            multi = Math.pow(1000, i + 1);
            if ( (retVal) / multi > 1 && numericSymbols[i] !== null) {
                ret = retVal / multi;
                ret = infChart.util.formatNumber(ret, 1);
                ret = ret + numericSymbols[i];
                hasNumeric = true;
            }
        }

        if (!hasNumeric) {
            ret = infChart.util.formatNumber(retVal, dp);
        }
        return ret;
    };

    var _isDefined = function(value) {
        return !isNaN(value) && value != null;
    };

    /**
    * copy the text to clipboard from fib levels
    * @param {String} label - The selected levels value to be copied.
    */
    var _copyToClipBoard = function (label) {
        navigator.clipboard.writeText(label);
    };
    
    /**
     * Wrap a method with extended functionality, preserving the original function.
     *
     * @function #wrap
     * @param {Object} obj - The context object that the method belongs to. In real
     *        cases, this is often a prototype.
     * @param {String} method - The name of the method to extend.
     * @param {Function} func - A wrapper function callback. This function is called
     *        with the same arguments as the original function, except that the
     *        original function is unshifted and passed as the first argument.
     *
     */
    var wrap = function (obj, method, func) {
        var proceed = obj[method];
        obj[method] = function () {
            var args = Array.prototype.slice.call(arguments),
                outerArgs = arguments,
                ctx = this,
                ret;
            ctx.proceed = function () {
                proceed.apply(ctx, arguments.length ? arguments : outerArgs);
            };
            args.unshift(proceed);
            ret = func.apply(this, args);
            ctx.proceed = null;
            return ret;
        };
    };

    /**
     * get symbol display name
     * @param {Object} symbol
     * @returns {string} symbol display name
     */
    var _getSymbolDisplayName = function (symbol) {
        return symbol.legendLabel ? symbol.legendLabel : symbol.symbolDesc ? symbol.symbolDesc : (symbol.symbol + (symbol.exchange ? ("." + symbol.exchange) : ""))
    };

    /**
     * Get candle data for given point index
     * @param chart
     * @param index
     * @returns {[*, *, *, *]}
     * @private
     */
    var _getCandleData = function (chart, index) {
        var chartObj = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id));
        var rangeData = chartObj.rangeData.ohlcv;
        var openDataPoint, highDataPoint, lowDataPoint, closeDataPoint;
        if (rangeData['o']) {
            openDataPoint = rangeData['o'][index]
        }
        if (rangeData['h']) {
            highDataPoint = rangeData['h'][index]
        }
        if (rangeData['l']) {
            lowDataPoint = rangeData['l'][index]
        }
        if (rangeData['c']) {
            closeDataPoint = rangeData['c'][index]
        }
        return [openDataPoint, highDataPoint, lowDataPoint, closeDataPoint]
    };

    return {
        wrap: wrap,
        isEmpty: _isEmpty,
        handleException: _handleException,
        //authenticate: _authenticate,
        extend: _extend,
        generateUUID: _generateUUID,
        //getIndicatorDescLabel: _getIndicatorDescLabel,
        getThousandSeparator: _getThousandSeparator,
        isLegendAvailable: _isLegendAvailable,
        //getLegendTitle: _getLegendTitle,
        //getTooltipSymbolRowValue: _getTooltipSymbolRowValue,
        //getTooltipRowValue: _getTooltipRowValue,
        //getTooltipBaseValue: _getTooltipBaseValue,
        //getTooltipDateValue: _getTooltipDateValue,
        calculateChange: _calculateChange,
        isSeriesInBaseAxis: _isSeriesInBaseAxis,
        isSeriesParallelToBaseAxis: _isSeriesParallelToBaseAxis,
        bindColorPicker: _bindColorPicker,
        binaryIndexOf: _binaryIndexOf,
        getDateStringFromTime: _getDateStringFromTime,
        getUserName: _getUserName,
        saveData: _saveData,
        getData: _getData,
        removeData: _removeData,
        bindDragEvents: _bindDragEvents,
        sendAjax: _sendAjax,
        num2Log: _num2Log,
        //log2Num: _log2Num,
        merge: _merge,
        isToday: _isToday,
        getLastDayOfWeek: _getLastDayOfWeek,
        getLastDayOfMonth: _getLastDayOfMonth,
        getLastDayOfYear: _getLastDayOfYear,
        getFirstDayOfWeek: _getFirstDayOfWeek,
        getFirstDayOfMonth: _getFirstDayOfMonth,
        getFirstDayOfYear: _getFirstDayOfYear,
        //getTooltipNews: _getTooltipNews,
        //getTooltipFlags: _getTooltipFlags,
        //setPopupPosition: _setPopupLocation,
        //getPopupPosition: _getPopupLocation,
        getNavigatorHeight: _getNavigatorHeight,
        //legendReference: _legendReference,
        console: _console,
        getColorFromColorObj: _getColorFromColorObj,
        rgbString2hex: _rgbString2hex,
        isIEBelow10: _isIEBelow10,
        isIE: _isIE,
        saveCanvasAsBlob: _saveCanvasAsBlob,
        getIEVersion: _getIEVersion,
        isSafari: _isSafari,
        //isFullscreenMode: _isFullscreenMode,
        showMessage: _showMessage,
        setCursor: _setCursor,
        escapeSpecialCharacters: _escapeSpecialCharacters,
        getRawValue: _getRawValue,
        getSeriesPointByTime: _getSeriesPointByTime,
        //createDialog: _createDialog,
        //getEventPositions: _getEventPositions,
        bindEvent: _bindEvent,
        unbindEvent: _unbindEvent,
        precisionRound: _precisionRound,
        getDerivedDate: _getDerivedDate,
        getDummySeriesConfig: _getDummySeriesConfig,
        getDateAndTimeStringFromTime: _getDateAndTimeStringFromTime,
        hasAllPatterns: _hasAllPatterns,
        hasPattern: _hasPattern,
        removeDataByKey: _removeDataByKey,
        forEach: _forEach,
        getOpacityFromRGBA: _getOpacityFromRGBA,
        getLoadingMessage : _getLoadingMessage,
        formatNumber : _formatNumber,
        formatDate : _formatDate,
        getColorGradients: _getColorGradients,
        getDefaultUpColor: _getDefaultUpColor,
        getDefaultDownColor: _getDefaultDownColor,
        getSeriesColors : _getSeriesColors,
        getNextSeriesColor : _getNextSeriesColor,
        getBaseURL : _getBaseURL,
        getStylesWithCls : _getStylesWithCls,
        formatWithNumericSymbols : _formatWithNumericSymbols,
        isDefined : _isDefined,
        getSymbolDisplayName: _getSymbolDisplayName,
        hideColorPicker: _hideColorPicker,
        dragFix: _dragFix,
        getCandleData: _getCandleData,
        copyToClipBoard: _copyToClipBoard
    }

})(jQuery, Highcharts, infChart);

infChart.math = (function(){

    /**
     * calculate linear regression
     * we use startYValue and startXValue as the reference i.e. to normalize the chart for the given x range(startYValue and startXValue will be 0,0)
     * @param {Highchart} chart
     * @param {*} startYValue
     * @param {*} startXValue
     * @param {*} endXValue
     * @param {number} [seriesIndex = 0] the series index to which regression is calculated
     */
    var calculateLinearRegression = function(chart, startYValue, startXValue, endXValue, seriesIndex){
        var series = chart.series[seriesIndex ? seriesIndex : 0];
        var sum = [0, 0, 0, 0, 0],
            n = 0,
            data = series.currentDataGrouping ? series.groupedData : series.data,
            compareValue = series.userOptions.compare && series.compareValue || 0,
            length = data.length,
            dataLength = 0,
            xAxis = series.xAxis,
            yAxis = series.yAxis,
            refX = xAxis.toPixels(startXValue),
            refY = yAxis.toPixels(startYValue),
            xDiffInPixels = xAxis.toPixels(endXValue) - xAxis.toPixels(startXValue),
            periodDataPoints = [];

        for (; n < length; n++) {
            var point = data[n];
            if (point && point.x >= startXValue && point.x <= endXValue) {
                var x = xAxis.toPixels(point.x) - refX;
                var y = (compareValue ? yAxis.toPixels((point.y / compareValue - 1) * 100) : yAxis.toPixels(point.y)) - refY ;
                sum[0] += x; //(X)
                sum[1] += y; //(Y)
                sum[2] += x * x; //(X^2)
                sum[3] += x * y; //(XY)
                sum[4] += y * y; //(Y^2)
                periodDataPoints.push({'x' : x, 'y' : y});
                dataLength++;
            }
        }

        var gradient, intercept, startPointY, endPointY;
        if(dataLength > 0) {
            gradient = (dataLength * sum[3] - sum[0] * sum[1]) / (dataLength * sum[2] - sum[0] * sum[0]);
            intercept = (sum[1] / dataLength) - (gradient * sum[0]) / dataLength;

            startPointY = intercept;
            endPointY = xDiffInPixels * gradient + intercept;
        }

        return {
            'calcData': {
                'points': periodDataPoints,
                'gradient': gradient,
                'intercept': intercept
            },
            'startPointY': startPointY,
            'endPointY': endPointY
        };
    };

    var calculateRegressionChannel = function(regressionPoints, startPointY, endPointY){
        var dataLength = regressionPoints.length,
            i = 0,
            j = 0,
            total = 0,
            diffSquaredSum = 0,
            relativePriceData = [];

        for (i; i < dataLength; i++) {
            relativePriceData.push(regressionPoints[i].y);
            total += (regressionPoints[i].y);
        }

        var mean = total / dataLength;

        for (j; j < relativePriceData.length; j++) {
            diffSquaredSum += Math.pow((relativePriceData[j] - mean), 2);
        }

        var standardDeviation = Math.sqrt(diffSquaredSum / dataLength);

        return {
            'upper': {
                startPointY: startPointY - standardDeviation,
                endPointY: endPointY - standardDeviation

            },
            'lower': {
                startPointY: startPointY + standardDeviation,
                endPointY: endPointY + standardDeviation
            }
        };
    };

    /**
     * Find the nearest x data index for given x value
     * @param seriesData chart series
     * @param xValue of given point on the chart
     * @returns {number|*}
     */
    var findNearestXDataPointIndex = function (seriesData, xValue) {
        var indexOfNearestXValueIndex = infChart.util.binaryIndexOf(seriesData, undefined, xValue);

        if(indexOfNearestXValueIndex < 0) {
            var absIndex = Math.abs(indexOfNearestXValueIndex);

            if(absIndex >= seriesData.length) {
                absIndex = seriesData.length - 1;
            }

            var rangeMaxValue = seriesData[absIndex];
            var rangeMinValue = seriesData[absIndex - 1];

            if(xValue >  (((rangeMaxValue - rangeMinValue) / 2) + rangeMinValue)) {
                indexOfNearestXValueIndex = absIndex;
            } else {
                indexOfNearestXValueIndex = absIndex - 1;
            }
        }

        return indexOfNearestXValueIndex;
    }

    /**
     * Find the nearest x data value for given x value
     * @param chart object
     * @param xValue of given point on the chart
     * @param seriesIndex of relevant data series
     * @param useAllXDataToFindNearestPoint use full series data to search the nearest x date point
     * @param useFutureDate use future date to calculate nearest point
     * @return {*}
     */
    var findNearestXDataPoint = function (chart, xValue, seriesIndex, useAllXDataToFindNearestPoint, useFutureDate) {
        return findNearestDataPoint(chart, xValue, seriesIndex, useAllXDataToFindNearestPoint, useFutureDate).xData;
    }



    /**
     * Find the nearest data point for given x value
     * @param chart object
     * @param xValue of given point on the chart
     * @param seriesIndex of relevant data series
     * @param useAllXDataToFindNearestPoint use full series data to search the nearest x date point
     * @param useFutureDate use future date to calculate nearest point
     * @return {*}
     */
    var findNearestDataPoint = function (chart, xValue, seriesIndex, useAllXDataToFindNearestPoint, useFutureDate) {
        var indexOfNearestXValueIndex;
        var yData;
        var nearestYData;
        var nearestXValue;
        var nearestYValue;
        var series = chart.series[seriesIndex ? seriesIndex : 0];
        var seriesXData = useAllXDataToFindNearestPoint ? series.xData : series.processedXData;
        var seriesYData = useAllXDataToFindNearestPoint ? series.yData : series.processedYData;
        var xDataMaxIndex = seriesXData.length - 1;
        var xDataMax = seriesXData[xDataMaxIndex];
        var totalPoints = infChart.manager.getTotalPoints(chart);

        if (useFutureDate && xValue > xDataMax && seriesXData.length >= 2) {
            indexOfNearestXValueIndex = findNearestXDataPointIndex(totalPoints, xValue);
            yData = infChart.util.getCandleData(chart, indexOfNearestXValueIndex);
            nearestYData = yData;
            nearestXValue = totalPoints[indexOfNearestXValueIndex];
            nearestYValue = totalPoints[indexOfNearestXValueIndex];
        } else {
            indexOfNearestXValueIndex = findNearestXDataPointIndex(seriesXData, xValue);
            yData = infChart.util.getCandleData(chart, indexOfNearestXValueIndex);
            nearestYData = yData;
            nearestXValue = seriesXData[indexOfNearestXValueIndex];
            nearestYValue = seriesYData[indexOfNearestXValueIndex];
        }
        return { xData: nearestXValue, yData: yData, dataIndex: indexOfNearestXValueIndex, nearestYData: nearestYData};
    };

    /**
     * Get future x value for given future index
     * @param chart
     * @param futureIndex
     * @param seriesIndex
     */
    var getFutureXValueForGivenIndex = function (chart, futureIndex, seriesIndex) {
        var series = chart.series[seriesIndex ? seriesIndex : 0];
        var seriesXData = series.xData;
        var xDataMaxIndex = seriesXData.length - 1;
        var xDataMax = seriesXData[xDataMaxIndex];
        var valueDiff = xDataMax - seriesXData[xDataMaxIndex - 1];
        var xAxis = chart.xAxis[seriesIndex ? seriesIndex : 0];
        var xDataMaxPixelValue = xAxis.toPixels(xDataMax);
        var pixelDifference = xDataMaxPixelValue - xAxis.toPixels(seriesXData[xDataMaxIndex - 1]);

        return xAxis.toValue(xDataMaxPixelValue + (futureIndex - xDataMaxIndex) * pixelDifference);
    }

    var getPixelDistanceBetweenCandles = function (chart, seriesIndex, fromCandleIndex, toCandleIndex) {
        var xAxis = chart.xAxis[seriesIndex ? seriesIndex : 0];
        var series = chart.series[seriesIndex ? seriesIndex : 0];
        var seriesXData = series.xData;
        var averageCandleDistance = xAxis.toPixels(series.processedXData[1]) - xAxis.toPixels(series.processedXData[0]);

        return (toCandleIndex - fromCandleIndex) * averageCandleDistance;
    }

    return{
        calculateLinearRegression : calculateLinearRegression,
        calculateRegressionChannel : calculateRegressionChannel,
        findNearestXDataPoint: findNearestXDataPoint,
        findNearestDataPoint: findNearestDataPoint,
        getFutureXValueForGivenIndex: getFutureXValueForGivenIndex,
        getPixelDistanceBetweenCandles: getPixelDistanceBetweenCandles
    }
})();

(function($){
    $.fn.xOutside = function(ename, cb){
        return this.each(function(){
            var self = this;
            $(document.body).bind(ename, function tempo(e){
                if(e.target !== self && !$.contains(self, e.target)){
                    var removeCallback = self.parentNode ? cb.apply(self, [e]) : true;
                    if( removeCallback) {
                        $(document.body).unbind(ename, tempo);
                    }
                }
            });
        });
    };

    $.fn.xIsInside = function(child, selector){
        if(selector) {
            var selfEl = this[0],
                parents = $(child).parents(selector),
                inside = false;
            for(var i= 0, iLen = parents.length; i<iLen; i++){
                if(parents[i] == selfEl) {
                    inside = true;
                    break
                }
            }
             return inside;
        }
    }
}(jQuery));

infChart.MouseWheelController = function (highChartInstance) {
    this.chart = highChartInstance;
    this.container = highChartInstance.container;
    this.zoomPosMin = 100;
    this.zoomPosMax = 0;
    this.zoomMidPoint = 50;
    this.tickSize = .01; //TODO - need to pass this value as a setting
    this.linearXTickSize = .01;
    this.tickSizeY = .01;
    this.chartMin = 0;
    this.chartMax = 0;
    this.mouseWheelDirection = {
        horizontal: "h",
        vertical: "v"
    }
};

infChart.MouseWheelController.prototype.initialize = function () {
    var self = this,
        chart = self.chart,
        chartZoomingTimeout;
    if (!infChart.settings.config.isMobile) {
        $(self.container).bind('wheel', function (event) {
            event.preventDefault();
            if (chartZoomingTimeout) {
                clearTimeout(chartZoomingTimeout);
            }

            chartZoomingTimeout = setTimeout(function () {
                self.onMouseWheel.call(self, event);
            }, 0);
        });
    } else {
        var mc = new Hammer.Manager(self.container);
        mc.add(new Hammer.Pinch({event: "pinch", pointers: 2, threshold: 0}));
        mc.on("pinch", function (event) {
            if (chartZoomingTimeout) {
                console.debug("Zooming :: pinch clearTimeout");
                clearTimeout(chartZoomingTimeout);
            }
            chartZoomingTimeout = setTimeout(function () {
                event.layerX = event.center.x;
                event.layerY = event.center.y;
                self.onMouseWheel.call(self, event);
                console.debug("Zooming :: pinch ", event);
            }, 0);
        });
    }
};

infChart.MouseWheelController.prototype.cursorToScrollbarPosition = function(chart, chartX) {
    var scroller = chart.scrollbar,
        options = scroller.options,
        minWidthDifference = options.minWidth > scroller.calculatedWidth ? options.minWidth : 0; // minWidth distorts translation

    return (chartX - scroller.x - scroller.xOffset) / (scroller.barWidth - minWidthDifference);
};

infChart.MouseWheelController.prototype.xAxisHorizontalScrollEventHandler = function (originalEvent, deltaX) {
    var self = this,
        chart = self.chart,
        scroller = chart.scrollbar,
        normalizedEvent = scroller.chart.pointer.normalize(originalEvent),
        scrollStartChartX = normalizedEvent.chartX,
        mousePosition = self.cursorToScrollbarPosition(chart, scrollStartChartX);

    scroller.chartX = mousePosition;
    // scroller.chartY = mousePosition.chartY;
    scroller.initPositions = [scroller.from, scroller.to];

    var scrollPosition,
        chartPosition,
        change,
        direction = 'chartX',
        newChartX = scrollStartChartX - self.calculateWheelDeltaFactor(deltaX, self.mouseWheelDirection.horizontal);

    // In iOS, a mousemove event with e.pageX === 0 is fired when holding the finger
    // down in the center of the scrollbar. This should be ignored.
    if ((!normalizedEvent.touches || normalizedEvent.touches[0][direction] !== 0)) { // #4696, scrollbar failed on Android
        chartPosition = self.cursorToScrollbarPosition(chart, newChartX);
        scrollPosition = scroller[direction];

        change = chartPosition - scrollPosition;

        //scroller.hasDragged = true;
        scroller.updatePosition(scroller.initPositions[0] + change, scroller.initPositions[1] + change);

        //if (scroller.hasDragged) {
            Highcharts.fireEvent(scroller, 'changed', {
                from: scroller.from,
                to: scroller.to,
                trigger: 'scrollbar',
                DOMType: normalizedEvent.type,
                DOMEvent: normalizedEvent
            });
        //}
    }
}

infChart.MouseWheelController.prototype.calculateWheelDeltaFactor = function (delta, direction) {
    var self = this,
        calculatedDelta, dividingFactor, absDelta = Math.abs(delta);
    switch (direction) {
        case self.mouseWheelDirection.vertical:
            dividingFactor = window.navigator.userAgent.toLowerCase().indexOf("chrome") !== -1 ? 20 : 5;
            calculatedDelta = absDelta / dividingFactor < 100 ? absDelta / dividingFactor : 100;
            calculatedDelta = calculatedDelta < 5 ? 5 : calculatedDelta;
            break;
        case self.mouseWheelDirection.horizontal:
            dividingFactor = window.navigator.userAgent.toLowerCase().indexOf("chrome") !== -1 ? 15 : 5;
            calculatedDelta = absDelta / dividingFactor <= 50 ? absDelta / dividingFactor : 50;
            break;
    }

    return delta < 0 ? -1 * calculatedDelta : calculatedDelta;
}

/**
 * Hide marker when mousewheel action fires
 * @private
 */
infChart.MouseWheelController.prototype._hideTracker = function () {
    var self = this, chart = self.chart;
    $(chart.renderTo).find(".highcharts-markers.highcharts-tracker").hide();
    chart.infTrackerHidden = true;
};
/**
 * Get executes on mousewheel action
 * @param {Event} e event object
 */
infChart.MouseWheelController.prototype.onMouseWheel = function (e) {
    var self = this, chart = self.chart;
    // Since firefox has the pageX only inside the originalEvent, originalEvent is taken into account always.
    var originalEvent = e.originalEvent || e;
    chart.pointer.normalize(originalEvent);

    this._hideTracker();

    var xAxis = chart.xAxis && chart.xAxis[0],
        isXZoom = (originalEvent.chartX ? originalEvent.chartX : originalEvent.layerX) < (xAxis.left + xAxis.width),
        deltaX = originalEvent.wheelDeltaX,
        deltaY = originalEvent.wheelDeltaY;

    if(isXZoom && Math.abs(deltaX) > Math.abs(deltaY)) {
        self.xAxisHorizontalScrollEventHandler.call(self, originalEvent, deltaX);
    } else {
        var axis = isXZoom ? xAxis : chart.yAxis && chart.yAxis[0],
            extremes = axis.getExtremes(),
            actualExRange = extremes.dataMax - extremes.dataMin,
            actualSeriesExtremes = !isXZoom && infChart.manager.getSeriesActualExtremes(chart.renderTo.id, chart.series[0].options.id),
            exDataMin = actualSeriesExtremes && actualSeriesExtremes.dataMin || extremes.dataMin,
            exDataMax = actualSeriesExtremes && actualSeriesExtremes.dataMax || extremes.dataMax,
            actualRange = !isXZoom && actualSeriesExtremes ? actualSeriesExtremes.dataMax - actualSeriesExtremes.dataMin : exDataMax - exDataMin,
            min = extremes.min,
            max = extremes.max,
            dataMin = isXZoom ? extremes.dataMin : exDataMin - actualRange,
            dataMax = isXZoom ? extremes.dataMax : exDataMax + actualRange,
            delta = originalEvent.detail ? originalEvent.detail * (-1) : deltaY / 120,
            timeLineChange,
            midPoint = originalEvent && originalEvent.target.point,
            midTime,
            totalTimeChange,
            currentRange = max - min,
            newRange,
            newMin,
            newMax,
            difference = dataMax - dataMin,
            infMouseMoved = chart.infMouseMoved,
            isLinearAxis = infChart.manager.isLinearData(chart),
            tickSize = isXZoom ? isLinearAxis ? self.linearXTickSize : self.tickSize : self.tickSizeY,
            midTimeIndex,
            totalPoints = self._getTotalPoints(),
            totalPointsLen = totalPoints.length,
            currentMinIndex = self._getIndexOfTime(min),
            currentMaxIndex = self._getIndexOfTime(max),
            currentRangePointsLen = currentMaxIndex - currentMinIndex,
            minZoomIndexChange = 5,
            doZoom = false,
            newRangeLen,
            minAdditional = 0,
            maxAdditional = 0,
            minIndexCorrection,
            maxIndexCorrection,
            midAdditional,
            midIndexCorrection;

        if (infChart.settings.config.isMobile && !isXZoom) {
            return;
        }

        if (!delta) {
            const isPositive = originalEvent.additionalEvent === 'pinchout' ? 1 : -1;
            delta = originalEvent.scale * isPositive;
        }

        if (!midPoint) {
            chart.pointer.normalize(originalEvent);
            if (e.center) {
                originalEvent.chartX = e.center.x;
                originalEvent.chartY = e.center.y;
            }
            midTime = isXZoom ? axis.toValue(originalEvent.chartX) : axis.toValue(originalEvent.chartY);
        } else {
            midTime = isXZoom ? midPoint.x : midPoint.y;
        }

        self.isXZoom = isXZoom;
        self.midTime = infMouseMoved ? midTime : self.midTime || midTime;
        midTimeIndex = Math.min(Math.max(currentMinIndex, self._getIndexOfTime(midTime)), currentMaxIndex);

        if (isXZoom && !isLinearAxis) {
            var currentMaxIndexTime = +totalPoints[currentMaxIndex];
            var currentMinIndexTime = +totalPoints[currentMinIndex];
            var currentMidIndexTime = +totalPoints[midTimeIndex];
            if (currentMinIndex >= 0) {
                if (currentMinIndexTime > min) {
                    minAdditional = currentMinIndex === 0 ? 0 : (currentMinIndexTime - min) / (currentMinIndexTime - (+totalPoints[currentMinIndex - 1]));
                    minIndexCorrection = currentMinIndex === 0 ? currentMinIndex : currentMinIndex - minAdditional;
                } else {
                    minAdditional = (min - currentMinIndexTime) / ((+totalPoints[currentMinIndex + 1]) - currentMinIndexTime);
                    minIndexCorrection = currentMinIndex + minAdditional;
                }
            }

            if (currentMaxIndex <= (totalPointsLen - 1)) {
                if (currentMaxIndexTime > max) {
                    maxAdditional = (currentMaxIndexTime - max) / (currentMaxIndexTime - (+totalPoints[currentMaxIndex - 1]));
                    maxIndexCorrection = currentMaxIndex - maxAdditional;
                } else {
                    maxAdditional = (currentMaxIndex === (totalPointsLen - 1)) ? 0 : (max - currentMaxIndexTime) / ((+totalPoints[currentMaxIndex + 1]) - currentMaxIndexTime);
                    maxIndexCorrection = (currentMaxIndex === (totalPointsLen - 1)) ? currentMaxIndex : currentMaxIndex + maxAdditional;
                }
            }

            if (midTimeIndex <= (totalPointsLen - 1) && midTimeIndex > 0) {
                if (currentMidIndexTime > midTime) {
                    midAdditional = (currentMidIndexTime - midTime) / (currentMidIndexTime - (+totalPoints[midTimeIndex - 1]));
                    midIndexCorrection = midTimeIndex - midAdditional;
                } else {
                    midAdditional = (midTime - currentMidIndexTime) / ((+totalPoints[midTimeIndex + 1]) - currentMidIndexTime);
                    midIndexCorrection = midTimeIndex + midAdditional;
                }
            }
            currentRangePointsLen = maxIndexCorrection - minIndexCorrection;
            midTimeIndex = midIndexCorrection;
        }

        if (delta > 0) {
            if (infChart.settings.config.isMobile) {
                timeLineChange = tickSize * delta;
            } else {
                timeLineChange = tickSize * (delta > 1 ? delta > 50 ? 23 : 8 : 4);
            }
            if (isXZoom && !isLinearAxis) { // zooming using number of differnet points(times) since axis is non-linear
                totalTimeChange = Math.max(minZoomIndexChange, timeLineChange * 2 * (currentRangePointsLen));
                newRangeLen = currentRangePointsLen - totalTimeChange;
                doZoom = newRangeLen > 0;
                if (doZoom) { // to keep minimum points to be 5
                    var newMaxPx = Math.min(totalPointsLen, midTimeIndex + (newRangeLen * ((maxIndexCorrection - midTimeIndex) / (currentRangePointsLen))));
                    var newMinPx = newMaxPx - newRangeLen;
                    self.setZoomPos(newMinPx, newMaxPx, 0, totalPointsLen);
                    self.setZoom(originalEvent);
                }

            } else {
                totalTimeChange = timeLineChange * 2 * (max - min);
                newRange = currentRange - totalTimeChange;
                doZoom = newRange > 0;

                if (doZoom) { // to keep minimum points to be 5
                    newMax = Math.min(dataMax, midTime + (newRange * ((max - midTime) / currentRange)));
                    newMin = newMax - newRange; //midTime - ( newRange * ((midTime - min) / currentRange));
                    self.setZoomPos(newMin, newMax, dataMin, difference);
                    self.setZoom(originalEvent);
                }
            }

        } else if (!(dataMin >= min && dataMax <= max)) {
            if(infChart.settings.config.isMobile){
                timeLineChange = tickSize * delta;
            } else {
                timeLineChange = tickSize * (delta < -1 ? delta < -50 ? 23 : 8 : 4);
            }

            if (isXZoom && !isLinearAxis) {
                minZoomIndexChange = 2;
                totalTimeChange = Math.max(minZoomIndexChange, timeLineChange * 2 * (currentRangePointsLen));
                newRangeLen = currentRangePointsLen + totalTimeChange;
                var maxZoomPointLen = infChart.manager.getMaxPointCount(chart);
                if (newRangeLen > maxZoomPointLen) {
                    newRangeLen = maxZoomPointLen;
                }

                if (currentRangePointsLen != newRangeLen) {
                    newMaxPx = Math.min(totalPointsLen, midTimeIndex + (newRangeLen * ((maxIndexCorrection - midTimeIndex) / (currentRangePointsLen))));
                    newMinPx = newMaxPx - newRangeLen;
                    self.setZoomPos(newMinPx, newMaxPx, 0, totalPointsLen);
                    self.setZoom(originalEvent);
                }
            } else {
                var maxZoom = infChart.manager.getMaxZoomRange(chart);

                totalTimeChange = timeLineChange * 2 * (max - min);
                newRange = currentRange + totalTimeChange;
                if (newRange > maxZoom) {
                    newRange = maxZoom;
                }

                if (currentRange < maxZoom && currentRange != newRange) {
                    newMax = Math.min(dataMax, midTime + (newRange * ((max - midTime) / currentRange)));
                    newMin = newMax - newRange;
                    self.setZoomPos(newMin, newMax, dataMin, difference);
                    self.setZoom(originalEvent);
                }
            }
            chart.infMouseMoved = false;
        }
    }

    /**
     * Stop the event
     * @param {Event} e event
     */
    function stopEvent(e) {
        if (e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            e.cancelBubble = true;
        }
    }

    stopEvent(originalEvent);
};

/**
 * Set the zoom position of the new values
 * This positions are set to the mousewheel object in the previous implementation that updated them from the axis' set extremes as well.
 * However those values are not used anywhere. Still keeping this in the object and used in setZoom to keep the room for changes in the future for
 * axis extreme changes.
 * @param {number} newMin new Min value or index that is going to be set
 * @param {number} newMax new Max value or index that is going to be set
 * @param {number} dataMin min data value of the data set
 * @param {number} difference diffrence of the range in (value, pixels or index :: other three params also should be in the same type)
 */
infChart.MouseWheelController.prototype.setZoomPos = function (newMin, newMax, dataMin, difference) {
    var self = this;
    self.zoomPosMax = 100 - (((newMax - dataMin) / difference) * 100);
    self.zoomPosMin = 100 - (((newMin - dataMin) / difference) * 100);
    if (self.zoomPosMin > 100) {
        self.zoomPosMin = 100;
    }
};

infChart.MouseWheelController.prototype.setExtremes = function (e, self) {
    //TODO : remove this method call from all the onfig files and then remove this method from here.
    //var min = e.min;
    //var max = e.max;
    //var difference = self.dataMax - self.dataMin;
    //
    //if (difference && self.dataMin != null && !isNaN(self.dataMin)) {
    //    this.zoomPosMax = 100 - (((max - self.dataMin) / difference) * 100);
    //    this.zoomPosMin = 100 - (((min - self.dataMin) / difference) * 100);
    //}
    //
    //if (this.zoomPosMin > 100) {
    //    this.zoomPosMin = 100;
    //}
    //
    //this.zoomMidPoint = this.zoomPosMax + (this.zoomPosMin - this.zoomPosMax) / 2;

    //console.log("Set Extreme -> Min : " + this.zoomPosMin + " Max : " + this.zoomPosMax + " midPoint :" + this.zoomMidPoint);
};

/**
 * Zoom the axis according to given zoom factors
 * @param {Event} e event
 */
infChart.MouseWheelController.prototype.setZoom = function (e) {
    var self = this;
    var chart = self.chart;
    var isLinearAxis = infChart.manager.isLinearData(chart);
    var axis = self.isXZoom ? chart && chart.xAxis && chart.xAxis[0] : chart && chart.yAxis && chart.yAxis[0];
    var mainSeries = chart && chart.series && chart.series[0];
    if (axis) {
        var actualSeriesExtremes = !self.isXZoom && infChart.manager.getSeriesActualExtremes(chart.renderTo.id, chart.series[0].options.id),
            extremes = axis.getExtremes(),
            exDataMin = actualSeriesExtremes && actualSeriesExtremes.dataMin || extremes.dataMin,
            exDataMax = actualSeriesExtremes && actualSeriesExtremes.dataMax || extremes.dataMax,
            actualRange = !self.isXZoom && actualSeriesExtremes ? actualSeriesExtremes.dataMax - actualSeriesExtremes.dataMin : exDataMax - exDataMin,
            dataMin = self.isXZoom ? extremes.dataMin : exDataMin - (actualRange),
            dataMax = self.isXZoom ? extremes.dataMax : exDataMax + (actualRange),
            mainSeriesDataMax = this.isXZoom ? (mainSeries && mainSeries.points && mainSeries.points[mainSeries.points.length - 1] && mainSeries.points[mainSeries.points.length - 1].x) : dataMax,
            mainSeriesDataMinX = this.isXZoom ? (mainSeries && mainSeries.points && mainSeries.points[0] && mainSeries.points[0].x) : dataMin,
            newMax,
            newMin;

        if (self.isXZoom && !isLinearAxis) {
            var totalPoints = self._getTotalPoints(),
                totalPointsLen = totalPoints.length,
                maxIndexRaw = (100 - self.zoomPosMax) * (totalPointsLen) / 100,
                minIndexRaw = (100 - self.zoomPosMin) * (totalPointsLen) / 100,
                maxIndexAdjusted = Math.min(totalPointsLen - 1, Math.floor(maxIndexRaw)),
                minIndexAdjusted = Math.max(0, Math.ceil(minIndexRaw));

            newMax = +totalPoints[maxIndexAdjusted];
            newMin = +totalPoints[minIndexAdjusted];
            if (maxIndexAdjusted < maxIndexRaw && maxIndexAdjusted < (totalPointsLen - 1)) {
                var nextToMax = +totalPoints[maxIndexAdjusted + 1];
                newMax = newMax + (nextToMax - newMax) * (maxIndexRaw - maxIndexAdjusted);
            }

            if (minIndexAdjusted > minIndexRaw && minIndexAdjusted > 0) {
                var nextToMin = +totalPoints[minIndexAdjusted - 1];
                newMin = newMin - (newMin - nextToMin) * (minIndexAdjusted - minIndexRaw);
            }
        } else {
            newMax = Math.max(mainSeriesDataMinX, dataMax - self.zoomPosMax * (dataMax - dataMin) / 100);
            newMin = dataMin + (100 - this.zoomPosMin) * (dataMax - dataMin) / 100;

        }

        var isZoomUp = (newMax - newMin) <= (axis.max - axis.min),
            dummyBkWd = chart.get(infChart.constants.dummySeries.backwardId),
            mainSeriesDataMin = self.isXZoom ? (dummyBkWd && dummyBkWd.points && dummyBkWd.points[0]) || (mainSeries && mainSeries.points && mainSeries.points[0] && mainSeries.points[0].x) : dataMin,
            isRange = !isZoomUp ? ((axis.max >= newMin && axis.max <= newMax) || (axis.min >= newMin && axis.min <= newMax)) : (newMin >= axis.min && newMax <= axis.max);

        if ((!isNaN(newMin) && !isNaN(newMax)) && isRange && (!isZoomUp ||
                (mainSeriesDataMax && mainSeriesDataMin && newMin < mainSeriesDataMax && newMax > mainSeriesDataMin))
            && (newMin !== self.chartMin || newMax != self.chartMax)) {
            // chart.infManualExtreme = true; // This property is used when used to keep the current extremes on tick updates after user manually changed the extremes.
            chart.setExtremesByMouseWheel = true;
            if (self.isXZoom) {
                infChart.manager.setUserDefinedXAxisExtremes(chart.renderTo.id, newMin, newMax, true);
            } else {
                infChart.manager.setUserDefinedYAxisExtremes(chart.renderTo.id, newMin, newMax, true, true);
            }

            chart.setExtremesByMouseWheel = false;
            chart.infManualCrosshair = true;
            chart.pointer.normalize(e);

            //TODO :: find out a proper solution to get the point of initial position
            var point = chart.pointer.getPointFromEvent(e);

            if (point && point.x != null) {
                chart.pointer.runPointActions(e, point);
            }
            chart.infManualCrosshair = false;

            self.chartMin = newMin;
            self.chartMax = newMax;
        }

    }
};

/**
 * Returns the index of given time
 * @param {number} time time stamp
 * @returns {number} index of the time
 * @private
 */
infChart.MouseWheelController.prototype._getIndexOfTime = function (time) {
    var chart = this.chart;
    var xTimeMap = infChart.manager.getAllTimeTicks(chart);
    var xData = Object.keys(xTimeMap);
    var indexOfNearestXValue = infChart.util.binaryIndexOf(xData, undefined, time);

    if (indexOfNearestXValue < 0) {
        var absIndex = Math.abs(indexOfNearestXValue);

        if (absIndex >= xData.length) {
            absIndex = xData.length - 1;
        }

        var rangeMaxValue = parseInt(xData[absIndex], 10);
        var rangeMinValue = parseInt(xData[absIndex - 1], 10);

        if (time > (((rangeMaxValue - rangeMinValue) / 2) + rangeMinValue)) {
            indexOfNearestXValue = absIndex;
        } else {
            indexOfNearestXValue = absIndex - 1;
        }
    }
    return indexOfNearestXValue;
};

/**
 * Returns the array of time map
 * @returns {Array} all times in array
 * @private
 */
infChart.MouseWheelController.prototype._getTotalPoints = function () {
    var chart = this.chart;
    var stockChart = chart && infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id));
    var totalPoints = stockChart.calculateTotalPoints(chart);
    return totalPoints;
};

/**
 * Unbind events on destroy
 */
infChart.MouseWheelController.prototype.destroy = function () {
    var self = this;
    $(self.container).unbind('wheel');
};
/**
 * @typedef {object} symbol
 * @property {string} symbolId - unique key
 * @property {string} symbol - name
 * @property {string} symbolDesc - description
 * @property {string} symbolType - equ, cur
 * @property {string} exchange - exchange
 * @property {string} currency - currency
 * @property {string} provider - provider
 * @property {string} legendLabel - legend label
 * @property {number} dp - decimal places
 * @property lineDataField - ???
 */

/**
 * Created by dushani on 8/26/15.
 * Core features of the stock chart will be handled here.
 * Ex : change symbol, symbol comparison , interval change , zooming etc ..
 */

var infChart = window.infChart || {};
const NO_OF_LAST_PRICE_DECIMAL_POINTS = 2;
const NO_OF_PREVIOUS_PRICE_DECIMAL_POINTS = 2;
const NO_OF_SPECIFIC_DECIMAL_POINTS = 2;

/**
 * This class works as a wrapper to the Highchart's stock chart and it has a reference to the highchart object
 * @param {string} id
 * @param dataManager data manager instance
 * @param {object} settings chart settings
 * @constructor
 */
infChart.StockChart = function (id, dataManager, settings) {
    this.id = id;
    this.dataManager = dataManager;

    this.performanceCheck = {};

    this.updateTicksTimer = undefined;
    this.resizeTimer = undefined;

    this._setDefaultProperties();

    this.settings = settings;
    this.mockData = settings.mockData;
    this.regularIntervalsOnUpdate = settings.config && settings.config.regularIntervalsOnUpdate || false;
    this.maxPeriodOnIntervalChange = settings.config && settings.config.maxPeriodOnIntervalChange || false;
    this.selfListeners = {};
    this.customGridLineColorEnabled = false;

    var toolbarConfig = settings.toolbar.config;
    if (toolbarConfig) {
        this._setChartTypeStyleOptions(toolbarConfig.chartType);
        this._setMinMaxOptions(toolbarConfig.minMax);
        this._setIntervalOptions(toolbarConfig.interval);
        this._setPeriodOptions(toolbarConfig.period);
        this._initNews(toolbarConfig.news);
    }
};

infChart.StockChart.prototype._printPerformance = function () {
    for (var i in this.performanceCheck) {
        if (this.performanceCheck.hasOwnProperty(i)) {
            console.debug("performance :: " + i + " :: " + this.performanceCheck[i].diff
                + ", startTime :" + this.performanceCheck[i].startTime +
                ", endTime : " + this.performanceCheck[i].endTime);
            delete this.performanceCheck[i];
        }

    }
};

infChart.StockChart.prototype.name = function () {
    return "infChart.StockChart >" + this.id;
};

infChart.StockChart.prototype.isFirstLoadInprogress = function () {
    return this.isfirstLoad;
};

infChart.StockChart.prototype._setDefaultProperties = function (isReset) {
    this.chartId = undefined;
    this.chart = undefined;
    this.mouseWheelController = undefined;
    this.symbol = undefined;
    this.useGrouping = false;

    this.period = 'Y_1';
    this.interval = 'D';
    this.pinInterval = false;
    this.type = 'candlestick';
    this.prevChartStyle = 'candlestick';
    this.isStyleChangedByForce = false;

    this.isCompare = false;
    this.isLog = false;
    this.isPercent = false;
    this.orderBookHistory = false;
    this.regularIntervalsOnUpdate = false;
    this.fixedIntervalOnPeriodChange = false;
    this.maxPeriodOnIntervalChange = true;

    this.volume = false;
    this.bidAskHistory = false;

    this.compareSymbols = {count: 0, symbols: {}, idMap: {}};

    this.indicatorFrameHeight = 0;//total height of indicatorsDissimilerToBaseAxes axes

    this.data = {compare: {}, base: []};
    this.dataMap = {compare: {}, base: {}};
    this.rangeData = {data: [], ohlcv: {}, compareData: {}, compareOHLCV: {}};
    this.rawData = {base: {}, compare: {}};
    this.seriesActualMinMax = {};

    this.processedData = {
        type: 'normal', // normal, log, percent
        data: [],
        isCompare: false,
        ohlcv: {o: [], h: [], l: [], c: [], v: [], b: [], a: [], ah: [], bl: []},
        compareSymbols: {},
        timeMap: {},
        pointPositions: []
    };

    this.rangeSelector = false;
    this.colorIndex = 0;
    this.crosshair = {enabled: true, type: "all"};
    this.ticks = {};
    this.loading = 0;
    this.tooltip = false;
    this.hasLastLine = false;
    this.hasLastLineForCompareSymbols = false;
    this.lastLabelForCompareSymbols = {};
    this.settingsPopups = {};
    this.isFavoriteEnabled = true;

    this.minMax = {enabled: false, minField: 'low', maxField: 'high'};

    if (!isReset) {

        this.styleTypes = {
            "default": ["candlestick", "ohlc", "line", "area", "column", "hlc"],
            compare: ["candlestick", "ohlc", "line", "area", "column", "hlc"]
        };
        this.chartStyleOptions = {};
        this.intervalOptions = {
            //"T": {grouping: false, maxPeriod: 'D_1', intraday: true},
            "I_1": {grouping: false, maxPeriod: 'M_1', intraday: true, time: 60000},
            "I_2": {grouping: false, maxPeriod: 'M_1', intraday: true, time: 60000 * 2},
            "I_3": {grouping: false, maxPeriod: 'M_1', intraday: true, time: 60000 * 3},
            "I_5": {grouping: false, maxPeriod: 'M_3', intraday: true, time: 60000 * 5},
            "I_10": {grouping: false, maxPeriod: 'M_3', intraday: true, time: 60000 * 10},
            "I_15": {grouping: false, maxPeriod: 'M_3', intraday: true, time: 60000 * 15},
            "I_30": {grouping: false, maxPeriod: 'M_3', intraday: true, time: 60000 * 30},
            "I_60": {grouping: false, maxPeriod: 'M_3', intraday: true, time: 60000 * 60},
            "I_120": {grouping: false, maxPeriod: 'M_3', intraday: true, time: 60000 * 120},
            "I_240": {grouping: false, maxPeriod: 'M_3', intraday: true, time: 60000 * 240},
            "I_360": {grouping: false, maxPeriod: 'M_3', intraday: true, time: 60000 * 360},
            "I_480": {grouping: false, maxPeriod: 'M_3', intraday: true, time: 60000 * 480},
            "I_720": {grouping: false, maxPeriod: 'M_3', intraday: true, time: 60000 * 720},
            "D": {grouping: false, time: 60000 * 60 * 24},
            "D_3": {grouping: false, time: 60000 * 60 * 24 * 3},
            "W": {grouping: false, time: 60000 * 60 * 24 * 7},
            "M": {grouping: false, time: 60000 * 60 * 24 * 30},
            "Y": {grouping: false, time: 60000 * 60 * 24 * 30 * 365}
        };
        this.periodOptions = {
            "I": {
                key: "I",
                desc: "Intraday",
                shortDesc: 'I',
                label: 'label.periods.I',
                shortLabel: 'label.periodShort.I',
                defaultInterval: "T" /*,
                 intervals: ["T", "I_1", "I_5", "I_15", "I_30", "I_60", "I_120", "I_240"] */
            },
            "I_H_1": {
                key: "I_H_1",
                desc: "1 Hour",
                shortDesc: '1H',
                label: 'label.periods.I_H_1',
                categoryDefault: true,
                shortLabel: 'label.periodShort.I_H_1',
                defaultInterval: "I_1"/*,
                 intervals : ["T", "I_1","I_5","I_15","I_30","I_60","I_120","I_240"]*/,
                category: "H"
            },
            "I_H_2": {
                key: "I_H_2",
                desc: "2 Hours",
                shortDesc: '2H',
                label: 'label.periods.I_H_2',
                shortLabel: 'label.periodShort.I_H_2',
                defaultInterval: "I_1"/*,
                 intervals : ["T", "I_1","I_5","I_15","I_30","I_60","I_120","I_240"]*/,
                category: "H"
            },
            "I_H_3": {
                key: "I_H_3",
                desc: "3 Hours",
                shortDesc: '3H',
                label: 'label.periods.I_H_3',
                shortLabel: 'label.periodShort.I_H_3',
                defaultInterval: "I_1"/*,
                 intervals : ["T", "I_1","I_5","I_15","I_30","I_60","I_120","I_240"]*/,
                category: "H"
            },
            "I_H_4": {
                key: "I_H_4",
                desc: "4 Hours",
                shortDesc: '4H',
                label: 'label.periods.I_H_4',
                shortLabel: 'label.periodShort.I_H_4',
                defaultInterval: "I_1"/*,
                 intervals : ["T", "I_1","I_5","I_15","I_30","I_60","I_120","I_240"]*/,
                category: "H"
            },
            "I_H_6": {
                key: "I_H_6",
                desc: "6 Hours ",
                shortDesc: '6H',
                label: 'label.periods.I_H_6',
                shortLabel: 'label.periodShort.I_H_6',
                defaultInterval: "I_3"/*,
                 intervals : ["T", "I_1","I_5","I_15","I_30","I_60","I_120","I_240"]*/,
                category: "H"
            },
            "I_H_8": {
                key: "I_H_8",
                desc: "8 Hours ",
                shortDesc: '8H',
                label: 'label.periods.I_H_8',
                shortLabel: 'label.periodShort.I_H_8',
                defaultInterval: "I_3"/*,
                 intervals : ["T", "I_1","I_5","I_15","I_30","I_60","I_120","I_240"]*/,
                category: "H"
            },
            "I_H_12": {
                key: "I_H_12",
                desc: "12 Hours",
                shortDesc: '12H',
                label: 'label.periods.I_H_12',
                shortLabel: 'label.periodShort.I_H_12',
                defaultInterval: "I_3"/*,
                 intervals : ["T", "I_1","I_5","I_15","I_30","I_60","I_120","I_240"]*/,
                category: "H"
            },
            "I_H_16": {
                key: "I_H_16",
                desc: "16 Hours",
                shortDesc: '16H',
                label: 'label.periods.I_H_16',
                shortLabel: 'label.periodShort.I_H_16',
                defaultInterval: "I_3"/*,
                 intervals : ["T", "I_1","I_5","I_15","I_30","I_60","I_120","I_240"]*/,
                category: "H"
            },
            "I_D_1": {
                key: "I_D_1",
                desc: "1 Day",
                shortDesc: '1D',
                label: 'label.periods.I_D_1',
                categoryDefault: true,
                shortLabel: 'label.periodShort.I_D_1',
                defaultInterval: "I_3"/*,
                 intervals : ["T", "I_1","I_5","I_15","I_30","I_60","I_120","I_240"]*/,
                category: "D"
            },
            "I_D_2": {
                key: "I_D_2",
                desc: "2 Days",
                shortDesc: '2D',
                label: 'label.periods.I_D_2',
                shortLabel: 'label.periodShort.I_D_2',
                defaultInterval: "I_5"/*,
                 intervals : ["T", "I_1","I_5","I_15","I_30","I_60","I_120","I_240"]*/,
                category: "D"
            },
            "I_D_3": {
                key: "I_D_3",
                desc: "3 Days",
                shortDesc: '3D',
                label: 'label.periods.I_D_3',
                shortLabel: 'label.periodShort.I_D_3',
                defaultInterval: "I_5"/*,
                 intervals : ["T", "I_1","I_5","I_15","I_30","I_60","I_120","I_240"]*/,
                category: "D"
            },
            "W_1": {
                key: "W_1",
                desc: "1 Week",
                shortDesc: '1W',
                label: 'label.periods.W_1',
                categoryDefault: true,
                shortLabel: 'label.periodShort.W_1',
                defaultInterval: "I_15"/*,
                 intervals : ["T", "I_1","I_5","I_15","I_30","I_60","I_120","I_240"]*/,
                category: "W"
            },
            "W_2": {
                key: "W_2",
                desc: "2 Weeks",
                shortDesc: '1W',
                label: 'label.periods.W_2',
                shortLabel: 'label.periodShort.W_2',
                defaultInterval: "I_30"/*,
                 intervals : ["T", "I_1","I_5","I_15","I_30","I_60","I_120","I_240"]*/,
                category: "W"
            },
            "W_3": {
                key: "W_3",
                desc: "3 Weeks",
                shortDesc: '3W',
                label: 'label.periods.W_3',
                shortLabel: 'label.periodShort.W_3',
                defaultInterval: "I_240"/*,
                 intervals : ["T", "I_1","I_5","I_15","I_30","I_60","I_120","I_240"]*/,
                category: "W"
            },
            "M_1": {
                key: "M_1",
                desc: "1 Month",
                shortDesc: '1M',
                shortLabel: 'label.periodShort.M_1',
                categoryDefault: true,
                label: 'label.periods.M_1',
                defaultInterval: "D"/*,
                 intervals : [ "I_1","I_5","I_15","I_30","I_60","I_120","I_240","D","W","M"]*/,
                category: "M"
            },
            "M_2": {
                key: "M_2",
                desc: "2 Month",
                shortDesc: '2M',
                shortLabel: 'label.periodShort.M_2',
                categoryDefault: false,
                label: 'label.periods.M_2',
                defaultInterval: "D"/*,
                 intervals : [ "I_1","I_5","I_15","I_30","I_60","I_120","I_240","D","W","M"]*/,
                category: "M"
            },
            "M_3": {
                key: "M_3",
                desc: "3 Months",
                shortDesc: '3M',
                label: 'label.periods.M_3',
                shortLabel: 'label.periodShort.M_3',
                defaultInterval: "D"/*,
                 intervals : [ "I_5","I_15","I_30","I_60","I_120","I_240","D","W","M"]*/,
                category: "M"
            },
            "M_6": {
                key: "M_6",
                desc: "6 Months",
                shortDesc: '6M',
                label: 'label.periods.M_6',
                shortLabel: 'label.periodShort.M_6',
                defaultInterval: "D"/*,
                 intervals : [  "I_5","D","W","M"]*/,
                category: "M"
            },
            "M_8": {
                key: "M_8",
                desc: "8 Months",
                shortDesc: '8M',
                label: 'label.periods.M_8',
                shortLabel: 'label.periodShort.M_8',
                defaultInterval: "D"/*,
                 intervals : [  "I_5","D","W","M"]*/,
                category: "M"
            },
            "M_10": {
                key: "M_10",
                desc: "10 Months",
                shortDesc: '10M',
                label: 'label.periods.M_10',
                shortLabel: 'label.periodShort.M_10',
                defaultInterval: "D"/*,
                 intervals : [  "I_5","D","W","M"]*/,
                category: "M"
            },
            "Y_1": {
                key: "Y_1",
                desc: "1 Year",
                shortDesc: '1Y',
                label: 'label.periods.Y_1',
                categoryDefault: true,
                shortLabel: 'label.periodShort.Y_1',
                defaultInterval: "D"/*,
                 intervals : [ "D","W","M"]*/,
                category: "Y"
            },
            "Y_2": {
                key: "Y_2",
                desc: "2 Years",
                shortDesc: '2Y',
                label: 'label.periods.Y_2',
                shortLabel: 'label.periodShort.Y_2',
                defaultInterval: "D"/*,
                 intervals : [ "D","W","M"]*/,
                category: "Y"
            },
            "Y_3": {
                key: "Y_3",
                desc: "3 Years",
                shortDesc: '3Y',
                label: 'label.periods.Y_3',
                shortLabel: 'label.periodShort.Y_3',
                defaultInterval: "D"/*,
                 intervals : [ "D","W","M"]*/,
                category: "Y"
            },
            "Y_5": {
                key: "Y_5",
                desc: "5 Years",
                shortDesc: '5Y',
                label: 'label.periods.Y_5',
                shortLabel: 'label.periodShort.Y_5',
                defaultInterval: "D"/*,
                 intervals : [ "D","W","M"]*/,
                category: "Y"
            },
            "Y_10": {
                key: "Y_10",
                desc: "10 Years",
                shortDesc: '10Y',
                label: 'label.periods.Y_10',
                shortLabel: 'label.periodShort.Y_10',
                defaultInterval: "D"/*,
                 intervals : [ "D","W","M"]*/,
                category: "Y"
            }

        };
        this.news = {enabled: false};
        this.flags = {enabled: [], types: {}};
        this.flagTypes = [];
        this.isfirstLoad = true;
    }

    //this.ohlcv = {o: [], h: [], l: [], c: [], v:[]};
    this.prevousClose = {};
    this.lastLabel = undefined;
    this.preCloseLabel = undefined;
    this.lastLine = undefined;
    this.preCloseLine = undefined;

    this.gridType = 'none';
    this.seriesColorOptions = {};
    //this.fsListeners = (this.fsListeners) ? this.fsListeners : { exit: [], enter: [] };

    this.recalStart = {}; // This is a hash map with the key of seriesId which keep the index to start recalculating of the series.
};

infChart.StockChart.prototype.getContainer = function () {
    this.container = this.container || document.body.querySelector("[inf-unique-id='" + this.id + "']");
    return this.container;
};

infChart.StockChart.prototype.createHighchartInstance = function (chartId, chartContainer, config, settings) {
    var hasEmpty = false, dummyIds = [];

    config.chart.renderTo = chartContainer;
    config.chart.infContainer = this.id;
    config.chart.infChart = true;
    config.chart.infScalable = settings.config.scalable;
    config.navigator.enabled = settings.config.navigator;
    var chartH = chartContainer.offsetHeight;
    config.navigator.height = (chartH) ? infChart.util.getNavigatorHeight(chartH, config) :
        settings.config.navigatorHeight ? settings.config.navigatorHeight : config.navigator.height;


    // copy the plot options of the main yAxis to all indicator yAxis
    infChart.util.forEach(config.yAxis, function (index, axis) {
        $.extend(axis, config.plotOptions.yAxis);
    });

    //// set empty data
    infChart.util.forEach(config.series, function (index, series) {

        if (series.infType == 'base') {
            series.infRefresh = settings.config.refreshBtn;
        } else if (series.infType == 'dummy') {
            hasEmpty = true;
            dummyIds.xPush(series.id);
        }

        if (!series.data) {
            $.extend(series, {data: []});
        }
        series.infHideClose = settings.config.hideClose;
        series.infHideSettings = typeof settings.config.hideSettings !== 'undefined' ? settings.config.hideSettings : false;
    });


    if (settings.config.displayAllIntervals && dummyIds.indexOf(infChart.constants.dummySeries.missingId) < 0) {
        config.series.xPush(infChart.util.getDummySeriesConfig(infChart.constants.dummySeries.missingId));
    }

    if (settings.config.panToFuture && dummyIds.indexOf(infChart.constants.dummySeries.forwardId) < 0) {
        config.series.xPush(infChart.util.getDummySeriesConfig(infChart.constants.dummySeries.forwardId));
    }

    if (settings.config.panToPast && dummyIds.indexOf(infChart.constants.dummySeries.backwardId) < 0) {
        config.series.xPush(infChart.util.getDummySeriesConfig(infChart.constants.dummySeries.backwardId));
    }

    this.chart = new Highcharts.StockChart(config);
    this.chartId = chartId;
    this.destroyed = false;
    this.chart.infScaleX = 1;   
    this.chart.infScaleY = 1; 

    this.setMouseWheel(settings.config.mouseWheelController);
};

infChart.StockChart.prototype.setMouseWheel = function (enable) {
    if (enable) {
        var mouseWheelController = new infChart.MouseWheelController(this.chart);
        mouseWheelController.initialize();
        this.mouseWheelController = mouseWheelController;
    } else {
        if (this.mouseWheelController) {
            this.mouseWheelController.destroy();
            this.mouseWheelController = undefined;
        }
    }
};

/**
 * @Deprecated
 * @returns {*}
 */
infChart.StockChart.prototype.getChartContainer = function () {
    return $("#" + this.chartId)[0];
};

infChart.StockChart.prototype._setIntervalOptions = function (config) {
    if (config && config.options) {
        var chart = this,
            displayIntervals = [],
            count = 0;

        infChart.util.forEach(config.options, function (key, val) {
            chart.intervalOptions[val.key] = $.extend({time: 0}, chart.intervalOptions[val.key], val);
            displayIntervals[count] = chart.intervalOptions[val.key];
            count++;
        });


        function compare(a, b) {
            if (a.time < b.time)
                return -1;
            if (a.time > b.time)
                return 1;
            return 0;
        }

        this.sortedIntervals = displayIntervals.sort(compare);
    } else {
        this.sortedIntervals = [];
    }
};

infChart.StockChart.prototype._setPeriodOptions = function (config) {
    if (config && config.options) {

        var chart = this,
            periodTime,
            displayIntervals = [],
            displayArr = config.display && config.display.split(","),
            count = 0;

        infChart.util.forEach(config.options, function (key, val) {
            if (!displayArr || displayArr.indexOf(val.key) >= 0) {
                periodTime = chart._getPeriodTime(val.key);
                chart.periodOptions[val.key] = $.extend({time: 0}, chart.periodOptions[val.key], val, {time: periodTime});
                displayIntervals[count] = chart.periodOptions[val.key];
                count++;
            }
        });

        function compare(a, b) {
            if (a.time < b.time)
                return -1;
            if (a.time > b.time)
                return 1;
            return 0;
        }

        this.sortedPeriods = displayIntervals.sort(compare);
    } else {
        this.sortedPeriods = [];
    }
};

infChart.StockChart.prototype._setMinMaxOptions = function (config) {
    if (config) {
        var chart = this;
        infChart.util.forEach(config, function (key, val) {
            chart.minMax[key] = val;
        });
    }
};

infChart.StockChart.prototype._setChartTypeStyleOptions = function (config) {
    var chartObj = this;
    if (config && config.options) {
        chartObj.styleTypes["default"] = $.map(config.options,
            function (value) {
                chartObj.chartStyleOptions[value["key"]] = value;
                return value["key"];
            }
        );
    }
};

infChart.StockChart.prototype.getCurrentIntervalOptions = function (interval) {
    return this.intervalOptions[interval];
};

infChart.StockChart.prototype._isIntraday = function (interval) {
    return (this.intervalOptions[interval] && this.intervalOptions[interval].intraday);
};

infChart.StockChart.prototype.isShortPeriod = function (period) {
    return (period == 'I' || period.indexOf("I_") == 0);
};

infChart.StockChart.prototype.getIntervalOption = function (interval) {
    return this.intervalOptions[interval];
};

infChart.StockChart.prototype.getMainSeries = function () {
    return this.chart && this.chart.series && this.chart.series[0];
};

infChart.StockChart.prototype._getSeriesCompareValue = function (series) {
    return series.compareValue ? series.compareValue : series.dataModify && series.dataModify.compareValue ? series.dataModify.compareValue : 0;
};

infChart.StockChart.prototype.getMainYAxis = function () {
    var mainSeries = this.getMainSeries();
    return mainSeries && mainSeries.yAxis;
};

infChart.StockChart.prototype.getMainXAxis = function () {
    var mainSeries = this.getMainSeries();
    return mainSeries && mainSeries.xAxis;
};

infChart.StockChart.prototype.isMainSeries = function (series) {
    var mainSeries = this.getMainSeries();
    return series && mainSeries && series.options.id === mainSeries.options.id;
};

infChart.StockChart.prototype.getSeriesData = function (series, isProcessed) {
    var data;
    switch (series.options.infType) {
        case 'base':
            if (isProcessed) {
                data = this.processedData.data;
            } else {
                data = this.rangeData.data;
            }
            break;
        case 'compare':
            if (isProcessed) {
                data = this.processedData.compareSymbols[series.options.id];
            } else {
                data = this.rangeData.compareData[series.options.id];
            }
            break;
        default:
            break;
    }
    return data;
};

infChart.StockChart.prototype.getCompareSeriesFromId = function (seriesId) {
    return this.chart.get(seriesId);
};

/**
 * check data is available in given range
 * @param  {Number} dataMin
 * @param  {Number} dataMax
 * @private
 */
infChart.StockChart.prototype._isDataAvailableInRange = function (dataMin, dataMax) {
    var _d = this.data.base;
    var rangeData = [];
    var dataRangeMin = parseInt(dataMin);
    var dataRangeMax = parseInt(dataMax);
    var isDataAvailable = false;

    if (dataRangeMin != 0 && dataRangeMax != 0) {
        infChart.util.forEach(_d, function (i, val) {
            if (val[0] >= dataRangeMin || val[0] <= dataRangeMax) {
                isDataAvailable = true;
                return;
            }
        });
    }

    return isDataAvailable;
};

/**
 * Method to set base chart symbol
 * @param {object} symbolProperties symbol properties object
 * @param {boolean} load get history
 * @param {boolean} redraw redraw
 * @param config compareSymbols - comparison symbols, indicators - indicator series, drawings - drawing items
 */
infChart.StockChart.prototype.setSymbol = function (symbolProperties, load, redraw, config, setDefaultChartSettings) {
    if (this.symbol && this.checkEquivalentSymbols(this.symbol, symbolProperties)) {
        console.log("Same symbol is sent to 'setSymbol'");
        return;
    }

    var previousSymbol, hChart = this.chart, mainSeries = this.getMainSeries();

    //remove all popups
    infChart.structureManager.common.closeAllPopups(this.id);
    infChart.structureManager.settings.hideAllSettingsPopups(true);

    if (this.symbol) {
        previousSymbol = $.extend({}, this.symbol);
        this.removeSeriesFromTimeMap(mainSeries.options.id);
    }
    //initialize private properties
    this.symbol = symbolProperties;
    this.dp = !isNaN(symbolProperties.dp) ? symbolProperties.dp : this.settings.config.defaultDp;
    this.marketOpenDetails = this.dataManager.getMarketOpenTimes(symbolProperties);

    if (typeof redraw == 'undefined') {
        redraw = false;
    }

    /**
     * clear last line & previous close
     */
    if (this.hasLastLine) {
        this._removeLastLine(true);
        this.hasLastLine = config ? !!config.last : true;
    }

    if (this.hasPreviousCloseLine) {
        this._removePreviousCloseLine(false, true);
        this.hasPreviousCloseLine = config ? !!config.preClose : true;
    }

    /**
     * clear navigator series
     */
    this._cleanNavigatorSeries(false, []);

    config = config || {};

    if (infChart.indicatorMgr && !config.setProperties) {
        infChart.indicatorMgr.resetIndicators(this.id, false);
    }

    if (config.setProperties) {
        var that = this;

        that.removeAllIndicators(false);

        infChart.util.forEach(that.compareSymbols.idMap, function (id, symbol) {
            that.removeCompareSymbol(symbol);
        });


        if (!config.isManualInterval) {

            //overwritten the config to set the best fitting interval for the period
            if(config.period == "C") {
                this.range = config.range ? config.range : {};
            }
            var interval = config.interval ? config.interval : this.getMinInterval(config.period);

            if (interval) {
                var intervalOptions = this.intervalOptions[interval],
                    settingsIntervalOptions = this.intervalOptions[config.interval];
                if (!settingsIntervalOptions || (config.fixedIntervalOnPeriodChange && settingsIntervalOptions.time < intervalOptions.time) ||
                    (!config.fixedIntervalOnPeriodChange && settingsIntervalOptions.time != intervalOptions.time)) {
                    config.interval = interval;
                }
            }
        } else {
            //overwritten the config to set the best fitting period for the interval
            config.period = this._getBestPeriod(config.interval, config.period);
        }
        that.seriesColorOptions = {};
        that._setProperties(config, setDefaultChartSettings);
    }

    this.getMainXAxis().update({
        ordinal: !this.isLinearData()
    }, false);

    mainSeries.update({
        data: [],
        name: symbolProperties.symbol,
        title: symbolProperties.symbolDesc,
        infLegendLabel: this._getSymbolDisplayName(symbolProperties),
        symbolType: symbolProperties.symbolType,
        infLineDataField: symbolProperties.lineDataField,
        dp: !isNaN(symbolProperties.dp) ? symbolProperties.dp : this.settings.config.defaultDp,
        type: this.type,
        hasColumnNegative: false,
        showInNavigator: true
    }, redraw); // clear

    //redraw water mark before set properties : CCA-2794
    hChart.options.watermark = this.getWatermarkContent();

    //this is fired before data is loaded
    this._fireEventListeners('setSymbol', [this.symbol, previousSymbol, config]);

    if (load) {
        if (config.userExtremes && (config.userExtremes.xAxis || config.userExtremes.yAxis)) {
            if (config.userExtremes.xAxis && config.userExtremes.xAxis.userMin && config.userExtremes.xAxis.userMax) {
                this.setXAxisExtremes(config.userExtremes.xAxis.userMin, config.userExtremes.xAxis.userMax, false, true);
            }

            if (config.userExtremes.yAxis && config.userExtremes.yAxis.userMin && config.userExtremes.yAxis.userMax) {
                this.setUserDefinedYAxisExtremes(config.userExtremes.yAxis.userMin, config.userExtremes.yAxis.userMax, false);
            }
        } else {
            //reset user extremes
            this.defaultXAxisExtremes = undefined;
            this.resetXAxisExtremesToDefault(false);
            this.resetYAxisExtremes(false);
        }

        //this.isManualPeriod = true;
        if (config.mainSeriesOptions) {
            this._setSeriesProperties(mainSeries, config.mainSeriesOptions, redraw);
        }

        this._loadHistory(config.compareSymbols, config.indicators, config.drawings, config.flags, undefined, config.range, undefined, config.noData, config.compareSeriesOptions, config.requestColums);
    }

    if(this.settingsPopups[mainSeries.options.id]){
        this.settingsPopups[mainSeries.options.id].remove();
        delete this.settingsPopups[mainSeries.options.id];
    }

    this._loadSettingWindow(!this.isRightPanelOpen(), {'seriesId': mainSeries.options.id});
    if (config.selectedSettingTabOptions && config.selectedSettingTabOptions.tabId) {
        this.showRightPanelWithTab(config.selectedSettingTabOptions.tabId);
        this.showActiveSctionInRightPanel(config.selectedSettingTabOptions.tabId, config.selectedSettingTabOptions.activeTabPaneIndex);
    }
};

///**
// * @Deprecated
// * with the new highcharts api, multiple navigator series available.
// * so chart.series[i].name.toLowerCase() == 'navigator' logic is not valid
// * use _cleanNavigatorSeries
// * Reset navigator series when setting new symbol to chart.
// * @param redraw
// */
//infChart.StockChart.prototype.resetNavigator = function (redraw) {
//    var chart = this.chart;
//    var seriesLength = chart.series.length;
//    var navigatorSeries;
//
//    for (var i = 0; i < seriesLength; i++) {
//        if (chart.series[i].name.toLowerCase() == 'navigator') {
//            navigatorSeries = chart.series[i];
//            break;
//        }
//    }
//
//    if (navigatorSeries) {
//        navigatorSeries.setData([], redraw, false, false);
//    }
//};

/**
 * Get history data from data manager ( Asynchronous data loading )
 */
infChart.StockChart.prototype._loadHistory = function (compareSymbols, indicators, drawings, flags, isReload, range, data, noData, compareSeriesOptions, requestColums) {

    if (this._isCustomPeriod() && range) {
        range.toDate = undefined;
    } else {
        range = undefined;
    }
    var intervalOptions = this.getCurrentIntervalOptions(this.interval);

    var properties = {
        symbol: this.symbol,
        interval: this.interval,
        reload: isReload,
        mockData: this.mockData,
        fromDate: range && range.fromDate,
        maxPeriod: intervalOptions ? intervalOptions.maxPeriod : undefined,
        toDate: range && range.toDate,
        data: data || this.symbol.data,
        noData: noData,
        regularIntervalsOnUpdate: this.regularIntervalsOnUpdate,
        requestColums: requestColums
    };

    this.range = range || {};
    this.cleanBaseSymbolData();

    if (compareSymbols) {
        properties.compareSymbols = compareSymbols;
        properties.compareSeriesOptions = compareSeriesOptions;
    }
    if (indicators) {
        properties.indicators = indicators;
    }
    if (drawings) {
        properties.drawings = drawings;
    }
    if (flags) {
        properties.flags = flags;
        if (this.flags.enabled.length > 0) {
            this.toggleFlags();
        }
    }
    this.setLoading(true);
    //this.chart.redraw();
    setTimeout(this.dataManager.readHistoryData(properties, this._onReadHistoryDataLoad, this), 0);
};

infChart.StockChart.prototype.cleanBaseSymbolData = function () {
    this.data.base = [];
    this.dataMap.base = {};
    this.symbol.data = undefined;
    this.rawData.base = {};

    //clean processed data to recalculate again and set fresh data set
    this.rangeData.data = [];
    this.rangeData.ohlcv = {};
    this.processedData.data = [];
    this.processedData.ohlcv = {};
    this.recalStart = {};
};

/**
 * Update the chart with given set of data
 * works as a callback function which executes after retrieving data
 * @param data
 * @param properties
 */
infChart.StockChart.prototype._onReadHistoryDataLoad = function (data, properties) {
    var onReadHistoryDataLoad = (new Date()).getTime();
    //todo : should we check destroyed property instead of chart??
    if (this.chart && !this.destroying && data.data && this.checkEquivalentSymbols(this.symbol, properties.symbol) && data.interval == this.interval) {
        try {

            if (data.data.length > 0) {
                console.debug("chart :: onReadHistoryDataLoad : start time - " + new Date(data.data[0][0]) + ", end time - " + new Date(data.data[data.data.length - 1][0]));
                console.debug(data);
            }
            this.cleanBaseSymbolData();
            this.data.base = data.data;
            this.dataMap.base = data.dataMap;
            this.symbol.data = undefined;

            this.rawData.base = data;


            //var manual = this.isManualPeriod;
            //this.chart.infManualExtreme = false; // Extremes need to be reset since a new data set is set to the chart.
            var cType = this.type;
            if(this.isStyleChangedByForce) {
                this.isStyleChangedByForce = false;
                this.setChartStyle(this.prevChartStyle, false, false);
                this.prevChartStyle = undefined;
            }
            if (this._isOHLCRequired() && data.hasOpenHighLow === false) {
                this.prevChartStyle = this.type;
                this.isManualChartType = false;
                cType = 'line';
                this.isStyleChangedByForce = true;
                this.setChartStyle('line', false, false); // in here isPropertyChange value sends as false to prevent adding changes to the undo/redo stack.
            }
            this._onPropertyChange("onHistoryDataLoad_type", [cType]); // fire a property change manually to avoid the issue IT-2185

            infChart.structureManager.legend.cleanSeriesData(this.id, this.getMainSeries().options.id, "base");

            this.setPeriod(this.period, this.isManualPeriod, false, undefined, false, false);
            this.isManualPeriod = false;
            this.isManualInterval = false;

            var that = this;

            if (properties) {
                if (properties.compareSymbols && properties.compareSymbols.length > 0) {
                    var i = 0, len = properties.compareSymbols.length;
                    for (i; i < len; i++) {
                        var symbol = properties.compareSymbols[i];
                        if (symbol.symbolId) {
                            var compareSeriesOptions = {};
                            if (properties.compareSeriesOptions && properties.compareSeriesOptions.length > 0) {
                                compareSeriesOptions = properties.compareSeriesOptions[i];
                            }
                            that.addCompareSymbol(symbol, { 'seriesOptions': compareSeriesOptions, 'range': that.range }, false);
                        }
                    }
                }

                var iCount = properties && properties.indicators ? properties.indicators.length : 0;
                if (iCount > 0) {
                    var redrawOnIndicator = !this.volume;
                    infChart.util.forEach(properties.indicators, function (i, val) {
                        iCount--;
                        if (!that._isSingletonIndicator(val.type)) {
                            // since volume property of the config handles the volume,
                            // removed the code changing that property dynamically if not can't off the volume from config when it is saved in indicators
                            try {
                                that.addIndicator(val.type, val, (iCount === 0 && redrawOnIndicator), false);
                            }
                            catch (x) {
                                infChart.util.console.error('error in adding indicator : ' + x);
                            }
                        }
                    });
                }

                if (properties.flags) {
                    this.flagTypes = properties.flags;
                    this.toggleFlags();
                }
            }

            this.setVolume(!!this.volume, false, false);
            this.setBidAskHistory(!!this.bidAskHistory, false, false);
            this.setSpread(!!this.spread, false, false);

            if (this.extremes) {//todo : check with below if loop
                // this.setRange(this.extremes.min, this.extremes.max);
                this.setXAxisExtremes(this.extremes.min, this.extremes.max);
                this.extremes = null;
                delete this.extremes;
            } else {
                this.chart.redraw();
            }
            if (this.chart.redrawWaterMark) {
                this.chart.redrawWaterMark();
            }

            if (this.isUserDefinedXAxisExtremes()) {
                var mainXAxis = this.getMainXAxis(),
                    zoomRangeMin = mainXAxis.userMin,
                    zoomRangeMax = mainXAxis.userMax;

                if (typeof this.data.base === 'undefined' || this.data.base.length === 0) { // chart has no data
                    this.resetXAxisExtremesToDefault();
                } else { //has data check zoom range has data
                    if (!this._isDataAvailableInRange(zoomRangeMin, zoomRangeMax)) {
                        this.resetXAxisExtremesToDefault();
                    }
                }

            }

            if (this.isUserDefinedYAxisExtremes()) {
                var mainYAxis = this.getMainYAxis();
                if (mainYAxis.dataMax < mainYAxis.min || mainYAxis.dataMin > mainYAxis.max) {
                    this.resetYAxisExtremes(true);
                }
            }
        }
        catch (ex) {
            infChart.util.console.error(this.id + ": Error in onReadHistoryDataLoad", ex);
        }
    } else {
        this.setSpread(!!this.spread, false, false);
    }

    this.setLoading(false);
    if (this.tooltip) {
        this.updateTooltipToLastPoint(true);
        if (this.isResizeRequired()) {
            this.resizeChart();
        }
    }
    this._showNoData(!this.isLoading() && (typeof this.data.base === 'undefined' || this.data.base.length === 0));
    if (this.isFirstLoadInprogress()) {
        this.loaded = true;
        this.isfirstLoad = false;
        // this.resizeChart();
        if (this.isResizeRequired()) {
            this.resizeChart();
        }
        //if (this.settings.events && this.settings.events.afterDataLoad) {
        //    this.settings.events.afterDataLoad.call(this);
        //}
        this._fireEventListeners('afterDataLoad');
    }

    this._fireEventListeners("onReadHistoryDataLoad", [this.rangeData.data, properties]);
    this._fireEventListeners('onBaseSymbolDataLoad', [this.rangeData.data]);

    var endTime = (new Date()).getTime();
    this.performanceCheck['onReadHistoryDataLoad'] = {
        diff: endTime - onReadHistoryDataLoad,
        startTime: onReadHistoryDataLoad,
        endTime: endTime
    };
    this._printPerformance();
    //chart.redraw();
};

/**
 * Method to update chart data
 */
infChart.StockChart.prototype._update = function () {//redraw
    //
    //if (typeof redraw == "undefined") {
    //    redraw = true;
    //}

    // if(!this.isUserDefinedYAxisExtremes()) {
    //     this.resetYAxisExtremes(false);
    // }

    this._setPeriodData();
    this._recalculateAll(false);
    this._clearPlotLines(false);
};

/**
 * Update data when streaming
 */
infChart.StockChart.prototype._updateFromTicks = function () {
    this._updatePeriodData();
    this._recalculateAll(false);
    this._clearPlotLines(false);
};

infChart.StockChart.prototype.getCompareSeriesId = function (symbol) {
    return "c_" + symbol.symbolId.replace(/[!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "_");
};

infChart.StockChart.prototype.getCompareSymbolFromSeriesId = function (seriesId) {
    return this.compareSymbols.idMap[seriesId];
};

/**
 * Method to add a comparison series to chart
 * @param symbol
 * @param config
 * @param {boolean} isPropertyChange
 */
infChart.StockChart.prototype.addCompareSymbol = function (symbol, config, isPropertyChange) {

    if (this.chart && !this.compareSymbols.symbols[symbol.symbolId]) { // add series if not added before
        var range = symbol.range || config && config.range,
            id = this.getCompareSeriesId(symbol),
            compareValue;

        this.compareSymbols.count++;
        this.compareSymbols.symbols[symbol.symbolId] = symbol;
        this.compareSymbols.idMap[id] = symbol;

        compareValue = (this.compareSymbols.count >= 1 && this.isPercent) || (this.compareSymbols.count == 1 && !this.isFirstLoadInprogress()) ? "percent" : undefined

        var properties = {
                "symbol": symbol,
                "seriesColor": infChart.util.getNextSeriesColor(),
                "compare": compareValue,
                "styleTypes": this.styleTypes.compare,
                "hideClose": this.settings.config.hideClose
            },
            series = this.addSeries(id, "compare", properties, false, config && config.seriesOptions);

        if (this.compareSymbols.count === 1) {
            this.setChartDataMode("compare", false, false);
            if (this._isToolbarEnabled()) {
                infChart.toolbar.setVisibility(this.id, 'spread', true);
            }
        }
        // if (isPropertyChange) {
        //     this.setChartDataMode("compare", false, isPropertyChange);
        // }
        this._loadCompareHistory(symbol, range, undefined, undefined, isPropertyChange);
        //this.scaleDrawings(this.id);

        if (this.compareSymbols.count === 1) {
            infChart.toolbar.setSelectedControls(this.id, "comparison", true);
        }

        this._loadSettingWindow(true, {'seriesId': series.options.id});

        this._fireEventListeners("onAddCompareSymbol", [symbol, this._getSeriesProperties(series)]);

        if (!this.isFirstLoadInprogress() && this.isResizeRequired()) {
            this.resizeChart();
        }
    }
};

/**
 * Remove given series of the given type from the chart
 * @param seriesId
 * @param type
 */
infChart.StockChart.prototype.removeSeriesFromChart = function (seriesId, type) {
    var self = this;
    switch (type) {
        case "compare":
            self.removeCompareSymbol(self.getCompareSymbolFromSeriesId(seriesId), true);
            break;
        default:
            self.removeSeries(seriesId, true);
            break;
    }
};

/**
 * Remove compare symbol Externally
 * @param {object} symbol
 * @param {boolean} isPropertyChange
 */
infChart.StockChart.prototype.removeCompareSymbol = function (symbol, isPropertyChange) {
    var id = this.getCompareSeriesId(symbol),
        series = this.chart.get(id);

    if (series) {
        this.compareSymbols.count--;
        delete this.compareSymbols.symbols[symbol.symbolId];
        delete this.data.compare[symbol.symbolId];
        delete this.dataMap.compare[symbol.symbolId];
        delete this.rawData.compare[symbol.symbolId];
        delete this.compareSymbols.idMap[id];
        delete this.rangeData.compareData[id];
        delete this.processedData.compareSymbols[id];
        this.removeSeries(id);
        if (this.compareSymbols.count <= 0) {
            if (this.spread) {
                this.toggleSingletonIndicatorByType('SPREAD', false, false, true);
            }
            if (this._isToolbarEnabled()) {
                infChart.toolbar.setVisibility(this.id, 'spread', false);
            }
            this.setChartDataMode("compareToNormal", true, isPropertyChange !== false);
            this.maxRangeVal = this.getMaxDisplayTime();
            this._setChartToMaxPossiblePeriod(true);
            infChart.toolbar.setSelectedControls(this.id, "comparison", false);
        }
        if (this.hasLastLineForCompareSymbols) {
            this._removeLastLineForCompareSymbol(id);
        }
        if (isPropertyChange !== false) {
            this._onPropertyChange("compareSymbols", {symbol: symbol, action: "remove"});
        }
        this._fireEventListeners("onRemoveCompareSymbol", [symbol]);
    }
};

/**
 * Method to load history data of a compare symbol
 * @param symbol
 * @param range
 * @param data
 * @param isReload whether to reload data or get from cache if available
 */
infChart.StockChart.prototype._loadCompareHistory = function (symbol, range, data, isReload, isPropertyChange) {

    range = !this._isCustomPeriod() ? undefined : range;

    var intervalOptions = this.getCurrentIntervalOptions(this.interval),
        properties = {
            symbol: symbol,
            interval: this.interval,
            reload: isReload,
            maxPeriod: intervalOptions ? intervalOptions.maxPeriod : undefined,
            fromDate: range && range.fromDate,
            toDate: range && range.toDate,
            data: data || symbol.data,
            regularIntervalsOnUpdate: this.regularIntervalsOnUpdate,
            isPropertyChange: isPropertyChange
        };
    this.cleanCompareData(symbol);
    this.setLoading(true);
    //this.chart.redraw();
    this.dataManager.readHistoryData(properties, this._onCompareDataLoad, this);
};

infChart.StockChart.prototype.cleanCompareData = function (symbol) {
    var symbolId = symbol.symbolId;
    this.data.compare[symbolId] = [];
    this.dataMap.compare[symbolId] = {};
    this.rawData.compare[symbolId] = {};

    var seriesId = this.getCompareSeriesId(symbol),
        series = this.chart.get(seriesId);

    // reset particular series data to set fresh data
    this.processedData.compareSymbols[seriesId] = [];
    this.recalStart[seriesId] = 0;
};

/**
 * callback method when loading history of a compare symbol
 * @param data
 * @param properties
 */
infChart.StockChart.prototype._onCompareDataLoad = function (data, properties) {
    var symbol = properties.symbol.symbolId;
    try {
        if (data.interval == this.interval) {
            var chart = this.chart,
                dataObj;
            this.data.compare[symbol] = data.data;
            this.dataMap.compare[symbol] = data.dataMap;
            this.rawData.compare[symbol] = data;

            var seriesId = this.getCompareSeriesId(properties.symbol),
                series = chart.get(seriesId);

            // reset particular series data to set fresh data
            this.processedData.compareSymbols[seriesId] = [];
            this.recalStart[seriesId] = 0;

            properties.symbol.data = undefined;

            infChart.structureManager.legend.cleanSeriesData(this.id, seriesId, "compare");

            if (data.data && data.data.length) {
                var newMinRangeVal = this.getPossibleMinRangeValue();
                if (newMinRangeVal != this.minRangeVal) {
                    this.minRangeVal = newMinRangeVal;
                }
            }

            this._setPeriodData(symbol);
            dataObj = this._processData(this.rangeData.compareData[seriesId],
                this.isCompare, this.isLog, this.isPercent, false, seriesId);
            this.processedData.compareSymbols[seriesId] = dataObj.data;

            var seriesData = this._getSeriesDataByChartType(series.options.type, this.processedData.compareSymbols[seriesId].slice(), series.options.infLineDataField);
            series.setData(seriesData, false, false, false);
            series.userOptions.data = this.rangeData.compareData[seriesId];

            this._setDummyData(false);
            this._recalculateIndicators(false, 0, ["compare"]);
            //this._setFullRange();

            //chart.redraw();
            this._setChartToMaxPossiblePeriod(true);

            this.prevousClose = {};
            this.updatePriceLines();

            //this.setLegendValue(seriesId);

            if (dataObj && dataObj.data && dataObj.data.length) {
                this._destroyNoDataLabel();
            }
            if (properties.isPropertyChange) {
                var value = {};
                value.symbol = properties.symbol;
                value.action = "add";
                this._onPropertyChange("compareSymbols", value);
            }
        }
    }
    catch (ex) {
        infChart.util.console.error("Error on onCompareDataLoad:" + ex);
    }

    if (properties && properties.isPropertyChange && (typeof this.data.compare[symbol] === 'undefined' || this.data.compare[symbol].length === 0)) {
        infChart.util.showMessage(this.id, infChart.manager.getLabel("msg.compareNoData").replace("{0}", this._getSymbolDisplayName(properties.symbol)));
    }

    this.setLoading(false);
    if (data.interval == this.interval) {
        this.updateMinMax();


        if (this.tooltip) {
            this.updateTooltipToLastPoint(true);
        }
        this._fireRegisteredMethod('onCompareSymbolLoad', [this.rangeData.compareData[seriesId], properties.symbol]);
        this._fireEventListeners("onCompareSymbolLoad", [properties.symbol, this.rangeData.compareData[seriesId]], true);
    }
};

infChart.StockChart.prototype.setTimeLagOnCompare = function (symbol, time, redraw) {
    var compSym = symbol && symbol.symbolId && this.compareSymbols.symbols[symbol.symbolId];
    if (compSym) {
        var seriesId = this.getCompareSeriesId(symbol),
            series = this.chart.get(seriesId),
            symbolId = symbol.symbolId,
            dataObj;
        compSym.timeLag = time;
        this._setPeriodData(symbolId);
        dataObj = this._processData(this.rangeData.compareData[seriesId],
            this.isCompare, this.isLog, this.isPercent, false, seriesId);

        this.seriesActualMinMax[seriesId] = {dataMin: dataObj.dataMin, dataMax: dataObj.dataMax};
        this.processedData.compareSymbols[seriesId] = dataObj.data;

        var seriesData = this._getSeriesDataByChartType(series.options.type, this.processedData.compareSymbols[seriesId].slice(), series.options.infLineDataField);
        series.setData(seriesData, redraw, false, false);
        series.userOptions.data = this.rangeData.compareData[seriesId];


        this._setFullRange();

        this.prevousClose = {};
        this.updatePriceLines();
    }

};

infChart.StockChart.prototype.setTimeLagOnBaseSymbol = function (time, redraw) {
    var series = this.getMainSeries(),
        symbol = this.symbol.symbolId,
        dataObj,
        seriesData;

    this.symbol.timeLag = time;
    this._setPeriodData();
    dataObj = this._processData(this.rangeData.data,
        this.isCompare, this.isLog, this.isPercent, true, series.options.id);

    this.processedData.data = dataObj.data;
    this.processedData.ohlcv = this.dataManager.getOHLCV(dataObj.data);

    seriesData = this._getSeriesDataByChartType(series.options.type, this.processedData.data.slice(), series.options.infLineDataField);
    series.setData(seriesData, redraw, false, false);
    series.userOptions.data = this.rangeData.data;


    this._setFullRange();

    this.prevousClose = {};
    this.updatePriceLines();

};

/**
 * filter chart data according to selected period
 * @param symbol
 * @private
 */
infChart.StockChart.prototype._setPeriodData = function (symbol) {
    // Todo : try to simplify this method more
    var _d = this.data.base,
        croppedData = [],
        mainSeriesData = [],
        mainSeriesMinMax = {},
        that = this,
        minRangeVal,
        min,
        max,
        count = 0;

    if (this.minRangeVal && this.maxRangeVal) {

        var rangDataFirst;
        if (!symbol) {

            infChart.util.forEach(_d, function (i, val) {
                minRangeVal = (that.symbol.timeLag && !isNaN(that.symbol.timeLag)) ? that.minRangeVal + that.symbol.timeLag : that.minRangeVal;
                if (val[0] >= minRangeVal) {
                    //if (val[0] <= that.maxRangeVal) {
                    max = (isNaN(max) || max < val[2]) ? val[2] : max;
                    min = (isNaN(min) || min > val[2]) ? val[2] : min;
                    croppedData[count] = val;
                    count++;
                    //} else {
                    //    return;
                    //}
                }
            });


            //this.getMainSeries().setData([], false); // clear
            mainSeriesData = croppedData;

        }
        var minMaxValues = this.getMinMaxRangeValues();
        rangDataFirst = minMaxValues && minMaxValues.min || mainSeriesData[0] || this.rangeData.data[0];

        infChart.util.forEach(this.compareSymbols.symbols, function (key, symbolObj) {
            if (symbol == key || !symbol) {
                croppedData = [];
                count = 0;
                if (that.data.compare[key]) {
                    min = undefined;
                    max = undefined;
                    minRangeVal = (symbolObj.timeLag && !isNaN(symbolObj.timeLag) && rangDataFirst) ? rangDataFirst[0] + symbolObj.timeLag : that.minRangeVal;
                    infChart.util.forEach(that.data.compare[key], function (i, val) {
                        if (val[0] >= minRangeVal) {
                            // if (val[0] <= that.maxRangeVal) {
                            croppedData[count] = val;
                            count++;
                            max = (isNaN(max) || max < val[2]) ? val[2] : max;
                            min = (isNaN(min) || min > val[2]) ? val[2] : min;
                            // } else {
                            //     return;
                            // }
                        }
                    });
                }
                var seriesId = that.getCompareSeriesId(symbolObj);
                that.rangeData.compareData[seriesId] = croppedData;
            }
        });
    } else {
        if (!symbol) {
            croppedData = _d;
            mainSeriesData = croppedData;
        }
        // TODO :: check whether this logic is required or not
        infChart.util.forEach(this.compareSymbols.symbols, function (key, symbolObj) {
            if (symbol == key || !symbol) {
                var seriesId = that.getCompareSeriesId(symbolObj);
                croppedData = that.data.compare[key];
                that.rangeData.compareData[seriesId] = croppedData;
            }
        });
    }

    if (mainSeriesData.length > 0) {
        this.rangeData.data = mainSeriesData;
        this.rangeData.ohlcv = this.dataManager.getOHLCV(mainSeriesData);
        //this.rangeData.compareData = compareData;
    } else {
        // this.rangeData.data = [];
        // this.rangeData.ohlcv = {};
    }
};

/**
 * Process and update new ticks to the series
 * this is triggered from update ticks method
 * To keep _setPeriodData more simple implemented updating in a new method.
 * @param symbol
 * @private
 */
infChart.StockChart.prototype._updatePeriodData = function (symbol) {

    var _d = this.data.base,
        croppedData = [],
        mainSeriesData = [],
        iChart = this,
        minRangeVal,
        min,
        max,
        count = 0,
        mainSeries = this.getMainSeries(),
        mainSeriesOldData = this.rangeData.data,
        recalStartIdx = Math.min((_d.length && (_d.length - 1)) || 0, (mainSeriesOldData.length && (mainSeriesOldData.length - 1)) || 0),
        i,
        val,
        removeLastFromBase = false;

    if (this.minRangeVal && this.maxRangeVal) {

        var rangDataFirst,
            oldLastTime = (mainSeriesOldData && mainSeriesOldData[recalStartIdx] && mainSeriesOldData[recalStartIdx][0]) || 0;
        if (!symbol && mainSeries) {

            // if symbol is not specified update the

            minRangeVal = (iChart.symbol.timeLag && !isNaN(iChart.symbol.timeLag)) ? iChart.minRangeVal + iChart.symbol.timeLag : iChart.minRangeVal;

            for (i = _d.length - 1; i >= 0; i--) {
                val = _d[i];

                if (val[0] >= minRangeVal) {
                    if (/*val[0] <= iChart.maxRangeVal &&*/ oldLastTime <= val[0]) {
                        max = (isNaN(max) || max < val[2]) ? val[2] : max;
                        min = (isNaN(min) || min > val[2]) ? val[2] : min;
                        croppedData.unshift(val);
                        count++;
                    } else {
                        break;
                    }
                }
            }

            if (croppedData.length > 0) {
                //this.getMainSeries().setData([], false); // clear
                if (oldLastTime >= croppedData[0][0]) {
                    removeLastFromBase = true;

                    // removes the all the main series data which are before the new ticks
                    for (i = mainSeriesOldData.length - 1; i >= 0; i--) {
                        if (mainSeriesOldData[i][0] >= croppedData[0][0] || _d.length <= mainSeriesOldData.length) {
                            mainSeriesOldData.splice(i
                                , mainSeriesOldData.length - i);
                        } else {
                            recalStartIdx = i + 1;// recalculats should start from the index of the first new tick
                            break;
                        }
                    }
                    //mainSeriesOldData.splice(mainSeriesOldData.length - 1, 1);
                } else if (_d.length <= mainSeriesOldData.length) {
                    mainSeriesOldData.splice(_d.length - 1, mainSeriesOldData.length - _d.length - 1);
                }
                iChart.recalStart[mainSeries.options.id] = mainSeriesOldData.length;
                mainSeriesData = mainSeriesOldData.concat(croppedData);
            }
        }

        var minMaxValues = this.getMinMaxRangeValues();
        rangDataFirst = minMaxValues && minMaxValues.min || mainSeriesData[0] || this.rangeData.data[0];

        infChart.util.forEach(this.compareSymbols.symbols, function (key, symbolObj) {
            if (symbol == key || !symbol) {
                croppedData = [];
                count = 0;
                if (iChart.data.compare[key]) {
                    min = undefined;
                    max = undefined;
                    minRangeVal = (symbolObj.timeLag && !isNaN(symbolObj.timeLag) && rangDataFirst) ? rangDataFirst + symbolObj.timeLag : rangDataFirst;

                    _d = iChart.data.compare[key];

                    var seriesId = iChart.getCompareSeriesId(symbolObj),
                        series = iChart.chart.get(seriesId),
                        seriesData = iChart.rangeData.compareData[seriesId];

                    if (seriesData && seriesData.length > 0) { //series && series.options.data,
                        var lastTimeIdx = Math.min((_d.length > 0 ? _d.length - 1 : 0), seriesData.length - 1),
                            seriesLastTime = seriesData[lastTimeIdx][0];

                        if (series) {
                            for (i = _d.length - 1; i >= 0; i--) {
                                val = _d[i];
                                if (val[0] >= minRangeVal) {
                                    if (/*val[0] <= iChart.maxRangeVal &&*/ seriesLastTime <= val[0]) {
                                        croppedData.unshift(val);
                                        count++;
                                        max = (isNaN(max) || max < val[2]) ? val[2] : max;
                                        min = (isNaN(min) || min > val[2]) ? val[2] : min;
                                    } else {
                                        break;
                                    }
                                }
                            }
                        }

                        if (croppedData.length > 0) {
                            if (seriesLastTime >= croppedData[0][0]) {
                                seriesData.splice(seriesData.length - 1, 1);

                                // removes the all the compare series data which are before the new ticks
                                for (i = seriesData.length - 1; i >= 0; i--) {
                                    if (seriesData[i][0] >= croppedData[0][0] || _d.length < seriesData.length) {
                                        seriesData.splice(i
                                            , seriesData.length - i);
                                    } else {
                                        //  recalStartIdx = i + 1;// re-calculates should start from the index of the first new tick
                                        break;
                                    }
                                }
                            } else if (_d.length < seriesData.length) {
                                seriesData.splice(_d.length - 1, seriesData.length - _d.length - 1);
                            }

                            iChart.recalStart[seriesId] = seriesData.length;
                            seriesData = seriesData.concat(croppedData);
                            iChart.rangeData.compareData[seriesId] = seriesData;
                        }
                    }
                }

            }
        });
    } else {
        if (!symbol) {
            croppedData = _d;
            mainSeriesData = croppedData;
        }
        // TODO :: check whether this logic is required or not
        infChart.util.forEach(this.compareSymbols.symbols, function (key, symbolObj) {
            if (symbol == key || !symbol) {
                var seriesId = iChart.getCompareSeriesId(symbolObj);
                croppedData = iChart.data.compare[key];
                iChart.rangeData.compareData[seriesId] = croppedData;
            }
        });
    }

    if (mainSeriesData.length > 0) {

        this.rangeData.data = mainSeriesData;
        // get data for the indicator
        var ohlcv = this.dataManager.getOHLCV(mainSeriesData, recalStartIdx);

        infChart.util.forEach(ohlcv, function (i, val) {

            if (iChart.rangeData.ohlcv[i]) {
                // remove the elements after the recalStartIdx from  Chart.rangeData.ohlcv
                if (recalStartIdx <= (iChart.rangeData.ohlcv[i].length - 1)) {
                    iChart.rangeData.ohlcv[i].splice(recalStartIdx, iChart.rangeData.ohlcv[i].length - recalStartIdx);
                }
                iChart.rangeData.ohlcv[i] = iChart.rangeData.ohlcv[i].concat(val);
            } else {
                iChart.rangeData.ohlcv[i] = val;
            }
        });

        //this.rangeData.compareData = compareData;

    }

};

/**
 * Recalculate all the data and set them to the series.
 * If only update is required user should set the recalStart number of the series
 * @param redraw
 * @private
 */
infChart.StockChart.prototype._recalculateAll = function (redraw) {
    var cCount = this.compareSymbols.count,
        dataObj;
    this._setMainSeriesData(cCount === 0 && redraw);
    //todo :: set user options ??

    if (cCount > 0) {
        var xChart = this;
        infChart.util.forEach(this.compareSymbols.symbols, function (k, val) {
            var seriesId = xChart.getCompareSeriesId(val),
                series = xChart.chart.get(seriesId),
                oldProcessedData = xChart.processedData.compareSymbols[seriesId],
                newProcessedData,
                oldData = series.options.data,
                newData,
                recalStart = xChart.recalStart[seriesId] || 0, // data processing starts from this number if specified
                isUpdate = (recalStart != 0),
                i,
                iLen;

            if (xChart.rangeData.compareData[seriesId]) {

                // remove all the prev data which are after the recalStart Index of the series
                if (isUpdate && oldData.length >= recalStart) {
                    for (i = recalStart, iLen = oldData.length; i < iLen; i++) {
                        var lastIdx = oldData.length - 1,
                            time = oldData[lastIdx];
                        oldData.splice(lastIdx, 1);
                        xChart.processedData.compareSymbols[seriesId].splice(lastIdx, 1);
                        if (xChart.processedData.timeMap[time] && xChart.processedData.timeMap[time].indexOf(seriesId) >= 0) {
                            xChart.processedData.timeMap[time].splice(xChart.processedData.timeMap[time].indexOf(seriesId), 1);
                            if (!xChart.processedData.timeMap[time].length) {
                                delete xChart.processedData.timeMap[time];
                            }
                        }
                    }
                }

                // ammend new data if availble and set them to the series
                dataObj = xChart._processData(xChart.rangeData.compareData[seriesId], xChart.isCompare, xChart.isLog, xChart.isPercent, false, seriesId, xChart.processedData.timeMap);
                newProcessedData = dataObj.data;
                xChart.processedData.compareSymbols[seriesId] = isUpdate ? oldProcessedData.concat(newProcessedData) : newProcessedData;
                cCount--;

                var data = xChart._getSeriesDataByChartType(series.options.type, dataObj.data, series.options.infLineDataField);
                newData = isUpdate ? oldData.concat(data) : data;
                series.setData(newData, cCount === 0 && redraw, false, false);
                series.userOptions.data = xChart.rangeData.compareData[seriesId];

            } else {
                infChart.util.console.log('range data not loaded yet for : ' + k);
            }
        });
    }
    // keep track of each time to be used when scaling (zooming and dragging)
    // convert these times to an array to avoid conversion on demand
    var pointPositions = [];
    infChart.util.forEach(this.processedData.timeMap, function (k, val) {
        pointPositions.push(k);
    });
    this.processedData.pointPositions = pointPositions;

    this.updatePriceLines();
};

/**
 * Returns relavent the series data for the given chart type
 * @param chartType
 * @param data
 * @param lineDataField
 * @returns {*}
 * @private
 */
infChart.StockChart.prototype._getSeriesDataByChartType = function (chartType, data, lineDataField) {
    var result = data;
    if (chartType === 'line' || chartType === 'area' || chartType === 'column' || chartType == 'step') {
        var index = 4;
        lineDataField = lineDataField || this.settings.config.lineDataField;
        if (lineDataField) {
            switch (lineDataField) {
                case "open":
                    index = 1;
                    break;
                case "high":
                    index = 2;
                    break;
                case "low":
                    index = 3;
                    break;
                case "close":
                    index = 4;
                    break;
                case "volume":
                    index = 5;
                    break;
            }
        }
        result = this.dataManager.merge(data, [0, index]); // set close value for data
    }
    return result;
};

infChart.StockChart.prototype._getSymbolDisplayName = function (symbol){
    var chartObj = this;
    var result;
    if(chartObj && chartObj.settings.registeredMethods && chartObj.settings.registeredMethods.getSymbolDisplayName) {
        result = chartObj.settings.registeredMethods.getSymbolDisplayName(symbol);
    } else {
        result = infChart.util.getSymbolDisplayName(symbol);
    }
    return result;
}

infChart.StockChart.prototype._getDummySeries = function (isForward) {

};

/**
 * calculate and set main series data
 * @private
 */
infChart.StockChart.prototype._setDummyData = function (redraw) {
    var
    //dummySeries = this.chart.get(infChart.constants.dummySeries.missingId),
        xAxis = this.getMainXAxis(),
        dummySeries2,
        processedData = this.processedData.data,
        min = (processedData[0] && processedData[0][0]) || 0,
        max = (processedData[processedData.length - 1] && processedData[processedData.length - 1][0]) || 0,
        periodMin = this._getMinDate(this.period, max),
        compareSymbols = this.processedData.compareSymbols,
        tempMin,
        tempMax,
        count = processedData.length /*+ (dummySeries && dummySeries.options.data && dummySeries.options.data.length) || 0*/,
        i,
        iLen,
        dummyData = [],
        softMinArr = [],
        softMaxArr = [],
        tempSoftMinArr = [],
        tempSoftMaxArr = [],
        lastVal = (processedData[processedData.length - 1] && processedData[processedData.length - 1]);

    if (processedData.length > 5) {
        for (i = processedData.length - 6, iLen = processedData.length; i < iLen; i++) {
            if (periodMin <= processedData[i][0]) {
                softMinArr.xPush(processedData[i][0]);
            }
        }

        if (processedData.length > 10) {
            for (i = 0, iLen = 5; i < iLen; i++) {
                softMaxArr.xPush(processedData[i][0]);
            }
        }
    }

    for (var sym in compareSymbols) {

        if (compareSymbols.hasOwnProperty(sym)) {
            tempSoftMinArr = [];
            tempSoftMaxArr = [];
            processedData = compareSymbols[sym];
            tempMin = (processedData[0] && processedData[0][0]);
            tempMax = (processedData[processedData.length - 1] && processedData[processedData.length - 1][0]);

            if (tempMin && tempMin < min) {
                for (i = 0; processedData[i] && processedData[i][0] < min; i++) {
                    count++;
                    tempSoftMaxArr.xPush(processedData[i][0]);
                }
                min = tempMin;

                if (tempSoftMaxArr.length > 0) {
                    for (i = 0, iLen = tempSoftMaxArr.length; i < iLen; i++) {
                        softMaxArr.unshift(tempSoftMaxArr[i]);
                    }
                    softMaxArr = softMaxArr.slice(5);
                }
            }

            if (tempMax && tempMax > max) {
                for (i = processedData.length; processedData[i] && processedData[i][0] > max; i--) {
                    count++;
                    tempSoftMinArr.unshift(processedData[i][0]);
                }
                max = tempMax;

                if (tempSoftMinArr.length > 0) {
                    softMinArr = softMinArr.slice(tempSoftMinArr.length);
                    for (i = 0, iLen = tempSoftMinArr.length; i < iLen; i++) {
                        softMinArr.xPush(tempSoftMinArr[i]);
                    }
                }
            }

        }
    }

    var prevTime = max,
        dummyCount = Math.min(200, Math.floor(count / 4)),
        tempTimeStart,
        tickInterval = this.intervalOptions[this.interval] && this.intervalOptions[this.interval].time,
        backwardSeries,
        foarwardSeries,
        minT = this._getMinDate(this.period, min, true),
        maxT = this._getMaxDate(this.period, max);

    if (dummyCount > 0 || minT < min) {

        if (this.interval == 'T') {
            //tempTimeStart = min + (max - min)/4;
            tickInterval = (max - min) / (4 * dummyCount);
        }

        if (this.settings.config.panToFuture) {

            var o = lastVal && lastVal[1] || null,
                h = lastVal && lastVal[2] || null,
                l = lastVal && lastVal[3] || null,
                c = lastVal && lastVal[4] || null,
                v = lastVal && lastVal[5] || null;

            this.removeSeriesFromTimeMap(infChart.constants.dummySeries.forwardId, false);
            prevTime = max;
            dummyCount = maxT > max ? Math.floor((maxT - max) / tickInterval) : dummyCount;
            for (i = 0; i < dummyCount; i++) {
                var tempTime = this.interval == 'T' ? prevTime + tickInterval : this.getNextTickTime(prevTime, this.interval);

                if(this._isValidCandleTime(tempTime)) {
                    dummyData.xPush([tempTime, o, h, l, c, v]);
                    this.addValueToTimeMap(tempTime, infChart.constants.dummySeries.forwardId, this.processedData.timeMap);
                }

                prevTime = tempTime;
            }

            dummySeries2 = this.settings.config.panToFuture && this.chart.get(infChart.constants.dummySeries.forwardId);
            dummySeries2.setData(dummyData, false, false, false);
        }

        if (this.settings.config.panToPast) {
            this.removeSeriesFromTimeMap(infChart.constants.dummySeries.backwardId, false);
            prevTime = min;
            dummyData = [];
            dummyCount = min > minT ? Math.floor((min - minT) / tickInterval) : dummyCount;
            for (i = 0; i < dummyCount; i++) {
                var tempTime = this.interval == 'T' ? prevTime - tickInterval : this.getNextTickTime(prevTime, this.interval, true);
                dummyData.unshift([tempTime, null, null, null, null, null]);
                this.addValueToTimeMap(tempTime, infChart.constants.dummySeries.backwardId, this.processedData.timeMap);
                prevTime = tempTime;
            }

            dummySeries2 = this.settings.config.panToPast && this.chart.get(infChart.constants.dummySeries.backwardId);
            dummySeries2.setData(dummyData, false, false, false);
        }

    } else {
        backwardSeries = this.settings.config.panToPast && this.chart.get(infChart.constants.dummySeries.backwardId);
        foarwardSeries = this.settings.config.panToFuture && this.chart.get(infChart.constants.dummySeries.backwardId);
        if (backwardSeries && backwardSeries.options.data && backwardSeries.options.data.length > 0) {
            backwardSeries.setData([], false, false, false);
        }
        if (foarwardSeries && foarwardSeries.options.data && foarwardSeries.options.data.length > 0) {
            foarwardSeries.setData([], false, false, false);
        }
    }

    if (softMinArr.length > 0 && xAxis.options.softMin != softMinArr[softMinArr.length - 1]) {
        xAxis.update({
            softMin: softMinArr[0]
        }, false);
    } else if (softMinArr.length == 0) {
        xAxis.update({
            softMin: undefined
        }, false);
    }

    if (softMaxArr.length > 0 && xAxis.options.softMax != softMaxArr[softMaxArr.length - 1]) {
        xAxis.update({
            softMax: softMaxArr[0]
        }, false);
    } else if (softMaxArr.length == 0) {
        xAxis.update({
            softMax: undefined
        }, false);
    }

    if (redraw) {
        this.chart.redraw(false);
    }
};

/**
 *
 * @param timeStamp
 * @returns {boolean}
 * @private
 */
infChart.StockChart.prototype._isValidCandleTime = function (timeStamp) {
    var isValid = true;

    if(!this.isLinearData()) {
        if (this.settings.config.ignoreWeekEndFromFutureDates && new Date(timeStamp).getUTCDay() % 6 === 0) {
            isValid = false;
        }

        if (isValid && this._hasRegisteredMethod('getHolidaysList')) {
            var holidaysList = this.settings.registeredMethods.getHolidaysList.call(this);
            var futureDate = new Date(timeStamp);
            var month = futureDate.getUTCMonth() + 1;
            var date = futureDate.getUTCDate();
            var convertedTimeStamp = futureDate.getUTCFullYear() + (month < 10? "0" : "") + month + (date < 10? "0" : "") + date;

            isValid = holidaysList.indexOf(convertedTimeStamp) === -1;
        }
    }

    return isValid;
}

/**
 * calculate and set main series data
 * @private
 */
infChart.StockChart.prototype._setMainSeriesData = function (redraw) {

    var mainSeries = this.getMainSeries(),
        seriesId = mainSeries.options.id,
        recalStart = this.recalStart[mainSeries.options.id] || 0,
        isUpdate = (recalStart != 0),
        dataObj = this._processData(this.rangeData.data, this.isCompare, this.isLog, this.isPercent, this.settings.config.displayAllIntervals, mainSeries.options.id, isUpdate && this.processedData.timeMap),
        newData,
        oldData = mainSeries.options.data,
        oldProcessedData = this.processedData.data,
        data,
        i,
        iLen;

    // Remove old data which are after the the recalStart index since they will be set with the new updates
    if (isUpdate && oldData.length >= recalStart) {
        for (i = recalStart, iLen = oldData.length; i < iLen; i++) {
            var lastIdx = oldData.length - 1, time = oldData[lastIdx][0];
            oldData.splice(lastIdx, 1);
            this.processedData.data.splice(lastIdx, 1);
            // delete old time references
            if (this.processedData.timeMap[time] && this.processedData.timeMap[time].indexOf(seriesId) >= 0) {
                this.processedData.timeMap[time].splice(this.processedData.timeMap[time].indexOf(seriesId), 1);
                if (!this.processedData.timeMap[time].length) {
                    delete this.processedData.timeMap[time];
                }
            }
        }
    }

    // amend new data if available and set them to the chart.
    this.processedData.data = isUpdate ? this.processedData.data.concat(dataObj.data) : dataObj.data;
    // keep track of each time to be used when scaling (zooming and dragging)
    if (isUpdate) {
        $.extend(this.processedData.timeMap, dataObj.timeMap);
    } else {
        this.processedData.timeMap = dataObj.timeMap;
    }

    // processd ohlcv data available
    if (isUpdate) {
        // processed new data and return all
        var iChart = this, tempOhlcv = this.dataManager.getOHLCV(this.processedData.data, recalStart);
        infChart.util.forEach(tempOhlcv, function (i, val) {
            if (iChart.processedData.ohlcv[i]) {
                if (recalStart <= (iChart.processedData.ohlcv[i].length - 1)) {
                    iChart.processedData.ohlcv[i].splice(recalStart, iChart.processedData.ohlcv[i].length - recalStart);
                }
                iChart.processedData.ohlcv[i] = iChart.processedData.ohlcv[i].concat(val);
            } else {
                iChart.processedData.ohlcv[i] = val;
            }
        });
    } else {
        this.processedData.ohlcv = this.dataManager.getOHLCV(this.processedData.data);
    }

    data = this._getSeriesDataByChartType(this.type, dataObj.data.slice(), this.symbol.lineDataField);
    newData = isUpdate ? oldData.concat(data) : data;

    /*var dummySeries = this.settings.config.displayAllIntervals && this.chart.get(infChart.constants.dummySeries.missingId);
     if (dummySeries) {
     if (dataObj.dummyData && dataObj.dummyData.length > 0) {
     // update new dummy data for the updates if availble
     newData = isUpdate ? dummySeries.options.data.concat(dataObj.dummyData) : dataObj.dummyData;
     dummySeries.setData(newData);
     } else {
     dummySeries.setData([]);
     }
     }*/

    this._setDummyData(false);

    if (this.settings.config.unGroupedDataOnLoad) {
        this._setUnGroupedRange(this.processedData.data);
    }

    //recalculate indicators if processing is required only for the updates send the index
    this._recalculateIndicators(false, isUpdate && this.recalStart[mainSeries.options.id]);

    this._setMainSeriesDataToChart(newData, redraw);
};

//region ===================== Period/Interval =========================================================================

/**
 * get current time from the service if provided
 * @returns Date
 */
infChart.StockChart.prototype.getCurrentTime = function() {
    if (this._hasRegisteredMethod('getUTCTimeDifference')) {
        var timeDiff = this.settings.registeredMethods.getUTCTimeDifference();
        var timeStamp = new Date().getTime() + timeDiff;
        return new Date(timeStamp);
    } else {
        return new Date();
    }
};

/**
 * Method to change chart period
 * @param period
 * @param isManually
 * @param setControl
 * @param range
 * @param {boolean} isPropertyChange
 * @param redraw
 */
infChart.StockChart.prototype.setPeriod = function (period, isManually, setControl, range, isPropertyChange, redraw) {
    infChart.util.console.log('calling onPeriodChange : ' + period);
    setControl = typeof setControl == "undefined" ? true : setControl;
    try {

        if (typeof redraw == "undefined") {
            redraw = true;
        }

        if (isPropertyChange) {
            this._onBeforePropertyChange("period", period);
        }

        this.period = period;
        this.recalStart = {};
        if (infChart.indicatorMgr) {
            infChart.indicatorMgr.resetIndicators(this.id, false);
        }

        this.isManualPeriod = isManually;
        /* Keep redraw true for _symbolSeries method to avoid https://xinfiit.atlassian.net/browse/CG-20
         *  Issue Desc :: The chart is getting empty, once after selected any period from Intraday (after changing a chart type into different one)*/
        this._symbolSeries(redraw);
        if (!this.isManualInterval) {
            this.isManualPeriod = false;
            this._setBestIntervalOfPeriod(period, isManually, range);
        }

        if (isManually) {
            this.chart.infManualExtreme = false;  // Extremes need to be reset since a new data set is set to the chart.
            this.isManualInterval = false;
            this.resetYAxisExtremes(false);
        }

        if (this.data.base) {
            var l = this.data.base.length;
            if (l > 0) {
                //set x-axis min/max
                var currentEx = this.getRange(),
                    minMaxValues = this.getMinMaxRangeValues(),
                    max = this.getMaxDisplayTime(),
                    extremeMax = (this.chart.infManualExtreme && currentEx && (currentEx.max || currentEx.userMax)) || max,
                    extremeMin = (this.chart.infManualExtreme && currentEx && (currentEx.min || currentEx.userMin)) || this._getMinDate(period, extremeMax);

                this.maxRangeVal = minMaxValues.max || max;
                this.minRangeVal = (this.settings && this.settings.config.showAllHistory && this.data.base[0][0]) || extremeMin;//this._getMinDate(period);
                this.exMinVal = extremeMin;

                //update data for period
                this._update();

                var min = /*isManually ||*/ this.chart.infManualExtreme ? extremeMin : (!this.minExVal && Math.max(extremeMin, this.minExVal)) || isManually ? Math.max(extremeMin, this.minRangeVal) : Math.max(extremeMin, this.minExVal) || extremeMin;
                if (max > 0) {
                    if (this.setMaxAvailablePeriod && !this.chart.infManualExtreme && min < minMaxValues.min) {
                        min = minMaxValues.min;
                    }

                    for (var i = 0, len = this.chart.xAxis.length; i < len; i++) {
                        var redrawOnExt = (i == len - 1) && redraw;
                        this._setDefaultXAxisExtremes(min, max); // Saving default xAxis extremes to show hide reset xAxis button
                        this.chart.xAxis[i].setExtremes(min, extremeMax, redrawOnExt, false);
                    }
                }

                //this._setFullRange();
                this._adjustRangeSelectorMinMax();
                this.updateMinMax();
                this.isManualPeriod = false;

            } else {
                this._hideMinMaxLabels();
                this._removePreviousCloseLineElements();
                this._removeLastLineElements();
            }

            if (redraw) {
                this.chart.redraw();
                if (this.isUserDefinedYAxisExtremes() && l > 0) {
                    var mainYAxis = this.getMainYAxis();
                    if (mainYAxis.dataMax < mainYAxis.min || mainYAxis.dataMin > mainYAxis.max) {
                        this.resetYAxisExtremes(true);
                    }
                }
            }
        } else {
            infChart.util.console.log('calling onPeriodChange : data not available');
        }

        if (setControl && this._isToolbarEnabled()) {
            infChart.toolbar.setSelectedControls(this.id, "period", this.period, "interval", this.interval);
        }

        if (isPropertyChange) {
            this._onPropertyChange("period");
        }
    }
    catch (x) {
        if (window.logMode == 'error') {
            infChart.util.console.error(x);
        }
    }
};

/**
 *  Retursn the maximum time to display by default
 * 1. When selecting 1D if Exchange is not open yet, then should show previous days chart.
 * 2. If Exchange is open then should show current days chart. The X axis should span the period for which the Exchange is open on the day.
 * 3. If 2D is selected and the Exchange is open it should show the previous days data and the current days data.
 * 4. If 1Week is selected it should show the last 5 trading days data. If the Exchange is open then it should show the current day and the previous 4 days.
 * 5. The X axis should not be linear. Periods with no data should be omitted from the X axis.
 * @returns {*}
 */
infChart.StockChart.prototype.getMaxDisplayTime = function () {

    var marketOpenDetails = this.marketOpenDetails,
        isMarketOpen = marketOpenDetails && marketOpenDetails.isOpenNow,
        lastOpenTime = marketOpenDetails && this.dataManager.getChartTime(marketOpenDetails.lastOpenTime, marketOpenDetails.timeZoneOffset, this.interval),
        newUtcDate,
        minMaxValues = this.getMinMaxRangeValues();

    if (!this.isLinearData() && isMarketOpen && lastOpenTime) {

        var periodAsArray = this.period.split("_"),
            periodType = periodAsArray[0],
            periodTypeSub = periodAsArray[1],
            units = (periodAsArray.length > 2) ? +periodAsArray[2] : periodAsArray.length > 1 ? +periodAsArray[1] : 1,
            useMarketTime;

        switch (periodType) {
            case 'I':
                useMarketTime = periodTypeSub == 'H' || (periodTypeSub == 'D' && units < 3);
                break;
            case 'D':
                useMarketTime = units < 3;
                break;
            case 'W':
                useMarketTime = units < 2;
                break;
            default:
                break;

        }

        if (useMarketTime) {

            var marketOpenTime = marketOpenDetails && marketOpenDetails.openHours,
                marketOpenHours = (marketOpenTime && Math.floor(marketOpenTime)) || 0,
                marketOpenMinutes = (marketOpenTime && (marketOpenTime % marketOpenHours) * 60) || 0,
                date = new Date(lastOpenTime),
                openTimePeriod = (marketOpenHours * 60 + marketOpenMinutes) * 60 * 1000,
                periodTime = this.periodOptions[this.period].time;

            newUtcDate = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours() + marketOpenHours, date.getUTCMinutes() + marketOpenMinutes, date.getUTCSeconds());

            if (periodTypeSub == 'H' && periodTime < openTimePeriod) {
                if ((lastOpenTime + periodTime) < minMaxValues.max) {
                    newUtcDate = minMaxValues.max;
                }
                else {
                    newUtcDate = lastOpenTime + periodTime;
                }
            }
        }
    }

    if (!newUtcDate) {
        newUtcDate = minMaxValues.max || ( this.data.base.length && this.data.base[this.data.base.length - 1][0]);
    }

    return newUtcDate;
};

/**
 * Change chart data interval
 * @param {string} interval
 * @param subInterval
 * @param {boolean} redraw
 * @param {boolean} isFixedPeriod
 * @param period
 * @param range
 * @param {boolean} isPropertyChange
 */
infChart.StockChart.prototype.setInterval = function (interval, subInterval, redraw, isFixedPeriod, period, range, isPropertyChange) {

    if (((!this.period || this.period == period && period == 'C' /*|| (!period && this.period == 'C')*/) &&
        range && range.fromDate == this.range.fromDate && range.toDate == this.range.toDate && this.interval == interval) ||
        (((period && period != 'C') || (!period && this.period && !this._isCustomPeriod())) &&
        (period && this.period == period && this.interval == interval) || (!period && this.interval == interval))) {
        return;
    }


    if (isPropertyChange) {
        this._onBeforePropertyChange("interval", interval);
    }

    //todo :: further check performance issue
    if (typeof redraw === 'undefined') {
        redraw = true;
    }
    var chart = this.chart;

    range = (period && period != 'C') || (!period && !this._isCustomPeriod()) ? undefined : range;

    /*var period;*/
    var allowedMultiples = undefined;
    var unitName = undefined;

    var isDataAvailable = this.interval === interval && !this._isCustomPeriod();

    switch (interval) {
        case 'T':
            /*if (!isFixedPeriod && this.period !== 'I') {
             period = 'I';
             }*/
            unitName = 'second';
            allowedMultiples = [1];
            break;
        case 'I_1':
        case 'I_3':
        case 'I_5':
        case 'I_15':
        case 'I_30':
        case 'I_60':
        case 'I_120':
        case 'I_240':
        case 'I_360':
            /* if (!isFixedPeriod && this.period !== 'I') {
             period = 'I';
             }*/
            unitName = 'minute';
            allowedMultiples = [1];
            break;
        case 'D':
            if (!isFixedPeriod && this.isShortPeriod(this.period)) {
                period = 'M_3';
            }
            break;
        case 'W':
            if (!isFixedPeriod && this.isShortPeriod(this.period)) {
                period = 'M_6';
            }
            unitName = 'week';
            allowedMultiples = [1];
            break;
        case 'M':
            if (!isFixedPeriod && (this.isShortPeriod(this.period) || this.period === 'M_1')) {
                period = 'Y_3';
            }
            unitName = 'month';
            allowedMultiples = [1];
            break;
        case 'Y':
            if (!isFixedPeriod && !(this.period === 'Y_1' || this.period === 'Y_3' || this.period === 'Y_5' || this.period === 'Y_10')) {
                period = 'Y_5';
            }
            unitName = 'year';
            allowedMultiples = [1];
            break;
        default:
            break;
    }

    if (this.useGrouping && unitName && allowedMultiples) {
        infChart.util.forEach(chart.series, function (idx, series) {
            series.update({
                dataGrouping: {
                    units: [[
                        unitName,
                        allowedMultiples
                    ]]
                }
            }, isDataAvailable);
        });
    }

    //var mainSeries = this.getMainSeries();
    if (interval === 'T') {
        /*if(mainSeries.options.dataGrouping && mainSeries.options.dataGrouping.enabled) {
         $.each(chart.series, function (idx, series) {
         series.update({dataGrouping: {enabled: false}}, false);
         });
         }*/

        /*if (this.type !== 'line') {
         this.prevChartType = this.type;
         this.setChartStyle('line', false);
         if (this._isToolbarEnabled()) {
         infChart.toolbar.setSelectedControls(this.id, 'chartType', 'line');
         }
         }*/
    } else {
        if (this.prevChartType && this.prevChartType != this.type) {

            this.setChartStyle(this.prevChartType, false);
            if (this._isToolbarEnabled()) {
                infChart.toolbar.setSelectedControls(this.id, 'chartType', this.prevChartType);
            }
            this.prevChartType = undefined;
        }

        /* if(!mainSeries.options.dataGrouping || !mainSeries.options.dataGrouping.enabled) {
         $.each(chart.series, function (idx, series) {
         series.update({dataGrouping: {enabled: true}}, false);
         });
         }*/
    }

    this._cleanNavigatorSeries(redraw);

    if (!isDataAvailable) {
        this.interval = interval;

        if (period) {
            this.period = period;
            if (isFixedPeriod) {
                this.isManualPeriod = true;
            }
        }
        if (range) {
            this.range = range;
        }
        if (this._isToolbarEnabled()) {
            infChart.toolbar.setSelectedControls(this.id, 'period', this.period, 'interval', this.interval);
        }
        var that = this, compRange, isManualInterval = this.isManualInterval;
        this.data.base = [];
        if (this.compareSymbols.count > 0) {
            infChart.util.forEach(this.compareSymbols.symbols, function (key, val) {
                that.data.compare[key] = [];
            });
        }
        this.minExVal = undefined;
        this.minRangeVal = undefined;
        this.maxRangeVal = undefined;
        this._loadHistory(undefined, undefined, undefined, this.flags.enabled, undefined, range);


        if (this.compareSymbols.count > 0) {
            infChart.util.forEach(this.compareSymbols.symbols, function (key, val) {
                that.data.compare[key] = [];
                compRange = val.range || that.range;
                that._loadCompareHistory(val, compRange);
            });
        }
    } else {
        this.setPeriod(period, true, true);
    }

    //this.setDataGrouping(undefined, true);

    if (isPropertyChange) {
        this._onPropertyChange("interval");
    }
};

/**
 *
 * Returns the min/max values of all the series data (base and compare)
 *
 * @returns {{min: *, max: *}}
 */
infChart.StockChart.prototype.getMinMaxRangeValues = function () {
    var min,
        max,
        compareData = this.data.compare;

    if (this.data.base.length) {
        min = this.data.base[0][0];
        max = this.data.base[this.data.base.length - 1][0];
    }

    if (this.compareSymbols.count > 0) {
        for (var key in compareData) {
            if (compareData.hasOwnProperty(key) && compareData[key] && compareData[key].length) {
                var cData = compareData[key];
                min = (min == undefined) ? cData[0][0] : Math.min(min, cData[0][0]);
                max = (max == undefined) ? cData[cData.length - 1][0] : Math.max(max, cData[cData.length - 1][0]);

            }
        }
    }
    return {min: min, max: max};

};

/**
 * get the best fitting period id given period is not fitting for the given interval
 * @param interval
 * @param currentPeriod
 * @returns {*}
 * @private
 */
infChart.StockChart.prototype._getBestPeriod = function (interval, currentPeriod, isIntervalChange) {
    var maxPeriod = this.getMaxPeriod(interval),
        minPeriod = this.getMinPeriod(interval),
        currentPeriodOptions = this.periodOptions[currentPeriod],
        currentPeriodTime = currentPeriodOptions.time,
        newPeriod = currentPeriod,
        shortestPeriodTime = this.sortedPeriods[0] && this.sortedPeriods[0].time,
        minIntervalTime = this.sortedIntervals[0] && this.sortedIntervals[0].time,
        currentIntervalTime = this.intervalOptions[interval] && this.intervalOptions[interval].time;

    if (this.maxPeriodOnIntervalChange && isIntervalChange) {
        newPeriod = maxPeriod.key;
    }

    // set the nearest possible period if current period is insufficient
    else if (!(currentPeriodTime >= minPeriod.time && currentPeriodTime <= maxPeriod.time)) {
        if (shortestPeriodTime && currentPeriodTime <= shortestPeriodTime && currentIntervalTime <= minIntervalTime) {
            newPeriod = this.sortedPeriods[0].key;
        } else {
            newPeriod = currentPeriodTime <= minPeriod.time ? minPeriod.key : maxPeriod.key;
        }
    }
    return newPeriod;
};

/**
 * change chart data interval manually (not from a result of actions like period change)
 * If current period is insufficient to show the requested interval, period will be changed to nearest possible period.
 * @param {string} interval
 * @param subInterval
 * @param {boolean} redraw
 * @param range
 * @param {boolean} isPropertyChange
 */
infChart.StockChart.prototype.setIntervalManually = function (interval, subInterval, redraw, range, isPropertyChange) {
    var newPeriod = (this.period !== "C") ? this._getBestPeriod(interval, this.period, true) : this.period;
    if (newPeriod) {
        this.isManualPeriod = true;
        this.isManualInterval = true;
        this.setInterval(interval, subInterval, redraw, true, newPeriod, range, isPropertyChange);
    }
};

/**
 * Priority is given to the period
 * @param period
 * @param interval
 * @param redraw
 * @param range
 * @param isPropertyChange
 */
infChart.StockChart.prototype.setPeriodAndIntervalManually = function (period, interval, redraw, range, isPropertyChange) {
    var currentInterval = interval,
        currentIntervalOptions = this.intervalOptions[currentInterval],
        currentIntervalTime = currentIntervalOptions && currentIntervalOptions.time,
        options = this.periodOptions[period],
        minInterval = this.getMinInterval(period),
        minIntervalOptions = this.intervalOptions[minInterval],
        minIntervalTime = minIntervalOptions && minIntervalOptions.time,
        maxInterval,
        maxIntervalOptions,
        maxIntervalTime,
        newInterval = currentInterval;

    minInterval = minInterval || options.defaultInterval;
    maxInterval = this.getMaxInterval(period);
    maxIntervalOptions = this.intervalOptions[maxInterval];
    maxIntervalTime = maxIntervalOptions && maxIntervalOptions.time;

    if (!(minIntervalTime <= currentIntervalTime && currentIntervalTime <= maxIntervalTime)) {

        // since current interval goes beyond the supported range of intervals apply the nearest possible interval for the period
        newInterval = currentIntervalTime < minIntervalTime ? minInterval : maxInterval;

    }

    this.isManualPeriod = true;
    this.isManualInterval = true;
    this.setInterval(newInterval, undefined, redraw, true, period, range, isPropertyChange);
};

/**
 * Private method to set default interval for the given period if interval is too small to cater with period
 * @param period
 * @param isManually
 * @param range
 * @returns {number}
 * @private
 */
infChart.StockChart.prototype._setBestIntervalOfPeriod = function (period, isManually, range) {

    if (isManually && this.periodOptions[period]) {

        var currentInterval = this.interval,
            currentIntervalOptions = this.intervalOptions[currentInterval],
            currentIntervalTime = currentIntervalOptions && currentIntervalOptions.time,
            options = this.periodOptions[period],
            minInterval = this.getMinInterval(period),
            minIntervalOptions = this.intervalOptions[minInterval],
            minIntervalTime = minIntervalOptions && minIntervalOptions.time,
            maxInterval,
            maxIntervalOptions,
            maxIntervalTime,
            newInterval,
            defaultInterval = options.defaultInterval,
            defaultIntervalOptions = this.intervalOptions[defaultInterval],
            defaultIntervalTime = defaultIntervalOptions && defaultIntervalOptions.time;

        minInterval = minInterval || defaultInterval;
        maxInterval = this.getMaxInterval(period);
        maxIntervalOptions = this.intervalOptions[maxInterval];
        maxIntervalTime = maxIntervalOptions && maxIntervalOptions.time;

        if (this.fixedIntervalOnPeriodChange) { // if current interval is applicable to the new period keep it as it is, if not calculated best interval is used
            if (!(minIntervalTime <= currentIntervalTime && currentIntervalTime <= maxIntervalTime)) {

                if (defaultIntervalTime >= minIntervalTime && defaultIntervalTime <= maxIntervalTime) {
                    // set the default interval if the default interval is in the possible range
                    newInterval = defaultInterval;
                } else {
                    // since current interval goes beyond the supported range of intervals apply the nearest possible interval for the period
                    newInterval = currentIntervalTime < minIntervalTime ? minInterval : maxInterval;
                }

            }
        } else if ((defaultInterval && currentInterval != defaultInterval)) {
            if (defaultIntervalTime > minIntervalTime && defaultIntervalTime < maxIntervalTime) {
                // old - set the default interval if the default interval is in the possible range
                // new - set the min interval if the default interval is in the possible range
                if (minInterval && currentInterval != minInterval) {
                    newInterval = minInterval;
                } else {
                    // newInterval = defaultInterval;
                }
            } else if ((minInterval && currentInterval != minInterval)) {
                newInterval = minInterval;
            }
        } else if ((minInterval && currentInterval != minInterval)) {
            // Set the calculated minInterval as the interval always. Doesn't keep the current interval even if it is applicable to the new period.
            newInterval = minInterval;
        }

        if (newInterval) {
            // reset all the properties since a new interval will be set
            this.data = {compare: {}, base: []};
            this.dataMap = {compare: {}, base: {}};
            this.rawData = {compare: {}, base: {}};
            this.processedData.data = [];
            this.processedData.ohlcv = undefined;
            this.recalStart = {};
            this.processedData.compareSymbols = {};
            this.setInterval(newInterval, undefined, false, true);
            if (this._isToolbarEnabled()) {
                infChart.toolbar.setSelectedControls(this.id, "interval", newInterval);
            }
        }

    } else if (period === 'C') {
        if (isManually) {
            // reset all the properties since a new interval will be set
            this.data = {compare: {}, base: []};
            this.dataMap = {compare: {}, base: {}};
            this.rawData = {compare: {}, base: {}};
            this.processedData.data = [];
            this.processedData.ohlcv = undefined;
            this.recalStart = {};
            this.processedData.compareSymbols = {};
            this.setInterval(this.interval, undefined, false, true, undefined, range);
        }
    }
    //this.setDataGrouping();
};

/**
 * Returns the count of the minimum possible data points for the current width
 * @returns {number}
 * @private
 */
infChart.StockChart.prototype._getMinPointCount = function () {

    var groupedPixelWidth = infChart.settings.defaults.maxGroupPixelWidth || 10,
        minDataCount = Math.floor(this._getChartPlotSizeXForPointCount() / groupedPixelWidth);

    return minDataCount;
};

/**
 * Returns the count of the maximum possible data points for the current width
 * @returns {number}
 * @private
 */
infChart.StockChart.prototype._getMaxPointCount = function () {

    var groupedPixelWidth = infChart.settings.defaults.minGroupPixelWidth || 1,
        maxDataCount = Math.floor(this._getChartPlotSizeXForPointCount() / groupedPixelWidth);

    return maxDataCount;
};

/**
 * Returns the adjusted plot size x since chart does not have the correct width when loading before displaying data (yAxis width is not set)
 * So the yAxis width is saved with the config and used that when loading untile data is displayed
 * (That saved y Axis width is used only if current chart's width is same as the chart's width by the time of saving y Axis width )
 * @returns {*}
 * @private
 */
infChart.StockChart.prototype._getChartPlotSizeXForPointCount = function () {

    var plotSizeX = this.chart.plotSizeX;
    if (this.isFirstLoadInprogress() && this.settings && this.settings.config.marginRight && this.settings.config.chartWidth &&
        this.settings.config.chartWidth == this.chart.chartWidth) {
        plotSizeX -= this.settings.config.marginRight;
    }

    return plotSizeX;
};

/**
 * Returns the maximum time interval that can be zoomed in milliseconds
 * @returns {number}
 */
infChart.StockChart.prototype.getMaxZoomRange = function () {

    if (this.chart.plotSizeX) {

        var data = this.processedData.data,
            maxDataCount = this._getMaxPointCount(),
            dataMax = data && data[data.length - 1] && data[data.length - 1][0],
            extStart;

        if(data && data.length > 0) {
            if(data.length >= maxDataCount) {
                extStart = data[data.length - maxDataCount][0];
            } else {
                extStart = data[0][0];
            }
        } else {
            extStart = dataMax && this.getShiftedTime(dataMax, this.interval, maxDataCount);
        }

        if (dataMax && extStart == dataMax) {
            var minIdx = Math.max(data.length - 1 - maxDataCount, 0);
            extStart = data[minIdx] && data[minIdx][0];
        }

        if (extStart) {
            // var minExVal = Math.max(this.minRangeVal, extStart);
            return (dataMax - extStart);
        }
    }
};

/**
 * Returns the maximums zoom range in pixels which will be benifitted in non-linear axes
 * @returns {undefined|number} range in pixels
 */
infChart.StockChart.prototype.getMaxZoomRangePx = function () {
    var scroller = this.chart && this.chart.scroller;
    return scroller && (scroller.size / scroller.baseSeries[0].options.data.length ) * this._getMaxPointCount();
};

/**
 * Returns the number of points that can be drawn in the current space
 * @returns {number} number of points
 */
infChart.StockChart.prototype.getPointsCountForCurrentDisplaySpace = function () {
    var xAxis = this.getMainXAxis();
    if (!this.isLinearData()) {
        var xTimeMap = this.getAllTimeTicks();
        var xData = Object.keys(xTimeMap);
        if (xData.length) {
            var minIndex = Math.abs(infChart.util.binaryIndexOf(xData, undefined, xAxis.min));
            var maxIndex = Math.abs(infChart.util.binaryIndexOf(xData, undefined, xAxis.max));
            return maxIndex - minIndex + 1;
        }
    } else {
        var intervalTime = this.intervalOptions[this.interval] && this.intervalOptions[this.interval].time;
        return (xAxis.max - xAxis.min) / intervalTime;
    }
};

/**
 * Returns total points
 * @returns {object} all points
 */
infChart.StockChart.prototype.calculateTotalPoints = function (chart) {
    var xTimeMap = infChart.manager.getAllTimeTicks(chart);
    var points = Object.keys(xTimeMap);
    if(chart){
        var seriesPoints = JSON.parse(JSON.stringify(chart.series[0].xData));
        for (let i = seriesPoints.length; i < points.length; i++) {
            seriesPoints.push(parseFloat(points[i]));
        }
        return seriesPoints;
    }else{
        return points;
    }
};

/**
 * Returns the maximum possible interval for the given period
 * @param period
 * @returns {*}
 */
infChart.StockChart.prototype.getMaxInterval = function (period) {

    if (this.chart.plotSizeX && this.sortedIntervals && this.sortedIntervals.length > 0) {

        var currentTime = (new Date()).getTime(),
            minTime = this._getMinDate(period, currentTime, true),
            maxDataCount = this._getMinPointCount(),
            calculatedInterval = (currentTime - minTime) / maxDataCount,
            interval,
            prevInterval;

        for (var i = this.sortedIntervals.length - 1; i >= 0; i--) {
            prevInterval = this.sortedIntervals[i + 1];
            interval = this.sortedIntervals[i];
            if (calculatedInterval > interval.time) {
                break;
            }
        }

        /*if (prevInterval && (prevInterval.time - calculatedInterval) < (calculatedInterval - interval.time) && calculatedInterval > prevInterval.time / 2) {
         interval = prevInterval;
         }*/

        return interval && interval.key;
    }
};

/**
 * Returns the maximum possible interval for the given period
 * @param period
 * @returns {*}
 */
infChart.StockChart.prototype.getMinInterval = function (period) {

    if (this.chart.plotSizeX && this.sortedIntervals && this.sortedIntervals.length > 0) {

        var currentTime = (new Date()).getTime(),
            minTime = this._getMinDate(period, currentTime, true),
            maxDataCount = this._getMaxPointCount(),
            calculatedInterval = (currentTime - minTime) / maxDataCount,
            interval,
            prevInterval;

        for (var i = 0, iLen = this.sortedIntervals.length; i < iLen; i++) {
            prevInterval = this.sortedIntervals[i - 1];
            interval = this.sortedIntervals[i];
            if (calculatedInterval < interval.time) {
                break;
            }
        }

        /*if (prevInterval && (calculatedInterval - prevInterval.time) < (interval.time - calculatedInterval) && calculatedInterval / 2 < prevInterval.time) {
         interval = prevInterval;
         }*/

        return interval && interval.key;
    }
};

/**
 * Returns the maximum possible period for the given interval
 * @param interval
 * @returns {*}
 */
infChart.StockChart.prototype.getMaxPeriod = function (interval) {

    if (this.chart.plotSizeX && this.sortedPeriods && this.sortedPeriods.length > 0) {

        var maxDataCount = this._getMaxPointCount(),
            calculatedInterval = this.intervalOptions[interval] && this.intervalOptions[interval].time,
            calculatedPeriod = maxDataCount * calculatedInterval,
            period,
            prevPeriod;

        for (var i = this.sortedPeriods.length - 1; i >= 0; i--) {
            prevPeriod = this.sortedPeriods[i + 1];
            period = this.sortedPeriods[i];
            if (calculatedPeriod > period.time) {
                break;
            }
        }

        if(!prevPeriod){
            prevPeriod = period;
        }

        /*if (prevPeriod /!*&&  (period.time -  calculatedPeriod ) > (calculatedPeriod - prevPeriod.time)*!/) {
         period = prevPeriod;
         }*/

        return prevPeriod && prevPeriod;
    }
};

/**
 * Returns the minimum possible period for the given interval
 * @param interval
 * @returns {*}
 */
infChart.StockChart.prototype.getMinPeriod = function (interval) {

    if (this.chart.plotSizeX && this.sortedPeriods && this.sortedPeriods.length > 0) {

        var maxDataCount = this._getMinPointCount(),
            calculatedInterval = this.intervalOptions[interval] && this.intervalOptions[interval].time,
            calculatedPeriod = maxDataCount * calculatedInterval,
            period,
            prevPeriod;

        for (var i = 0, iLen = this.sortedPeriods.length; i < iLen; i++) {
            prevPeriod = this.sortedPeriods[i - 1];
            period = this.sortedPeriods[i];
            if (calculatedPeriod < period.time) {
                break;
            }
        }

        if(!prevPeriod){
            prevPeriod = period;
        }

        /*if (prevPeriod /!*&&  (period.time -  calculatedPeriod ) > (calculatedPeriod - prevPeriod.time)*!/) {
         period = prevPeriod;
         }*/

        return prevPeriod && prevPeriod;
    }
};

/**
 * Set the min value where data grouping is not required
 * @param data
 * @private
 */
infChart.StockChart.prototype._setUnGroupedRange = function (data) {

    if (this.chart.plotSizeX) {
        var maxDataCount = this._getMaxPointCount(),
            dataMax = data && data[data.length - 1] && data[data.length - 1][0],
            extStart = dataMax && this.getShiftedTime(dataMax, this.interval, maxDataCount);
        if (dataMax && extStart == dataMax) {
            var minIdx = Math.max(data.length - 1 - maxDataCount, 0);
            extStart = data[minIdx] && data[minIdx][0];
        }
        if (extStart && this.minRangeVal < extStart) {
            this.minExVal = extStart;
        }
    }

};

/**
 * Shift the given time to givin no of points and interval
 * @param time
 * @param interval
 * @param count
 * @returns {*}
 */
infChart.StockChart.prototype.getShiftedTime = function (time, interval, count) {
    var dt;

    switch (interval) {
        case 'T':
            return time;
        case 'I_1':
            return time - count * 60000;
        case 'I_2':
            return time - count * 2 * 60000;
        case 'I_3':
            return time - count * 3 * 60000;
        case 'I_5':
            return time - count * 5 * 60000;
        case 'I_10':
            return time - count * 10 * 60000;
        case 'I_15':
            return time - count * 15 * 60000;
        case 'I_30':
            return time - count * 30 * 60000;
        case 'I_60':
            return time - count * 60 * 60000;
        case 'I_120':
            return time - count * 120 * 60000;
        case 'I_240':
            return time - count * 240 * 60000;
        case 'I_360':
            return time - count * 360 * 60000;

        case 'D':
            dt = infChart.util.getDerivedDate(time);
            return Date.UTC(dt.year, dt.month, dt.day - count, dt.hour, dt.minute, dt.second, dt.milliSecond);
        //TODO get last day of week , month or year;

        case 'W':
            dt = infChart.util.getDerivedDate(time);
            return Date.UTC(dt.year, dt.month, dt.day - 7 * count, dt.hour, dt.minute, dt.second, dt.milliSecond);
        case 'M':
            dt = infChart.util.getDerivedDate(time);
            return Date.UTC(dt.year, dt.month - count, dt.day, dt.hour, dt.minute, dt.second, dt.milliSecond);
        case 'Y':
            dt = infChart.util.getDerivedDate(time);
            return Date.UTC(dt.year - count, dt.month, dt.day, dt.hour, dt.minute, dt.second, dt.milliSecond);
    }

};

infChart.StockChart.prototype.getNextTickTime = function (currentTickTime, interval, isBackward) {
    var dt, direction = isBackward ? -1 : 1, tickTime;

    switch (interval) {
        case 'T':
            tickTime = 0;
            break;
        case 'I_1':
            tickTime = currentTickTime + (direction * 60000);
            break;
        case 'I_2':
            tickTime = currentTickTime + (direction * 2 * 60000);
            break;
        case 'I_3':
            tickTime = currentTickTime + (direction * 3 * 60000);
            break;
        case 'I_5':
            tickTime = currentTickTime + (direction * 5 * 60000);
            break;
        case 'I_10':
            tickTime = currentTickTime + (direction * 10 * 60000);
            break;
        case 'I_15':
            tickTime = currentTickTime + (direction * 15 * 60000);
            break;
        case 'I_30':
            tickTime = currentTickTime + (direction * 30 * 60000);
            break;
        case 'I_60':
            tickTime = currentTickTime + (direction * 60 * 60000);
            break;
        case 'I_120':
            tickTime = currentTickTime + (direction * 120 * 60000);
            break;
        case 'I_240':
            tickTime = currentTickTime + (direction * 240 * 60000);
            break;
        case 'I_360':
            tickTime = currentTickTime + (direction * 360 * 60000);
            break;
        case 'D':
            dt = infChart.util.getDerivedDate(currentTickTime);
            tickTime = Date.UTC(dt.year, dt.month, dt.day + direction, dt.hour, dt.minute, dt.second, dt.milliSecond);
            //return currentTickTime + 24 * 60 * 60000;
            //TODO get last day of week , month or year;
            break;
        case 'W':
            dt = infChart.util.getDerivedDate(currentTickTime);
            tickTime = Date.UTC(dt.year, dt.month, dt.day + direction * 7, dt.hour, dt.minute, dt.second, dt.milliSecond);
            //return currentTickTime + 7 * 24 * 60 * 60000;
            break;
        case 'M':
            dt = infChart.util.getDerivedDate(currentTickTime);
            tickTime = Date.UTC(dt.year, dt.month + direction, dt.day, dt.hour, dt.minute, dt.second, dt.milliSecond);
            //return currentTickTime + 30 * 24 * 60 * 60000;
            break;
        case 'Y':
            dt = infChart.util.getDerivedDate(currentTickTime);
            tickTime = Date.UTC(dt.year + direction, dt.month, dt.day, dt.hour, dt.minute, dt.second, dt.milliSecond);
            //return currentTickTime + 30 * 24 * 60 * 60000;
            break;
        default:
            break;
    }
    return tickTime;
};

///**
// * Check whether the current extremes of x axis is similar to default extremes
// */
//infChart.StockChart.prototype.isDefaultXAxisExtremes = function (currentXAxisExtremes) {
//    return this.defaultXAxisExtremes ? (currentXAxisExtremes.min === this.defaultXAxisExtremes.min && currentXAxisExtremes.max === this.defaultXAxisExtremes.max) : true;
//};

infChart.StockChart.prototype._setChartToMaxPossiblePeriod = function (redraw) {

    var extremes = this.getRange(),
        extremestMin = extremes.min || extremes.userMin,
        extremestMax = extremes.max || extremes.userMax,
        max = (this.chart.infManualExtreme) ? extremestMax : this.maxRangeVal,
        minEx = (this._getMinDate(this.period, max) || this.minExVal) || this.minRangeVal,
    //min = (this.chart.infManualExtreme) ? /*(minEx > extremes.min) ? minEx :*/ extremes.min : ( minEx > this.minRangeVal ) ? minEx : this.minRangeVal,
        min = this.chart.infManualExtreme ? extremestMin : (minEx > this.minRangeVal || !this.setMaxAvailablePeriod) ? minEx : this.minRangeVal || minEx,
        minMaxValues,
        defaultMin = min;

    if (!this.chart.infManualExtreme && (this.setMaxAvailablePeriod)) {
        minMaxValues = this.getMinMaxRangeValues();
        min = Math.min(minMaxValues.min, minEx); // TODO :: need to set minRange or set all the data  in the compare load
    }

    if (this.chart.infManualExtreme) {
        var defaultEx = this.defaultXAxisExtremes,
            defaultMinTemp = this._getMinDate(this.period, this.maxRangeVal) || (defaultEx && defaultEx.min) || minEx;
        defaultMin = (defaultMinTemp > this.minRangeVal || !this.setMaxAvailablePeriod) ? defaultMinTemp : this.minRangeVal || defaultMinTemp
    }

    this._setDefaultXAxisExtremes(defaultMin, this.maxRangeVal); // Saving default xAxis extremes to show hide reset xAxis button

    var fireAfterRedrawXAxisWithoutSetExtremes = false;
    if (min != extremestMin || max != extremestMax) {
        // this.setRange(min, max);
        this.setXAxisExtremes(min, max, false, false);
    } else {
        fireAfterRedrawXAxisWithoutSetExtremes = true;
    }

    if (redraw) {
        this.chart.redraw();
    }
    if(fireAfterRedrawXAxisWithoutSetExtremes) {
        this._fireEventListeners('afterRedrawXAxisWithoutSetExtremes');
    }
};

/**
 * Returns the possible min range value for the chart
 * @returns {*|newMinRangeVal}
 */
infChart.StockChart.prototype.getPossibleMinRangeValue = function () {
    var currentEx = this.getRange(),
        max = this.getMaxDisplayTime(),
        extremeMax = (this.chart.infManualExtreme && currentEx && (currentEx.max || currentEx.userMax)) || max,
        extremeMin = this._getMinDate(this.period, extremeMax),
        minRangeVal = this.minRangeVal || extremeMin;

    if (this.settings && this.settings.config.showAllHistory && this.setMaxAvailablePeriod) {

        var minMaxValues = this.getMinMaxRangeValues();
        minRangeVal = minMaxValues.min;

    }
    return minRangeVal;

};

//endregion ================== end of Period/Interval ==================================================================

/**
 * calculate and set main series data
 * @private
 */
infChart.StockChart.prototype._setMainSeriesDataToChart = function (data, redraw) {
    this.getMainSeries().setData(data, false, false, false);

    if (this.chart.scroller && this.chart.scroller.series) {
        var seriesArr = (Array.isArray(this.chart.scroller.series)) ? this.chart.scroller.series.length > 0 ? this.chart.scroller.series : [] : [this.chart.scroller.series];
        if (seriesArr.length > 0) {
            for (var i = 0; i < seriesArr.length - 1; i++) {
                if(seriesArr[i].hasGroupedData && seriesArr[i].groupedData) {
                    /*When navigator height is zero highcharts assign empty points to series's groupedData object. When removing those series
                    * highcharts call destroy method of those point which cause exceptions in highcharts library. Hence we are removing those
                    * series data from here to avoid exceptions
                    * */

			        seriesArr[i].hasGroupedData = false;
			        seriesArr[i].groupedData = undefined;
			    }
                seriesArr[i].remove(redraw);
            }

            if (seriesArr[seriesArr.length - 1] && seriesArr[seriesArr.length - 1].setData) {
                seriesArr[seriesArr.length - 1].setData(data, false, false, false);
            }

            seriesArr.splice(0, seriesArr.length - 1);
        }
    }
    if (redraw) {
        this.chart.redraw();
    }
};

/**
 * _cleanNavigatorSeries
 * @param redraw
 * @param data
 * @private
 */
infChart.StockChart.prototype._cleanNavigatorSeries = function (redraw, data) {
    if (this.chart.scroller && this.chart.scroller.series) {
        var seriesArr = (Array.isArray(this.chart.scroller.series)) ? this.chart.scroller.series.length > 0 ? this.chart.scroller.series : [] : [this.chart.scroller.series];
        if (seriesArr.length > 0) {
            var i = 0, len = seriesArr.length - 1;
            for (i; i < len; i++) {
                if (seriesArr[i]) {
                    if(seriesArr[i].hasGroupedData && seriesArr[i].groupedData) {
                        /*When navigator height is zero highcharts assign empty points to series's groupedData object. When removing those series
                        * highcharts call destroy method of those point which cause exceptions in highcharts library. Hence we are removing those
                        * series data from here to avoid exceptions
                        * */
    			        seriesArr[i].hasGroupedData = false;
    			        seriesArr[i].groupedData = undefined;
    			    }
                    seriesArr[i].remove(false);
                }
            }

            if (data && seriesArr[len]) {
                seriesArr[len].setData(data, false, false, false);
            }
            seriesArr.splice(0, len);
        }
    }
    if (redraw) {
        this.chart.redraw();
    }
};

/**
 * _cleanNavigatorSeries
 * @param redraw
 * @param data
 * @private
 */
infChart.StockChart.prototype._symbolSeries = function (redraw) {
    if (this.chart.series) {
        var seriesArr = (this.chart.series && this.chart.series.length > 0) ? this.chart.series : [];
        if (seriesArr.length > 0) {
            var i = 0, len = seriesArr.length;
            for (i; i < len; i++) {
                if (seriesArr[i].options.data && seriesArr[i].options.data.length &&
                    (seriesArr[i].options.infType == "compare" || seriesArr[i].options.infType == "base" || seriesArr[i].options.infType == "dummy")) {
                    seriesArr[i].setData([], false, false, false);
                }
            }
        }
    }
    if (redraw) {
        this.chart.redraw();
    }
};

infChart.StockChart.prototype._getInitialValue = function (data, index) {
    var value;
    infChart.util.forEach(data, function (i, val) {
        if (val && val[index] != null && val[index] != undefined) {
            value = val;
            return true;
        }
    });
    return value;
};

infChart.StockChart.prototype._processData = function (data, isCompare, isLog, isPercent, setDummy, seriesId, timeMap) {

    // this.processedData.ohlcv = undefined;

    var initialClose = 0,
        o, h, l, c, v, a, b, ah, bl,
        tempData = [],
        dummyData = [],
        self = this,
        prevTime,
        currentTime,
        min,
        max,
        count = 0,
        dummyCount = 0,
        recalStart = this.recalStart[seriesId] || 0, // When updating chart real-time there is no need to process the data from the beiginning so it starts the calculation from the recalStart value for the given series which is set when updating ticks
        initialVal;

    timeMap = timeMap || {};

    infChart.util.forEach(data, function (i, val) {

        if (val) {
            currentTime = undefined;
            /*if (isPercent) {

             if (initialVal) {

             o = val[1] == null || !initialClose ? null : (val[1] / initialClose - 1) * 100;
             h = val[2] == null || !initialClose ? null : (val[2] / initialClose - 1) * 100;
             l = val[3] == null || !initialClose ? null : (val[3] / initialClose - 1) * 100;
             c = val[4] == null || !initialClose ? null : (val[4] / initialClose - 1) * 100;
             v = val[5] == null || !initialClose ? null : val[5] <= 0 ? 0 : (val[5] / initialClose - 1) * 100;
             b = val[6] == null || !initialClose ? null : (val[6] / initialClose - 1) * 100;
             a = val[7] == null || !initialClose ? null : (val[7] / initialClose - 1) * 100;
             ah = val[8] == null || !initialClose ? null : (val[8] / initialClose - 1) * 100;
             bl = val[9] == null || !initialClose ? null : (val[9] / initialClose - 1) * 100;
             tempData[count] = [val[0], o, h, l, c, v, b, a, ah, bl];
             count++;

             } else if (!initialVal) { // Initial value is yet to be set for this loop

             if (!recalStart && val[4] > 0) { // processing data from the beginning and this is the first value
             initialVal = val

             } else { // processing data from the middle(from updateTicks) and setting the first value as the initial value
             // TODO :: get the first data available item
             initialVal = self._getInitialValue(data,4);
             }

             if (initialVal && initialVal[4]) {
             initialClose = isLog ? self._num2Log(initialVal[4]) : initialVal[4];
             o = val[1] == null ? null : isLog ? (self._num2Log(val[1]) / initialClose - 1) * 100 : (val[1] / initialClose - 1) * 100;
             h = val[2] == null ? null : isLog ? (self._num2Log(val[2]) / initialClose - 1) * 100 : (val[2] / initialClose - 1) * 100;
             l = val[3] == null ? null : isLog ? (self._num2Log(val[3]) / initialClose - 1) * 100 : (val[3] / initialClose - 1) * 100;
             c = val[4] == null ? null : isLog ? (self._num2Log(val[4]) / initialClose - 1) * 100 : (val[4] / initialClose - 1) * 100;
             v = val[5] == null ? null : val[5] <= 0 ? 0 : isLog ? (self._num2Log(val[5]) / initialClose - 1) * 100 : (val[5] / initialClose - 1) * 100;
             b = val[6] == null ? null : isLog ? (self._num2Log(val[6]) / initialClose - 1) * 100 : (val[6] / initialClose - 1) * 100;
             a = val[7] == null ? null : isLog ? (self._num2Log(val[7]) / initialClose - 1) * 100 : (val[7] / initialClose - 1) * 100;
             ah = val[8] == null ? null : isLog ? (self._num2Log(val[8]) / initialClose - 1) * 100 : (val[8] / initialClose - 1) * 100;
             bl = val[9] == null ? null : isLog ? (self._num2Log(val[9]) / initialClose - 1) * 100 : (val[9] / initialClose - 1) * 100;
             tempData[count] = [val[0], o, h, l, c, v, b, a, ah, bl];
             count++
             }
             }

             max = (isNaN(max) || max < h) ? h : max;
             min = (isNaN(min) || min > h) ? h : min;


             }
             /!*else if (isCompare) {
             if (tempData.length > 0) {
             o = isLog ? that._num2Log(val[1]) - initialClose : val[1] - initialClose;
             h = isLog ? that._num2Log(val[2]) - initialClose : val[2] - initialClose;
             l = isLog ? that._num2Log(val[3]) - initialClose : val[3] - initialClose;
             c = isLog ? that._num2Log(val[4]) - initialClose : val[4] - initialClose;
             v = isLog ? that._num2Log(val[5]) - initialClose : val[5] - initialClose;
             tempData.push([val[0], o, h, l, c, v]);
             } else {
             initialClose = isLog ? that._num2Log(val[4]) : val[4];
             tempData.push([val[0], 0, 0, 0, 0, 0]);
             }
             }*!/
             else*/
            if (isLog) {

                o = val[1] == null ? null : self._num2Log(val[1]);
                h = val[2] == null ? null : self._num2Log(val[2]);
                l = val[3] == null ? null : self._num2Log(val[3]);
                c = val[4] == null ? null : self._num2Log(val[4]);
                v = val[5] == null ? null : val[5] <= 0 ? 0 : self._num2Log(val[5]);
                b = val[6] == null ? null : self._num2Log(val[6]);
                a = val[7] == null ? null : self._num2Log(val[7]);
                ah = val[8] == null ? null : self._num2Log(val[8]);
                bl = val[9] == null ? null : self._num2Log(val[9]);
                tempData[count] = [val[0], o, h, l, c, v, b, a, ah, bl];
                count++;

                max = (isNaN(max) || max < h) ? h : max;
                min = (isNaN(min) || min > h) ? h : min;
            } else {
                tempData[count] = val;
                count++;
                h = (!isNaN(val[2]) && val[2]) || val[4];
                max = (isNaN(max) || max < h) ? h : max;
                min = (isNaN(min) || min > h) ? h : min;
            }

            self.addValueToTimeMap(val[0], seriesId, timeMap);

            if (setDummy && prevTime != val[0] && prevTime && self.interval != 'T') {

                for (var tempTime = self.getNextTickTime(prevTime, self.interval);
                     tempTime < val[0];
                     tempTime = self.getNextTickTime(tempTime, self.interval)) {
                    dummyData[dummyCount] = [tempTime, null, null, null, null, null];
                    dummyCount++;
                }
            }
            prevTime = val[0];
        }
    }, recalStart); // Process updated points only if invoked from updateTicks
    //}

    if (!recalStart || !this.seriesActualMinMax[seriesId]) {
        this.seriesActualMinMax[seriesId] = {dataMin: min, dataMax: max};
    } else {
        var seriesMinMax = this.seriesActualMinMax[seriesId];
        seriesMinMax.dataMin = Math.min(min, seriesMinMax.dataMin);
        seriesMinMax.dataMax = Math.max(max, seriesMinMax.dataMax);
    }
    return {
        data: tempData, dummyData: dummyData,
        dataMin: this.seriesActualMinMax[seriesId].dataMin,
        dataMax: this.seriesActualMinMax[seriesId].dataMax,
        timeMap: timeMap
    };
};

infChart.StockChart.prototype.getSeriesProcessedValue = function (series, val) {

    var returnVal = this.getProcessedValue(series, val);

    /* Apply the correction with the compareValue for the proccessed value
     since actual value used in the highchart object is derived using compareValue*/
    if (returnVal != undefined) {
        var compareValue = series.compareValue || 0,
            sign,
            chart = this.chart;


        if (this.isCompare) {
            /*var mainSeries = this.getMainSeries(),
             cropStart = mainSeries.cropStart,
             diff = compareValue,
             baseInitRow = this._getInitialValue(this.processedData.data, 4),
             initialClose = baseInitRow && baseInitRow[4];

             if (this.processedData.data.length > 0 && cropStart && this.compareSymbols.count > 0) {
             if (mainSeries.groupedData && mainSeries.currentDataGrouping) {
             diff = this.processedData.data[cropStart][4] - initialClose;
             }
             else {
             diff = this.processedData.data[cropStart][4] - initialClose;
             }
             }*/
            if (this.isLog) {
                //sign = (returnVal < 0) ? -1 : 1;
                //returnVal -= (compareValue * sign);
                if (this.isPercent) {
                    returnVal = (returnVal / compareValue - 1) * 100;
                }
            } else {
                if (this.isPercent && compareValue) {
                    //sign = (returnVal < 0) ? -1 : 1;
                    returnVal = (returnVal / compareValue - 1) * 100;
                }
                /*
                 else {
                 // returnVal -= diff;
                 }*/
            }
        }
    }
    return returnVal;
};

/**
 * Returns the actual data min/max of the series regardless of the displayed data
 * @param seriesId
 * @returns {*}
 */
infChart.StockChart.prototype.getSeriesActualExtremes = function (seriesId) {
    var chart = this.chart,
        series = chart && chart.get(seriesId),
        compareValue = this._getSeriesCompareValue(series);

    if (seriesId) {
        if (compareValue && this.isPercent && this.isCompare) {
            return {
                dataMax: (this.seriesActualMinMax[seriesId].dataMax / compareValue - 1) * 100,
                dataMin: (this.seriesActualMinMax[seriesId].dataMin / compareValue - 1) * 100
            }
        } else {
            return this.seriesActualMinMax[seriesId];
        }
    } else if (this.chart.options.navigator.enabled && this.chart.options.navigator.series && this.chart.options.navigator.length) {
        var nav = this.chart.options.navigator.series[0];
        return {dataMax: nav.dataMax, dataMin: nav.dataMin};
    } else {
        // TODO :: need to go through all the compare series and base series. Since base series implementation is
        // enough for the time being this section is not omplemented
    }
};

/**
 * set x axis values based on selected chart type
 * if not tick by tick time component from date will be removed
 * @param dateTime value
 */
infChart.StockChart.prototype.getDateTime = function (dateTime) {
    switch (this.interval) {
        case 'D':
        case 'W':
        case 'M':
            var d = new Date(dateTime);
            //d.setHours(0, 0, 0, 0);
            dateTime = d.getTime();
            break;
        default:
            break;
    }
    return dateTime;
};

infChart.StockChart.prototype._num2Log = function (num) {
    if (num !== 0) {
        return Math.log(num) / Math.LN10;
    }
    return 0;
};

infChart.StockChart.prototype._log2Num = function (num) {
    return Math.pow(10, num);
};

infChart.StockChart.prototype._plotter = function (ind) {
    try {
        var axis = ind.getAxisId(),
            iChart = this,
            hChart = this.chart,
            yAxis = hChart.get(axis),
            x, y,
            resizeTheme = Highcharts.theme && Highcharts.theme.resizeHandler || {
                    backgroundColor: '#383E4C',
                    color: '#9C9C9C',
                    height: 4
                };

        if (yAxis && !isNaN(yAxis.left) && yAxis.left != null && !isNaN(yAxis.top) && yAxis.left != null) {
            x = yAxis.left;
            y = yAxis.top /*- 6*/;

            if (!hChart.axisTitles)
                hChart.axisTitles = {};

            if (!hChart.axisTitles[axis + '_bg']) {
                //  chart.axisTitles[axis + '_bg'] = chart.renderer.rect(x, y - 14, 5000, 20, 0).add();
                //chart.axisTitles[axis] = chart.renderer.text(text, x, y).add();
            }
            //chart.axisTitles[axis + '_bg'].attr({
            //    x: x,
            //    y: y - 14,
            //    fill: Highcharts.theme.indicator.axisBackgroundColor // TODO : get from theme
            //});

            if (!hChart.axisTitles[axis + '_resize']) {

                hChart.axisTitles[axis + '_resize'] = hChart.renderer.rect(x, y /*- 14*/ - resizeTheme.height, hChart.plotWidth, resizeTheme.height, 0).attr({
                    fill: resizeTheme.backgroundColor, cursor: "row-resize"
                }).add();

                hChart.axisTitles[axis + '_resizeH'] = hChart.renderer.text('=', hChart.plotWidth / 2, y /*- 14*/ - resizeTheme.height).attr({
                    fill: resizeTheme.color, cursor: "row-resize"
                }).add();

                var _dragFunction = function (event) {
                    this.crosshairType = (!iChart.resizing) ? iChart.crosshair.enabled : this.crosshairType;
                    //this.crosshairType = that.crosshair.enabled;
                    iChart.resizing = true;
                    iChart.crosshair.enabled = false;
                    if (event.chartY > 20) {
                        var currentY = yAxis.top/* - 6 - 14*/ - resizeTheme.height;
                        var targetY = event.chartY;

                        yAxis = hChart.get(axis);

                        var prevInd = iChart._getPreviousIndicator(ind.id);

                        var prevIndAxis = iChart._getPreviousPanelY(ind.id);

                        if (currentY > targetY) {
                            var maxY = prevIndAxis.top + 10;
                            if ((maxY) > targetY) {
                                targetY = maxY;
                            }
                        } else {
                            var minY = yAxis.top + yAxis.height /*- 20 */ - resizeTheme.height - 10;
                            if (minY < targetY) {
                                targetY = minY
                            }
                        }

                        var newHeight = yAxis.height /*+ 20*/ + resizeTheme.height + (currentY - targetY);
                        ind.heightPercent = (newHeight / iChart.indicatorFrameHeight) * 100;

                        var prevIndNewHeight = prevIndAxis.height - (currentY - targetY);
                        var newAxisHieght = yAxis.height + (currentY - targetY);

                        if (newHeight > 0 && prevIndNewHeight > 0 && newAxisHieght > 0) {

                            yAxis.update({
                                top: yAxis.top - (currentY - targetY), // 20 - indicator title height, 4- indicator resize handler
                                height: newAxisHieght
                            }, false);


                            prevIndAxis.update({
                                top: prevIndAxis.top, // 20 - indicator title height, 4- indicator resize handler
                                height: prevIndNewHeight
                            }, true);

                            iChart._plotter(ind);

                            if (prevInd) {
                                var prevInHeight = prevIndAxis.height /*+ 20*/ + resizeTheme.height - (currentY - targetY);
                                prevInd.heightPercent = (prevInHeight / iChart.indicatorFrameHeight) * 100;
                                iChart._plotter(prevInd);
                            } else {
                                var parallelToBaseAxes = infChart.indicatorMgr.getParallelToBaseAxes(iChart.id);
                                for (var i = 0, iLen = parallelToBaseAxes.length; i < iLen; i++) {
                                    /*hChart.get(parallelToBaseAxes[i]).update({
                                     /!*top: prevIndAxis.top,*!/
                                     height: prevIndNewHeight
                                     }, false);*/
                                    var parallelAxis = hChart.get(parallelToBaseAxes[i]),
                                        parallelAxisHeight = prevIndNewHeight * (parallelAxis.options.infHeightPercent || 0.3),
                                        topCorr = 1,
                                        parallelAxisTop = (hChart.yAxis[0].top || 0) + prevIndNewHeight - parallelAxisHeight - topCorr;
                                    hChart.get(parallelToBaseAxes[i]).update({
                                        top: parallelAxisTop,
                                        //bottom: mainHeight,
                                        height: parallelAxisHeight
                                    }, false);
                                }
                                //iChart.updateYAxis(hChart.get('#1'), {
                                //    top: prevIndAxis.top,
                                //    height: prevIndNewHeight
                                //}, false);
                                iChart.updateMinMax();
                                iChart.adjustPriceLineLabels();
                                iChart.onBaseAxisResize();
                            }
                        } else {
                            infChart.util.console.log("newHeight:" + newHeight + " prevIndNewHeight:" + prevIndNewHeight + " newAxisHieght:" + newAxisHieght);
                        }
                    }
                };

                var _stopFunction = function () {
                    iChart.crosshair.enabled = this.crosshairType;
                    iChart.resizing = false;
                    setTimeout(function () {
                        var prevInd = iChart._getPreviousIndicator(ind.id),
                            i, len,
                            isBaseResized;
                        if (prevInd) {
                            for (i = 0, len = prevInd.series.length; i < len; i++) {
                                prevInd.series[0].update({}, false);
                            }
                        } else {
                            isBaseResized = true;
                        }

                        for (i = 0, len = ind.series.length - 1; i < len; i++) {
                            ind.series[0].update({}, false);
                        }

                        ind.series[len].update({}, true);

                        //iChart.scaleDrawings(iChart.id);

                        if (isBaseResized) {
                            iChart.onBaseAxisResize();
                        }
                    }, 1);

                };

                // bind events for both handler and bar
                //infChart.util.bindDragEvents(hChart.axisTitles[axis + '_resize'], _dragFunction, _stopFunction);
                //infChart.util.bindDragEvents(hChart.axisTitles[axis + '_resizeH'], _dragFunction, _stopFunction);
                infChart.util.bindDragEvents(hChart, hChart.axisTitles[axis + '_resize'], _dragFunction, _stopFunction);
                infChart.util.bindDragEvents(hChart, hChart.axisTitles[axis + '_resizeH'], _dragFunction, _stopFunction);

            } else {
                hChart.axisTitles[axis + '_resize'].attr({
                    width: hChart.plotWidth
                });

                hChart.axisTitles[axis + '_resizeH'].attr({
                    width: hChart.plotWidth
                });
            }

            hChart.axisTitles[axis + '_resize'].attr({
                x: x,
                y: y/* - 14 */ - resizeTheme.height,
                zIndex: 20
            });

            var resizeElH = resizeTheme.height;
            var resizeHandleY = y - resizeTheme.height / 2 + 2;

            hChart.axisTitles[axis + '_resizeH'].attr({
                x: hChart.plotWidth / 2,
                y: (resizeHandleY == y) ? y + 2 : resizeHandleY,
                zIndex: 21
            });

            ind.setTitle(ind.getAxisId(), x, y, 20);
        }
    }
    catch (e) {
        infChart.util.console.error(e);
    }
};

infChart.StockChart.prototype._getPreviousIndicator = function (indicatorId) {
    var indicatorsDissimilerToBaseAxes = infChart.indicatorMgr.getIndicatorsDissimilarToBaseAxes(this.id);
    var idx = indicatorsDissimilerToBaseAxes.indexOf(indicatorId);
    var previousInd;
    if (idx > 0) {
        previousInd = infChart.indicatorMgr.getIndicatorById(this.id, indicatorsDissimilerToBaseAxes[idx - 1]);
    }
    return previousInd;
};

infChart.StockChart.prototype._getPreviousPanelY = function (indicatorId) {
    var previousIndicator = this._getPreviousIndicator(indicatorId);
    var previousAxis;
    if (previousIndicator) {
        previousAxis = this.chart.get(previousIndicator.getAxisId());
    } else {
        previousAxis = this.getMainYAxis();
    }
    return previousAxis;
};

infChart.StockChart.prototype.setCompareMode = function (compareValue, redraw) {
    var compareSymbols = this.compareSymbols.symbols,
        seriesId,
        compareSeries,
        hChart = this.chart;

    for (var symId in compareSymbols) {
        if (compareSymbols.hasOwnProperty(symId)) {
            seriesId = this.getCompareSeriesId(compareSymbols[symId]);
            compareSeries = hChart.get(seriesId);
            if (compareSeries) {
                compareSeries.update({
                    compare: compareValue
                }, false);
            }
        }
    }

    if (redraw) {
        this.chart.redraw(false);
    }
};

/**
 * Method to set basic chart properties
 * @param value
 * @param redraw
 * @param {boolean} isPropertyChange
 */
infChart.StockChart.prototype.setChartDataMode = function (value, redraw, isPropertyChange) {
    var chart = this.chart;
    var disableEventFireModeChange = false,
        changedProperties = {};
    if (typeof redraw === 'undefined') {
        redraw = true;
    }
    infChart.util.console.log('chart data mode : ' + value + " redraw : " + redraw);

    this.resetYAxisExtremes(false);

    //if (typeof infChart.drawingsManager !== 'undefined' && chart.annotations && chart.annotations.allItems.length > 0) {
    //    this.convertYAxisUserExtremes(value, redraw);
    //}

    var mainSeries = this.getMainSeries();
    switch (value) {
        case 'percent':
            this.isPercent = true;
            changedProperties.isPercent = true;
            if (this.isCompare) {
                mainSeries.update({
                    compare: "percent"
                }, false);
                this.setCompareMode("percent", false);
            }
            break;
        case 'compare':
            disableEventFireModeChange = true;
            this.isCompare = true;
            changedProperties.isCompare = true;
            if (!this.isFirstLoadInprogress()) {
                this.isPercent = true;
                changedProperties.isPercent = true;
            }
            var compareType = this.isPercent ? "percent" : undefined;
            if (this.isLog) {
                if (this.isFirstLoadInprogress()) {
                    // if log mode is saved in the templated loaded or given config, we need to keep it as it is.
                    // So avoided changing data mode
                    this.isPercent = false;
                    changedProperties.isPercent = false;
                    compareType = undefined;
                } else {
                    this.isLog = false;
                    changedProperties.isLog = false;
                }
            }
            if (this._isToolbarEnabled()) {
                infChart.toolbar.setSelectedControls(this.id, 'value', this.isLog, 'log');
                infChart.toolbar.setSelectedControls(this.id, 'value', this.isPercent, 'percent');
            }
            mainSeries.update({
                compare: compareType
            }, false);
            break;
        case 'normal':
            this.isLog = false;
            this.isPercent = false;
            changedProperties.isLog = false;
            changedProperties.isPercent = false;
            break;
        case 'log':
            this.isLog = true;
            changedProperties.isLog = true;
            break;
        case 'logToNormal':
            this.isLog = false;
            changedProperties.isLog = false;
            this._clearPlotLines(redraw);
            break;
        case 'percentToNormal':
            this.isPercent = false;
            changedProperties.isPercent = false;
            if (this.isCompare) {
                mainSeries.update({
                    compare: undefined
                }, false);
                this.setCompareMode(undefined, false);
            }
            break;
        case 'percentToLog':
            // when mode has been changed to  percentage from log,
            // disabled the log mode since both cannot be shown same time
            this.isPercent = false;
            changedProperties.isPercent = false;
            this.isLog = true;
            changedProperties.isLog = true;
            if (this.isCompare) {
                mainSeries.update({
                    compare: undefined
                }, false);
                this.setCompareMode(undefined, false);
            }

            if (this._isToolbarEnabled()) {
                infChart.toolbar.setSelectedControls(this.id, 'value', this.isPercent, 'percent');
            }
            break;
        case 'logToPercent':

            // when mode has been changed to log from percentage,
            // disabled the log mode since both cannot be shown same time
            this.isPercent = true;
            changedProperties.isPercent = true;
            this.isLog = false;
            changedProperties.isLog = false;
            if (this.isCompare) {
                mainSeries.update({
                    compare: "percent"
                }, false);
                this.setCompareMode("percent", false);
            }
            if (this._isToolbarEnabled()) {
                infChart.toolbar.setSelectedControls(this.id, 'value', this.isLog, 'log');
            }
            break;
        case 'compareToNormal':
            disableEventFireModeChange = true;
            this.isCompare = false;
            changedProperties.isCompare = false;
            this.isPercent = false;
            changedProperties.isPercent = false;
            if (this._isToolbarEnabled()) {
                infChart.toolbar.setSelectedControls(this.id, 'value', this.isPercent, 'percent');
            }
            mainSeries.update({
                compare: undefined
            }, true);
            this._clearPlotLines(redraw);
            break;
        default:
            break;
    }

    this.prevousClose = {};
    /* Since Data need to be re processed for the new mode need to start calculations from the beginning.
     So clear all the flags and processed data */
    this.recalStart = {};
    this.processedData.ohlcv = undefined;
    this._recalculateAll(redraw);
    this.updateMinMax();
    if(!disableEventFireModeChange){
        this._fireEventListeners('modeChange', [value]);
    }

    //if (value !== "compare" && value !== "compareToNormal") {
    //    this.scaleDrawings(this.id);
    //}
    if (isPropertyChange) {
        this._onPropertyChange("mode", changedProperties);
    }
};

/**
 * when chart data mode is changed we are setting the y axis extremes
 * this is called before data mode is set
 * get the base price value and then convert it to corresponding value
 * @param mode
 * @param redraw
 */
infChart.StockChart.prototype._convertYAxisUserExtremes = function (mode, redraw) {
    var yAxis = this.getMainYAxis(), min = /*yAxis.userMin || */yAxis.dataMin, max = /*yAxis.userMax || */yAxis.dataMax, baseYValue;
    switch (mode) {
        case 'log':
            if (!isNaN(min)) {
                baseYValue = this.getBaseValue(min, false, this.isCompare, this.isPercent);
                min = this.convertBaseYValue(baseYValue, true, this.isCompare, this.isPercent);
            }
            if (!isNaN(max)) {
                baseYValue = this.getBaseValue(max, false, this.isCompare, this.isPercent);
                max = this.convertBaseYValue(baseYValue, true, this.isCompare, this.isPercent);
            }
            break;
        case 'percent':
            if (!isNaN(min)) {
                baseYValue = this.getBaseValue(min, this.isLog, this.isCompare, false);
                min = this.convertBaseYValue(baseYValue, this.isLog, this.isCompare, true);
            }
            if (!isNaN(max)) {
                baseYValue = this.getBaseValue(max, this.isLog, this.isCompare, false);
                max = this.convertBaseYValue(baseYValue, this.isLog, this.isCompare, true);
            }
            break;
        case 'compare':
            if (!isNaN(min)) {
                baseYValue = this.getBaseValue(min, this.isLog, this.isCompare, this.isPercent);
                //compare is set to false because we are setting the chart x-scale to full range - so crop start should not be used
                min = this.convertBaseYValue(baseYValue, this.isLog, false, true);
            }
            if (!isNaN(max)) {
                baseYValue = this.getBaseValue(max, this.isLog, this.isCompare, this.isPercent);
                //compare is set to false because we are setting the chart x-scale to full range - so crop start should not be used
                max = this.convertBaseYValue(baseYValue, this.isLog, false, true);
            }
            break;
        case 'logToNormal':
            if (!isNaN(min)) {
                baseYValue = this.getBaseValue(min, true, this.isCompare, this.isPercent);
                min = this.convertBaseYValue(baseYValue, false, this.isCompare, this.isPercent);
            }
            if (!isNaN(max)) {
                baseYValue = this.getBaseValue(max, true, this.isCompare, this.isPercent);
                max = this.convertBaseYValue(baseYValue, false, this.isCompare, this.isPercent);
            }
            break;
        case 'percentToNormal':
            if (!isNaN(min)) {
                baseYValue = this.getBaseValue(min, this.isLog, this.isCompare, true);
                min = this.convertBaseYValue(baseYValue, this.isLog, this.isCompare, false);
            }
            if (!isNaN(max)) {
                baseYValue = this.getBaseValue(max, this.isLog, this.isCompare, true);
                max = this.convertBaseYValue(baseYValue, this.isLog, this.isCompare, false);
            }
            break;
        case 'compareToNormal':
            if (!isNaN(min)) {
                baseYValue = this.getBaseValue(min, this.isLog, true, this.isPercent);
                min = this.convertBaseYValue(baseYValue, this.isLog, false, false);
            }
            if (!isNaN(max)) {
                baseYValue = this.getBaseValue(max, this.isLog, true, this.isPercent);
                max = this.convertBaseYValue(baseYValue, this.isLog, false, false);
            }
            break;
        default:
            break;
    }
    if (!isNaN(min) || !isNaN(max)) {
        console.log('convertYAxisUserExtremes => userMin : ' + yAxis.userMin + ", userMax : " + yAxis.userMax);
        console.log('convertYAxisUserExtremes => min : ' + min + ", max : " + max);
        yAxis.setExtremes(min, max, true, false);
    }
};

/**
 * remove grid lines
 * @param redraw to redraw chart
 */
infChart.StockChart.prototype._clearPlotLines = function (redraw) {
    /*this.chart.get("#1").update({
     plotLines: [],
     gridLineWidth: this.yGridLineWidth
     }, redraw);*/
};

/**
 * change chart style
 * @param {string} type
 * @param {boolean} redraw
 * @param {boolean} isPropertyChange
 */
infChart.StockChart.prototype.setChartStyle = function (type, redraw, isPropertyChange) {
    var mainSeries = this.getMainSeries();
    if (typeof redraw === 'undefined') {
        redraw = true;
    }

    if(this.isManualType && this.isStyleChangedByForce){
        this.isStyleChangedByForce = false;
    }

    var settingPanel = this.settingsPopups[mainSeries.options.id];
    if(settingPanel) {
        if(isPropertyChange) {
            settingPanel.find("[ind-ind-type=" + type + "]").trigger('click');
        }
        else{
            infChart.structureManager.toolbar.setChartTypeTabActive(settingPanel, type);
        }
    }
    if(!settingPanel || !isPropertyChange){
        this._changeSeriesType(mainSeries, type, redraw, isPropertyChange);
    }


    this._fireEventListeners("onSeriesTypeChange");
};

/**
 * Returns the series options to set to the new chart type
 * @param series
 * @param type
 * @returns {*}
 */
infChart.StockChart.prototype.getSeriesOptionsOnChartTypeChange = function (series, type) {

    var seriesColorOption = this.seriesColorOptions[series.options.id],
        colorCfg = (seriesColorOption && seriesColorOption[type]) ? seriesColorOption[type] :
            this.chart.options.plotOptions[type] ? this._getColorPropertiesFromOptions($.extend(Highcharts.theme.plotOptions[type], this.chart.options.plotOptions[type]), type, series) : undefined;

    return colorCfg;
};

infChart.StockChart.prototype._changeSeriesType = function (series, type, redraw, isPropertyChange) {
    var isMainSeries = this.isMainSeries(series);
    if (isMainSeries) {
        if(!this.isStyleChangedByForce) {
            this.type = type;
        }
        /*To fix the issue with onKey value of the flag indicator series */
        if (infChart.indicatorMgr) {
            infChart.util.forEach(infChart.indicatorMgr.getIndicators(this.id), function (i, ind) {
                ind.resetSeriesOptions(type);
            });
        }
        if (this._isToolbarEnabled()) {
            infChart.toolbar.setSelectedControls(this.id, 'chartType', this.type);
        }
    }

    var colorCfg = this.getSeriesOptionsOnChartTypeChange(series, type);
    var data = this.getSeriesData(series, true);

    var tempConfig = $.extend({}, colorCfg, {
        type: type
    });

    if (data && data.length > 0) {
        tempConfig.data = this._getSeriesDataByChartType(type, data, series.options.infLineDataField);
        series.update(tempConfig, false);
        //this._setMainSeriesDataToChart(data, redraw);
        this._cleanNavigatorSeries(redraw);
        this.adjustPriceLineLabels();
        this.updateMinMax();
    } else {
        series.update(tempConfig, redraw);
    }

    if (isPropertyChange && isMainSeries) {
        this._onPropertyChange("type", [type]);
    }
};

infChart.StockChart.prototype.setDataGrouping = function (series, redraw) {
    var intervalOpt = this.intervalOptions[this.interval];
    var isEnable = !(intervalOpt && intervalOpt.grouping == false);
    redraw = !!(redraw);
    if (series) {
        series.update({dataGrouping: {enabled: isEnable}}, false);
    }
    else {
        infChart.util.forEach(this.chart.series, function (idx, seriesC) {
            seriesC.update({dataGrouping: {enabled: isEnable}}, false);
        });

    }
    this._cleanNavigatorSeries(redraw);
};

infChart.StockChart.prototype._getPeriodTime = function (period) {
    var currentTime = (new Date).getTime();
    return (currentTime - this._getMinDate(period, currentTime, true));
};

/**
 * Util method to get min date  for a period
 *
 * 1. When selecting 1D if Exchange is not open yet, then should show previous days chart.
 * 2. If Exchange is open then should show current days chart. The X axis should span the period for which the Exchange is open on the day.
 * 3. If 2D is selected and the Exchange is open it should show the previous days data and the current days data.
 * 4. If 1Week is selected it should show the last 5 trading days data. If the Exchange is open then it should show the current day and the previous 4 days.
 * 5. The X axis should not be linear. Periods with no data should be omitted from the X axis.
 * @param period
 * @param lastDate
 * @returns {*}
 * @private
 */
infChart.StockChart.prototype._getMinDate = function (period, lastDate, isLinearTime) {
    var l = this.data.base.length;
    if (l > 0 || lastDate) {
        //set x-axis min/max
        var max = lastDate || this.data.base[l - 1][0],
            min = lastDate ? (new Date(0)).getTime() : this.data.base[0][0],
            date = new Date(max),
            periodAsArray = period.split("_"),
            periodType = periodAsArray[0],
            periodTypeSub = periodAsArray[1],
            units = (periodAsArray.length > 2) ? +periodAsArray[2] : periodAsArray.length > 1 ? +periodAsArray[1] : 1,
            marketOpenDetails = this.marketOpenDetails,
            isMarketOpen = marketOpenDetails && marketOpenDetails.isOpenNow,
            lastOpenTime = marketOpenDetails && this.dataManager.getChartTime(marketOpenDetails.lastOpenTime, marketOpenDetails.timeZoneOffset, periodType);

        switch (periodType) {
            case 'I':
                var newUTCDate;
                if (periodTypeSub == "H") {
                    newUTCDate = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours() - units, date.getUTCMinutes(), date.getUTCSeconds());
                } else {
                    newUTCDate = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate() - units, date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
                }
                var periodTime = this.periodOptions[period].time;
                if (!this.isLinearData() && !isLinearTime && isMarketOpen && newUTCDate < lastOpenTime &&
                    (!periodTime || !lastDate || periodTypeSub != "H" || (periodTime >= (lastDate - lastOpenTime)))) {
                    newUTCDate = lastOpenTime;
                }
                return newUTCDate;
                break;
            case 'D':
                if (!this.isLinearData() && !isLinearTime && isMarketOpen) {
                    date = new Date(lastOpenTime);
                    units--;
                }
                return Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate() - units, date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
            case 'W':
                var daysPerWeek = 7;
                if (!this.isLinearData() && !isLinearTime && isMarketOpen && lastOpenTime) {
                    date = new Date(lastOpenTime);
                    daysPerWeek--;
                }
                return Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate() - units * daysPerWeek, date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
            case 'M':
                return Date.UTC(date.getUTCFullYear(), date.getUTCMonth() - units, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
            case 'Y':
                return Date.UTC(date.getUTCFullYear() - units, date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
            case 'YTD':
                var date1 = new Date();
                var date2 = new Date(date1.getUTCFullYear(), 0, 1);
                return date2.getTime();
            case 'C':
                return this.range && this.range.fromDate ? this.range.fromDate : min;
            /*var timeDiff = Math.abs(date2.getTime() - date1.getTime());
             return Math.ceil(timeDiff / (1000 * 3600 * 24))git ;*/
            default:
                return Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate() - 1);
        }
    }
};

/**
 *
 * 1. When selecting 1D if Exchange is not open yet, then should show previous days chart.
 * 2. If Exchange is open then should show current days chart. The X axis should span the period for which the Exchange is open on the day.
 * 3. If 2D is selected and the Exchange is open it should show the previous days data and the current days data.
 * 4. If 1Week is selected it should show the last 5 trading days data. If the Exchange is open then it should show the current day and the previous 4 days.
 * 5. The X axis should not be linear. Periods with no data should be omitted from the X axis.
 * @param period
 * @param latestDate
 * @param isLinearTime
 * @returns {*}
 * @private
 */
infChart.StockChart.prototype._getMaxDate = function (period, latestDate, isLinearTime) {
    var l = this.data.base.length;
    if (l > 0) {
        //set x-axis min/max
        var max = latestDate || this.data.base[0][0],
            date = new Date(max),
            periodAsArray = period.split("_"),
            periodType = periodAsArray[0],
            periodTypeSub = periodAsArray[1],
            units = (periodAsArray.length > 2) ? +periodAsArray[2] : periodAsArray.length > 1 ? +periodAsArray[1] : 1,
            marketOpenDetails = this.marketOpenDetails,
            isMarketOpen = marketOpenDetails && marketOpenDetails.isOpenNow,
            lastOpenTime = marketOpenDetails && this.dataManager.getChartTime(marketOpenDetails.lastOpenTime, marketOpenDetails.timeZoneOffset, periodType),
            marketOpenTime = marketOpenDetails && marketOpenDetails.openHours,
            marketOpenHours = (marketOpenTime && Math.floor(marketOpenTime)) || 0,
            marketOpenMinutes = (marketOpenTime && (marketOpenTime % marketOpenHours) * 60) || 0;

        switch (periodType) {
            case 'I':
                var newUTCDate;
                if (periodTypeSub == "H") {
                    newUTCDate = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours() + units, date.getUTCMinutes(), date.getUTCSeconds());
                } else {
                    newUTCDate = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate() + units, date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
                }

                if (!this.isLinearData() && !isLinearTime && isMarketOpen) {
                    date = new Date(lastOpenTime);
                    newUTCDate = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours() + marketOpenHours, date.getUTCMinutes() + marketOpenMinutes, date.getUTCSeconds());
                }
                return newUTCDate;
                break;
            case 'D':
                newUTCDate = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate() + units, date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());

                if (!this.isLinearData() && !isLinearTime && isMarketOpen) {
                    date = new Date(lastOpenTime);
                    newUTCDate = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours() + marketOpenHours, date.getUTCMinutes() + marketOpenMinutes, date.getUTCSeconds());
                }
                return newUTCDate;
            case 'W':
                return Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate() + units * 7, date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
            case 'M':
                return Date.UTC(date.getUTCFullYear(), date.getUTCMonth() + units, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
            case 'Y':
                return Date.UTC(date.getUTCFullYear() + units, date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
            case 'YTD':
                var date1 = new Date();
                var date2 = new Date(date1.getUTCFullYear(), 0, 1);
                return date2.getTime();
            case 'C':
                var maxDate = this.range ? this.range.toDate ? this.range.toDate : Date.now() : max
                return maxDate;
            /*var timeDiff = Math.abs(date2.getTime() - date1.getTime());
             return Math.ceil(timeDiff / (1000 * 3600 * 24));*/
            default:
                return Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate() - 1);
        }
    }
};

/**
 * add series to the chart
 * @param {string} id - series id
 * @param {string} type - series type
 * @param {object} properties - series properties
 * @param {boolean} redraw - need to redraw or not
 * @param {object} options - series properties
 * @returns {object} series
 */
infChart.StockChart.prototype.addSeries = function (id, type, properties, redraw, options) {
    if (this.chart) {
        var seriesOptions, series;
        switch (type) {
            case "compare":
                seriesOptions = {
                    id: id,
                    name: properties.symbol.symbol,
                    title: properties.symbol.symbolDesc,
                    dp: properties.symbol.dp,
                    symbolType: properties.symbol.symbolType,
                    type: options && options.type ? options.type : "line",
                    data: [],
                    color: properties.seriesColor,
                    lineColor: properties.seriesColor,
                    infType: "compare",
                    compare: properties.compare,
                    infLineDataField: properties.symbol.lineDataField,
                    styleTypes: properties.styleTypes,
                    hasColumnNegative: false,
                    showInNavigator: false,
                    infHideClose: properties.hideClose,
                    infLegendLabel: this._getSymbolDisplayName(properties.symbol)
                };
                break;
            case "indicator":
                break;
            case "news":
                seriesOptions = {
                    id: id,
                    name: "news",
                    title: "N",
                    type: "flags",
                    data: [],
                    infType: "news",
                    compare: "value",
                    onSeries: properties.onSeries,
                    shape: "circlepin",
                    fillColor: '#9258b3',
                    style: {
                        color: "#ffffff"
                    },
                    states: {
                        hover: {
                            fillColor: "#009e91"
                        }
                    },
                    point: {
                        events: {
                            click: properties.onClick
                        }

                    }
                };
                break;
            case "flags":
                seriesOptions = {
                    id: id,
                    name: "flags",
                    title: properties.symbol,
                    type: "flags",
                    data: [],
                    infType: "flags",
                    infFlagType: properties.flagType,
                    compare: "value",
                    onSeries: properties.onSeries,
                    shape: properties.shape,
                    fillColor: properties.fillColor,
                    color: "#ffffff",
                    lineColor: properties.lineColor,
                    style: {
                        color: "#ffffff"
                    },
                    states: {
                        hover: {
                            fillColor: "#009e91"
                        }
                    },
                    point: {
                        events: {
                            click: properties.onClick
                        }
                    }
                };
                break;
            default:
                break;
        }
        series = this.chart.addSeries(seriesOptions, redraw);
        if (options) {
            this._setSeriesProperties(series, options);
        }
        infChart.manager.setLegend(series);
        return series;
    }
};

/**
 * Remove a given series from the chart
 * @param seriesId
 * @param isPropertyChange
 */
infChart.StockChart.prototype.removeSeries = function (seriesId, isPropertyChange) {

    var chart = this.chart,
        propertyName = "",
        value = {},
        series = chart.get(seriesId),
        checkNoData;

    if (!series) {
        return;
    }

    var heightChange = true,
        parallelToBase,
        contId = this.id;

    this.prevousClose = {};

    if (infChart.util.isLegendAvailable(series.options)) {
        infChart.structureManager.legend.removeLegendItem(this.id, seriesId, series.options.infType);
    }

    if (this.settingsPopups[seriesId]) {
        this.settingsPopups[seriesId].remove();
        delete this.settingsPopups[seriesId];
    }

    switch (series.options.infType) {
        case "compare":
            //var legendComp = containerEl.querySelector("[inf-legend] [inf-legend-comp-symbol]"),
            //    legendLiEl = legendComp && legendComp.querySelector("[inf-comp-legend-li]");
            //
            //if (legendLiEl && legendLiEl.children.length == 1) {
            //    legendComp.querySelector("div[rel='legend-comp-dropdown']").style.display = 'none';
            //}
            heightChange = false;
            this.removeSeriesFromTimeMap(seriesId);
            series.remove(false);
            checkNoData = true;
            break;
        case "indicator":
            //var legendInd = containerEl.querySelector("[inf-legend] [inf-legend-ind]"),
            //    legendLiEl = legendInd && legendInd.querySelector("[inf-comp-legend-li]");
            //
            //if (legendLiEl && legendLiEl.children.length == 1) {
            //    legendInd.find("div[rel='legend-ind-dropdown']").hide();
            //}

            var indicator = infChart.indicatorMgr.getIndicatorBySeriesId(contId, seriesId);
            parallelToBase = infChart.util.isSeriesInBaseAxis(indicator.getAxisId()) || infChart.indicatorMgr.isParallelToBaseAxes(this.id, indicator);
            infChart.indicatorMgr.removeIndicatorSeries(contId, seriesId, isPropertyChange);

            if (indicator.series.length === 0) {
                propertyName = "indicators";
                value.id = indicator.id;
                value.type = indicator.type;
                value.action = "remove";
            }        
            if (infChart.indicatorMgr.getNotSingletonIndicatorCount(this.id) <= 0) {
                infChart.toolbar.setSelectedControls(this.id, "indicator", false);
            }
            break;
        case "news":
            series.remove(false);
            heightChange = false;
            break;
        case "flags":
            series.remove(false);
            heightChange = false;
            break;
        default:
            break;
    }
    if (heightChange) {
        // this.setYAxisExtremes(false);
        this._setIndicatorFrames(true);
        this._setLabels();
    }

    this.updateMinMax();
    //this.scaleDrawings(this.id);


    if (this.isResizeRequired()) {
        this.resizeChart();
    }

    if (checkNoData && !this._hasData()) {
        this._showNoData(true)
    }

    if (isPropertyChange && propertyName) {
        this._onPropertyChange(propertyName, value);
    }
    if (parallelToBase != undefined && !parallelToBase) {
        this.onBaseAxisResize();
    } else {
        this.onBaseAxisScaled();
    }
};

/**
 * Reload a given series in the chart
 * @param seriesId
 */
infChart.StockChart.prototype.refreshSeries = function (seriesId) {

    var chart = this.chart;
    var series = chart.get(seriesId);
    var heightChange = true;
    switch (series.options.infType) {
        case "compare":
            break;
        case "indicator":
            break;
        case "base":
            this._loadHistory(undefined, undefined, undefined, undefined, true);
            break;
        default:
            break;
    }
    if (heightChange) {
        // this.setYAxisExtremes(false);
        this._setIndicatorFrames(true);
        this._setLabels();
    }
    this.updateMinMax();
    //this.scaleDrawings();
};

infChart.StockChart.prototype.reloadData = function () {

    var iChart = this;

    iChart._loadHistory(undefined, undefined, undefined, this.flags.enabled, true);

    if (iChart.compareSymbols.count > 0) {
        infChart.util.forEach(this.compareSymbols.symbols, function (key, val) {
            iChart.data.compare[key] = [];
            iChart._loadCompareHistory(val, undefined, undefined, true);
        });
    }
};

infChart.StockChart.prototype.setSize = function (width, hieght) {
    var chart = this.chart;
    chart.setSize(width, hieght);
    this.updateMinMax();
};

infChart.StockChart.prototype._clearToolbarControls = function (type, applyFading) {
    if (this._isToolbarEnabled()) {
        infChart.toolbar.clearSelectedControls(this.id, type, applyFading);
    }
};

//region===================Zooming and Rage Select======================================================================

infChart.StockChart.prototype.getZoomExtremes = function (isZoomIn) {
    var newExtremes = {}, extremes = this.getRange(), mainSeries = this.getMainSeries(),
        noOfPoints = mainSeries.points && mainSeries.points.length;
    if (noOfPoints) {
        if (isZoomIn) {
            if ((extremes.max - extremes.min) > mainSeries.closestPointRange * 5) {
                var startIndex = (noOfPoints > 3) ? Math.floor(noOfPoints / 3) : (noOfPoints > 1) ? 1 : 0;
                var endValue = extremes.dataMax;
                if (extremes.dataMax != extremes.max) {
                    var endIndex = (extremes.dataMax == extremes.max) ? noOfPoints - 1 : (noOfPoints > startIndex) ? noOfPoints - startIndex : noOfPoints - 1;
                    endValue = mainSeries.points[endIndex].x;
                }
                newExtremes.min = mainSeries.points[startIndex].x;
                newExtremes.max = endValue;
            }
        } else {
            var maxZoom = this.getMaxZoomRange();
            if (extremes.max - extremes.min != maxZoom) {
                var allPoints = this.rangeData.data.length, startIndexOnRange = infChart.util.binaryIndexOf(this.rangeData.data, 0, extremes.min);

                startIndexOnRange = startIndexOnRange < 0 ? startIndexOnRange * -1 : startIndexOnRange;

                var pointsOnRight = allPoints - startIndexOnRange - noOfPoints;
                var pointsOnLeft = startIndexOnRange;

                // var divFactor = 2;
                var minAdjustmentPoints = 20;

                var rightAdjustment = (pointsOnRight > 0) ? Math.floor((allPoints / pointsOnRight) * 10) : 0;//Math.floor(pointsOnRight / divFactor);
                var leftAdjustment = (pointsOnLeft > 0) ? Math.floor((allPoints / pointsOnLeft) * 10) : 0; // Math.floor(pointsOnLeft / divFactor);

                rightAdjustment = (pointsOnRight > minAdjustmentPoints || rightAdjustment > minAdjustmentPoints) ? rightAdjustment : (pointsOnRight > 0) ? pointsOnRight : 0;
                leftAdjustment = (pointsOnLeft > minAdjustmentPoints || leftAdjustment > minAdjustmentPoints) ? leftAdjustment : (pointsOnLeft > 0) ? pointsOnLeft : 0;

                var maxIndex = startIndexOnRange + noOfPoints - 1 + rightAdjustment;
                maxIndex = (maxIndex < allPoints) ? maxIndex : allPoints - 1;

                var minIndex = startIndexOnRange - leftAdjustment;
                minIndex = (minIndex >= 0) ? minIndex : 0;

                var startTime = this.rangeData.data[minIndex][0],
                    endTime = this.rangeData.data[maxIndex][0],
                    diff = endTime - startTime;

                if (maxZoom && maxZoom < diff) {
                    var prevMid = extremes.min + (extremes.max - extremes.min) / 2,
                        nextMid = startTime + (endTime - startTime) / 2;

                    if (prevMid == nextMid) {
                        startTime = prevMid - maxZoom / 2;
                        endTime = prevMid + maxZoom / 2;
                    } else {
                        startTime = endTime == extremes.dataMax ? endTime - maxZoom : Math.max(nextMid - maxZoom / 2, extremes.dataMin);
                        endTime = startTime == extremes.dataMin ? startTime + maxZoom : Math.min(nextMid + maxZoom / 2, extremes.dataMax);
                    }
                }
                newExtremes.min = startTime;
                newExtremes.max = endTime;
            }
        }
    }
    return newExtremes;
};

infChart.StockChart.prototype.getZoomExtremesOnCtrlClick = function (event) {
    var newExtremes = {}, mainSeries = this.getMainSeries(), extremes = this.getRange();
    if ((extremes.max - extremes.min) > mainSeries.closestPointRange * 5) {
        var point, clickedTime;
        if (event.point) {

            point = event.point;

        } else if (event.xAxis && event.xAxis.length > 0) {

            clickedTime = event.xAxis[0].value;
            point = infChart.util.getSeriesPointByTime(mainSeries, clickedTime);
        }

        if (point) {
            var series = point.series;
            var startIdx = 0,
                endIdx = series.points.length - 1,
                pointIndex = point.index - series.cropStart,
                noOfLeftPoints = pointIndex - startIdx,
                noOfRightPoints = endIdx - pointIndex,
                noOfPointsToShow = (mainSeries.points.length) * 0.9,
                startIndex = pointIndex - Math.floor(noOfPointsToShow * (noOfLeftPoints / (series.points.length))),// startIdx + ((noOfLeftPoints > 3) ? Math.floor(noOfLeftPoints / 3) : (noOfLeftPoints > 1) ? 1 : 0);
                endIndex = pointIndex + Math.floor(noOfPointsToShow * (noOfRightPoints / (series.points.length)));//((noOfRightPoints > 3) ? Math.floor(noOfRightPoints / 3) : (noOfRightPoints > 1) ? 1 : 0);

            endIndex = endIndex >= mainSeries.points.length ? series.points.length - 1 : endIndex;
            startIndex = startIndex > pointIndex ? pointIndex : startIdx < 0 ? 0 : startIndex;

            newExtremes.min = series.points[startIndex].x;
            newExtremes.max = series.points[endIndex].x;
        } else {
            newExtremes = this.getZoomExtremes(true)
        }
    }
    return newExtremes;
};

/**
 * Zoom in current range
 */
// infChart.StockChart.prototype.zoomIn = function () {
//     var extremes = this.getRange(), mainSeries = this.getMainSeries(),
//         noOfPoints = mainSeries.points && mainSeries.points.length,
//         startIndex = (noOfPoints > 3) ? Math.floor(noOfPoints / 3) : (noOfPoints > 1) ? 1 : 0;

//     if (noOfPoints) {
//         var endValue = extremes.dataMax;
//         if (extremes.dataMax != extremes.max) {
//             var endIndex = (extremes.dataMax == extremes.max) ? noOfPoints - 1 : (noOfPoints > startIndex) ? noOfPoints - startIndex : noOfPoints - 1;
//             endValue = mainSeries.points[endIndex].x;
//         }
//          this.setXAxisExtremes(mainSeries.points[startIndex].x, endValue, true);
//         // this.clearToolbarControls("period", true);
//     }

//     // infChart.manager.afterScalingAxis(this.chartId, {
//     //     xAxis: true,
//     //     yAxis: false
//     // });
// };

/**
 * Zoom out chart from current range
 */
// infChart.StockChart.prototype.zoomOut = function () {

//     var extremes = this.getRange(),
//         maxZoom = this.getMaxZoomRange(),
//         allPoints = this.rangeData.data.length,
//         mainSeries = this.getMainSeries(),
//         noOfPoints = mainSeries.points && mainSeries.points.length;

//     if (extremes.max - extremes.min == maxZoom || !noOfPoints) {
//         return;
//     }

//     var startIndexOnRange = infChart.util.binaryIndexOf(this.rangeData.data, 0, extremes.min);
//     startIndexOnRange = startIndexOnRange < 0 ? startIndexOnRange * -1 : startIndexOnRange;

//     var pointsOnRight = allPoints - startIndexOnRange - noOfPoints;
//     var pointsOnLeft = startIndexOnRange;

//     var divFactor = 2;
//     var minAdjustmentPoints = 20;

//     var rightAdjustment = (pointsOnRight > 0) ? Math.floor((allPoints / pointsOnRight) * 10) : 0;//Math.floor(pointsOnRight / divFactor);
//     var leftAdjustment = (pointsOnLeft > 0) ? Math.floor((allPoints / pointsOnLeft) * 10) : 0; // Math.floor(pointsOnLeft / divFactor);

//     rightAdjustment = (pointsOnRight > minAdjustmentPoints || rightAdjustment > minAdjustmentPoints) ? rightAdjustment : (pointsOnRight > 0) ? pointsOnRight : 0;
//     leftAdjustment = (pointsOnLeft > minAdjustmentPoints || leftAdjustment > minAdjustmentPoints) ? leftAdjustment : (pointsOnLeft > 0) ? pointsOnLeft : 0;

//     var maxIndex = startIndexOnRange + noOfPoints - 1 + rightAdjustment;
//     maxIndex = (maxIndex < allPoints) ? maxIndex : allPoints - 1;

//     var minIndex = startIndexOnRange - leftAdjustment;
//     minIndex = (minIndex >= 0) ? minIndex : 0;

//     var startTime = this.rangeData.data[minIndex][0],
//         endTime = this.rangeData.data[maxIndex][0],
//         diff = endTime - startTime;

//     if (maxZoom && maxZoom < diff) {
//         var prevMid = extremes.min + (extremes.max - extremes.min) / 2,
//             nextMid = startTime + (endTime - startTime) / 2;

//         if (prevMid == nextMid) {
//             startTime = prevMid - maxZoom / 2;
//             endTime = prevMid + maxZoom / 2;
//         } else {
//             startTime = endTime == extremes.dataMax ? endTime - maxZoom : Math.max(nextMid - maxZoom / 2, extremes.dataMin);
//             endTime = startTime == extremes.dataMin ? startTime + maxZoom : Math.min(nextMid + maxZoom / 2, extremes.dataMax);
//         }
//     }

//     var args = {xAxis: true, yAxis: false};
//     infChart.manager.setUserDefinedXAxisExtremes(this.chartId, startTime, endTime, true, args);
//     // this.setXAxisExtremes(startTime, endTime, true);
//     // this.clearToolbarControls("period", true);

//     // infChart.manager.afterScalingAxis(this.chartId, {
//     //     xAxis: true,
//     //     yAxis: false
//     // });
// };

/**
 * Zoom out on alt and mouse click chart from current range
 */
// infChart.StockChart.prototype.zoomOutOnAltlClick = function (event) {
//     this.zoomOut();
// };

/**
 * Zoom in on ctrl and mouse click chart from current range
 */
// infChart.StockChart.prototype.zoomOnCtrlClick = function (event) {
//     var point,
//         series,
//         clickedTime,
//         mainSeries = this.getMainSeries(),
//         extremes = this.getRange();

//     if (!extremes || (extremes.max - extremes.min) <= mainSeries.closestPointRange * 5) {
//         return; // skip if minimum zooming limit has been reached
//     }

//     if (event.point) {
//         point = event.point;
//     } else if (event.xAxis && event.xAxis.length > 0) {
//         clickedTime = event.xAxis[0].value;
//         point = infChart.util.getSeriesPointByTime(mainSeries, clickedTime);
//     }

//     if (point) {
//         series = point.series;
//         var startIdx = 0,
//             endIdx = series.points.length - 1,
//             pointIndex = point.index - series.cropStart,
//             noOfLeftPoints = pointIndex - startIdx,
//             noOfRightPoints = endIdx - pointIndex,
//             noOfPointsToShow = (mainSeries.points.length) * 0.9,
//             startIndex = pointIndex - Math.floor(noOfPointsToShow * (noOfLeftPoints / (series.points.length))),// startIdx + ((noOfLeftPoints > 3) ? Math.floor(noOfLeftPoints / 3) : (noOfLeftPoints > 1) ? 1 : 0);
//             endIndex = pointIndex + Math.floor(noOfPointsToShow * (noOfRightPoints / (series.points.length)));//((noOfRightPoints > 3) ? Math.floor(noOfRightPoints / 3) : (noOfRightPoints > 1) ? 1 : 0);

//         endIndex = endIndex >= mainSeries.points.length ? series.points.length - 1 : endIndex;
//         startIndex = startIndex > pointIndex ? pointIndex : startIdx < 0 ? 0 : startIndex;

//         // this.setRange(series.points[startIndex].x, series.points[endIndex].x);
//         var args = {xAxis: true, yAxis: false};
//         infChart.manager.setUserDefinedXAxisExtremes(this.chartId, series.points[startIndex].x, series.points[endIndex].x, true, args);

//     } else {
//         infChart.manager.zoomIn(infChart.manager.getContainerIdFromChart(this.chartId));
//         // this.zoomIn();
//     }

// };

// infChart.StockChart.prototype.setRange = function (startTime, endTime, redraw) {
//     this.getMainXAxis().setExtremes(startTime, endTime, redraw);
// };

infChart.StockChart.prototype._setFullRange = function () {
    var extremes = this.getRange();
    /*this.setRange(extremes.dataMin, extremes.dataMax);*/
    // this.setRange(extremes.min + 1, extremes.max);
    /*This is done for fixing issue of displaying same data point of compare symbols and base symbol in two x axis positions */
    // this.setRange(extremes.dataMin, extremes.dataMax);
    this.setXAxisExtremes(extremes.dataMin, extremes.dataMax, true, true);
};

infChart.StockChart.prototype.getRange = function () {
    return this.getMainXAxis().getExtremes();
};

/**
 * returns the min/max values to be shown in the navigator
 * @returns {{min: *, max: *}}
 */
infChart.StockChart.prototype.getExtremesForNavigator = function () {
    var data = this.processedData.data;
    if (data && data.length > 1) {
        return {min: data[0][0], max: data[data.length - 1][0]};
    }
};

/**
 * Create initialize range selector if not created before
 */
infChart.StockChart.prototype._setRangeSelector = function () {

    this.rangeSelector = true;

    var yHeight = this.chart.series[1].yAxis.height;
    var that = this;

    var div = this.rangeSelectorEl = $(document.createElement('div'));
    div.insertAfter($('#' + this.chartId));
    div.addClass("range-selector");
    div.html('<input type="text" id="dpFrom_' + this.chartId + '"/><input type="text" id="dpTo_' + this.chartId + '"/>' +
        '<div type="button" class="icon ico-arrow-horizontal full-range" id="fullRange_' + this.chartId + '" >' + '</div>');

    this.fromDatePicker = $('#dpFrom_' + this.chartId).datepicker({
        dateFormat: 'yy-mm-dd',
        onSelect: function () {
            var toDt = $('#dpTo_' + that.chartId).datepicker('getDate');
            var fromDate = $(this).datepicker('getDate');
            var UTCFromDate = Date.UTC(fromDate.getFullYear(), fromDate.getMonth(), fromDate.getDate(), 0, 0, 0, 0);
            var UTCToDate = Date.UTC(toDt.getFullYear(), toDt.getMonth(), toDt.getDate(), 23, 59, 0, 0);
            // that.setRange(UTCFromDate, UTCToDate);
            that.setXAxisExtremes(UTCFromDate, UTCToDate, true, true);
        },
        beforeShow: function (textbox, instance) {

            setTimeout(function () {
                if (that.chart.infScaleX && that.chart.infScaleY) {
                    var el = $('#ui-datepicker-div'),
                        pos = el.position(),
                        hz = el.width() * (1 - that.chart.infScaleX),
                        vl = el.height() * (1 - that.chart.infScaleY);
                    el.css({
                        "transform": "scale(" + that.chart.infScaleX + ", " + that.chart.infScaleY + ")",
                        "-ms-transform": "scale(" + that.chart.infScaleX + "," + that.chart.infScaleY + ")",
                        "-webkit-transform": "scale(" + that.chart.infScaleX + "," + that.chart.infScaleY + ")",
                        "margin-top": vl / 2,
                        "margin-left": -1 * hz / 2

                    });
                }
            });
        },
        onClose: function () {
            $('#ui-datepicker-div').appendTo(document.body);
        }
    });

    this.toDatePicker = $('#dpTo_' + this.chartId).datepicker({

        dateFormat: 'yy-mm-dd',
        onSelect: function () {
            var toDt = $(this).datepicker('getDate');
            var fromDate = $('#dpFrom_' + that.chartId).datepicker('getDate');
            var UTCFromDate = Date.UTC(fromDate.getFullYear(), fromDate.getMonth(), fromDate.getDate(), 0, 0, 0, 0);
            var UTCToDate = Date.UTC(toDt.getFullYear(), toDt.getMonth(), toDt.getDate(), 23, 59, 0, 0);
            // that.setRange(UTCFromDate, UTCToDate);
            that.setXAxisExtremes(UTCFromDate, UTCToDate, true, true);
        },
        beforeShow: function (textbox, instance) {
            //var pos = $( "#" + that.id).position()
            setTimeout(function () {
                if (that.chart.infScaleX && that.chart.infScaleY) {
                    var el = $('#ui-datepicker-div'),
                        pos = el.position(),
                        hz = el.width() * (1 - that.chart.infScaleX),
                        vl = el.height() * (1 - that.chart.infScaleY);
                    el.css({
                        "transform": "scale(" + that.chart.infScaleX + ", " + that.chart.infScaleY + ")",
                        "-ms-transform": "scale(" + that.chart.infScaleX + "," + that.chart.infScaleY + ")",
                        "-webkit-transform": "scale(" + that.chart.infScaleX + "," + that.chart.infScaleY + ")",
                        "margin-top": vl / 2,
                        "margin-left": -1 * hz / 2

                    });
                }
            });
            //$('#ui-datepicker-div').appendTo("#" + that.id);

        },
        onClose: function () {
            $('#ui-datepicker-div').removeAttr("style");
        }

    });

    $('#fullRange_' + this.chartId).on('click', function () {
        that._setFullRange();
    });

    this._adjustRangeSelectorPosition();

};

/**
 * Set the position of the range selector
 */
infChart.StockChart.prototype._adjustRangeSelectorPosition = function () {

    var div = this.rangeSelectorEl;
    if (div && div.length > 0 && this.chart && this.chart.navigator) {
        var yHeight = this.chart.navigator.height,
            containerHeight = div.height(),
            chartCont = div.parent(),
            chartEl = chartCont.find("[inf-container='chart']"),
            chartBottom = chartCont.height() - chartEl.height();

        div.css({
            bottom: (yHeight + chartBottom - containerHeight) + 'px'

        });
    }
};

/**
 * Adjust min/max values of range selector
 */
infChart.StockChart.prototype._adjustRangeSelectorMinMax = function () {
    if (this.chart.options.navigator.enabled === true) {
        var extremes = this.getRange();
        var from = $('#dpFrom_' + this.chartId);
        var to = $('#dpTo_' + this.chartId);
        try {
            var minDate = new Date(infChart.util.getDateStringFromTime(extremes.dataMin));
            var maxDate = new Date(infChart.util.getDateStringFromTime(extremes.dataMax));

            from.datepicker('option', 'minDate', minDate);
            from.datepicker('option', 'maxDate', maxDate);
            to.datepicker('option', 'minDate', minDate);
            to.datepicker('option', 'maxDate', maxDate);
            this._setRangeSelectorValues();
        }
        catch (e) {
            infChart.util.console.error(e);
        }
    }
};

/**
 * Set current values of from, to inputs of range selector
 */
infChart.StockChart.prototype._setRangeSelectorValues = function () {
    if (!this.settings.config || !this.settings.config.disableRangeSelector) {
        if (!this.rangeSelector) {
            this._setRangeSelector();
        }
        var extremes = this.getRange();
        this.fromDatePicker.datepicker("disable");
        this.fromDatePicker.datepicker('setDate', new Date(infChart.util.formatDate(extremes.min, '%Y-%m-%d')));
        this.fromDatePicker.datepicker("enable");

        this.toDatePicker.datepicker("disable");
        this.toDatePicker.datepicker('setDate', new Date(infChart.util.formatDate(extremes.max, '%Y-%m-%d')));
        this.toDatePicker.datepicker("enable");
    }
};

/**
 * Executes after changing the x axis extremes
 */
infChart.StockChart.prototype.afterSetExtremes = function () {

    var navigator = this.chart.navigator;
    if (navigator && this.chart.options.navigator.enabled === true && !navigator.infHasDragged) {
        this._setRangeSelectorValues();
    }

    this.updateMinMax();
    this.updatePriceLines(true);

    this._fireEventListeners('afterSetExtremes');
    this._fireEventListeners('afterXSetExtremes', [this.getRange()]);

    //if (this.chart && this.chart.annotations) {
    //    this.scaleDrawings();
    //}
};

/**
 * afterYSetExtremes
 */
infChart.StockChart.prototype.afterYSetExtremes = function () {
    if (this.hasLastLine || this.hasPreviousCloseLine) {
        this.adjustPriceLineLabels();
    }
    this.updateMinMax();

    this._fireEventListeners('afterYSetExtremes');
    this._fireEventListeners('afteYSetExtremes', [this.getMainYAxis().getExtremes()]);
};

/**
 * beforeScalingAxis
 */
infChart.StockChart.prototype._beforeScalingAxis = function (args) {
    this._fireEventListeners('beforeScalingAxis', args);
    //this._fireRegisteredMethod('beforeScalingAxis', args);
};

/**
 * afterScalingAxis
 */
infChart.StockChart.prototype._afterScalingAxis = function (args) {
    this._fireEventListeners('afterScalingAxis', args);
    //this._fireRegisteredMethod('afterScalingAxis', args);
};

/**
 * Return the x axis labels
 */
infChart.StockChart.prototype.getXAxisCrosshairLabel = function (value, axis) {
    var minuteData = this.interval && this.interval.split('_')[0] === 'I' ? " " + axis.options.dateTimeLabelFormats.minute : "";

    return infChart.util.formatDate(value, axis.options.dateTimeLabelFormats.day + minuteData);
};

/**
 * reset y axis extremes
 * need to reset whenever data set changes
 * 1. when chart mode changes
 * 2. when chart period changes
 * 3. when chart symbol changes
 * @param redraw
 */
infChart.StockChart.prototype.resetYAxisExtremes = function (redraw) {
    this.chart.infIsUserYExt = false;
    this.getMainYAxis().setExtremes(undefined, undefined, redraw, false);
};

/**
 * set y axis extremes by zooming
 * mouse wheel or scalable axis
 * @param {number} userMin new min
 * @param {number} userMax new max
 * @param {boolean} redraw redraw required or not
 * @param {boolean|undefined} isUserInteraction user interacted action or not
 */
infChart.StockChart.prototype.setUserDefinedYAxisExtremes = function (userMin, userMax, redraw, isUserInteraction) {
    if (typeof isUserInteraction === "undefined") {
        isUserInteraction = true;
    }
    this.chart.infIsUserYExt = isUserInteraction;
    this.getMainYAxis().setExtremes(userMin, userMax, redraw, false);
};

/**
 * has user set the extremes
 * @returns {boolean}
 */
infChart.StockChart.prototype.isUserDefinedYAxisExtremes = function () {
    return this.chart.infIsUserYExt === true;
};

/**
 * Set new default extremes when max value changed
 * @param newMin new min value of the series
 * @param newMax new max value of the series
 */
infChart.StockChart.prototype._setDefaultXAxisExtremes = function (newMin, newMax) {
    this.defaultXAxisExtremes = {min: newMin, max: newMax};
};

/**
 * has user set the extremes
 * @returns {boolean}
 */
infChart.StockChart.prototype.isUserDefinedXAxisExtremes = function () {
    return this.chart.infManualExtreme === true;
};

infChart.StockChart.prototype.resetXAxisExtremesToDefault = function () {
    this.chart.infManualExtreme = false;
    if (this.defaultXAxisExtremes) {
        this.getMainXAxis().setExtremes(this.defaultXAxisExtremes.min, this.defaultXAxisExtremes.max, true);
    }
};

infChart.StockChart.prototype.isDefaultXAxisExtremes = function () {
    var xAxis = this.getMainXAxis();
    return (this.defaultXAxisExtremes && xAxis.min == this.defaultXAxisExtremes.min && xAxis.max == this.defaultXAxisExtremes.max);
};

infChart.StockChart.prototype.setXAxisExtremes = function (userMin, userMax, redraw, isUserInteraction) {
    this._beforeScalingAxis({xAxis: true, yAxis: false});
    this.chart.infManualExtreme = isUserInteraction;
    this.getMainXAxis().setExtremes(userMin, userMax, redraw);
    this._clearToolbarControls("period", true);
    this._afterScalingAxis({xAxis: true, yAxis: false});
};

/**
 * Method to convert given value of the given types to the base value
 * @param value
 * @param isLog
 * @param isCompare
 * @param isPercent
 * @returns {*}
 */
infChart.StockChart.prototype.convertBaseYValue = function (value, isLog, isCompare, isPercent) {
    var convertedValue;

    if (isLog) {
        value = infChart.util.num2Log(Math.abs(value));
    }

    if (isPercent) {
        if (isCompare) {
            var mainSeries = this.getMainSeries(),
                compareValue = this._getSeriesCompareValue(mainSeries);

            convertedValue = compareValue ? (value / compareValue - 1) * 100 : value;
        } else {
            convertedValue = value;
        }
    } else {
        convertedValue = value;
    }
    return convertedValue;
};

infChart.StockChart.prototype.onNavigatorScrollStart = function (navigator) {
    if (this.rangeSelectorEl) {
        this.rangeSelectorEl.hide();
    }
    if (this.mouseWheelController) {
        this.mouseWheelController.destroy();
    }
    this._fireEventListeners('onNavigatorScrollStart', []);
    this._afterScalingAxis({xAxis: true, yAxis: false});
};

infChart.StockChart.prototype.onNavigatorScrollStop = function (navigator) {
    if (this.rangeSelectorEl) {
        this.rangeSelectorEl.show();
    }
    if (this.mouseWheelController) {
        this.mouseWheelController.initialize();
    }

    if (navigator.infHasDragged) {
        this._setRangeSelectorValues();
    }

    /*if (self.config.events.onNavigatorScrollStop && basexAxis && !isNaN(basexAxis.min) && !isNaN(basexAxis.max)) {
     self.config.events.onNavigatorScrollStop.apply(this, [basexAxis.min, basexAxis.max]);
     }*/
    var extremes = this.getRange(),
        resultObj = {timeZoneOffset: this.dataManager.getTimeZone(this.interval)};
    if (extremes.dataMax != extremes.max) {
        resultObj.max = extremes.max;
    }
    if (extremes.dataMin != extremes.min) {
        resultObj.min = extremes.min;
    }

    this._fireEventListeners('onNavigatorScrollStop', [resultObj], true);
    this._fireRegisteredMethod('onNavigatorScrollStop', [resultObj]);
};

//endregion===================End of Zooming and Rage Select============================================================

infChart.StockChart.prototype.redrawChart = function (avoidHighChartRedraw) {
    //this.setYAxisExtremes(false);
    var hchart = this.chart;

    if (hchart.redraw && !avoidHighChartRedraw) {
        this._setIndicatorFrames(false);
        hchart.redraw();
    }
    this._setLabels();
    this.updateMinMax();
    //this.setLegendValue();
    //this.scaleDrawings(this.id);

    if (hchart.redrawWaterMark) {
        hchart.redrawWaterMark();
    }
    this._fireEventListeners("resize");
};

//infChart.StockChart.prototype.hideAllIndicatorSettingsPopups = function () {
//    $.each(infChart.indicatorMgr.getAllIndicators(this.id), function (key, indicator) {
//        indicator.hideSettingsPopup();
//    });
//};

//infChart.StockChart.prototype.hideAllSettingsPopups = function () {
//    $.each(this.settingsPopups, function (key, settingsPopup) {
//        if (settingsPopup) {
//            settingsPopup.hide();
//        }
//    });
//    this.hideAllIndicatorSettingsPopups();
//};

/**
 * use infChart.indicatorMgr.indicatorLegendClick
 * @Deprecated
 * @param seriesId
 */
//infChart.StockChart.prototype.indicatorLegendClick = function (seriesId) {
//    infChart.indicatorMgr.getIndicatorBySeriesId(this.id, seriesId).loadSettingWindow(false);
//};

infChart.StockChart.prototype.seriesLegendClick = function (seriesId) {
    this._loadSettingWindow(false, {'seriesId': seriesId});
};

infChart.StockChart.prototype._hasSeriesColorOptions = function (seriesId, type) {
    return this.seriesColorOptions[seriesId] && this.seriesColorOptions[seriesId][type];
};

infChart.StockChart.prototype._getSeriesColorOptions = function (seriesId, type) {
    return this.seriesColorOptions[seriesId] && this.seriesColorOptions[seriesId][type] ? this.seriesColorOptions[seriesId][type] : this.chart.options.plotOptions[type];
};

/**
 * todo : support popup??
 * load settings window
 * @param {boolean} hide
 * @param options
 */
infChart.StockChart.prototype._loadSettingWindow = function (hide, options) {
    var self = this, container = $(infChart.structureManager.getContainer(self.getContainer(), "symbolSettingsPanelView")),
    seriesId = options.seriesId, series = self.chart.get(seriesId),
    chartSettingPanel = infChart.structureManager.settings.getChartSettingPanel(self.chartId);

    if (container && container.length) {

        if(chartSettingPanel.length){
            chartSettingPanel.remove();
        }

        var title = infChart.manager.getLabel('label.chartSettings');
        var settingContent = infChart.structureManager.settings.getPanelBodyHTML([infChart.structureManager.settings.getChartStyleSection(self)]);
        var settingHTML = infChart.structureManager.settings.getPanelHTML(self.chartId + "-chart-settings-panel", self.chartId, title, settingContent, true);
        $(settingHTML).prependTo(container);

        self._bindChartSettingsWindow();
        self.toggleGridSettingPanel();

        if (!self.settingsPopups[seriesId]) {
            var styleTypes = (self.styleTypes[seriesId]) ? self.styleTypes[seriesId] : (series.options.styleTypes) ? series.options.styleTypes : self.styleTypes["default"];

            var chartTypes = [];
            infChart.util.forEach(styleTypes, function (i, chartType) {
                var cls = self.chartStyleOptions[chartType] && self.chartStyleOptions[chartType].ico ? self.chartStyleOptions[chartType].ico : 'ico-chart-' + chartType;
                chartTypes.xPush({
                    'type': chartType,
                    'icon': cls,
                    'colors': self.getColorsForChartType(series, chartType)
                });
            });

            var content = infChart.structureManager.settings.getPanelBodyHTML([infChart.structureManager.settings.getSeriesStyleSection(seriesId, chartTypes)]);
            var html = infChart.structureManager.settings.getPanelHTML(self.id + "-symbol-settings-panel", seriesId, series.options.infLegendLabel, content, self.isMainSeries(series));

            self.settingsPopups[seriesId] = $(html).appendTo(container);

            self._bindSettingsWindow(self.settingsPopups[seriesId], series);
        } else {
            //if main symbol has changed
            self.settingsPopups[seriesId].find('[rel="panelTitle"]').html(series.options.infLegendLabel);
        }

        if (!hide) {
            self.showRightPanelWithTab(self.id + "_" + "symbolSettingsPanelView");
        }

        //if panel is visible
        if (!self.settingsPopups[seriesId].find('div.panel-collapse').is(":visible")) {
            self.settingsPopups[seriesId].find('div.panel-collapse').collapse("show");
            //self.settingsPopups[seriesId].find('div.panel-heading a').trigger('click');
        }

        var xGridLineWidth = self.chart.options.xAxis[0].gridLineWidth;
        var yGridLineWidth = self.chart.options.yAxis[0].gridLineWidth;
        var gridLineWidth = xGridLineWidth > yGridLineWidth ? xGridLineWidth: yGridLineWidth;
        var backgroundType = this.chart.options.chart.backgroundColor && typeof this.chart.options.chart.backgroundColor !== 'string' ? "gradient" : "solid";
        chartSettingPanel = container.find('div[rel="panel_'+ self.chartId +'"]');

        infChart.structureManager.settings.initializeStylePanel(self.settingsPopups[seriesId], seriesId, series.type, series.options.lineWidth);
        infChart.structureManager.settings.initializeChartStylePanel(gridLineWidth, chartSettingPanel, self.chartId, backgroundType);
    }
};

infChart.StockChart.prototype._bindChartSettingsWindow = function () {
    var self = this,
    container = $(infChart.structureManager.getContainer(self.getContainer(), "symbolSettingsPanelView")),
    chartSettingPanel = container.find('div[rel="panel_'+ self.chartId +'"]');

    function onGridLineWidthChange(strokeWidth) {
        var redraw = !self.isFirstLoadInprogress();
        var xGridLineWidth = self.chart.options.xAxis[0].gridLineWidth > 0 ? strokeWidth : undefined;
        var yGridLineWidth = self.chart.options.yAxis[0].gridLineWidth > 0 ? strokeWidth : undefined;

        self.setGridLineWidth(xGridLineWidth, yGridLineWidth, redraw, true);
    }

    function onGridLineColorChange(xGridLineColor, yGridLineColor) {
        self.setGridLineColor(xGridLineColor, yGridLineColor, true);
    }

    function onBackgroundColorChange(color, opacity, rgb) {
        self.setChartBackgroundColor(color, opacity, true,);
    }

    function onGradientBackgroundColorChange(topColor, bottomColor, topOpacity, bottomOpacity, rgb) {
        self.setGradientChartBackgroundColor(topColor, bottomColor, topOpacity, bottomOpacity, true);
    }

    var callbacks = {
        onGridLineWidthChange: onGridLineWidthChange,
        onGridLineColorChange: onGridLineColorChange,
        onBackgroundColorChange: onBackgroundColorChange,
        onGradientBackgroundColorChange: onGradientBackgroundColorChange
    }
    infChart.structureManager.settings.bindChartStyleElements( self.chartId, chartSettingPanel, callbacks);
    infChart.structureManager.settings.bindPanel(chartSettingPanel);

};

infChart.StockChart.prototype._bindSettingsWindow = function (settingsContainer, series) {
    var self = this, seriesId = series.options.id;
    function onChartTypeChange(seriesId, chartType, colorObj) {
        var redraw = !self.isFirstLoadInprogress();
        var isUndoRedo = settingsContainer.data("infUndoRedo");

        self._changeSeriesType(series, chartType, false, !isUndoRedo);
        var theme = infChart.themeManager.getTheme();
        var lineWidth = (theme.plotOptions[series.type].lineWidth) ? theme.plotOptions[series.type].lineWidth : series.options.lineWidth;
        if(lineWidth){
            self.setLineWidth(series, lineWidth, false);
        }
        if (colorObj.color) {
            self.setColor(series, colorObj.hexColor, colorObj.color, undefined, redraw);
        } else {
            self.setColor(series, colorObj.hexColor, colorObj.upColor, colorObj.downColor, redraw);
        }
        settingsContainer.data("infUndoRedo", false);
    }

    function onColorChange(seriesId, colorObj) {
        var redraw = !self.isFirstLoadInprogress();
        if (colorObj.color) {
            self.setColor(series, colorObj.hexColor, colorObj.color, undefined, redraw, true);
        } else {
            self.setColor(series, colorObj.hexColor, colorObj.upColor, colorObj.downColor, redraw, true);
        }
    }

    function onLineWidthChange(seriesId, strokeWidth) {
        var redraw = !self.isFirstLoadInprogress();
        self.setLineWidth(series, strokeWidth, redraw, true);
        //series.update({
        //        lineWidth: strokeWidth
        //    }, redraw
        //);
        //if (self.seriesColorOptions[series.options.id] && self.seriesColorOptions[series.options.id][series.options.type]) {
        //    self.seriesColorOptions[series.options.id][series.options.type].lineWidth = strokeWidth;
        //}
    }

    // bind style type tabs
    infChart.structureManager.settings.bindStyleElements(settingsContainer, seriesId, series.color, onChartTypeChange, onColorChange, onLineWidthChange);
    if (self.isMainSeries(series)) {
        infChart.structureManager.settings.bindPanel(settingsContainer);
    } else {
        infChart.structureManager.settings.bindPanel(settingsContainer, function (seriesId) {
            self.removeSeriesFromChart(seriesId, series.options.infType)
        });
    }
};

infChart.StockChart.prototype._getLineColor = function (series, type) {
    var typeLineColor = (this.seriesColorOptions[series.options.id] && this.seriesColorOptions[series.options.id][type] && this.seriesColorOptions[series.options.id][type].lineColor) ? this.seriesColorOptions[series.options.id][type].lineColor : undefined;
    var seriesOptionLineColor = (this.seriesColorOptions[series.options.id] && this.seriesColorOptions[series.options.id]["line"] && this.seriesColorOptions[series.options.id]["line"].lineColor) ? this.seriesColorOptions[series.options.id]["line"].lineColor : undefined;
    return typeLineColor ? typeLineColor : seriesOptionLineColor ? seriesOptionLineColor :
        this.chart.options.plotOptions[type] && this.chart.options.plotOptions[type].lineColor ? this.chart.options.plotOptions[type].lineColor :
            (this.chart.options.plotOptions["line"].lineColor) ? this.chart.options.plotOptions["line"].lineColor : series.options.lineColor;
};

/**
 * set series color
 * @param series - highchart series
 * @param hexColor - color code in hex
 * @param upColor - rgb up color
 * @param downColor - rgb down color
 * @param redraw redraw or not
 * @param isPropertyChange isPropertyChange
 * @param useSeriesLineColor - true if use series line color - used in area chart
 */
infChart.StockChart.prototype.setColor = function (series, hexColor, upColor, downColor, redraw, isPropertyChange, useSeriesLineColor) {

    if (typeof redraw == "undefined") {
        redraw = true;
    }

    var theme = infChart.themeManager.getTheme();
    var type = series.type;
    var cfg = {color: hexColor};
    var propertyType = "seriesColor";
    switch (type) {
        case 'area':
            cfg.lineColor = useSeriesLineColor ? hexColor : this._getLineColor(series, type);
            cfg.color = cfg.lineColor;
            //cfg.lineColor = hexColor;
            cfg.negativeColor = series.options.negativeColor;
            if (series.options.hasAreaNegative) {
                cfg.fillColor = upColor;
                cfg.negativeFillColor = downColor;
            } else {
                cfg.fillColor = {
                    linearGradient: {x1: 0, y1: 0, x2: 0, y2: 1},
                    stops: [
                        [0, upColor],
                        [1, downColor]
                    ]
                };
            }
            break;
        case 'line':
        case 'dash':
        case 'step':
            cfg.lineColor = hexColor;
            cfg.negativeColor = null;
            break;
        case 'arearange':
            cfg.lineColor = hexColor;
            cfg.fillOpacity = infChart.util.getOpacityFromRGBA(upColor);
            cfg.negativeColor = null;
            break;
        case 'column':
            if (series.options.hasColumnNegative) {
                cfg.color = upColor;
                cfg.negativeColor = downColor;
            } else {
                cfg.color = hexColor;
                cfg.negativeColor = hexColor;
            }
            break;
        case 'volume':
            if (series.options.hasColumnNegative) {
                cfg.upColor = upColor;
                cfg.upLineColor = upColor;
                cfg.color = downColor;
                cfg.lineColor = downColor;
            } else {
                cfg.color = hexColor;
                cfg.lineColor = downColor;
                cfg.upColor = downColor;
            }
            break;
        case 'candlestick':
        case 'ohlc':
        case 'hlc':
        case 'heikinashi':
        case 'equivolume':
        case 'point':
        case 'customCandle':
        case 'engulfingCandles':
            cfg.color = downColor;
            cfg.lineColor = downColor;
            cfg.upColor = upColor;
            cfg.upLineColor = upColor;
            cfg.negativeColor = null;
            break;
        case 'flags':
            cfg.fillColor = upColor;
            break;
        case 'infUDSignal':
            cfg.fillColor = upColor;
            cfg.lineColor = upColor;
            break;
        case 'infsignal':
            cfg.fillColor = upColor;
            cfg.lineColor = upColor;
            cfg.style = {color: upColor};
            break;
        case 'plotrange':
            cfg.color = upColor;
            cfg.fillColor = upColor;
            break;
        default:
            break;
    }
    //cfg.lineWidth = (theme.plotOptions[type].lineWidth) ? theme.plotOptions[type].lineWidth : series.options.lineWidth;
    var obj = {};
    obj[type] = cfg;
    this.seriesColorOptions[series.options.id] = $.extend({}, this.seriesColorOptions[series.options.id], obj);
    series.update(cfg, false);

    this._cleanNavigatorSeries(redraw);


     if(isPropertyChange){
        this._onPropertyChange("onChartColorChange", propertyType);
    }

};

// infChart.StockChart.prototype.getColors = function () {
//     return Highcharts.theme.seriesColorMap || ["#fbf201", "#00aeff", "#ff15af", "#8aff00", "#9f37ff"];
// };

/**
 * set series line Width
 * @param {Highcharts.series} series series to update
 * @param {number} width width to update
 * @param {boolean} redraw redraw or not
 * @param {boolean} isPropertyChange property change or not (used in wrappers)
 */
infChart.StockChart.prototype.setLineWidth = function (series, width, redraw, isPropertyChange) {

    series.update({
            lineWidth: width
        }, redraw
    );

    if (this.seriesColorOptions && this.seriesColorOptions[series.options.id] && this.seriesColorOptions[series.options.id][series.type]) {
        this.seriesColorOptions[series.options.id][series.type].lineWidth = width;
    }
};

infChart.StockChart.prototype.setGridLineWidth = function (xAxisGridLineWidth, yAxisGridLineWidth, redraw, isPropertyChange) {

    if (xAxisGridLineWidth) {
        this.chart.xAxis[0].update({
            gridLineWidth: xAxisGridLineWidth,
        }, false);
        this.xGridLineWidth = xAxisGridLineWidth;
    }
    if (yAxisGridLineWidth) {
        this.chart.yAxis[0].update({
            gridLineWidth: yAxisGridLineWidth,
        }, false);
        this.yGridLineWidth = yAxisGridLineWidth;
    }

    this.chart.redraw();

    if(isPropertyChange){
        this._onPropertyChange("gridSettings");
    }
};

infChart.StockChart.prototype.setGridLineColor = function (xGridColor, yGridColor, isPropertyChange) {

    if(xGridColor){
        this.chart.xAxis[0].update({
            gridLineColor: xGridColor
        }, false);
    }

    if(yGridColor){
        this.chart.yAxis[0].update({
            gridLineColor: yGridColor,
        }, false);
    }

    if(isPropertyChange){
        this.customGridLineColorEnabled = true;
    }

    this.chart.redraw();

    if(isPropertyChange) {
        this._onPropertyChange("onChartColorChange", "gridLineColor");
    }
};

infChart.StockChart.prototype.setChartBackgroundColor = function (color, opacity, isPropertyChange) {

    this.chart.update({
        chart: {
            backgroundColor: Highcharts.color(color).setOpacity(opacity).get(),
          }
    }, false);

    this.chartBackgroundColor = color;
    this.backgroundColorOpacity = opacity;
    this.chart.redraw();

    if(isPropertyChange) {
        this._onPropertyChange("onChartColorChange", "backgroundColor");
    }
};

infChart.StockChart.prototype.setGradientChartBackgroundColor = function (topColor, bottomColor, topColorOpacity, bottomColorOpacity, isPropertyChange) {

    var topGradientColor = this.chartBgTopGradientColor;
    var bottomGradientColor = this.chartBgBottomGradientColor;

    topGradientColor = topColor ? topColor : topGradientColor;
    bottomGradientColor = bottomColor ? bottomColor : bottomGradientColor;

    this.chart.update({
        chart: {
            backgroundColor: {
              linearGradient: [0, 0, 0, 500],
              stops: [
                [0, Highcharts.color(topGradientColor).setOpacity(topColorOpacity).get()],
                [1,  Highcharts.color(bottomGradientColor).setOpacity(bottomColorOpacity).get()]
              ]
            }
          },
    }, false);

    if(topColor){
        this.chartBgTopGradientColor = topColor;
        this.chartBgTopGradientColorOpacity = topColorOpacity;

    }
    if(bottomColor){
        this.chartBgBottomGradientColor = bottomColor;
        this.chartBgBottomGradientColorOpacity = bottomColorOpacity;
    }
    this.chart.redraw();

    if(isPropertyChange) {
        this._onPropertyChange("onChartColorChange", "backgroundColor");
    }
};


infChart.StockChart.prototype.updateSeriesOptions = function (series, options) {

    for (var i = 0; i < options.length; i++) {
        var redraw = (i === options.length - 1), option = options[i];
        switch (option.type) {
            case 'lineWidth':
                this.setLineWidth(series, option.values.width, redraw);
                break;
            case 'zIndex':
                series.update({
                        zIndex: option.values.zIndex
                    }, redraw
                );
                break;
            case 'color':
                this.setColor(series, option.values.hexColor, option.values.upColor, option.values.downColor, redraw, false, true);
                break;
            default:
                break;
        }
    }
};

// infChart.StockChart.prototype.getTheme = function () {
//     return Highcharts.theme;
// };

infChart.StockChart.prototype.isAfterRedrawRequired = function () {
    return !!this.plotHeight;
};

infChart.StockChart.prototype.afterRedraw = function () {

    if (this.chart && this.plotHeight != this.chart.plotHeight) {
        this.redrawChart(); //#CCA-2972 - remove this and call resizeChart to scale drawings
        //this._setIndicatorFrames(false); //#CCA-2972 - resizeChart did not set indicator frames
        //this.resizeChart();
    } else if (this.chart && this.chart.infPrevAxisOffset) {
        var mainYAxis = this.getMainYAxis(),
            side = mainYAxis.side;
        if (this.chart.axisOffset[side] != this.chart.infPrevAxisOffset[side]) {
            this.redrawChart(true);
        }
    }

    var mainseries = this.getMainSeries();
    mainseries && mainseries.group && mainseries.group.toFront && mainseries.group.toFront();
};

infChart.StockChart.prototype.updatePriceLines = function (redraw) {
    redraw = (redraw == true);

    if (this.hasLastLine) {
        this._drawLastLine();
    }
    if (this.hasPreviousCloseLine) {
        this._enablePreviousCloseLine(redraw);
    }
    if (this.hasLastLineForCompareSymbols) {
        this._drawLastLineForCompareSymbols();
    }
};

/**
 * Adjust the last and pre close labels when y axis changes
 */
infChart.StockChart.prototype.adjustPriceLineLabels = function () {
    var yAxis = this.getMainYAxis(), lineIds = [], labels = [], preservedCount = 0, lineIdx,
        prevCloseLineIds = [];

    if (yAxis) {
        if (this.hasLastLine && this.lastLabel && this.lastLine) {
            lineIds.xPush(this.lastLine);
            labels.xPush(this.lastLabel);
        }

        if (this.hasPreviousCloseLine && this.preCloseLabel && this.preCloseLine) {
            lineIds.xPush(this.preCloseLine);
            labels.xPush(this.preCloseLabel);
            prevCloseLineIds.xPush(this.preCloseLine);
        }

        if (this.hasLastLineForCompareSymbols) {
            for (var lineId in this.lastLabelForCompareSymbols) {
                if (this.lastLabelForCompareSymbols.hasOwnProperty(lineId)) {
                    lineIds.xPush(lineId);
                    labels.xPush(this.lastLabelForCompareSymbols[lineId]);
                }
            }
        }

        var plotLines = yAxis.plotLinesAndBands,
            labelAlign,
            isPrevClose;

        if (lineIds.length > 0 && plotLines.length > 0) {

            for (var i = 0, iLen = plotLines.length; i < iLen; i++) {
                lineIdx = lineIds.indexOf(plotLines[i].options.id);
                isPrevClose = prevCloseLineIds.indexOf(plotLines[i].options.id) >= 0;
                labelAlign = isPrevClose ? this.settings.config.previousCloseLabelAlign : this.settings.config.lastLabelAlign;

                if (lineIdx >= 0) {
                    var anchorx = (labelAlign == "right") ? undefined : this.chart.chartWidth;
                    var xPix = (labelAlign == "right") ? undefined : yAxis.left;
                    this._setPositionsForCalloutLabel(labels[lineIdx], labels[lineIdx].text.textStr, yAxis, yAxis.toPixels(plotLines[i].options.value), xPix, anchorx);
                    preservedCount++;

                    if (preservedCount == lineIds.length) {
                        break;
                    }
                }
            }
        }
    }
};

//region =====================last line=================================================================================

/**
 * Returns the processed last value of the series
 * @returns {number}
 */
infChart.StockChart.prototype.getLastValue = function () {

    var series = this.getMainSeries(), diff = 0, pointYValue = 0;

    if (series && series.yData && series.yData.length > 0) {

        if (this.rangeData.data.length > 0) {
            pointYValue = this.rangeData.data[this.rangeData.data.length - 1][4];

        }
        pointYValue = this.getSeriesProcessedValue(series, pointYValue);
    }
    return pointYValue;
};

/**
 * Returns the processed last value of the series
 * @returns {number}
 */
infChart.StockChart.prototype.getLastPrice = function (callback) {
    var series = this.getMainSeries(), diff = 0, pointYValue = 0;

    if (this._hasRegisteredMethod('lastPrice')) {
        this._fireEventListeners('lastPrice', [callback]);
    } else if (this.data.base && this.data.base.length > 0) {
        callback.call(this, this.data.base[this.data.base.length - 1][4], this.data.base[this.data.base.length - 1]);
    } else {
        callback.call(this, undefined);
    }

};

/**
 * Returns the current data which chart is drawn for given symbol
 * @returns {number}
 */
infChart.StockChart.prototype.getCurrentData = function (symbol) {
    var data;
    if (this.chart) {
        if (this.checkEquivalentSymbols(this.symbol, symbol)) {
            data = this.data.base;
        } else if (this._isCompareSymbol(symbol)) {
            data = this.data.compare[symbol.symbolId];
        }
    }
    return data;
};

/**
 * get max label width from last and previous close
 * only when labels align to right
 */
infChart.StockChart.prototype.getMaxLastLabelWidth = function () {
    var llLabelWidth = 0;
    var pclLabelWidth = 0;
    if(this.hasLastLine && this.settings.config.lastLabelAlign == "right") {
        llLabelWidth = this.lastLabel && this.lastLabel.width;
    }
    if(this.hasPreviousCloseLine && this.settings.config.previousCloseLabelAlign == "right") {
        pclLabelWidth = this.preCloseLabel && this.preCloseLabel.width;
    }
    return Math.max(llLabelWidth, pclLabelWidth);
};

/**
 * add last line as a plot line
 */
infChart.StockChart.prototype._drawLastLine = function () {
    var chart = this.chart,
        series = this.getMainSeries(),
        redrawYLabels = !this.hasLastLine;

    if (this.rangeData.data && this.rangeData.data.length && series.yData && series.yData.length > 0) {

        var pointYValue,
            lastValue = this.rangeData.data[this.rangeData.data.length - 1][4],
            mainSeries = this.getMainSeries(),
            lastlineTheme = this._getLastLineTheme(),
            yAxis = this.getMainYAxis(),
            labelTx;

        pointYValue = this.getSeriesProcessedValue(series, lastValue);

        if (this.hasLastLine) {
            this._removeLastLine(true);
        }

        this.lastLine = this.chartId + "_last";

        var useSeriesColor = this.hasLastLineForCompareSymbols;

        if (!isNaN(pointYValue)) {
            var anchorx, xPix, shape;
            labelTx = this.formatValue(lastValue, mainSeries.options.dp, undefined, true, false, NO_OF_LAST_PRICE_DECIMAL_POINTS);
            if(this.settings.config.lastLabelAlign === "right") {
                shape = 'rect';
            } else {
                anchorx = chart.chartWidth;
                xPix = yAxis.left;
                shape = "callout";
            }
            yAxis.addPlotLine(
                {
                    /*"label": {
                     text: infChart.manager.getLabel('L'),
                     style: {
                     color: lastlineTheme.color
                     }
                    },*/
                    //useHTML:true,
                    id: this.lastLine,
                    "value": pointYValue,
                    "color": useSeriesColor ? series.options.color : lastlineTheme.color,
                    "dashStyle": "shortdash",
                    "width": 1,
                    "zIndex": 3
                }
            );

            if (!this.lastLabel) {
                this.lastLabel = this.chart.renderer.label(labelTx, null, null, shape).attr({
                    align: "right",
                    "zIndex": 20,
                    padding: 3,
                    r: 1,
                    fill: useSeriesColor ? series.options.color : lastlineTheme.label.fill
                }).css({
                    color: lastlineTheme.label.color,
                    "font-size": lastlineTheme.label.fontSize
                }).add();
            }

            this._setPositionsForCalloutLabel(this.lastLabel, labelTx, yAxis, yAxis.toPixels(pointYValue), xPix, anchorx);

            this.hasLastLine = true;

            //if (redrawYLabels) {
            //
            //    // this._setYAxisWidth(true);
            //    this._setPositionsForCalloutLabel(this.lastLabel, labelTx, yAxis, yAxis.toPixels(pointYValue), xPix, anchorx);
            //
            //}
        }
    }
};

infChart.StockChart.prototype._drawLastLineForCompareSymbol = function (seriesId) {
    var stockChart = this, chart = stockChart.chart;
    var series = chart.get(seriesId);
    if (series.yData && series.yData.length > 0) {
        var pointYValue,
            lastLineTheme = stockChart._getLastLineTheme(),
            yAxis = stockChart.getMainYAxis(),
            lineId = stockChart.chartId + "_" + seriesId + "_last",
            rangeData = stockChart.rangeData.compareData[seriesId],
            lastValue = rangeData[rangeData.length - 1][4],
            symbol = stockChart.getCompareSymbolFromSeriesId(seriesId);

        pointYValue = this.getSeriesProcessedValue(series, lastValue);
        var labelTx = this.formatValue(lastValue, series.options.dp, symbol);

        if (stockChart.lastLabelForCompareSymbols[lineId]) {
            yAxis.removePlotLine(lineId);
        }

        yAxis.addPlotLine(
            {
                'id': lineId,
                'value': pointYValue,
                'color': series.options.lineColor,
                'dashStyle': "shortdash",
                'width': 1,
                'zIndex': 3
            }
        );

        if (!stockChart.lastLabelForCompareSymbols[lineId]) {
            stockChart.lastLabelForCompareSymbols[lineId] = chart.renderer.label(labelTx, null, null, "callout").attr({
                align: "right",
                "zIndex": 20,
                padding: 3,
                r: 1,
                fill: series.options.lineColor
            }).css({
                color: lastLineTheme.label.color,
                "font-size": lastLineTheme.label.fontSize
            }).add();
        }

        var anchorx = (stockChart.settings.config.lastLabelAlign == "right") ? undefined : chart.chartWidth;
        var xPix = (stockChart.settings.config.lastLabelAlign == "right") ? undefined : yAxis.left;

        stockChart._setPositionsForCalloutLabel(stockChart.lastLabelForCompareSymbols[lineId], labelTx, yAxis, yAxis.toPixels(pointYValue), xPix, anchorx);
    }
};

infChart.StockChart.prototype._removeLastLineForCompareSymbol = function (seriesId) {
    var stockChart = this;
    var lineId = stockChart.chartId + "_" + seriesId + "_last";
    stockChart.getMainYAxis().removePlotLine(lineId);
    if (stockChart.lastLabelForCompareSymbols[lineId]) {
        stockChart.lastLabelForCompareSymbols[lineId].destroy();
        delete stockChart.lastLabelForCompareSymbols[lineId];
    }
};

infChart.StockChart.prototype._drawLastLineForCompareSymbols = function () {
    var stockChart = this;
    if (stockChart.compareSymbols.count > 0) {
        for (var seriesId in stockChart.compareSymbols.idMap) {
            if (stockChart.compareSymbols.idMap.hasOwnProperty(seriesId)) {
                stockChart._drawLastLineForCompareSymbol(seriesId);
            }
        }
    }
};

infChart.StockChart.prototype._setPositionsForCalloutLabel = function (label, text, yAxis, yPix, xPix, anchorX) {
    var crossBox = label.getBBox(),
        hchart = this.chart,
        offset = 0,
        halfLineWidth = 0.5,
        yBottom = yAxis.top + yAxis.height - halfLineWidth,
        yTop = yAxis.top - halfLineWidth,
        posx = !isNaN(xPix) ? xPix : yAxis.opposite ? yAxis.width + yAxis.left : 0,
        adjustedY = (yTop > yPix - crossBox.height / 2 && yTop < yPix) ? yTop :
            (yBottom < yPix + crossBox.height / 2 && yBottom > yPix) ? yBottom - crossBox.height : undefined;

    if (!adjustedY && (yPix < yTop || yPix > yBottom)) {
        label.hide()
    } else {
        label.show().attr({
            text: text,
            x: posx,
            y: adjustedY != undefined ? adjustedY : yPix - crossBox.height / 2,
            visibility: 'visible'
        }).toFront();
    }

    //var limit = {
    //    left: yAxis.labelAlign === 'left' ? yAxis.left : 0,
    //    right: yAxis.labelAlign === 'right' ? yAxis.left + yAxis.width + crossBox.height / 4 : hchart.chartWidth
    //};

    // left edge
    //if (label.translateX < limit.left) {
    //    offset = limit.left - label.translateX;
    //}
    //
    //if (label.translateX + crossBox.width >= limit.right) {
    //    offset = -(label.translateX + crossBox.width - limit.right);
    //}

    label.attr({
        x: xPix != undefined ? posx + crossBox.width : posx + hchart.marginRight,
        y: adjustedY != undefined ? adjustedY : yPix - crossBox.height / 2,
        anchorY: yPix,
        showHalfAnchor: adjustedY != undefined,
        anchorX: anchorX ? anchorX : yAxis.opposite ? 0 : hchart.chartWidth
    });

};

/**
 * Returns the theme for las line
 * @private
 */
infChart.StockChart.prototype._getLastLineTheme = function () {
    return $.extend({
        color: "#505050",
        label: {fontSize: "11px", color: "#000000", fill: "rgba(255,255,255,0.3)"}
    }, Highcharts.theme && Highcharts.theme.lastLine);
};

/**
 * Returns the theme for pre close line
 * @private
 */
infChart.StockChart.prototype._getPreCloseLineTheme = function () {
    return $.extend({
        color: "#505050",
        label: {fontSize: "11px", color: "#000000", fill: "rgba(255,255,255,0.3)"}
    }, Highcharts.theme && Highcharts.theme.preCloseLine);
};

infChart.StockChart.prototype._removeLastLineElements = function () {
    this.getMainYAxis().removePlotLine(this.lastLine);
    if (this.lastLabel) {
        this.lastLabel.destroy();
        this.lastLabel = undefined;
    }
    this.lastLine = undefined;
};

/**
 * remove last line
 */
infChart.StockChart.prototype._removeLastLine = function () {
    this._removeLastLineElements();
    this.hasLastLine = false;
    //if (!fromDrawing) {
    //    this._setYAxisWidth(true);
    //}

};

///**
// * set last line
// * @Deprecated
// */
//infChart.StockChart.prototype.setLastLine = function (enabled) {
//    if (enabled && !this.hasLastLine) {
//        this._drawLastLine();
//        if (this._isToolbarEnabled()) {
//            infChart.toolbar.setSelectedControls(this.id, 'last', true);
//        }
//    } else if (!enabled && this.hasLastLine) {
//        this._removeLastLine();
//        if (this._isToolbarEnabled()) {
//            infChart.toolbar.setSelectedControls(this.id, 'last', false);
//        }
//    }
//
//};

//endregion

//region =====================previous Close line=======================================================================

//infChart.StockChart.prototype.updatePreviousCloseLine = function (redraw) {
//    if (this.hasPreviousCloseLine) {
//        redraw = (redraw == true) ? true : false;
//        this._enablePreviousCloseLine(redraw);
//    }
//};

/**
 * add last line as a plot line
 */
infChart.StockChart.prototype._enablePreviousCloseLine = function (redraw) {
    var chart = this.chart,
        series = this.getMainSeries(),
        extrems = this.getRange();

    if (!(this.rangeData.data && this.rangeData.data.length) || (this.prevousClose && this.prevousClose.extremes && this.prevousClose.extremes.min == extrems.min && this.prevousClose.extremes.max == extrems.max)) {
        return;
    }
    this.prevousClose.extremes = extrems;
    if (!this.isShortPeriod(this.period) && !this._isIntraday(this.interval)) {
        if (this.processedData && this.processedData.data && this.processedData.data.length > 0) {
            var preCloseDataObj = this.dataManager.getPreviousClose(this.processedData.data),
                pointYValue = preCloseDataObj.value,
                lastValue = this.rangeData.data[preCloseDataObj.idx][4];
            pointYValue = this.getSeriesProcessedValue(series, lastValue);
            this._drawPreviousCloseLine(pointYValue, lastValue, redraw);
        }
    } else {
        var intervalOptions = this.getCurrentIntervalOptions('D'),
            properties = {
                symbol: this.symbol,
                interval: 'D',
                maxPeriod: intervalOptions ? intervalOptions.maxPeriod : undefined,
                regularIntervalsOnUpdate: this.regularIntervalsOnUpdate
            };
        this.setLoading(true);
        this.dataManager.readHistoryData(properties, function (data, properties) {
            var dataList = data.data;
            if (dataList && dataList.length > 0 && this.data && this.data.base && this.data.base.length > 0) {
                var preCloseDataObj = this.dataManager.getPreviousClose(dataList);
                lastValue = preCloseDataObj.value;
                pointYValue = this.getSeriesProcessedValue(series, lastValue);
                this._drawPreviousCloseLine(pointYValue, lastValue, redraw);
            } else {
                this.setLoading(false);
                this.hasPreviousCloseLine = false;
                var containerId = infChart.manager.getContainerIdFromChart(this.chartId);
                infChart.toolbar.setSelectedControls(containerId, "preclose", this.hasPreviousCloseLine);
                /*this.prevousClose = {};*/
            }
        }, this);
    }
    this.hasPreviousCloseLine = true;
};

infChart.StockChart.prototype._drawPreviousCloseLine = function (pointYValue, lastValue, redraw) {
    if (!isNaN(pointYValue) && !isNaN(lastValue)) {

        var redrawYLabels = !this.hasPreviousCloseLine,
            labelTx;

        if (this.hasPreviousCloseLine) {
            this._removePreviousCloseLine(false, true);
        }
        this.prevousClose.extremes = this.getRange();
        var mainSeries = this.getMainSeries(), preCloseTheme = this._getPreCloseLineTheme();
        this.preCloseLine = this.chartId + "_preclose";

        var yAxis = this.getMainYAxis();

        yAxis.addPlotLine(
            {
                /*"label": {
                 text: infChart.manager.getLabel('label.preClose'),
                 y: 10,
                 style: {
                 color: preCloseTheme.color
                 }
                 },*/
                id: this.preCloseLine,
                "value": pointYValue,
                "color": preCloseTheme.color,
                "dashStyle": "shortdash",
                "width": 1,
                "zIndex": 3
            }
        );
        /*this.setThresholdColors(pointYValue, redraw);*/
        labelTx = this.formatValue(lastValue, mainSeries.options.dp, undefined, undefined, undefined, NO_OF_PREVIOUS_PRICE_DECIMAL_POINTS);

        if (!this.preCloseLabel) {
            this.preCloseLabel = this.chart.renderer.label(labelTx, null, null,this.settings.config.previousCloseLabelAlign === "right" ? "rect": "callout").attr({
                align: "right",
                "zIndex": 20,
                padding: 3,
                r: 1,
                fill: preCloseTheme.label.fill
            }).css({
                color: preCloseTheme.label.color,
                "font-size": preCloseTheme.label.fontSize
            }).add();
        }

        var anchorx = (this.settings.config.previousCloseLabelAlign == "right") ? undefined : this.chart.chartWidth;
        var xPix = (this.settings.config.previousCloseLabelAlign == "right") ? undefined : yAxis.left;

        this._setPositionsForCalloutLabel(this.preCloseLabel, labelTx, yAxis, yAxis.toPixels(pointYValue), xPix, anchorx);

        this.hasPreviousCloseLine = true;


        if (this.settings.config.previousCloseLabelAlign === "right") {
            if (!this.hasPreviousCloseLine || this.getMaxLastLabelWidth() > this.getMainYAxis().maxLabelLength) {
                this.getMainYAxis().isDirty = true;
                this.chart.redraw();
            }
        }

        //if (redrawYLabels) {
        //
        //    //this._setYAxisWidth(true);
        //    this._setPositionsForCalloutLabel(this.preCloseLabel, labelTx, yAxis, yAxis.toPixels(pointYValue), xPix, anchorx);
        //
        //}

    }
    this.setLoading(false);
};

infChart.StockChart.prototype._removePreviousCloseLineElements = function () {
    this.getMainYAxis().removePlotLine(this.preCloseLine);
    this.preCloseLine = undefined;
    if (this.preCloseLabel) {
        this.preCloseLabel.hide();
    }
};

/**
 * remove last line
 */
infChart.StockChart.prototype._removePreviousCloseLine = function (redraw, fromDrawing) {
    this._removePreviousCloseLineElements();
    this.hasPreviousCloseLine = false;
    var mainSeries = this.getMainSeries();
    /*if (mainSeries.groupedData) {
     mainSeries.redraw();
     }*/
    if (mainSeries.zones && mainSeries.zones.length > 0 && mainSeries.points) {
        redraw = !!redraw;
        mainSeries.update({zones: []}, false);
        if (redraw) {
            mainSeries.redraw();
        }
    }

    //if (!fromDrawing) {
    //    this._setYAxisWidth(true);
    //}
    this.prevousClose = {};
};

///**
// * set last line
// * @Deprecated
// */
//infChart.StockChart.prototype.setPreviousCloseLine = function (enabled) {
//    if (enabled && !this.hasPreviousCloseLine) {
//        this._enablePreviousCloseLine(true);
//        if (this._isToolbarEnabled()) {
//            infChart.toolbar.setSelectedControls(this.id, 'preclose', true);
//        }
//    } else if (!enabled && this.hasPreviousCloseLine) {
//        this._removePreviousCloseLine(false);
//        if (this._isToolbarEnabled()) {
//            infChart.toolbar.setSelectedControls(this.id, 'preclose', false);
//        }
//    }
//
//};

//endregion

infChart.StockChart.prototype.setThresholdColors = function (threshold, redraw) {
    // var mainSeries = this.chart.get('c0');
    var mainSeries = this.getMainSeries();
    var currentTrend;
    var zones = [];
    redraw = (redraw == true) ? true : false;
    try {
        if ((this.isShortPeriod(this.period) || this._isIntraday(this.interval)) && /*this.hasPreviousCloseLine &&*/ !(mainSeries.zones.length > 0) && (this.type === 'line' || this.type === 'area' || this.type === 'column')) {

            if (mainSeries.zones.length == 0) {
                mainSeries.update({
                    zones: [{
                        value: threshold,
                        color: 'red'
                    }, {
                        color: 'green'
                    }]
                }, false);
                if (redraw) {
                    mainSeries.redraw();
                }
            }
        }
        /* else if (mainSeries.zones.length > 0) {
         mainSeries.update({zones: [{color: mainSeries.color}]}, redraw);

         }*/
    }
    catch (x) {
        infChart.util.console.error(x);
    }
};

//region =====================tooltip===================================================================================

/**
 * Get Values for tooltip of given series for given index
 * @param {number} time time
 * @returns {string}
 */
infChart.StockChart.prototype.getTooltipTime = function (time) {
    var format;
    switch (this.interval) {
        case 'T':
            format = '%d.%m.%Y %H:%M:%S';
            break;
        case 'I_1':
        case 'I_2':
        case 'I_5':
        case 'I_3':
        case 'I_10':
        case 'I_15':
        case 'I_30':
        case 'I_60':
        case 'I_120':
        case 'I_240':
        case 'I_360':
            format = '%d.%m.%Y %H:%M';
            break;
        case 'M':
            format = '%d.%b.%Y';
            break;
        case 'Y':
            format = '%Y';
            break;
        case 'D':
            format = '%d.%m.%Y %H:%M';
            break;
        default:
            format = '%d.%m.%Y';
            break;
    }
    return infChart.util.formatDate(time, format);
};

/**
 * @typedef {Object} tooltipData
 * @property {string} [label]
 * @property {string} [color]
 * @property {object} raw
 * @property {object} formatted
 * @property {array<string>} [displayItems] - we show only these
 */

/**
 * get tooltip value
 * @param point
 * @param isBase
 * @returns {tooltipData}
 */
infChart.StockChart.prototype.getTooltipValue = function (point, isBase) {
    var dp = point.series.options.dp, index = point.index, data, tooltipData = {}, formattedTooltipData = {}, displayItems = [],
        cropStart = point.series.cropStart,
        startData,
        grpVolIdx,
        compSym = !isBase && point && point.series && point.series.options && this.getCompareSymbolFromSeriesId(point.series.options.id);

    if (isBase) {
        if (point.series.groupedData && point.series.options.dataGrouping && point.series.options.dataGrouping.enabled) {
            data = point.series.groupedData[index];
            grpVolIdx = this.getGroupedVolumeIndex(point, this.rangeData.data);
            var dataR = this.rangeData.data[grpVolIdx];
            var hasData = false;
            if (dataR) {
                hasData = true;
                tooltipData.time = dataR[0];
                tooltipData.close = dataR[4];
                tooltipData.open = dataR[1];
                tooltipData.high = dataR[2];
                tooltipData.low = dataR[3];
            } else if (data.xPoint) {
                hasData = true;
                tooltipData.close = this.getYLabel(data.xPoint.close, false, true, true);
                tooltipData.open = this.getYLabel(data.xPoint.open, false, true, true);
                tooltipData.high = this.getYLabel(data.xPoint.high, false, true, true);
                tooltipData.low = this.getYLabel(data.xPoint.low, false, true, true);
            } else if (data.close == undefined) {
                if (dataR) {
                    hasData = true;
                    tooltipData.time = dataR[0];
                    tooltipData.close = dataR[4];
                    tooltipData.open = dataR[1];
                    tooltipData.high = dataR[2];
                    tooltipData.low = dataR[3];
                }
            } else {
                hasData = true;
                tooltipData.close = this.getYLabel(data.close, false, true, true);
                tooltipData.open = this.getYLabel(data.open, false, true, true);
                tooltipData.high = this.getYLabel(data.high, false, true, true);
                tooltipData.low = this.getYLabel(data.low, false, true, true);
            }

            if (hasData) {
                tooltipData.volume = dataR ? dataR[5] : undefined;

                if (this.isCompare) {
                    tooltipData.pchg = point.change;
                    formattedTooltipData.pchg = this.formatValue(tooltipData.pchg, dp);
                } else /*if (this.interval !== 'T')*/ {
                    formattedTooltipData.high = this.formatValue(tooltipData.high, dp);
                    formattedTooltipData.low = this.formatValue(tooltipData.low, dp);
                    formattedTooltipData.open = this.formatValue(tooltipData.open, dp);
                    displayItems.xPush('open');
                    displayItems.xPush('high');
                    displayItems.xPush('low');
                }
            }
        } else {
            data = this.rangeData.data[index];
            startData = this.rangeData.data[cropStart];
            if (point.xPoint) {
                data = $.extend([], data, [data[0], point.xPoint.open, point.xPoint.high, point.xPoint.low, point.xPoint.close, data[5]]);
                tooltipData.close = this.getYLabel(point.xPoint.close, false, true, true);
                tooltipData.open = this.getYLabel(point.xPoint.open, false, true, true);
                tooltipData.high = this.getYLabel(point.xPoint.high, false, true, true);
                tooltipData.low = this.getYLabel(point.xPoint.low, false, true, true);
            } else if (data) {
                tooltipData.close = data[4];
                tooltipData.open = data[1];
                tooltipData.high = data[2];
                tooltipData.low = data[3];
            }

            if (this.isCompare) {
                tooltipData.pchg = point.change;
                tooltipData.chg = startData && (tooltipData.close - startData[4]);
                //formattedTooltipData.pchg = this.formatValue(point.y, dp);
            } else if (!(this.interval === 'T' && tooltipData.open == tooltipData.close && data && data[2] == data[3] && tooltipData.open == data[2])) {
                formattedTooltipData.high = tooltipData.high ? this.formatValue(tooltipData.high, dp, undefined, undefined, undefined, NO_OF_SPECIFIC_DECIMAL_POINTS) : '--';
                formattedTooltipData.low = tooltipData.low ? this.formatValue(tooltipData.low, dp, undefined, undefined, undefined, NO_OF_SPECIFIC_DECIMAL_POINTS) : '--';
                formattedTooltipData.open = tooltipData.open ? this.formatValue(tooltipData.open, dp, undefined, undefined, undefined, NO_OF_SPECIFIC_DECIMAL_POINTS) : '--';
                displayItems.xPush('open');
                displayItems.xPush('high');
                displayItems.xPush('low');
            }
            tooltipData.volume = data && data[5];

            if (this.bidAskHistory && data) {
                tooltipData.bidAskHistory = {
                    bidLast: data[6],
                    askLast: data[7],
                    askHigh: data[8],
                    bidLow: data[9]
                };

                formattedTooltipData.bidAskHistory = {
                    bidLast: data[6] ? this.formatValue(data[6], dp) : '--',
                    askLast: data[7] ? this.formatValue(data[7], dp) : '--',
                    askHigh: data[8] ? this.formatValue(data[8], dp) : '--',
                    bidLow: data[9] ? this.formatValue(data[9], dp) : '--'
                }
            } else {
                tooltipData.bidAskHistory = null;
            }

            displayItems.xPush('bidAskHistory');
        }
    } else {

        if (point.series.groupedData && point.series.options.dataGrouping && point.series.options.dataGrouping.enabled) {
            var compareSeries = this.rangeData.compareData[point.series.options.id];
            var compareIndx = this.getGroupedVolumeIndex(point, compareSeries);
            if (compareSeries[compareIndx]) {
                var compYVal = (compareIndx == 0) ? 0 : point.change;
                tooltipData.volume = compareSeries[compareIndx][5];
                tooltipData.close = compareSeries[compareIndx][4];
                tooltipData.open = compareSeries[compareIndx][1];
                tooltipData.pchg = compYVal;
                formattedTooltipData.pchg = this.formatValue(tooltipData.pchg, dp, compSym);
            }
        } else {
            data = this.rangeData.compareData[point.series.options.id][index];
            startData = this.rangeData.compareData[point.series.options.id][cropStart];
            if (data) {
                tooltipData.volume = data[5];
                tooltipData.close = data[4];
                tooltipData.open = data[1];
            }
            tooltipData.pchg = point.change;
            tooltipData.chg = startData && (tooltipData.close - startData[4]);
            formattedTooltipData.pchg = this.formatValue(tooltipData.pchg, dp, compSym);
            formattedTooltipData.chg = this.formatValue(tooltipData.chg, dp, compSym);
        }
    }

    if (typeof tooltipData.close !== 'undefined') {
        formattedTooltipData.close = tooltipData.close ? this.formatValue(tooltipData.close, dp, compSym, undefined, undefined, NO_OF_SPECIFIC_DECIMAL_POINTS) : '--';
        displayItems.xPush('close');
    }

    if (typeof tooltipData.volume !== 'undefined') {
        formattedTooltipData.volume = this.formatVolume(tooltipData.volume, compSym);
        displayItems.xPush('volume');
    }

    var time;

    if (grpVolIdx && grpVolIdx >= 0 && this.rangeData.data[grpVolIdx]) {
        time = this.rangeData.data[grpVolIdx][0];
    } else {
        time = point.x;
    }

    this.ttgrpVolIdx = grpVolIdx;
    this.ttTime = time;

    tooltipData.time = time;
    formattedTooltipData.time = this.getTooltipTime(time);
    if (isBase) {
        displayItems.xPush('time');
    }

    return {
        'raw': tooltipData,
        'formatted': formattedTooltipData,
        'color': point.series.color,
        'label': point.series.name,
        'displayItems': displayItems
    };
};

/**
 * Get Values for tooltip of given series for given index
 * @param point tooltip point
 * @returns {tooltipData}
 */
infChart.StockChart.prototype.getIndicatorTooltipValue = function (point) {
    var tooltipData, indicator = infChart.indicatorMgr.getIndicatorBySeriesId(this.id, point.series.options.id);
    if (indicator) {
        if (point.series.groupedData && point.series.options.dataGrouping && point.series.options.dataGrouping.enabled) {
            var grpVolIdx = this.getGroupedVolumeIndex(point, point.series.options.data);
            tooltipData = indicator.getTooltipValueByBaseRow(point, point.series.options.data[grpVolIdx], grpVolIdx);
        } else {
            tooltipData = indicator.getTooltipValue(point);
        }
    }

    return tooltipData;
};

infChart.StockChart.prototype.getGroupedVolumeIndex = function (point, actualValues) {

    var corpStart = point.series && point.series.cropStart || 0,
        startIdx = point.dataGroup.start + corpStart,
        volume,
        i;

    if (point.dataGroup) {

        for (i = startIdx; i < (startIdx + point.dataGroup.length); i++) {
            if (actualValues[i][0] == point.x) {
                volume = i;
                break;
            }
            else if (actualValues[i][0] > point.x) {
                volume = Math.max(0, point.dataGroup.start, i - 1);
                break;
            }
        }
    }
    return volume;
};

infChart.StockChart.prototype.getOHLCfromPoint = function (point) {
    var series = point.series;

    if (series) {
        var seriesOptions = series.options,
            isBase = (seriesOptions.infType !== 'compare' && seriesOptions.infType !== 'indicator'),
            index = point.index, dataPoint = {}, gropedDataPoint;

        if (isBase) {
            if (series.groupedData && seriesOptions.dataGrouping && seriesOptions.dataGrouping.enabled) {
                gropedDataPoint = point;//.series.groupedData[index];
                var j,
                    row,
                    startMapIdx,
                    stopMapIdx,
                    corpStart = series && series.cropStart || 0,
                    pointGroup = gropedDataPoint.dataGroup,
                    groupStart = pointGroup.start + corpStart,
                    dataR = this.rangeData.data[this.getGroupedVolumeIndex(point, this.rangeData.data)];

                if (gropedDataPoint.close == undefined || this.isCompare) {

                    if (pointGroup) {

                        if (dataR) {

                            dataPoint.close = dataR[4];
                            dataPoint.open = dataR[1];
                            dataPoint.high = dataR[2];
                            dataPoint.low = dataR[3];

                        } else {

                            dataPoint.close = this.getYLabel(gropedDataPoint.y, false, true, true);
                            dataPoint.open = this.getYLabel(gropedDataPoint.y, false, true, true);
                            dataPoint.high = 0;
                            dataPoint.low = this.getYLabel(gropedDataPoint.y, false, true, true);
                        }

                        if (this.rangeData.data[groupStart]) {

                            startMapIdx = groupStart;
                            stopMapIdx = groupStart + pointGroup.length - 1;
                        }
                    }
                    if (startMapIdx != undefined && stopMapIdx != undefined) {

                        for (j = startMapIdx; j <= stopMapIdx && j < this.rangeData.data.length; j++) {

                            row = this.rangeData.data[j];

                            if (row[2] > dataPoint.high) {
                                dataPoint.high = row[2];
                            }

                            if (row[3] < dataPoint.low) {
                                dataPoint.low = row[3];
                            }
                        }
                    }
                } else {

                    dataPoint.close = this.getYLabel(gropedDataPoint.close, false, true, true);
                    dataPoint.open = this.getYLabel(gropedDataPoint.open, false, true, true);
                    dataPoint.high = this.getYLabel(gropedDataPoint.high, false, true, true);
                    dataPoint.low = this.getYLabel(gropedDataPoint.low, false, true, true);
                }

            } else {

                gropedDataPoint = this.rangeData.data[index];
                dataPoint.close = gropedDataPoint[4];
                dataPoint.open = gropedDataPoint[1];
                dataPoint.high = gropedDataPoint[2];
                dataPoint.low = gropedDataPoint[3];

            }
        } else {
            // TODO : for compare
        }
        return dataPoint;
    }
};

/**
 * update tooltip of given series
 * @param seriesId
 * @param x
 */
infChart.StockChart.prototype.updateToolTip = function (seriesId, x) {
    var chart = this.chart;
    var series = chart.get(seriesId);

    switch (series.options.infType) {
        case "indicator":
            if (!infChart.util.isSeriesInBaseAxis(series.options.yAxis) && !infChart.util.isSeriesParallelToBaseAxis(chart.get(series.options.yAxis))) {
                infChart.indicatorMgr.getIndicatorBySeriesId(this.id, seriesId).updateToolTip(seriesId, x);
            }
            break;
        default:
            break;
    }
};

/**
 * Show/hide chart tooltip
 * @returns {boolean|*}
 * @Deprecated
 */
infChart.StockChart.prototype.setTooltip = function (enabled) {
    if (enabled && !this.tooltip) {
        this.toggleToolTip();
        if (this._isToolbarEnabled()) {
            infChart.toolbar.setSelectedControls(this.id, 'tooltip', true);
        }
    } else if (!enabled && this.tooltip) {
        this.toggleToolTip();
        if (this._isToolbarEnabled()) {
            infChart.toolbar.setSelectedControls(this.id, 'tooltip', false);
        }
    }
};

/**
 * updating tootip to last value
 * @param force
 */
infChart.StockChart.prototype.updateTooltipToLastPoint = function (force, isReApply) {
    var self = this;

    if (self.tooltip && ((self.chart && !self.chart.infMouseIn) || force)) {

        var mainSeries = self.getMainSeries(),
            lastPoint = mainSeries && mainSeries.points && mainSeries.points.length > 0 && mainSeries.points[mainSeries.points.length - 1],
            tooltipObj = lastPoint && infChart.manager.getTooltipValue({point: lastPoint, x: lastPoint.x});

        if (tooltipObj) {

            var tooltipHtml = infChart.manager.getTooltipHTML(tooltipObj);

            infChart.structureManager.legend.updateSymbolDataInLegend($(infChart.structureManager.getContainer(self.getContainer(), 'chart_top')), tooltipHtml.baseHTML, tooltipHtml.compareSymHTML);
            self._fireRegisteredMethod('updateTooltipToLastPoint', [tooltipObj]);

            if (!isReApply && !self.selfListeners['updateTooltipToLastPoint_onReApplyFormatters']) {
                var lsnIdx = self.registerForEvents('onReApplyFormatters', self.updateTooltipToLastPoint, [true, true]);
                self.selfListeners['updateTooltipToLastPoint_onReApplyFormatters'] = {
                    id: lsnIdx,
                    method: 'onReApplyFormatters'
                };
            }
        }
    }
};

infChart.StockChart.prototype.unRegisterLastPointTooltipEvents = function () {
    var self = this,
        listener = self.selfListeners['updateTooltipToLastPoint_onReApplyFormatters'];

    if (listener) {
        self.removeRegisteredEvent(listener.method, listener.id);
        delete self.selfListeners['updateTooltipToLastPoint_onReApplyFormatters'];
    }
};

/**
 * Returns the last point of the base series
 */
infChart.StockChart.prototype.getLastPoint = function () {
    var self = this,
        mainSeries = self.getMainSeries(),
        lastPoint = mainSeries && mainSeries.points && mainSeries.points.length > 0 && mainSeries.points[mainSeries.points.length - 1];
    return lastPoint;

};

//endregion ===================== end of tooltip========================================================================

//region =====================legend====================================================================================

infChart.StockChart.prototype.getLegendTitle = function (series) {
    var title;
    if (series.options.infType === 'indicator') {
        title = infChart.indicatorMgr.getLegendTitle(this.id, series);
    } else {
        title = series.options.infLegendLabel;
    }
    return title;
};

//endregion

//region ========================== Axis ===============================================================================

//region ++++++++++++++++++++++++++ Axis value converters+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

/**
 * Return y axis label for given actual y Value
 * @param yValue
 * @param axis
 * @param isAxisLabel
 * @param isValue
 * @returns {*}
 */
infChart.StockChart.prototype.getYLabel = function (yValue, isAxisLabel, isBaseValue, isValue) {
    var mainSeries = this.getMainSeries(),
        rangeData = this.rangeData && this.rangeData.data,
        retVal,
        baseInitVal,
        yLabel,
        baseValueCropStart,
        processedValueCropEnd,
        baseValueCropEnd;

    if (rangeData.length > 0) {
        if (this.isLog) {
            retVal = this._log2Num(yValue);
        } else if (this.isCompare) {
            var compareValue = this._getSeriesCompareValue(mainSeries);
            if (this.isPercent && isBaseValue) {
                retVal = (yValue / 100 + 1) * compareValue;
            } else {
                retVal = yValue;
            }
        } else if (this.isPercent) {
            if (isBaseValue) {
                retVal = yValue;
            } else {
                baseInitVal = this._getInitialValue(rangeData, 4);
                baseInitVal = baseInitVal && baseInitVal[4];
                baseValueCropStart = mainSeries.cropStart ? mainSeries.compareValue : baseInitVal;
                processedValueCropEnd = yValue;// - (mSeriesCompareValue || 0),
                retVal = ((processedValueCropEnd / baseValueCropStart) - 1) * 100;
            }
        } else {
            retVal = yValue;
        }
    } else {
        retVal = yValue;
    }

    if (isNaN(retVal)) {
        return '';
    }

    if (isValue) {
        yLabel = retVal;
    } else {
        yLabel = this.formatYValue(retVal, (this.isPercent && !isBaseValue), isAxisLabel);
    }

    return yLabel;
};

/**
 * Returns whether numeric symbol should be shown for the given value
 * @param retVal
 * @private
 */
infChart.StockChart.prototype._useNumericSymbol = function (retVal) {
    return !this.disableNumericSymbols && !this.temperoryDisableNumericSymbols && (retVal >= 10000 || this.useNumericSymbolsAlways);
};

infChart.StockChart.prototype.formatYValue = function (retVal, isPercent, isAxisLabel, dp) {
    var retArr, intVal,
        iChart = this,
        formatValue = function (retVal1, useNumericSym, isAxisLabel, customDP) {
            var decimalPlaces;
            if (!useNumericSym) {
                decimalPlaces = (customDP != undefined) ? customDP : iChart.decimalDigits;
            } else {
                decimalPlaces = (customDP != undefined) ? customDP : 0;
            }

            if (decimalPlaces >= 0) {
                if (retVal1.toString().indexOf("e") >= 0) {
                    var ex = retVal1.toString().split("e")[1];
                    if (parseInt(ex) < 0 && Math.abs(parseInt(ex)) > decimalPlaces) {
                        retVal1 = 0;
                    }
                }
                if (typeof isAxisLabel !== 'undefined' && !isAxisLabel) {
                    retVal1 = infChart.util.formatNumber(retVal1, (decimalPlaces + 1));
                } else {
                    retVal1 = infChart.util.formatNumber(retVal1, decimalPlaces);
                }
            }
            return retVal1;
        };

    if (this._useNumericSymbol(retVal)) {
        var numericSymbols = ['k', 'M', 'G', 'T', 'P', 'E'],
            hasNumeric = false;
        // Decide whether we should add a numeric symbol like k (thousands) or M (millions).
        // If we are to enable this in tooltip or other places as well, we can move this
        // logic to the numberFormatter and enable it by a parameter.
        var i = numericSymbols.length, ret, multi;
        while (i-- && ret === undefined) {
            multi = Math.pow(1000, i + 1);
            if (/*numericSymbolDetector >= multi &&*/ (retVal) / multi > 1 && numericSymbols[i] !== null) {
                ret = retVal / multi;
                /* dp = ret<100?4 : 0;*/
                ret = infChart.util.formatNumber(ret, this.decimalDigits);
                //ret = infChart.util.formatNumber(ret);
                /*retArr = ret.split('.');*/

                /*if (retArr.length > 1) {
                 intVal = parseInt(retArr[1]);
                 if (intVal > 0) {
                 ret = ret.replace(/[0]+$/, '');
                 } else {
                 ret = retArr[0];
                 }
                 }*/
                ret = ret + numericSymbols[i];
                hasNumeric = true;
            }
        }

        if (!hasNumeric) {
            ret = formatValue(retVal, this.useNumericSymbols);
        }

    } else {
        ret = formatValue(retVal, this.useNumericSymbols, isAxisLabel, dp);
    }

    var postFix = (isPercent) ? '%' : '';

    ret = (ret == undefined) ? retVal : ret;
    /* var retNumArr = ret.toString().split('.');
     if (retNumArr.length > 1 && !this.useNumericSymbolsAlways && this.decimalDigits>1) {
     ret = ret.replace(/.[0]+$/, '');
     //ret = retNumArr[0]+'.'+ parseFloat(retNumArr[1]);
     }*/
    // retNumArr[1].replace(/^0+|0+$/g, "");
    // yLabel = (infChart.util.formatNumber(retVal, dp, '.', infChart.util.getThousandSeparator()) + postFix);
    var yLabel = (ret + postFix);
    return yLabel;
};

infChart.StockChart.prototype.getBaseValue = function (yValue, isLog, isCompare, isPercent) {
    return this.getSeriesBaseValue(this.getMainSeries(), yValue, isLog, isCompare, isPercent);
};

infChart.StockChart.prototype.getSeriesBaseValue = function (series, yValue, isLog, isCompare, isPercent) {

    var retVal,
        baseInitRow = this._getInitialValue(this.rangeData.data, 4),
        baseInitVal = baseInitRow && baseInitRow[4];
    if (isLog) {

        /*if (isCompare) {
         if (baseInitVal == 0 || baseInitVal) {
         retVal = (this._log2Num(((yValue + series.compareValue) / 100 + 1) * this._num2Log(baseInitVal)));
         }
         } else {*/
        retVal = this._log2Num(yValue);
        //}
    } else if (isCompare) {
        if (isPercent && series.compareValue) {
            retVal = (yValue / 100 + 1) * series.compareValue;
        } else {
            retVal = yValue;
        }
        //return '';
    } else /*if (isPercent) {
     retVal = baseInitVal && ((yValue * baseInitVal / 100) + baseInitVal);
     } else*/ {
        retVal = yValue;
    }

    return retVal;
};

infChart.StockChart.prototype.getsBaseValueFromProcessedValue = function (yValue) {

    var retVal;
    if (this.isLog) {
        retVal = this._log2Num(yValue);
    } else {
        retVal = yValue;
    }

    return retVal;
};

/**
 * Returns the Base min/max values and relavant properties
 * @param yAxis
 * @param yMin
 * @param yMax
 * @returns {{maxVal: *, minVal: *, baseInitVal: *, baseRangeFirst: *}}
 * @private
 */
infChart.StockChart.prototype.getYMinMaxBaseValue = function (yAxis, yMin, yMax) {
    var mainSeries = this.getMainSeries(),
        maxVal,
        minVal,
        baseRangeFirst,
        rangeData = this.rangeData.data,
        mSeriesCompareValue = this._getSeriesCompareValue(mainSeries),
        baseInitRow = this._getInitialValue(rangeData, 4),
        baseInitVal = baseInitRow && baseInitRow[4];

    yMin = !isNaN(yMin) ? yMin : yAxis.min;
    yMax = !isNaN(yMax) ? yMax : yAxis.max;

    if (rangeData.length > 0 && (this.isLog || this.isCompare)) {

        if (this.isLog) {

            if (this.isCompare && this.isPercent) {

                maxVal = this._log2Num((yMax / 100 + 1) * mSeriesCompareValue);
                minVal = this._log2Num((yMin / 100 + 1) * mSeriesCompareValue);

            } else {
                maxVal = this._log2Num(yMax);
                minVal = this._log2Num(yMin);
            }

        } else if (this.isCompare) {

            maxVal = yMax;
            minVal = yMin;
        }
    } else {
        if (this.isPercent) {
            maxVal = ((yMax / mSeriesCompareValue) - 1) * 100;
            minVal = ((yMin / mSeriesCompareValue) - 1) * 100;
        } else {
            maxVal = yMax;
            minVal = yMin;
        }

    }

    return {
        maxVal: Math.max(maxVal || minVal),
        minVal: Math.min(minVal || maxVal),
        baseInitVal: baseInitVal,
        baseRangeFirst: baseRangeFirst
    }
};


/**
 * Returns the processed value (which is sending to highcharts) of the given display value
 * @param series
 * @param val
 * @returns {number}
 */
infChart.StockChart.prototype.getProcessedValueFromDisplayValue = function (series, val) {

    var returnVal;
    if (this.isLog) {

        returnVal = this._num2Log(val);

    } else if (!this.isCompare && this.isPercent) {

        var mainSeries = this.getMainSeries(),
            mSeriesCompareValue = this._getSeriesCompareValue(mainSeries),
            rangeData = this.rangeData && this.rangeData.data,
            baseInitValRow = rangeData && this._getInitialValue(rangeData, 4),
            baseInitVal = baseInitValRow && baseInitValRow[4],
            baseValueCropStart = mSeriesCompareValue || baseInitVal;

        returnVal = baseValueCropStart ? ((val / 100) + 1) * baseValueCropStart : undefined;
    }
    // TODO :: need to implement for 'isCompare' if used for comparison mode
    return returnVal;
};
/**
 * Returns the processed value (which is sending to highcharts) of the given base value
 * @param series
 * @param val
 * @returns {number}
 */
infChart.StockChart.prototype.getProcessedValue = function (series, val) {

    var returnVal = 0;
    /*, initialClose;
     if (series.options.infType == 'compare') {
     var symbol = series.options.id.slice(2, series.options.id.length),
     baseInitRow = this._getInitialValue(this.rangeData.compareData[symbol], 4);
     initialClose = baseInitRow && baseInitRow[4];
     }
     else if (series.options.infType == "base") {
     baseInitRow = this._getInitialValue(this.rangeData.data, 4);
     initialClose = baseInitRow && baseInitRow[4];
     }
     else {
     return;
     }*/
    /*if (this.isPercent) {

     returnVal = (val / initialClose - 1) * 100;

     }
     else*/
    if (this.isLog) {

        returnVal = this._num2Log(val);
    } else {
        returnVal = val;
    }
    return returnVal;
};

/**
 * Returns the highcharts' yAxis value of the given base value
 * @param series series refered to the value
 * @param val base value
 */

//endregion ++++++++++++++++++++++++++ Axis value converters++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

/**
 * Set decimal digits from settings if specified
 * @param axis
 * @private
 */
infChart.StockChart.prototype._setMinYDecimalPlaces = function (axis) {

    var minYDecimalPlaces = this.settings.config.minYDecimalPlaces;

    if (minYDecimalPlaces != undefined) {

        this.decimalDigits = Math.max((
            minYDecimalPlaces == 'symbol' ? (this.symbol && this.symbol.dp) || (!this.symbol && this.settings.config.defaultDp) : minYDecimalPlaces
        ), this.decimalDigits);
    }
};

///**
// * Change yAxis width according to the label widths when redrawing chart
// * @param axis
// * @private
// */
//infChart.StockChart.prototype.setYAxisWidthOnRedraw = function (axis) {
//
//    if (axis.options.id != '#1') {
//        return;
//    }
//
//    var maxLength = 0, tickPositions = axis.tickPositions.length;
//
//    if (tickPositions > 0) {
//
//        //infChart.util.forEach(axis.ticks, function (k, val) {
//        //    if (maxLength < val.labelLength) {
//        //        maxLength = val.labelLength;
//        //        maxTickPositions = val.label.textStr && val.label.textStr.length;
//        //    }
//        //});
//        //
//        //maxLength = Math.ceil(maxLength) + 6;
//        //
//        //infChart.util.forEach(this.chart.axes, function (i, e) {
//        //
//        //    if (!e.isXAxis && e.options.labels.x != maxLength) {
//        //        if (!maxTickPositions || !e.infMaxLabelSize || maxTickPositions == e.infMaxLabelSize) {
//        //            e.infMaxLabelSize = maxTickPositions;
//        //            e.isDirty = true;
//        //        }
//        //        e.options.labels.x = maxLength;
//        //    }
//        //    /* e.right = maxLength+26 ; showFirstLabel*/
//        //});
//
//        //add 2 to increase space between last number and the margin.
//        maxLength = Math.ceil(axis.maxLabelLength) + (axis.options.labels.x + 2);
//
//        if ((this.lastLabel && this.hasLastLine) || (this.hasPreviousCloseLine && this.preCloseLabel)) {
//
//            var maxWidth = Math.max((this.hasLastLine && this.settings.config.lastLabelAlign == "right" ? this.lastLabel.width : 0), (this.hasPreviousCloseLine && this.settings.config.previousCloseLabelAlign == "right" ? this.preCloseLabel.width : 0));
//            maxLength = (maxLength > maxWidth) ? maxLength : maxWidth;
//        }
//        this.chart.margin[1] = maxLength;
//        this.chart.marginRight = maxLength;
//
//        //this.chart.margin[1] = maxLength + 3;
//        //axis.options.offset = -1*(maxLength + 3);
//        //this.chart.options.marginRight =  maxLength + 3;
//        //this.chart.marginRight = maxLength + 3;
//        /*this.chart.update({
//         chart: {
//         marginRight: maxLength + 3
//         }
//         }, false);
//
//         if (redraw) {
//         this.chart.redraw();
//         }*/
//    }
//};

///**
// * Change yAxis width according to the label widths forcefully
// * @param redraw
// * @private
// */
//infChart.StockChart.prototype._setYAxisWidth = function (redraw) {
//
//    var hchart = this.chart,
//        axis = hchart.get("#1");
//
//    if (axis && axis.ticks) {
//
//        var prevMargin = hchart.marginRight;
//
//        this._setYAxisWidthOnRedraw(hchart.get("#1"));
//
//        if (prevMargin != hchart.marginRight) {
//
//            hchart.update({
//                chart: {
//                    marginRight: hchart.marginRight
//                }
//            }, false);
//
//            if (redraw) {
//                hchart.redraw();
//            }
//        }
//    }
//};

/**
 * Method to update y Axis configs
 * @param yAxis
 * @param config
 * @param redraw
 */
infChart.StockChart.prototype.updateYAxis = function (yAxis, config, redraw) {
    //config.labels = {x: yAxis.options.labels.x};
    yAxis.update(config, redraw);
};

infChart.StockChart.prototype._getXAxisLabelFormat = function (axisFormats, tickValue, prevTickValue, isFirst) {

    var tickDate = new Date(tickValue),
        tickMonth = tickDate.getUTCMonth(),
        prevTickDate = new Date(prevTickValue),
        prevTickMonth = prevTickDate.getUTCMonth(),
        labelFormat;

    if (this.period == "M_1" && this.interval == "D") {

        labelFormat = "%e";

        if (isFirst) {

            labelFormat = " " + axisFormats.month;

        } else if (tickMonth != prevTickMonth) {

            labelFormat = (tickDate.getUTCFullYear() != prevTickDate.getUTCFullYear()) ? "%Y" : "%b";
        }
    }
    return labelFormat;
};

/**
 * Return the x axis labels
 */
infChart.StockChart.prototype.getXAxisLabel = function (label) {

    var tickValue = label.value,
        axis = label.axis,
        axisOptions = axis.options,
        axisFormats = axisOptions.dateTimeLabelFormats,
        labelFormat = label.dateTimeLabelFormat;

    if (axisFormats && labelFormat == axisFormats.month && this.interval != 'M') {
        // To avoid displaying only month in non-month intervals
        labelFormat = axisFormats.day;

    } else if (!labelFormat && this.period == "M_1" && this.interval == "D") {
        var tickPositions = axis.tickPositions,
            tickIndex = tickPositions.indexOf(tickValue);

        labelFormat = this._getXAxisLabelFormat(axisFormats, tickValue, tickPositions[tickIndex - 1], label.isFirst);
    }

    return infChart.util.formatDate(tickValue, labelFormat);
};

/**
 * Return the y axis labels
 */
infChart.StockChart.prototype.getYAxisLabel = function (labelObj, isAxis) {

    var value = labelObj.value;

    if (isAxis) {

        var axisId = labelObj.axis && labelObj.axis.options && labelObj.axis.options.id,
            mainYAxis = this.getMainYAxis();

        if (axisId === mainYAxis.options.id) {
            return this.getYLabel(value, isAxis);
        } else {
            return value;
        }
    } else {
        return this.getYLabel(value, isAxis);
    }

};

/**
 * final check after rendering the axis labels goes here.
 * For xAxis, remove the first label if it crops
 * @param axis
 */
infChart.StockChart.prototype.afterRenderAxisLabels = function (axis) {

    /**
     *
     * For fixing issue of cropping first and last x labels checked the positions of first and last values after rendering
     * and hide those label if cropped and show all hidden labels before this logic.
     *
     * TODO ::  Need to find out a proper solution for this. Followings are the failed attempts
     * 1. Changing the positions of the cropping label - label position didn't changed
     * 2. Hide over flown labels and just showing all the labels(without keeping previous position as xPositions) before hiding cropped labels
     * - if label is previously hidden its position was (0,0) so it didn't appear in the x axis
     * 3. Set textOverflow as hidden - it didn't hide the label
     *
     * After all above failed attempts previous position of hidden labels are kept in xPosition of the tick and set those positions when showing them again.
     * IMPORTANT :: Issue(2.) of hiding labels forever happens only in zoomed charts
     */

    for (var i in axis.ticks) {
        var lbl = axis.ticks[i];
        if (lbl.xPosition) {
            lbl.label.element.style.x = lbl.xPosition.x;
            lbl.label.element.style.y = lbl.xPosition.y;
            lbl.label.show();
            lbl.xPosition = undefined;
            lbl.gridLine && lbl.gridLine.show();
        }
    }
    var tickPositions = axis.tickPositions,
        ticks = axis.ticks,
        firstLabelTime = tickPositions && tickPositions[0],
        firstTick = ticks && ticks[firstLabelTime] && ticks[firstLabelTime],
        firstTickPos = axis.toPixels(firstLabelTime),
        firstLabelSize = firstTick && firstTick.label && firstTick.label.getBBox(),
        lastLabelTime = tickPositions && tickPositions[tickPositions.length - 1],
        lastTickPos = axis.toPixels(lastLabelTime),
        lastTick = ticks && ticks[lastLabelTime] && ticks[lastLabelTime],
        lastLabelSize = lastTick && lastTick.label && lastTick.label.getBBox();

    if (axis.isXAxis) {


        var firstLabelX = firstLabelSize && (axis.labelAlign === 'center' ? firstTickPos - firstLabelSize.width / 2 :
                    axis.labelAlign === 'left' ? firstTickPos - firstLabelSize.width : firstTickPos),
            lastLabelX = lastLabelSize && (axis.labelAlign === 'center' ? lastTickPos - lastLabelSize.width / 2 :
                    axis.labelAlign === 'left' ? lastTickPos - lastLabelSize.width :
                        lastTickPos),
            labelPos;

        // Remove the first label if it crops
        if (firstTick && firstLabelX < axis.left) {

            labelPos = firstTick.label.getBBox();
            firstTick.xPosition = {
                x: labelPos.x,
                y: labelPos.y
            };

            firstTick.label && firstTick.label.hide();

        }

        // Remove the last label if it crops
        if (lastTick && lastLabelX != null && !isNaN(lastLabelX) && (lastLabelX + lastLabelSize.width) > (axis.left + axis.width)) {

            labelPos = lastTick.label.getBBox();
            lastTick.xPosition = {
                x: labelPos.x,
                y: labelPos.y
            };
            lastTick.label && lastTick.label.hide();
        }
    } else if (tickPositions.length > 1) {
        var lastLabelY = lastLabelSize && (lastTickPos - lastLabelSize.height / 2),
            firstHidden = false,
            labelY = axis.options.labels && axis.options.labels.y || 0;

        // Remove the first label if it crops
        if (firstTick && firstTick.label && firstTickPos != null && !isNaN(firstTickPos) && (firstTickPos + labelY) > axis.top + axis.height) {

            labelPos = firstTick.label.getBBox();
            firstTick.xPosition = {
                x: labelPos.x,
                y: labelPos.y
            };

            firstTick.label && firstTick.label.hide();
            firstTick.gridLine && firstTick.gridLine.hide();
            firstHidden = true;
        }

        // Remove the last label if it crops
        if ((tickPositions.length > 2 || !firstHidden) && lastTick && lastTick.label && lastLabelY < axis.top) {

            labelPos = lastTick.label.getBBox();
            lastTick.xPosition = {
                x: labelPos.x,
                y: labelPos.y
            };
            lastTick.label && lastTick.label.hide();
            lastTick.gridLine && lastTick.gridLine.hide();
        }
    }
};

//region +++++++++++++++++++++Grid Lines++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

/**
 * Set pixel interval for the normal axis (!log || !compare)
 * @param axis
 */
infChart.StockChart.prototype.setAxisPixelInterval = function (axis) {
    var iChart = this,
        mainYAxis = this.getMainYAxis();
    if (!axis.isXAxis && mainYAxis && axis.options.id == mainYAxis.options.id) {

        if (this.isLog || this.isCompare || this.isPercent) {
            // TODO ::
        } else {
            var yMin = axis.min || axis.dataMin,
                yMax = axis.max || axis.dataMax,
                maxVal = yMax,
                minVal = yMin;
            if (!isNaN(yMin) && !isNaN(yMax) && yMin != null && yMax != null) {

                var displayMin = iChart.getYLabel(yMin, false, false, true),
                    displayMax = iChart.getYLabel(yMax, false, false, true),
                    gapProp = this._getYGaps(displayMin, displayMax),
                    calculatedGap = gapProp.calculatedGap;

                this._setUseNumericSymbols(displayMin, displayMax);
                this._setDecimalDigits(displayMin, displayMax);

                if (calculatedGap != 0) {
                    this._setMinYDecimalPlaces();
                    axis.options.tickPixelInterval = calculatedGap;
                    axis.options.tickPositions = undefined; // TODO remove if necessary
                }
            }
        }
    } else if (!axis.isXAxis && axis.options.infAxisType == "indicator") {
        gapProp = infChart.indicatorMgr.getYGap(this.id, axis);
        if (gapProp && gapProp.calculatedGap != 0) {
            axis.options.tickPixelInterval = gapProp.calculatedGap;
            axis.options.tickPositions = undefined; // TODO remove if necessary
        }
    }
};

/**
 * Returns the tick positions for log and compare axis .
 * Returns undefined if normal axis since normal axis is catered from 'setAxisPixelInterval' method.
 * @param axis
 * @param min
 * @param max
 * @returns {Array.<T>}
 */
infChart.StockChart.prototype.yAxisTickPositioner = function (axis, min, max) {

    if (!axis.isXAxis && min != null && max != null) {

        var iChart = this,
            mainYAxis = this.getMainYAxis();

        if (mainYAxis && axis.options.id == mainYAxis.options.id && !isNaN(min) && !isNaN(max)) {

            var minMaxProp = this.isLog ? this.getYMinMaxBaseValue(axis, min, max) : {maxVal: max, minVal: min},
            //displayMax = minMaxProp.maxVal,
            //baseMinVal = minMaxProp.minVal,
                displayMax = iChart.getYLabel(max, false, false, true),
                displayMin = iChart.getYLabel(min, false, false, true);

            this._setUseNumericSymbols(displayMin, displayMax);
            this._setDecimalDigits(displayMin, displayMax);

            if (this.isLog || (!this.isCompare && this.isPercent)) {
                var gapProp = this._getYGaps(displayMin, displayMax),
                    avgGaps = gapProp.avgGaps,
                    mainSeries = this.getMainSeries(),
                    gap = (displayMax - displayMin) / avgGaps;

                if (gap !== 0) {
                    var gapLog = Math.floor(infChart.util.num2Log(Math.abs(gap))),
                        gapLogVal = Math.pow(10, gapLog),
                        factor = Math.round(gap / gapLogVal),
                        minMultiFactor = (gapLog < 0) ? Math.pow(10, Math.abs(gapLog)) : 1,
                        minMultiFactorLog = (gapLog < 0) ? Math.abs(gapLog) : 0,
                        minLog = Math.floor(infChart.util.num2Log(Math.abs(displayMin * minMultiFactor)) * minMultiFactor) / minMultiFactor - minMultiFactorLog,
                        minLogVal = Math.pow(10, minLog),
                        minfactor = Math.floor(displayMin / minLogVal),
                        i = 0,
                        adjustedMin,
                        tickPositions = [],
                        remainder,
                        actualGap, actualMin;

                    actualGap = gapLogVal * factor;
                    actualMin = minLogVal * minfactor;


                    remainder = (Math.floor(Math.abs(actualMin)) == 0) ? 0 : Math.abs(actualMin) % Math.floor(Math.abs(actualMin));

                    if (!this.useNumericSymbolsAlways && remainder == 0 && actualGap > 1) {
                        this.decimalDigits = 0;
                    }

                    var gridValue = actualMin;
                    adjustedMin = (actualMin < 0 && displayMax > 0) ? 0 : actualMin;

                    while (gridValue <= displayMax) {
                        i++;
                        gridValue = Math.round((adjustedMin + actualGap * i) * minMultiFactor) / minMultiFactor;
                        if (gridValue >= displayMin && (axis.height / (displayMax - displayMin)) * (displayMax - gridValue) > 10) {
                            // plotLine = this._getGridLine(gridValue, baseInitVal, baseRangeFirst);
                            // plotLines.push(plotLine);
                            tickPositions.xPush(this.getProcessedValueFromDisplayValue(mainSeries, gridValue));
                        }

                    }

                    if (adjustedMin > displayMin) {

                        i = -1;
                        actualGap = actualGap * -1;
                        gridValue = adjustedMin;

                        while (displayMin <= gridValue) {

                            i++;
                            gridValue = Math.round((adjustedMin + actualGap * i) * minMultiFactor) / minMultiFactor;

                            if (displayMin <= gridValue && (axis.height / (displayMax - displayMin)) * (displayMax - gridValue ) > 10) {
                                // plotLine = this._getGridLine(gridValue, baseInitVal, baseRangeFirst);
                                // plotLines.push(plotLine);
                                tickPositions.xPush(this.getProcessedValueFromDisplayValue(mainSeries, gridValue));
                            }
                        }
                    }

                    if (!tickPositions.length) {
                        // when there is no tick possitions add middle value as the tick position
                        gridValue = Math.round((displayMin + (displayMax - displayMin) / 2) * minMultiFactor) / minMultiFactor;
                        //plotLine = this._getGridLine(gridValue, baseInitVal, baseRangeFirst);
                        //tickPositions.xPush(plotLine.value);
                        tickPositions.xPush(this.getProcessedValueFromDisplayValue(mainSeries, gridValue));
                    }

                    this._setMinYDecimalPlaces(axis);

                    return tickPositions.sort().reverse();
                }
            }
        }
    }
};

/**
 * Returns the average gap count and calculated gap between grid lines and set decimal places related properties
 * update decimalDigits & useNumericSymbolsAlways
 * @param axis
 * @param minVal
 * @param maxVal
 * @returns {{avgGaps: number, calculatedGap: number}}
 * @private
 */
infChart.StockChart.prototype._getYGaps = function (minVal, maxVal) {
    var plotHeight = this.chart.plotBox.height, //axis.height,
        avgGaps = 10,
        calculatedGap = 0,
        maxGap = 80,
        minGap = Math.max(15, Math.ceil(plotHeight / 10)),
        initialAvgGapsCount = 10,
        initialAvgGap = Math.round(plotHeight / initialAvgGapsCount),
        minGapsCount = Math.floor(plotHeight / minGap);

    var avgGapValue;
    //calculate avgGaps and avgGapValue
    if (maxVal > 10000) {
        avgGaps = Math.floor(plotHeight / ((maxGap + minGap) / 2));
        avgGapValue = (maxVal - minVal) / avgGaps;
    } else {
        avgGapValue = (maxVal - minVal) / avgGaps;
        if (avgGapValue < 1) {
            avgGaps = Math.floor((maxVal - minVal) / (1 / (this._log2Num(this.decimalDigits)))) || 1;
        }
    }

    //calculate calculatedGap
    if (avgGaps < 10) {
        if (initialAvgGap > minGap) {
            calculatedGap = initialAvgGap;
            avgGaps = initialAvgGapsCount;
        } else {
            calculatedGap = minGap;
            avgGaps = minGapsCount
        }
    } else if (plotHeight >= (avgGaps * maxGap)) {
        calculatedGap = maxGap;
        avgGaps = Math.floor(plotHeight / maxGap);
    } else if (plotHeight >= (avgGaps * minGap)) {
        calculatedGap = Math.floor(plotHeight / avgGaps);
    } else {
        calculatedGap = minGap;
        avgGaps = minGapsCount;
    }

    return {avgGaps: avgGaps, calculatedGap: calculatedGap};
};

/**
 * set/update useNumericSymbolsAlways and useNumericSymbols
 * @param  {Number} minVal
 * @param  {Number} maxVal
 */
infChart.StockChart.prototype._setUseNumericSymbols = function (minVal, maxVal) {
    this.useNumericSymbolsAlways = false;
    this.useNumericSymbols = false;

    if (maxVal > 10000 && minVal > 10000) {
        this.useNumericSymbolsAlways = true;
    } else if (maxVal > 10000) {
        this.useNumericSymbolsAlways = false;
    }

    this.useNumericSymbols = maxVal >= 10000;
};

/**
 * set/update decimal digits
 * @param  {Number} minVal
 * @param  {Number} maxVal
 */
infChart.StockChart.prototype._setDecimalDigits = function (minVal, maxVal) {
    var plotHeight = this.chart.plotBox.height,
        avgGaps = 10,
        maxGap = 80,
        minGap = 30;
    var avgGapValue;

    if (maxVal > 10000) {
        // This is a temperory solution need to get actual gaps set by highcharts for a correct solution
        avgGaps = this._getYGaps(minVal, maxVal).avgGaps; // IMPORTANT :: do not use this for max values under 10000 since decimalDigits are used there
        // avgGaps = Math.floor(plotHeight / (maxGap - minGap));
    }

    this.temperoryDisableNumericSymbols = false;
    avgGapValue = (maxVal - minVal) / avgGaps;

    if (avgGapValue < 1) {
        if (avgGapValue < 0.0000000001) {
            this.decimalDigits = Math.ceil(Math.abs(this._num2Log(Math.abs(minVal)))) + 5;
        } else {
            this.decimalDigits = Math.ceil(Math.abs(this._num2Log(Math.abs(avgGapValue))));
        }
    } else {
        var maxLog = Math.floor(this._num2Log(maxVal)),
            gapLog = Math.floor(this._num2Log(avgGapValue));
        if (maxVal > 10000 && minVal > 10000) {

            if (avgGapValue < 100) {
                this.temperoryDisableNumericSymbols = true;
            } else {
                this.decimalDigits = maxLog - gapLog;
            }
        } else {
            if (maxVal > 10000) {
                if (avgGapValue < 100) {
                    this.temperoryDisableNumericSymbols = true;
                } else {
                    this.decimalDigits = maxLog - gapLog;
                }
            } else {
                this.decimalDigits = 0;
            }
        }
    }


};

/**
 * Get plot line config for given grid value with given initial base value and initial base value of current range
 * @param gridValue
 * @param baseInitVal
 * @param baseRangeFirst
 * @returns {{label: {align: string, text: string, style: {font-size: string, fill: string, color: string}, x: number, y: number}, value: *, color: string, width: number, zIndex: number}}
 * @private
 */
infChart.StockChart.prototype._getGridLine = function (gridValue, baseInitVal, baseRangeFirst) {
    var gridLog, actualYValue, sign;
    var mainSeries = this.getMainSeries(),
        compareValue = this._getSeriesCompareValue(mainSeries);

    /* if (this.isCompare) {
     if (this.isLog) {
     gridLog = this._num2Log(gridValue) - compareValue;
     } else {
     if (this.isPercent) {
     /!*actualYValue = ((gridValue + baseRangeFirst) / 100 + 1) * baseInitVal;
     sign = (actualYValue < 0) ? -1 : 1;*!/
     gridLog = gridValue; ///((Math.abs(actualYValue) / baseInitVal - 1) * 100) - mainSeries.compareValue * sign;
     }
     else {
     gridLog = gridValue;
     }
     }
     }
     else if (this.isPercent) {
     //actualYValue = ((gridValue + baseRangeFirst) / 100 + 1) * baseInitVal;
     gridLog = gridValue; //(this._num2Log(actualYValue) / this._num2Log(baseInitVal) - 1) * 100;
     }
     else {
     gridLog = this._num2Log(gridValue);
     }*/

    gridLog = this.getSeriesProcessedValue(mainSeries, gridValue);

    /* var postFix = (this.isPercent) ? '%' : '';
     var dp = (gridValue > 1000) ? 0 : 4;
     var numArr = gridValue.toFixed(dp).split('.');
     dp = ( numArr.length > 1) ? (parseInt(numArr[1]) == 0) ? 0 : dp : dp;
     var ret = infChart.util.formatNumber(gridValue, dp, '.', infChart.util.getThousandSeparator());
     ret = numArr[0].replace(/[0]+$/, '');*/
    var label = this.formatYValue(gridValue, this.isPercent);
    var gridLineWidth = (this.yGridLineWidth == 0) ? 0.00001 : 1;

    return {
        "label": {
            align: "right",
            text: label,
            style: {

                "font-size": "11px",
                "fill": Highcharts.theme && Highcharts.theme.yAxis.labels.style.color,
                "color": Highcharts.theme && Highcharts.theme.yAxis.labels.style.color
            },
            x: 28,
            y: 4
        },
        "value": gridLog,
        "color": Highcharts.theme && Highcharts.theme.yAxis.gridLineColor,
        "width": gridLineWidth,
        "zIndex": 1,
        "infType": "gridLine"
    };
};

/**
 * set grid type
 * @param {('all'|'horizontal'|'vertical'|'none'} type
 * @param {boolean} redraw
 * @param {boolean} isPropertyChange
 */
infChart.StockChart.prototype.setGridType = function (type, redraw, isPropertyChange) {

    if (typeof redraw === 'undefined') {
        redraw = true;
    }

    this.gridType = type;
    var xgridLineWidth = 1,
        ygridLineWidth = 1,
        customXgridWidth = this.chart.options.xAxis[0].gridLineWidth > 0 ? this.chart.options.xAxis[0].gridLineWidth : undefined,
        customYgridWidth = this.chart.options.yAxis[0].gridLineWidth > 0 ? this.chart.options.yAxis[0].gridLineWidth : undefined,
        gridLineWidth = 1;

    if (this.xGridLineWidth || this.yGridLineWidth) {
        gridLineWidth = this.xGridLineWidth ? this.xGridLineWidth : this.yGridLineWidth;
    }

    switch (type) {
        case "all":
            xgridLineWidth = gridLineWidth;
            ygridLineWidth = gridLineWidth;
            break;
        case "horizontal":
            xgridLineWidth = 0;
            ygridLineWidth = gridLineWidth;
            break;
        case "vertical":
            xgridLineWidth = gridLineWidth;
            ygridLineWidth = 0;
            break;
        case "none":
            xgridLineWidth = 0;
            ygridLineWidth = 0;
            break;
        default:
            break;
    }

    this.yGridLineWidth = ygridLineWidth;
    this.xGridLineWidth = xgridLineWidth;

    var mainSeries = this.getMainSeries();

    if (mainSeries && mainSeries.xAxis) {

        var seriesId = mainSeries.options.id;
        var rightPanel = this._getSettingsPanel();
        var activeGridLineWidth;

        if(type == "none") {
            activeGridLineWidth = 0;
        } else {
            activeGridLineWidth = gridLineWidth;
        }

        if(rightPanel){
            infChart.structureManager.settings.setActiveGridLineWidth(rightPanel, this.chartId, activeGridLineWidth);
        }

        mainSeries.xAxis.update({
            gridLineWidth: this.xGridLineWidth
        }, false);
        var yAxis = this.getMainYAxis();
        this.updateYAxis(yAxis, {
            gridLineWidth: this.yGridLineWidth
        }, !this.isFirstLoadInprogress() && redraw);
    }
    if (isPropertyChange) {
        this._onPropertyChange("grid");
    }

    this.toggleGridSettingPanel();
};

/**
 * xAxis Tick positioner
 * @param xAxis
 * @param min
 * @param max
 * @returns {Array}
 */
infChart.StockChart.prototype.xAxisTickPositioner = function (xAxis, min, max) {

    var ordinalPositions = xAxis.ordinalPositions,
        tickPositions = [],
        i,
        iLen;

    if (this.period == "M_1" && this.interval == "D") {

        if (ordinalPositions && ordinalPositions.length > 1 && (max - min) > Highcharts.timeUnits.day) {
            var labelOptions = xAxis.options.labels,
                axisOptions = xAxis.options,
                axisFormats = axisOptions.dateTimeLabelFormats,
                tickVal,
                labelVal,
                tickWidth = Math.floor(xAxis.width / (ordinalPositions.length - 1)),
                labelWidth = 0,
                accumilatedWidth = 0,
                label,
                prevTick;

            for (i = 0, iLen = ordinalPositions.length; i < iLen && accumilatedWidth < xAxis.width; i++) {

                tickVal = ordinalPositions[i];
                prevTick = tickPositions.length == 0 ? undefined : tickPositions[tickPositions.length - 1];
                if (!prevTick || (tickVal - prevTick) >= Highcharts.timeUnits.day) {
                    labelVal = infChart.util.formatDate(tickVal, this._getXAxisLabelFormat(axisFormats, tickVal, prevTick, !prevTick));

                    /* Create a label to calculate the width for the text and destroy it afterwards */
                    label = xAxis.chart.renderer.text(
                        labelVal,
                        0,
                        0,
                        false
                    ).css(labelOptions.style).add(xAxis.labelGroup);

                    labelWidth = label.element.clientWidth + 2;
                    label.destroy();

                    if (accumilatedWidth == 0 || accumilatedWidth < (tickWidth * (i) - labelWidth / 2)) {

                        if (accumilatedWidth && tickPositions.length > 1 && accumilatedWidth > tickWidth * i - labelWidth / 2) {
                            tickPositions[tickPositions.length - 1] = tickVal;
                        } else {
                            tickPositions.xPush(tickVal);
                        }

                        accumilatedWidth = (i == 0) ? labelWidth : tickWidth * i + labelWidth / 2;
                    }
                }
            }
            if (tickPositions.length <= 2) {
                tickPositions = undefined;
            }
            return tickPositions;
        }

    } else if (ordinalPositions && this.interval == "D") {
        /* TODO :: implement on request
         if( xAxis.width/( ordinalPositions.length - 1 ) >  60 ) {
         return ordinalPositions;
         } else {
         var factor = Math.ceil(60/(xAxis.width/( ordinalPositions.length - 1 )));
         for(i=0, iLen = ordinalPositions.length; i< iLen; i += factor) {
         tickPositions.push(ordinalPositions[i]);
         }
         return tickPositions;
         }*/

    }
};

//endregion +++++++++++++++++++++++ end of Grid Line +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//endregion ========================== end of Axis =====================================================================

//region =====================Template Saving===========================================================================

infChart.StockChart.prototype.destroy = function (properties) {
    this.destroying = true;
    this._destroyNoDataLabel();

    if (this.rangeSelector) {
        this.fromDatePicker.remove();
        this.toDatePicker.remove();
        if (this.rangeSelectorEl) {
            this.rangeSelectorEl.remove();
        }
    }
    infChart.util.forEach(this.settingsPopups, function (i, popup) {
        popup.remove();
    });

    this.removeAllIndicators(false);
    // legend of the series(compare symbols and indicators need to be removed  if destroy is called for loading another template.
    infChart.structureManager.legend.cleanLegendContainer(this.id);
    if (this.mouseWheelController) {
        this.mouseWheelController.destroy();
    }

    if (this.updateTicksTimer) {
        clearTimeout(this.updateTicksTimer);
    }
    if (this.resizeTimer) {
        clearTimeout(this.resizeTimer);
    }

    this._fireEventListeners("destroy", []);

    this.chart && this.chart.destroy();

    this.destroyed = true;
    this.chart = null;
    this.container = undefined;
    this.symbol = null;
    this.chartId = null;
    //infChart.manager.removeChart(this.id);
    this.destroying = false;
};

/**
 * set volume
 * @param {boolean} enabled - enable/disable
 * @param {boolean} propertyChange - fire property change
 * @param {boolean | undefined} redraw - redraw chart
 */
infChart.StockChart.prototype.setVolume = function (enabled, propertyChange, redraw) {
    if (typeof redraw === 'undefined') {
        redraw = true;
    }
    var toolbarConfig = this.settings.toolbar.config;
    var indicatorType = toolbarConfig && toolbarConfig.volume && toolbarConfig.volume.type ? toolbarConfig.volume.type : "VOLUME";
    return this.toggleSingletonIndicatorByType(indicatorType, propertyChange, enabled, redraw);
};

/**
 * set bid ask history
 * @param {boolean} enabled - enable/disable
 * @param {boolean} propertyChange - fire property change
 * @param {boolean | undefined} redraw - redraw chart
 */
infChart.StockChart.prototype.setBidAskHistory = function (enabled, propertyChange, redraw) {
    if (typeof redraw === 'undefined') {
        redraw = true;
    }
    var toolbarConfig = this.settings.toolbar.config;
    var indicatorType = toolbarConfig && toolbarConfig.bidAskHistory && toolbarConfig.bidAskHistory.type ? toolbarConfig.bidAskHistory.type : "BAH";
    return this.toggleSingletonIndicatorByType(indicatorType, propertyChange, enabled, redraw);
};

/**
 * set spread
 * @param {boolean} enabled - enable/disable
 * @param {boolean} propertyChange - fire property change
 * @param {boolean | undefined} redraw - redraw chart
 */
infChart.StockChart.prototype.setSpread = function (enabled, propertyChange, redraw) {
    var isSpreadEnabel = false;
    if (typeof redraw === 'undefined') {
        redraw = true;
    }
    var toolbarConfig = this.settings.toolbar.config;
    var indicatorType = toolbarConfig && toolbarConfig.spread && toolbarConfig.spread.type ? toolbarConfig.spread.type : "SPREAD";
    isSpreadEnabel = this.toggleSingletonIndicatorByType(indicatorType, propertyChange, enabled, redraw);
    if (this._isToolbarEnabled()) {
        infChart.toolbar.setVisibility(this.id, 'spread', this.compareSymbols.count > 0);
    }
    return isSpreadEnabel;
};

//infChart.StockChart.prototype.isBidAskEnabled = function () {
//    return this.bidAskHistory;
//};

infChart.StockChart.prototype._isSingletonIndicator = function (indicatorType) {
    return infChart.indicatorMgr.isSingletonIndicator(indicatorType);
};

/**
 * toggle singleton indicator
 * @param {string} indicatorType - type
 * @param {boolean} enabled - enable/disable
 * @param {object} config - config object
 * @param {boolean} redraw - redraw chart
 * @param {boolean} propertyChange - fire property change
 * @param {string} controlName - set toolbar
 */
infChart.StockChart.prototype._toggleSingletonIndicator = function (indicatorType, enabled, config, redraw, propertyChange, controlName) {
    var indicator = undefined;
    if (infChart.indicatorMgr) {
        indicator = infChart.indicatorMgr.getSingletonIndicator(this.id, indicatorType);
    }

    if (enabled) {
        if (controlName && this._isToolbarEnabled()) {
            infChart.toolbar.setSelectedControls(this.id, controlName, true);
        }
        if (!indicator) {
            this.addIndicator(indicatorType, config, redraw, propertyChange);
            if(indicatorType === 'BAH') {
                if (this.tooltip) {
                    this.updateTooltipToLastPoint(true);
                    this.resizeChart();
                }
            }
        }
    } else {
        if (controlName && this._isToolbarEnabled()) {
            infChart.toolbar.setSelectedControls(this.id, controlName, false);
        }
        if (indicator) {
            this.removeIndicator(indicator, propertyChange);
            if(indicatorType === 'BAH') {
                if (this.tooltip) {
                    this.updateTooltipToLastPoint(true);
                    this.resizeChart();
                }
            }
        }
    }
};

/**
 * Enable / disable history
 * @param enabled
 */
infChart.StockChart.prototype._setHistory = function (enabled) {
    if (!enabled && this.chart.options.navigator.enabled) {
        this.chart.options.navigator.height = this.settings.config.navigatorHeight ? this.settings.config.navigatorHeight : infChart.util.getNavigatorHeight(this.chart.chartHeight, this.chart.options);
        this._toggleNavigator(false);
    } else if(enabled && !this.chart.options.navigator.enabled) {
        this.chart.options.navigator.enabled = true;
        this._toggleNavigator(false);
    } else if(!enabled && !this.chart.options.navigator.enabled) {
        this.chart.options.navigator.enabled = true;
        this._toggleNavigator(false);
    }
};

/**
 * Enable / disable history
 * @param enabled
 * @deprecated
 */
infChart.StockChart.prototype.setChartMode = function (type, enabled) {

    if (enabled) {
        if (type == 'log') {
            if (this.isPercent) {
                this.isPercent = false;
                type = "percentToLog";
                if (this._isToolbarEnabled()) {
                    infChart.toolbar.setSelectedControls(this.id, 'value', this.isPercent, 'percent');
                }
            }
        } else if (type == 'percent') {
            if (this.isLog) {
                this.isLog = false;
                type = "logToPercent";
                if (infChart.toolbar) {
                    infChart.toolbar.setSelectedControls(this.id, 'value', this.isLog, 'log');
                }
            }
        }
        this.setChartDataMode(type, true);
        if (this._isToolbarEnabled()) {
            infChart.toolbar.setSelectedControls(this.id, 'value', true, type);
        }

    } else {
        //when chart mode is normal, no need to set chart data mode.
        if (this.isCompare || this.isLog || this.isPercent) {
            if (type == 'log') {
                this.setChartDataMode("logToNormal", true);
            } else if (type == 'percent') {
                this.setChartDataMode("percentToNormal", true);
            } else {
                this.setChartDataMode("normal", true);
            }
        }
        if (this._isToolbarEnabled()) {
            infChart.toolbar.setSelectedControls(this.id, 'value', false, type);
        }

    }
};

infChart.StockChart.prototype.setProviderProperties = function (providerProperties) {
    this.provider = providerProperties;
    if (providerProperties.type === 'WEBFG') {
        this.useGrouping = false;
    }
};

infChart.StockChart.prototype.updateProperties = function (properties, setDefaultChartSettings) {
    var that = this;
    var mainSeries = that.getMainSeries();
    var mainSeriesId = mainSeries.options.id;

    if (that.hasLastLine) {
        that._removeLastLine(true);
    }

    if (that.hasPreviousCloseLine) {
        that._removePreviousCloseLine(false, true);
    }

    infChart.util.forEach(that.compareSymbols.idMap, function (id, symbol) {
        that.removeCompareSymbol(symbol, false);
    });

    that.removeAllIndicators(false);

    infChart.themeManager.resetMainSeriesColors(that._getSeriesProperties(mainSeries));

    if (this.settingsPopups[mainSeriesId]) {
        this.settingsPopups[mainSeriesId].remove();
        delete this.settingsPopups[mainSeriesId];
    }
    that.seriesColorOptions = {};
    that._setProperties(properties, setDefaultChartSettings);
    if (properties.mainSeriesOptions) {
        that._setSeriesProperties(mainSeries, properties.mainSeriesOptions);
    }
    that._loadSettingWindow(!that.isRightPanelOpen(), {'seriesId': mainSeriesId});

    //reset user extremes
    that.defaultXAxisExtremes = undefined;
    that.resetXAxisExtremesToDefault(false);
    that.resetYAxisExtremes(false);

    that._loadHistory(properties.compareSymbols, properties.indicators, properties.drawings, properties.flags, undefined, properties.range, undefined, properties.noData, properties.compareSeriesOptions);
};

infChart.StockChart.prototype._setProperties = function (chartProperties, setDefaultChartSettings) {
    this.interval = chartProperties.interval;
    this.pinInterval = chartProperties.pinInterval;
    this.period = chartProperties.period;
    this.customGridLineColorEnabled = chartProperties.customGridLineColorEnabled;
    this.backgroundColor = chartProperties.backgroundColor;
    this.chartBackgroundColor = chartProperties.chartBackgroundColor;
    this.chartBgTopGradientColor = chartProperties.chartBgTopGradientColor;
    this.chartBgBottomGradientColor = chartProperties.chartBgBottomGradientColor;
    this.backgroundType = chartProperties.backgroundType;
    this.backgroundColorOpacity = chartProperties.backgroundColorOpacity;
    this.chartBgTopGradientColorOpacity = chartProperties.chartBgTopGradientColorOpacity;
    this.chartBgBottomGradientColorOpacity = chartProperties.chartBgBottomGradientColorOpacity;

    if(setDefaultChartSettings){
        var theme = infChart.themeManager.getTheme();
        infChart.commandsManager.clearFromCommandStacks(this.id, undefined, "undo");
        infChart.commandsManager.clearFromCommandStacks(this.id, undefined, "redo");
        this.setGridType("none", true);
        this._onPropertyChange("gridType", "none", true);
        this.setChartBackgroundColor(theme.chart.backgroundColor, theme.chart.backgroundOpacity);
        this.setChartBackgroundColor(theme.chart.backgroundColor);
        this.customGridLineColorEnabled = false;
        this.chartBackgroundColor = theme.chart.backgroundColor;
        this.chartBgTopGradientColor = theme.chart.chartBgTopGradientColor;
        this.chartBgBottomGradientColor = theme.chart.chartBgBottomGradientColor;
    }
    else{
        if(chartProperties.gridSettings){
            this.setGridLineColor(chartProperties.gridSettings.xGridLineColor, chartProperties.gridSettings.yGridLineColor);
            this.setGridLineWidth(chartProperties.gridSettings.xGridLineWidth, chartProperties.gridSettings.yGridLineWidth);
        }

        if (this.backgroundType == "gradient") {
            this.setGradientChartBackgroundColor(chartProperties.chartBgTopGradientColor, chartProperties.chartBgBottomGradientColor, chartProperties.chartBgTopGradientColorOpacity, chartProperties.chartBgBottomGradientColorOpacity);
        }
        else {
            this.setChartBackgroundColor(chartProperties.backgroundColor, chartProperties.backgroundColorOpacity);
        }
        this.setGridType(chartProperties.grid, false);
    }

    this.isManualPeriod = true;
    this.isManualInterval = true;

    this.type = chartProperties.type;
    this.setChartStyle(chartProperties.type, false, false);

    this.isLog = chartProperties.isLog;
    this.isPercent = chartProperties.isPercent;

    this._setMinMax(chartProperties.minMax);
    //    this.minMax.enabled = chartProperties.minMax;

    this.hasLastLine = chartProperties.last;
    this.hasLastLineForCompareSymbols = chartProperties.lastLineForCompareSymbols;
    this.hasPreviousCloseLine = chartProperties.preClose;
    this.disableNumericSymbols = chartProperties.disableNumericSymbols;

    if (chartProperties.crosshair != this.crosshair.type) {
        this.setCrosshair(chartProperties.crosshair);
    }

    if (this.tooltip != chartProperties.tooltip) {
        this.toggleToolTip();
    } else {
        this.setToolTipOptions();
    }

    if (chartProperties.news) {
        this.toggleNews()
    }
    if (chartProperties.flags) {
        this.flagTypes = chartProperties.flags;
        this.toggleFlags();
    }

    if (chartProperties.extremes) {
        this.extremes = chartProperties.extremes;
    }

    this._setHistory(chartProperties.navigator);

    this.volume = chartProperties.volume;
    this.orderBookHistory = chartProperties.orderBookHistory;
    this.regularIntervalsOnUpdate = chartProperties.regularIntervalsOnUpdate;
    this.fixedIntervalOnPeriodChange = chartProperties.fixedIntervalOnPeriodChange;
    //this.maxPeriodOnIntervalChange = chartProperties.maxPeriodOnIntervalChange;
    this.setMaxAvailablePeriod = chartProperties.setMaxAvailablePeriod;
    // used to calculate the max data count for the first time since there is no data to show the yAxis(yAxis width (margin right od the chart )) needed in the calculation
    //this.marginRight = chartProperties.marginRight;

    //if (infChart.depthManager) {
    //    var resizeRequired = infChart.depthManager.setProperties(this.id, infChart.structureManager.getContainer(this.getContainer(), 'chartContainer'), chartProperties.depth);
    //    if (resizeRequired) { //&& !this.isFirstLoadInprogress()
    //        this.resizeChart();
    //    }
    //}

    this.bidAskHistory = chartProperties.bidAskHistory;
    this.spread = chartProperties.spread && chartProperties.compareSymbols && chartProperties.compareSymbols.length > 0;

    if (this._isToolbarEnabled()) {
        infChart.toolbar.setDefaultValues($(this.getContainer()), chartProperties);
    }

    var isRightPanelOpened = this.isRightPanelOpen();
    if ((chartProperties.rightPanel && !isRightPanelOpened) || (!chartProperties.rightPanel && isRightPanelOpened)) {
        this.toggleRightPanel(this.getContainer, false);
    }
};

infChart.StockChart.prototype.getProperties = function () {
    var indicators = [], compareSymbols = [], compareSeriesOptions = [], iChart = this, drawings = [], properties, series;

    //if (infChart.indicatorMgr) {
    //    infChart.util.forEach(infChart.indicatorMgr.getIndicators(that.id), function (i, ind) {
    //        indicators.xPush(ind.getProperties());
    //    });
    //}

    infChart.util.forEach(this.compareSymbols.symbols, function (i, symbol) {
        series = iChart.chart && iChart.chart.get(iChart.getCompareSeriesId(symbol));
        compareSymbols.xPush(symbol);
        compareSeriesOptions.xPush(iChart._getSeriesProperties(series));
    });

    properties = {
        period: this.period,
        interval: this.interval,
        pinInterval: this.pinInterval,
        type: this.type,
        isCompare: this.isCompare,
        isLog: this.isLog,
        isPercent: this.isPercent,
        volume: this.volume,
        indicators: indicators,
        compareSymbols: compareSymbols,
        compareSeriesOptions: compareSeriesOptions,
        mainSymbol: this.symbol,
        mainSeriesOptions: infChart.themeManager.getChangedSeriesThemeColors(iChart._getSeriesProperties(this.getMainSeries()), this.getMainSeries().type),
        crosshair: (this.crosshair.enabled) ? this.crosshair.type : 'none',
        minMax: this.minMax.enabled,
        navigator: this.isHistoryEnabled(),
        last: this.hasLastLine,
        lastLineForCompareSymbols: this.hasLastLineForCompareSymbols,
        preClose: this.hasPreviousCloseLine,
        tooltip: this.tooltip,
        news: this.news.enabled,
        flags: this.flags.enabled,
        grid: this.gridType,
        customGridLineColorEnabled: this.customGridLineColorEnabled,
        gridSettings: {
            xGridLineColor: this.chart.options.xAxis[0].gridLineColor,
            yGridLineColor: this.chart.options.yAxis[0].gridLineColor,
            gridLineWidth: this.chart.options.yAxis[0].gridLineWidth > this.chart.options.xAxis[0].gridLineWidth  ? this.chart.options.yAxis[0].gridLineWidth : this.chart.options.xAxis[0].gridLineWidth,
            xGridLineWidth: this.chart.options.xAxis[0].gridLineWidth,
            yGridLineWidth: this.chart.options.yAxis[0].gridLineWidth
        },
        chartBackgroundColor: this.chartBackgroundColor,
        backgroundColor: this.chart.options.chart.backgroundColor,
        chartBgTopGradientColor:  this.chartBgTopGradientColor,
        chartBgBottomGradientColor: this.chartBgBottomGradientColor,
        backgroundType: typeof this.chart.options.chart.backgroundColor === 'string' ? "solid" : "gradient",
        backgroundColorOpacity: this.backgroundColorOpacity,
        chartBgTopGradientColorOpacity: this.chartBgTopGradientColorOpacity,
        chartBgBottomGradientColorOpacity: this.chartBgBottomGradientColorOpacity,

        //refreshBtn: this.settings.config.refreshBtn,
        //hideClose: this.settings.config.hideClose,
        //displayAllIntervals: this.settings.config.displayAllIntervals, // Used this property to determine whether dummy points are needed or not in place of missing intervals
        //unGroupedDataOnLoad: this.settings.config.unGroupedDataOnLoad || 0.5,
        //panToFuture: this.settings.config.panToFuture,
        //panToPast: this.settings.config.panToPast,
        //disableRangeSelector: this.settings.config.disableRangeSelector || false,
        //maxIndicatorCount: this.settings.config.maxIndicatorCount,
        //showAllHistory: this.settings.config.showAllHistory, // Used to determine whether to display all history or max zoom when changing the period
        //scalable: this.settings.config.scalable,
        //previousCloseLabelAlign: this.settings.config.previousCloseLabelAlign,
        //lastLabelAlign: this.settings.config.lastLabelAlign,
        //minYDecimalPlaces: this.settings.config.minYDecimalPlaces,
        //defaultDp: this.settings.config.defaultDp,
        //tickUpdateDelay: this.settings.config.tickUpdateDelay,
        //maxResizeDelay: this.settings.maxResizeDelay,
        //navigatorHeight: this.settings.config.navigatorHeight,
        //lineDataField: this.settings.config.lineDataField,
        isManualInterval: this.isManualInterval,
        orderBookHistory: this.orderBookHistory,
        bidAskHistory: this.bidAskHistory,
        regularIntervalsOnUpdate: this.regularIntervalsOnUpdate,
        fixedIntervalOnPeriodChange: this.fixedIntervalOnPeriodChange,  // Flag to keep the current interval fixed on period change when it is applicable
        //maxPeriodOnIntervalChange: this.maxPeriodOnIntervalChange,
        setMaxAvailablePeriod: this.setMaxAvailablePeriod,
        spread: this.spread,
        // marginRight & plotSizeX are used to calculate the max data count for the first time since there is no data to show the yAxis(yAxis width (margin right od the chart )) needed in the calculation
        marginRight: this.chart && this.chart.marginRight,
        chartWidth: this.chart && this.chart.chartWidth,
        rightPanel: this.isRightPanelOpen()
    };

    //if (infChart.depthManager) {
    //    properties.depth = infChart.depthManager.getProperties(this.id);
    //}
    //if (type == "all") {
    //    properties.drawings = drawings;
    //}

    return properties;
};

//infChart.StockChart.prototype.getTemplate = function (type) {
//    return this.getProperties(type);
//};

infChart.StockChart.prototype._getSeriesProperties = function (series) {
    if (series) {
        var cfg = this._getColorPropertiesFromOptions(series.options, series.type, series);
        cfg.infColor = this.seriesColorOptions[series.options.id];
        if (series.options.hideLegend) {
            cfg.hideLegend = series.options.hideLegend;
        }
        cfg["type"] = series.type;
        return cfg;
    }
};

/**
 * get series color properties from options
 * @param {object} options - series option
 * @param {string} type - series type
 * @param {object} series - the series
 * @param {boolean} useSeriesLineColor - use series line color if true
 * @returns {object} - color option
 */
infChart.StockChart.prototype._getColorPropertiesFromOptions = function (options, type, series, useSeriesLineColor) {
    var cfg = {
        color: options.color
    };
    cfg.lineWidth = infChart.util.isDefined(options.lineWidth) ? options.lineWidth : series.options.lineWidth;

    switch (type) {
        case 'area':
            cfg.lineColor = (useSeriesLineColor && series.options.lineColor) ? series.options.lineColor : this._getLineColor(series, type);
            //cfg.lineColor = hexColor;
            cfg.negativeColor = options.negativeColor;
            if (options.negativeFillColor) {
                cfg.negativeFillColor = options.negativeFillColor;
            }
            cfg.fillColor = options.fillColor;
            break;
        case 'line':
        case 'dash':
        case 'arearange':
        case 'step':
            cfg.lineColor = options.lineColor;
            cfg.negativeColor = options.negativeColor;
            cfg.fillOpacity = options.fillOpacity;
            break;
        case 'column':
            cfg.color = options.color;
            if (options.negativeColor) {
                cfg.negativeColor = options.negativeColor;
            }
            break;
        case 'volume':
            if (series.options.hasColumnNegative) {
                cfg.upColor = options.upColor;
                cfg.upLineColor = options.upColor;
                cfg.color = options.color;
                cfg.lineColor = options.color;
            } else {
                cfg.color = options.color;
                cfg.lineColor = options.color;
                cfg.upColor = options.color;
            }
            break;
        case 'heikinashi':
        case 'equivolume':
        case 'point':
        case 'candlestick':
        case 'ohlc':
        case 'hlc':
        case 'customCandle':
        case 'engulfingCandles':
            cfg.color = options.color;
            cfg.lineColor = options.lineColor;
            cfg.upColor = options.upColor;
            cfg.upLineColor = options.upLineColor;
            break;
        default:
            break;
    }
    return cfg;
};

infChart.StockChart.prototype._setSeriesProperties = function (series, options, redraw) {
    if (typeof redraw === 'undefined') {
        redraw = false;
    }
    this.seriesColorOptions[series.options.id] = $.extend({}, this.seriesColorOptions[series.options.id], options.infColor);
    series.update(options, redraw);
};

///**
// * @deprecated
// * @param name
// * @param type
// * @param template
// */
//infChart.StockChart.prototype.loadTemplate = function (name, type, template) {
//    infChart.manager.loadTemplate(this.id, name, type, template);
//};

//endregion =====================end of Template Saving=================================================================

//region =====================Show Min/Max==============================================================================

/**
 * Enable / disable minmax
 * @param enabled
 */
infChart.StockChart.prototype._setMinMax = function (enabled, isPropertyChange) {
    if (enabled && !this.minMax.enabled) {
        this.toggleShowMinMax(isPropertyChange);
        if (this._isToolbarEnabled()) {
            infChart.toolbar.setSelectedControls(this.id, 'minMax', true);
        }
    } else if (!enabled && this.minMax.enabled) {
        this.toggleShowMinMax(isPropertyChange);
        if (this._isToolbarEnabled()) {
            infChart.toolbar.setSelectedControls(this.id, 'minMax', false);
        }
    }
};

infChart.StockChart.prototype.updateMinMax = function () {
    if (this.minMax.enabled) {
        this._showMinMax();
    }
};

infChart.StockChart.prototype._hideMinMaxLabels = function () {
    if (this.minMax.min) {
        this.minMax.min.hide();
    }
    if (this.minMax.max) {
        this.minMax.max.hide();
    }
};

infChart.StockChart.prototype._hideMinMax = function () {
    this.minMax.enabled = false;
    this._hideMinMaxLabels();
};

infChart.StockChart.prototype._showMinMax = function () {

    var mainSeries = this.getMainSeries();
    if (!this.minMax.axisAdjusted) {
        /*mainSeries.yAxis.update({
         "startOnTick": true,
         "endOnTick": true
         }, true);*/
        this.minMax.axisAdjusted = true;
    }
    this.minMax.enabled = true;
    var minField = this.minMax.minField;
    var maxField = this.minMax.maxField;

    if (!this.minMax.min) {
        var red = infChart.util.getDefaultDownColor();
        var green = infChart.util.getDefaultUpColor();
        this.minMax.min = this.chart.renderer.label('').attr({
            "zIndex": 20,
            padding: 3,
            r: 1
        }).css({
            color: red,
            "font-size": '11px'
        }).add();

        this.minMax.max = this.chart.renderer.label('').attr({
            "zIndex": 20,
            padding: 3,
            r: 1
        }).css({
            color: green,
            "font-size": '11px'
        }).add();
    }


    var points = mainSeries.points;
    if (points && points.length > 0) {
        var dataPoint;
        /*if(this.interval == 'T'){

         var pointHValue = (points[0].high != undefined)?points[0].high : (points[0].close != undefined) ? points[0].close : points[0].y;
         var pointLValue = (points[0].low != undefined)?points[0].low : (points[0].close != undefined) ? points[0].close : points[0].y;
         if(pointHValue != undefined && pointLValue != undefined ) {
         dataPoint = {};
         dataPoint.low = this.getYLabel(pointHValue);
         dataPoint.high = this.getYLabel(pointLValue);
         }
         } else {*/
        dataPoint = this.getOHLCfromPoint(points[0]);
        //}

        if (dataPoint && dataPoint[minField] != undefined && dataPoint[maxField] != undefined) {
            var yMin = dataPoint[minField] + 1; // (points[0].close != undefined) ? points[0].close : points[0].y;
            var yMax = dataPoint[maxField] - 1; //(points[0].close != undefined) ? points[0].close : points[0].y;
            var xMin, plotXmin, plotYmin, minClose;
            var xMax, plotXmax, plotYmax, maxClose;
            var yPointValMin, minPontIndex, maxPointIndex;
            var shapeHMin, shapeHMax, shapeWidth = 0;
            var that = this;

            infChart.util.forEach(
                points, function (i, point) {
                    /*if(that.interval == 'T'){
                     var pointHValue = (point.high != undefined)?point.high : (point.close != undefined) ? point.close : point.y;
                     var pointLValue = (point.low != undefined)?point.low : (point.close != undefined) ? point.close : point.y;

                     dataPoint.low = that.getYLabel(pointHValue);
                     dataPoint.high = that.getYLabel(pointLValue);
                     }else {*/
                    dataPoint = that.getOHLCfromPoint(point);
                    //var close = (point.close != undefined) ? point.close : point.y;
                    //}
                    if (dataPoint[minField] <= yMin) {

                        minPontIndex = i;
                        yMin = dataPoint[minField];
                        xMin = point.x;
                        plotXmin = point.plotX;
                        plotYmin = (point.xPlotMin) ? point.xPlotMin : point.plotLow ? point.plotLow : point.plotY;
                        yPointValMin = plotYmin;
                        shapeHMin = (point.shapeArgs && !point.xPlotMin) ? point.shapeArgs.height : 0;
                        minClose = (point.xMinMaxKey) ? point[point.xMinMaxKey] : (point.low != undefined) ? point.low : point.y;
                        shapeWidth = point.pointWidth ? point.pointWidth : 0;
                    }
                    if (dataPoint[maxField] >= yMax) {
                        maxPointIndex = i;
                        yMax = dataPoint[maxField];
                        xMax = point.x;
                        plotXmax = point.plotX;
                        plotYmax = (point.yPlotMax) ? point.yPlotMax : (point.plotHigh) ? point.plotHigh : point.plotY;
                        shapeHMax = 15;
                        shapeWidth = point.pointWidth ? point.pointWidth : 0;
                        maxClose = (point.xMinMaxKey) ? point[point.xMinMaxKey] : (point.high != undefined) ? point.high : point.y;
                    }
                }
            );

            var y, x;
            if (xMin) {
                var minValue = infChart.util.formatNumber(yMin, mainSeries.options.dp); // this.formatYValue(yMin);//this.getYLabel(yMin);
                y = yPointValMin + shapeHMin;
                var yAxisMinPos = mainSeries.yAxis.top + mainSeries.yAxis.height - 15;
                y = (y > yAxisMinPos) ? yAxisMinPos : y;
                this.minMax.min.show().attr({
                    hAlign: 'left',
                    x: plotXmin - shapeWidth / 2,
                    y: y,
                    text: '' + minValue
                });

                x = (plotXmin < 20) ? (plotXmin < (this.chart.plotLeft - shapeWidth / 2)) ? this.chart.plotLeft : plotXmin - shapeWidth / 2 :
                    ((plotXmin + this.minMax.min.width) > (this.chart.plotLeft + this.chart.plotWidth)) ? this.chart.plotLeft + this.chart.plotWidth - this.minMax.min.width : plotXmin - this.minMax.min.width / 2;

                this.minMax.min.show().attr({
                    x: x
                });
                if (mainSeries.dataMin < minClose) {
                    var labelY = this._getLabelPosition(this.minMax.min, mainSeries, minPontIndex, false);
                    if (labelY > y) {
                        this.minMax.min.show().attr({
                            y: labelY
                        })
                    }
                }


            }

            if (xMax) {
                var maxValue = infChart.util.formatNumber(yMax, mainSeries.options.dp);// this.formatYValue(yMax);//this.getYLabel(yMax);
                y = (plotYmax < shapeHMax) ? 0 : plotYmax - shapeHMax;
                this.minMax.max.show().attr({
                    hAlign: 'left',
                    x: plotXmax - shapeWidth / 2,
                    y: y,
                    text: '' + maxValue
                });
                x = (plotXmax < 20) ? (plotXmax < (this.chart.plotLeft - shapeWidth / 2)) ? this.chart.plotLeft : plotXmax - shapeWidth / 2 :
                    ((this.minMax.max.x + this.minMax.max.width) > (this.chart.plotLeft + this.chart.plotWidth)) ? this.chart.plotLeft + this.chart.plotWidth - this.minMax.max.width : plotXmax - this.minMax.max.width / 2;

                this.minMax.max.show().attr({
                    x: x
                });
                if (mainSeries.dataMax > maxClose) {
                    var labelY = this._getLabelPosition(this.minMax.max, mainSeries, maxPointIndex, true);
                    if (labelY < y) {
                        this.minMax.max.show().attr({
                            y: labelY
                        });
                    }
                }
            }
        }
    }
};

/**
 * Return Y position of the label as label not overlap with series
 * @param label
 * @param series
 * @param xposition
 * @param isAbove
 * @returns {*}
 */
infChart.StockChart.prototype._getLabelPosition = function (label, series, xposition, isAbove) {

    function getLabelYPosition(labelDirection, searchDirection, labelWidth, labely, labelx, seriesLast) {
        var i = xposition;
        while (i != seriesLast) {
            var previousPoint = series.points[i];
            i += searchDirection;
            var point = series.points[i];
            if ((Math.abs(i - xposition) > 1 && ((labelx - point.plotX - labelWidth) * searchDirection) < 0) || ((previousPoint.plotX - labelx) * searchDirection > 0)) {
                break;
            } else if (((labely - point.plotY) * labelDirection) < 0) {
                //continue;
            } else {
                var slopeToPoint = (previousPoint.plotY - point.plotY) / (previousPoint.plotX - point.plotX);
                var slopeToLabel = (previousPoint.plotY - labely) / (previousPoint.plotX - labelx);

                if (Math.abs(slopeToLabel) > Math.abs(slopeToPoint)) {
                    //continue;
                } else {
                    if ((point.plotX - labelx) * searchDirection <= 0) {
                        labely = point.plotY;
                    } else {
                        labely = point.plotY + slopeToPoint * (labelx - point.plotX);
                    }
                }
            }
        }

        return labely;
    }

    var labely = label.y + label.height;

    if (isAbove) {
        labely = label.y + label.height;
        /*Backward search for overlaps */
        labely = getLabelYPosition(1, -1, label.width, labely, label.x, 0);
        /*Forward search for overlaps */
        labely = getLabelYPosition(1, 1, label.width, labely, label.x + label.width, series.points.length - 1);
        labely = labely - label.height;

    } else {

        labely = label.y;
        /*Backward search for overlaps */
        labely = getLabelYPosition(-1, -1, label.width, labely, label.x, 0);
        /*Forward search for overlaps */
        labely = getLabelYPosition(-1, 1, label.width, labely, label.x + label.width, series.points.length - 1);
    }
    return labely;
};

//endregion =====================end of TShow Min/Max===================================================================

//region =====================Crosshair=================================================================================

infChart.StockChart.prototype.setCrosshair = function (type) {
    if (type == "none") {
        this.crosshair.enabled = false;
        this.crosshair.type = 'none';
    } else {
        type = (type) ? type : 'all';
        this.crosshair.type = type;
        this.crosshair.enabled = true;
    }
    if (this._isToolbarEnabled()) {
        infChart.toolbar.setSelectedControls(this.id, 'crosshair', this.crosshair.type);
    }
};

infChart.StockChart.prototype.isDefaultCrosshairEnabled = function (axis) {
    return this.crosshair.enabled && axis && (axis.isXAxis || (!axis.isXAxis && this.crosshair.type != 'last'));
};

infChart.StockChart.prototype.isCrosshairEnabled = function (axis) {
    return (this.chart && ((this.chart.annotations && this.chart.annotations.tradingMode) || (!this.chart.annotations || this.chart.annotations.allowZoom))) && this.crosshair.enabled;
};

infChart.StockChart.prototype.isLastCrosshair = function () {
    return this.crosshair.enabled && this.crosshair.type == 'last';
};

infChart.StockChart.prototype.updateCrosshair = function (x, y, point, yAxis, event) {
    var that = this;
    var crosshairTheme = Highcharts.theme && Highcharts.theme.crosshair || {
            lineColor: "#ffffff",
            label: {
                color: "#ffffff",
                fill: "rgba(80, 80, 80, 1.00)"
            }
        };

    if (!(y <= this.chart.plotSizeY && y >= 0 /*&& x <= this.chart.plotSizeX && x>=0*/)) {
        this.showCrosshair(false);
        return;
    }
    if (this.crosshair.type == 'all' && !(yAxis.top <= y && (yAxis.top + yAxis.height) >= y)) {
        return; // To avoid replacing main axis' crosshair label from indicator axis values
    }

    if (!that.chart.annotations.tradingMode && this.crosshair.type == 'last') {
        try {
            if (!point || point.series.options.id != "c0") {
                if (this.chart.hoverPoints && this.chart.hoverPoints.length > 0) {
                    infChart.util.forEach(this.chart.hoverPoints, function (i, val) {
                        if (val.series.options.id == "c0") {
                            point = val;
                        }
                    });
                }
                if (!point) {
                    point = this.chart.pointer.findNearestKDPoint([this.getMainSeries()], false, event);
                }
            }

            if (point && point.series.options.id == "c0") {
                var plotVal = (point.plotClose != undefined) ? point.plotClose : point.plotY;
                var labelVal = that.formatValue((( point.close != undefined ) ? point.close : point.y), that.getMainSeries().options.dp, undefined, true, false);
                if (!that.crosshair.y) {
                    that.crosshair.y = that.chart.renderer.path(['M', 0, plotVal, 'H', yAxis.width + yAxis.left])
                        .attr({
                            'stroke-width': 0.5,
                            "zIndex": 3,
                            stroke: crosshairTheme.lineColor
                        }).add();
                    that.crosshair.yLabel = that.chart.renderer.label(labelVal, null, null, "callout")
                        .attr({
                            align: "right",
                            zIndex: 20,
                            padding: 3,
                            r: 1,
                            fill: crosshairTheme.label.fill
                        })
                        .css({
                            color: crosshairTheme.label.color,
                            "font-size": '11px'
                        }).add();
                } else {
                    that.crosshair.y.show().attr({
                        d: ['M', 0, plotVal, 'H', yAxis.width + yAxis.left]
                    });
                    // that.crosshair.yLabel.show();
                }
                //var posx = yAxis.opposite ? yAxis.width + yAxis.left : 0,
                //    posy = plotVal - 10;

                this._setPositionsForCalloutLabel(that.crosshair.yLabel, labelVal, yAxis, plotVal);

            }
        }
        catch (x) {
            infChart.util.console.error(x);
        }
    }
    /* else {
     var yPx = y;
     if (!that.crosshair.yLabel) {

     /!*that.crosshair.y = that.chart.renderer.path(
     ['M', 0, yPx, 'H', that.chart.chartWidth]
     ).attr({
     "zIndex": 3,
     'stroke-width': 0.5,
     stroke: crosshairTheme.lineColor
     }).add();
     *!/
     that.crosshair.yLabel = that.chart.renderer.label('').attr({
     "zIndex": 20,
     padding: 5,
     paddingTop: 10,
     r: 1,
     fill: crosshairTheme.label.fill
     }).css({
     color: crosshairTheme.label.color,
     "font-size": '11px'
     }).add();

     } else {

     /!*that.crosshair.y.attr({
     d: ['M', 0, yPx, 'H', that.chart.chartWidth/!*, yPx*!/]
     });*!/

     var yValue = (that.chart.annotations.tradingMode) ? this.getYLabel(yAxis.toValue(y, true), false, true, true) :
     (infChart.util.isSeriesInBaseAxis(yAxis.options.id)) ? this.getYLabel(yAxis.toValue(y, true)) : this.formatYValue(yAxis.toValue(y, false), false);

     that.crosshair.yLabel.show().attr({
     hAlign: 'right',
     vAlign: 'bottom',
     x: yAxis.left + yAxis.width,
     y: y - 10,
     text: '' + yValue
     });
     }
     this.crosshair.yLabel.show().attr({
     x: yAxis.right + yAxis.width - this.crosshair.yLabel.width
     });
     }*/


};

infChart.StockChart.prototype.updateCrosshairFromToolTip = function (x, y, pointArr) {
    var that = this;
    if (this.crosshair.enabled && this.crosshair.type == 'last') {
        infChart.util.forEach(pointArr, function (i, point) {
            if (point && point.series.options.id == "c0") {
                that.updateCrosshair(x, y, point.point, point.series.yAxis);
                return;
            }
        });
    }
};

/**
 * Display/hide crosshair
 * @param {boolean} visibility - crosshair visibility to set
 */
infChart.StockChart.prototype.showCrosshair = function (visibility) {
    if (this.crosshair.y) {
        if (visibility) {
            this.crosshair.y.show();
            this.crosshair.yLabel.show();
        } else {
            this.crosshair.y.hide();
            this.crosshair.yLabel.hide();

        }
    }
};

//endregion =====================end of Crosshair===================================================================

//region ==========================Print===================================================================
///**
// * print or save chart as an image according to requested type
// * @param type
// * @param afterPrint
// */
//infChart.StockChart.prototype.exportChart = function (type, afterPrint) {
//    var _self = this;
//
//    function _exportChart() {
//        switch (type) {
//            case 'print':
//                //this.chart.print();
//                _self.printChart(afterPrint);
//                break;
//            default:
//                _self.exportChartToImage(type);
//                break;
//        }
//    }
//
//    if (infChart.util.isSafari() && infChart.util.isFullscreenMode()) {
//        _self._addFullscreenListeners("exit", _exportChart);
//        document.cancelFullScreen();
//    } else {
//        _exportChart();
//    }
//};

/**
 * export Chart as an image
 * ***since highchart's exporting doesn't work properly we use a custom method to export chart as a png***
 * @param afterPrint
 */
infChart.StockChart.prototype.printChart = function (afterPrint) {

    var chart = this.chart,
        container = chart.container,
        origDisplay = [],
        origParent = container.parentNode,
        body = document.body,
        childNodes = body.childNodes;

    if (chart.isPrinting) { // block the button while in printing mode
        return;
    }
    this.printEl = [];
    this._setElementsToChartBeforePrint();
    chart.isPrinting = true;

    //fireEvent(chart, 'beforePrint');

    // hide all body content
    infChart.util.forEach(childNodes, function (i, node) {
        if (node.nodeType === 1) {
            origDisplay[i] = node.style.display;
            node.style.display = 'none';
        }
    });

    // pull out the chart
    body.appendChild(container);

    // print
    window.focus(); // #1510
    window.print();
    var chartObj = this;

    var onClosePrintWindow = function () {
        // put the chart back in
        origParent.appendChild(container);

        // restore all body content
        infChart.util.forEach(childNodes, function (i, node) {
            if (node.nodeType === 1) {
                node.style.display = origDisplay[i];
            }
        });

        chartObj._removeElementsFromChartAfterPrint();

        if (afterPrint) {
            afterPrint.apply(chart, []);
        }

        chart.isPrinting = false;
    };
    var ua = navigator.userAgent.toLowerCase();
    var isSafari = (ua.indexOf("safari") != -1 && ua.indexOf('chrome') == -1);

    if (isSafari) {
        /* To fix the issue of printing everything in the Safari.*/
        // allow the browser to prepare before reverting
        setTimeout(function () {
            onClosePrintWindow();
        }, 1000);
    }
    else {
        onClosePrintWindow();
    }
};

/**
 * get svg without right panel
 * @returns {object} svg
 */
infChart.StockChart.prototype._getSVG = function () {
    var container = $(this.getContainer());
    var svg = container.find("svg")[0];

    if (this.isRightPanelOpen()) {
        this.toggleRightPanel();
        svg = container.find("svg")[0];
        this.toggleRightPanel();
    }

    return svg;
};

/**
 * Set HTML elements to svg before printing
 * @private
 */
infChart.StockChart.prototype._setElementsToChartBeforePrint = function () {
    var container = $(this.getContainer()),
        svg = this._getSVG(),
        svgSize = svg.getBoundingClientRect(),
        chart = this,
        y,
        x = 10;

    this.printEl = [];

    this.attachCssToSvg(svg);

    $.each(container.find("[inf-legend] [inf-series]"), function (i, ele) {
        var series = chart.chart.get($(ele).attr("inf-series"));
        if (!y) {
            y = chart.chart.legend.itemY;
        }
        if ((x + $(ele).width()) > svgSize.width) {
            x = 10;
            y += $(ele).height();
        }
        var rect = chart.chart.renderer.rect(x, 0, 5, parseInt($(ele).css('font-size')), 0).attr({
            zIndex: 10,
            fill: series.options.color
        }).add();
        var text = chart.chart.renderer.text('<span style="color:' + $(ele).css('color') + '; font-weight:lighter; padding-left:5px; "> ' + series.options.name + '</span>', x + 6, (parseInt($(ele).css('font-size')) - y)).
        attr({zIndex: 10}).add();

        chart.printEl.xPush(rect);
        chart.printEl.xPush(text);

        x += (rect.getBBox().width + text.getBBox().width + 2);
    });
    /* Set range */
    if (chart.isHistoryEnabled() && chart.chart.options.navigator.series) {
        var navigator = chart.chart.get(chart.chart.options.navigator.series.id);
        if (navigator && chart.rangeSelectorEl) {
            var textY = svgSize.height - navigator.clipBox.height + chart.fromDatePicker.height();

            var color = chart.fromDatePicker.css('color');

            chart.printEl.xPush(chart.chart.renderer.text('<span style="color:' + color + '; font-weight:lighter; padding-left:5px; "> ' + chart.fromDatePicker.val() + '</span>', 10, textY).
                attr({zIndex: 10}).add());
            chart.printEl.xPush(chart.chart.renderer.text('<span style="color:' + color + '; font-weight:lighter; padding-left:5px; "> ' + chart.toDatePicker.val() + '</span>', 10 + chart.toDatePicker.width(), textY).
                attr({zIndex: 10}).add());

        }
    }
    //add background #CCA-2968
    if (this._hasRegisteredMethod('getCustomElementsForPrint')) {
        var customElements = this.settings.registeredMethods.getCustomElementsForPrint.call(chart);
        $.each(customElements, function (i, element) {
            chart.printEl.xPush(element);
        });
    }

    this.chart.xOnUrlChange && this.chart.xOnUrlChange("");
};

/**
 * Remove attached elements and css from the chart after printing
 * @private
 */
infChart.StockChart.prototype._removeElementsFromChartAfterPrint = function () {
    var chart = this,
        container = $(this.getContainer()),
        svg = container.find("svg")[0],
        style = svg.getElementById(this.id + "svgStyle");

    /* remove elements added for image */
    infChart.util.forEach(chart.printEl, function (key, renderedObj) {
        renderedObj.destroy();
    });

    chart.printEl = [];

    chart.chart.xOnUrlChange && chart.chart.xOnUrlChange(infChart.util.getBaseURL() || "");

    if (style) {
        style.parentNode.xRemoveChild(style);
    }

};

/**
 * Attach css needed to the svg in a seperatefile
 * @param svg
 */
infChart.StockChart.prototype.attachCssToSvg = function (svg) {
    var style = document.createElement('style'),
        cssMap = infChart.util.getStylesWithCls(["inf-chart", "highcharts"]),
        cssStr = '';

    style.type = 'text/css';
    style.id = this.id + "svgStyle";

    for (var cls in cssMap) {
        if (cssMap.hasOwnProperty(cls)) {
            cssStr += " " + cssMap[cls];
        }
    }
    //region computed styles
    //uncomment this section if computed styles of the element need to be attached
    /*
     function getNodeStyle(sourceNode) {
     var computedStyle = window.getComputedStyle(sourceNode),
     styleStr = "";

     Array.from(computedStyle).forEach(function (key) {
     styleStr += ";" + key + ":" + computedStyle.getPropertyValue(key);
     });
     return styleStr;
     }

     cssStr += " svg {" + getNodeStyle(svg) + "}";*/
    //endregion
    style.innerHTML = cssStr;
    var defs = svg.getElementsByTagName("defs");

    defs && defs[0].appendChild(style);

};

/**
 * repace annotation clip-path attribute
 * @param {object} svg - svg object
 */
infChart.StockChart.prototype._replaceAnnotationClipPath = function(svg) {
    var clipPathElements = $(svg).find('g[clip-path]');
    $.each(clipPathElements, function (id, item) {
        if ($(item).attr('clip-path') !== 'none') {
            var clipPath = $(item).attr('clip-path').replace('url(','').replace(')','').replace(/\"/gi, "").split("#")[1];
            $(item)[0].setAttribute('clip-path', "url(#" + clipPath + ")");
        }
    });
};

/**
 * export the chart as binary data
 * @returns {string} - binary data
 */
infChart.StockChart.prototype.exportChartAsBinaryData = function(){
    var chart = this;

    chart.printEl = [];
    chart._setElementsToChartBeforePrint();
    var source = chart._getSVGData();
    chart._removeElementsFromChartAfterPrint();

    return window.btoa(unescape(encodeURIComponent(source)));
};

/**
 * get svg data
 * @returns {string} svg data
 */
infChart.StockChart.prototype._getSVGData = function () {
    var svg = this._getSVG();

    this._replaceAnnotationClipPath(svg);
    //get svg source.
    var serializer = new XMLSerializer();
    var source = serializer.serializeToString(svg);
    //add name spaces.
    if (!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)) {
        source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
    }
    if (!source.match(/^<svg[^>]+"http\:\/\/www\.w3\.org\/1999\/xlink"/)) {
        source = source.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
    }
    //add xml declaration
    source = '<?xml version="1.0" standalone="no"?>\r\n' + source;

    //convert svg source to URI data scheme.
    return source;
};

infChart.StockChart.prototype.exportChartToImage = function (type) {
    var chart = this;

    this.printEl = [];
    this._setElementsToChartBeforePrint();
    function removePrintEl() {
        chart._removeElementsFromChartAfterPrint();
    }

    var source, url, dataUrl, svgData, canvas, ctx, img;
    switch (type) {
        case 'svg':
            source = chart._getSVGData();
            url = dataUrl = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
            break;
        default:
            var container = $(this.getContainer());
            var svg = this._getSVG();
            var svgSize = svg.getBoundingClientRect();

            svgData = chart._getSVGData();
            canvas = document.createElement("canvas");
            canvas.width = svgSize.width * 1/(this.chart.infScaleX ? this.chart.infScaleX : 1);
            canvas.height = svgSize.height * 1/(this.chart.infScaleY ? this.chart.infScaleY : 1);

            ctx = canvas.getContext("2d");
            break;
    }

    if (infChart.util.isIE()) {
        if (!infChart.util.isIEBelow10()) {
            if (type == 'svg') {
                var blobObject = new Blob([source]);
                window.navigator.msSaveBlob(blobObject, 'chart.svg'); // The user only has the option of clicking the Save button.
            } else {
                canvg(canvas, svgData);
                infChart.util.saveCanvasAsBlob(canvas, type);
            }
            removePrintEl();
        } else {
            canvg(canvas, svgData);
            img = document.createElement("img");
            url = (type != 'svg') ? canvas.toDataURL("image/" + type) : url;
            img.onload = function () {

                if (type != 'svg') {
                    dataUrl = canvas.toDataURL("image/" + type);
                }
                removePrintEl();
                var a = $("<a>")
                    .attr("href", dataUrl).attr("target", "_blank")
                    .attr("download", "img." + type)
                    .appendTo("body");

                a[0].click();
            };
            img.setAttribute("src", url);
            /* alert('Please upgrade you browser to IE10 or above');*/
        }
    } else {

        img = document.createElement("img");
        img.onload = function () {
            if (type != 'svg') {
                ctx.drawImage(img, 0, 0);
                dataUrl = canvas.toDataURL("image/" + type);
            }
            removePrintEl();
            var a = $("<a>")
                .attr("href", dataUrl).attr("target", "_blank")
                .attr("download", "img." + type)
                .appendTo("body");

            a[0].click();
            //a.remove();
        };

        url = (type != 'svg') ? "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svgData))) : url;

        img.setAttribute("src", url);
    }
};


//endregion===================end of Print===================================================================

//region =====================Streaming=================================================================================

/**
 * Check whether given tick has valid data
 * @param tickData
 * @returns {boolean|Array}
 * @private
 */
infChart.StockChart.prototype._isValidTick = function (tickData) {
    var data = [], chartSym;
    if (this.checkEquivalentSymbols(this.symbol, tickData)) {
        data = this.data.base;
        chartSym = this.symbol;
    } else if (this._isCompareSymbol(tickData)) {
        data = this.data.compare[tickData.symbolId];
        chartSym = this.compareSymbols.symbols[tickData.symbolId];
    }

    if (!chartSym) {
        return false;
    }

    /* if (this.dataManager.isRequestInProgress(chartSym, this.interval, this.regularIntervalsOnUpdate)) {
     return false;
     }*/

    var regularIntervalsOnUpdate = this.regularIntervalsOnUpdate,
        chartTime = this.dataManager.getChartTime(tickData.dateTime, tickData.timeZoneOffset, this.interval),
        currentTickTime = (data && data[data.length - 1] && data[data.length - 1][0]) || 0,
        prevTickTime = currentTickTime && this.dataManager.getNextTickTime(currentTickTime, this.interval, true);

    return (tickData && !isNaN(tickData.close) && !isNaN(chartTime) &&
    ((currentTickTime && currentTickTime <= chartTime) || (
        !data || data.length == 0
    ) || (regularIntervalsOnUpdate && chartTime > prevTickTime)));
};

/**
 * To Update chart realtime
 * @param data format is as follows
 * {
    symbol : 'IBEX35', // symbol name
    symbolId : 'ES0SI0000005_indices_55_df', // symbol id
    close : 9500,
    dateTime : Date.UTC(2017,1,7,17,10,10),
    volume : 100
   }
 */
infChart.StockChart.prototype.addTick = function (data) {
    if (!this._isValidTick(data)) {
        console.log("Invalid Tick");
        return;
    }

    var rawData;
    if (this.checkEquivalentSymbols(this.symbol, data)) {
        rawData = this.rawData.base;
    } else if (this._isCompareSymbol(data)) {
        rawData = this.rawData.compare[data.symbolId];
    }

    var from, to;
    if(this.period === 'C' && typeof this.range !== 'undefined'){
        from = this.range.fromDate;
        to = this.range.toDate;
    }

    this.dataManager.addTick(data, from, to, this.interval, this.regularIntervalsOnUpdate, rawData, this.id);

    infChart.util.console.debug(this, " addTick >>" + data.symbolId);

    var chartObj = this;
    if (!chartObj.updateTicksTimer) {
        //if (chartObj.data.base.length > 0) {
        if (chartObj.chart && !chartObj.isUserInteractionInprogress()) {
            chartObj.updateTicksTimer = setTimeout(function () {
                if (!chartObj.isUserInteractionInprogress()) {
                    try {
                        chartObj._updateTicks();
                    }
                    catch (err) {
                        infChart.util.console.error("_updateTicks", err, chartObj.chart.renderTo.id);
                    }
                    finally {
                        chartObj.updateTicksTimer = undefined;
                    }
                } else {
                    chartObj.updateTicksRequiredAfterUserInteraction = true;
                }

            }, chartObj.settings.config.tickUpdateDelay);
        } else {
            chartObj.updateTicksRequiredAfterUserInteraction = true;
        }
        //}
        // chartObj.updateTicksTimer = setTimeout(function () {
        //     if (chartObj.data.base.length > 0) {
        //         if (chartObj.chart && !chartObj.isUserInteractionInprogress()) {
        //             console.debug("chartObj.chart.mouseIsDown :" + chartObj.chart.mouseIsDown + " , chartObj.chart.activeAnnotation :" + chartObj.chart.activeAnnotation);
        //             chartObj._updateTicks();
        //         } else {
        //             chartObj.updateTicksRequiredAfterUserInteraction = true;
        //         }
        //     }
        //     chartObj.updateTicksTimer = undefined;
        // }, chartObj.settings.config.tickUpdateDelay);
    }
};

infChart.StockChart.prototype.isUserInteractionInprogress = function () {
    return (this.chart && this.chart.activeAnnotation && this.chart.mouseIsDown != "mousedown") || this.chart.annotationChangeInProgress || this.chart.isChartDragging;
};

infChart.StockChart.prototype.onAnnotationRelease = function () {
    if (this.updateTicksRequiredAfterUserInteraction) {
        this._updateTicks();
        this.updateTicksTimer = undefined;
    }
};

infChart.StockChart.prototype.onDocumentMouseUp = function () {
    if (this.updateTicksRequiredAfterUserInteraction) {
        this._updateTicks();
        this.updateTicksTimer = undefined;
    }
};

/**
 * Check whether given two symbols are equivalent
 * @param {symbol} symbol1
 * @param {symbol} symbol2
 * @returns {boolean}
 */
infChart.StockChart.prototype.checkEquivalentSymbols = function (symbol1, symbol2) {
    return symbol1 && symbol2 && symbol1.symbolId === symbol2.symbolId;
};

/**
 * check if symbol is a compare symbol
 * @param {symbol} symbol
 * @returns {boolean}
 */
infChart.StockChart.prototype._isCompareSymbol = function (symbol) {
    var status = false, self = this;
    for (var symbolId in self.compareSymbols.symbols) {
        if (self.compareSymbols.symbols.hasOwnProperty(symbolId) && self.checkEquivalentSymbols(self.compareSymbols.symbols[symbolId], symbol)) {
            status = true;
            break;
        }
    }
    return status;
};

infChart.StockChart.prototype._getSymbols = function (addLastTime) {
    var that = this,
        sym,
        symbols = [this.symbol],
        compareSyms = this.compareSymbols.symbols,
        symbolData,
        symbolDataMap,
        lastIdx,
        lastTick,
        prevLast,
        prevLastTime
        ;
    for (var sk in compareSyms) {
        if (compareSyms.hasOwnProperty(sk)) {
            sym = compareSyms[sk];
            symbolData = that.data.compare[sym.symbolId] || [];
            symbolDataMap = that.dataMap.compare[sym.symbolId];
            lastIdx = symbolData.length - 1;
            lastTick = symbolData[lastIdx];
            prevLast = symbolData[lastIdx - 1];
            prevLastTime = prevLast && prevLast[0];

            symbols.push($.extend(compareSyms[sk], {lastTime: lastTick && lastTick[0], prevLastTime: prevLastTime}));
        }
    }
    return symbols;
};

/**
 * Update Recently added ticks to the chart
 */
infChart.StockChart.prototype._updateTicks = function () {
    this.updateTicksRequired = false;
    this.updateTicksRequiredAfterUserInteraction = false;

    var that = this,
        lastIdx = that.data.base.length - 1,
        lastTick = that.data.base[lastIdx],
        prevLast = that.data.base[lastIdx - 1],
        prevLastTime = prevLast && prevLast[0],
        ticks = this.dataManager.getNewTicks(prevLastTime || lastTick && lastTick[0], this.interval, this._getSymbols(true), this.regularIntervalsOnUpdate),
        baseSymbolTicks = [],
        compareSymbolTicks = {},
    // extremes = this.getRange(),
        i,
        iLen,
        temptick,
        lastTime = lastTick && lastTick[0] || 0,
        hasUpdates = false,
        tickInterval = this.intervalOptions[this.interval] && this.intervalOptions[this.interval].time,
        symbolData,
        symbolDataMap,
        redrawRequired,
        startingLength,
        prevSeriesLast;

    console.debug(this.id + "update ticks : prevLastTime || lastTick && lastTick[0] ::" + new Date(prevLastTime || lastTick && lastTick[0]));

    if (ticks) {
        var isBaseSymbolUpdated = false,
            updatedTimes = {},
            oneAdded = false;

        infChart.util.forEach(ticks, function (symbol, val) {
            var data = val.data,
                isBase = false;
            symbolData = undefined;
            symbolDataMap = undefined;
            oneAdded = false;

            if (that.symbol.symbolId == data.symbol) {
                isBase = true;
                if (that.data.base) {

                    symbolData = that.data.base;
                    symbolDataMap = that.dataMap.base;

                }
            }
            else {
                symbolData = that.data.compare[data.symbol];
                symbolDataMap = that.dataMap.compare[data.symbol];
                if (symbolData) {
                    lastIdx = symbolData.length - 1;
                    lastTick = symbolData[lastIdx];
                    prevLast = symbolData[lastIdx - 1];
                    prevLastTime = prevLast && prevLast[0];

                    compareSymbolTicks[data.symbol] = [];
                }
            }

            if (symbolData) {

                startingLength = symbolData.length;

                prevSeriesLast = lastTime = lastTick && lastTick[0] || 0;

                for (i = 0, iLen = val.newTicks.length; i < iLen; i++) {

                    //oneAdded = false;

                    if (prevLastTime == val.newTicks[i]) {
                        continue;
                    }

                    redrawRequired = true;

                    var lastTimeNextTick = that.dataManager.getNextTickTime(lastTime, that.interval);
                    console.debug(that.id + "update ticks : symbol :: " + data.symbol + ", val.newTicks[i] ::" + new Date(val.newTicks[i]) + "  lastTime::" + new Date(lastTime) + "  lastTimeNextTick :: " + new Date(lastTimeNextTick) + "  tickInterval : " + tickInterval + "  (lastTime - val.newTicks[i])::" + (lastTime - val.newTicks[i]));

                    if (!that.regularIntervalsOnUpdate /*&& !that.dataMap.base[val.newTicks[i]]*/ &&
                        ((lastTime >= val.newTicks[i] && (lastTime - val.newTicks[i]) < tickInterval) ||
                        (lastTime < val.newTicks[i] && (val.newTicks[i] - lastTimeNextTick) < tickInterval) ||
                        (val.newTicks[i] == lastTimeNextTick))) {

                        console.debug(that.id + "update ticks :replaced");
                        symbolData.splice(lastIdx, 1);
                        delete symbolDataMap[lastTime];
                        lastIdx--;
                        lastTick = symbolData[lastIdx];
                        lastTime = lastTick && lastTick[0] || 0;
                    }

                    if (!data.dataMap[val.newTicks[i]]) {
                        continue; // TODO :: check why this is undefined.
                    }

                    if (!symbolDataMap[val.newTicks[i]] && lastTime < val.newTicks[i]) {

                        isBaseSymbolUpdated = true;
                        hasUpdates = true;
                        temptick = data.dataMap[val.newTicks[i]].slice();
                        symbolData.xPush(temptick);
                        if (isBase) {
                            baseSymbolTicks.xPush(temptick);
                        } else {
                            compareSymbolTicks[data.symbol].push(temptick);
                        }
                        symbolDataMap[val.newTicks[i]] = temptick;
                        lastTime = val.newTicks[i];
                        lastIdx = symbolData.length - 1;
                        //lastIdx = baseSymbolTicks.length - 1; //TODO :: check why?
                        oneAdded = true;
                        updatedTimes[lastTime] = {isUpdated: false};

                    } else if (lastTime == val.newTicks[i]) {
                        isBaseSymbolUpdated = true;
                        updatedTimes[lastTime] = {isUpdated: !oneAdded};
                        temptick = data.dataMap[val.newTicks[i]].slice();

                        symbolData[lastIdx] = temptick;
                        if (isBase) {
                            baseSymbolTicks.xPush(temptick);
                        } else {
                            compareSymbolTicks[data.symbol].push(temptick);
                        }
                        symbolDataMap[val.newTicks[i]] = temptick;
                    } else {
                        console.debug(that.id + "update ticks : symbol :: " + data.symbol + ", symbolData last item removed")
                    }

                }
            }
        });

        if (/*that.data.base && that.data.base.length > 0 &&*/ redrawRequired) {

            if (!lastTick) {
                that._showNoData(false);
            }
            that.maxRangeVal = this.getMaxDisplayTime();

            console.debug(this.id + "update ticks : that.maxRangeVal ::" + new Date(that.maxRangeVal));

            this._updateFromTicks(true); // update new ticks only

            this._setChartToMaxPossiblePeriod(true);

            if (isBaseSymbolUpdated) {
                this._fireEventListeners("onUpdateChartTick", [baseSymbolTicks, compareSymbolTicks], true);
                this._fireRegisteredMethod('onUpdateChartTick', [baseSymbolTicks, updatedTimes]);
            }
            if (this.tooltip || this.crosshair.enabled) {
                if (this.chart.infMouseIn && this.chart.infLastMouseMoveEvent) {
                    this.chart.container.dispatchEvent.call(this.chart.container, this.chart.infLastMouseMoveEvent);
                } else {
                    this.tooltip && this.updateTooltipToLastPoint(true);
                }
            }
        }
    }
};

/**
 * If price formatters need to be re-apply use this method from outside. Which ever the listeners listen on this (onReApplyFormatters)
 * will get executed once this is called
 * Applied a wait time since this is called from real-time updates of chart widget in xinfinit app
 */
infChart.StockChart.prototype.reApplyFormatters = function () {

    var self = this,
        applyListeners = function () {
            self._fireEventListeners('onReApplyFormatters');
            self.reApplyFormattersRequired = false;
        };

    if (!self.waitForReApplyFormatters) {
        applyListeners();
        self.waitForReApplyFormatters = true;
        setTimeout(function () {
            if (self.reApplyFormattersRequired) {
                applyListeners();
            }
            self.waitForReApplyFormatters = false;
        }, 1000);
    } else {
        self.reApplyFormattersRequired = true;
    }
};


//endregion =====================end of Streaming===================================================================

//region =====================Indicator=================================================================================

/**
 * Method to add new Indicator
 * @param {string} type indicator type
 * @param {object} config indicator config
 * @param {boolean} redraw indicate redrow or not
 * @param {boolean} isNewConfig is property change
 * @param {string} indicatorId specific id if needed
 * @param {number|undefined} index - specific place to position the indicator if needed (used in _indicatorsDissimilerToBaseAxes)
 * @returns {infChart.Indicator} new indicator
 */
infChart.StockChart.prototype.addIndicator = function (type, config, redraw, isNewConfig, indicatorId, index) {

    if (typeof redraw == "undefined") {
        redraw = true;
    }

    var iChart = this, maxCount = (this.settings && this.settings.config.maxIndicatorCount);

    if (infChart.indicatorMgr.hasMaxIndicatorCountReached(this.id, maxCount, type)) {
        infChart.util.showMessage(this.id, infChart.manager.getLabel("msg.indicatorLimitExceeded").replace("{0}", maxCount));
        return;
    }

    var indicator = infChart.indicatorMgr.createIndicator(this.id, type, config, indicatorId, index);
    var parallelToBase = infChart.util.isSeriesInBaseAxis(indicator.getAxisId()) || infChart.indicatorMgr.isParallelToBaseAxes(this.id, indicator);

    // this.setYAxisExtremes(false);
    this._setIndicatorFrames(false);

    //if (this.interval === 'T') {
    /*$.each(indicator.series, function (idx, series) {
     series.update({dataGrouping: {enabled: false}}, false);
     });*/

    //}

    var indData = this.getDataForIndicators(indicator),
        baseData = indData.base && indData.base.ohlcv && indData.base;

    if (baseData && baseData.ohlcv && baseData.data && baseData.data.length) {
        indicator.calculate(baseData.ohlcv, baseData.data, false, undefined, indData);
    }


    indicator.loadSettingWindow(true);

    indicator.setIndicatorReady(true);

    if (infChart.indicatorMgr.getNotSingletonIndicatorCount(this.id) === 1) {
        infChart.toolbar.setSelectedControls(this.id, "indicator", true);
    }
    indicator.updateLegendColor();

    if (redraw) {
        this.chart.redraw();
    }

    if (isNewConfig) {
        this._onPropertyChange("indicators", {id: indicator.id, type: indicator.type, action: 'add'});
    }

    function afterChartRedraw() {

        iChart._setLabels();
        iChart.updateMinMax();//todo : required?????
        //iChart.scaleDrawings(iChart.id);

        if (!parallelToBase) {
            iChart.onBaseAxisResize();
        } else if (redraw) {
            iChart.onBaseAxisScaled();
        }

        if (!iChart.isFirstLoadInprogress() && iChart.isResizeRequired()) {
            iChart.resizeChart();
        }
    }

    if (redraw) {
        afterChartRedraw();
    } else {
        this.registerForEvents("onReadHistoryDataLoad", afterChartRedraw);
    }
    return indicator;
};

infChart.StockChart.prototype.removeIndicator = function (indicator, isPropertyChange) {
    var si = indicator.series.length - 1;
    for (si; si >= 0; si--) {//doing this backwards as we splice the series array - https://stackoverflow.com/questions/9882284/looping-through-array-and-removing-items-without-breaking-for-loop
        var s = indicator.series[si];
        if (s && s.options.id !== indicator.id) {
            if (this.destroying) {
                infChart.indicatorMgr.removeIndicatorSeries(this.id, s.options.id);
            } else {
                this.removeSeries(s.options.id, false);
            }
        }
    }

    if (this.destroying && indicator.series.length > 0) {
        // there are unnecessary stuffs going on in the 'removeSeries' which are not needed when destroying the chart
        infChart.indicatorMgr.removeIndicatorSeries(this.id, indicator.id);
    } else if (indicator.series.length) {
        this.removeSeries(indicator.series[0].options.id, isPropertyChange);
    }
};

infChart.StockChart.prototype._setIndicatorFrames = function (redraw) {

    var iChart = this, chart = this.chart,
        y = chart.plotTop,
        height = chart.plotHeight,
        pos,
        indicatorHeight,
        mainHeight = height,
        defaultIndHPercent = 20,
        maxIndicatorPercent = 70,
        resizeHandlerHeight = Highcharts.theme && Highcharts.theme.resizeHandler.height || 4,
        yAxis = iChart.getMainYAxis();

    this.plotHeight = chart.plotHeight;

    var indicatorsDissimilerToBaseAxes = infChart.indicatorMgr.getIndicatorsDissimilarToBaseAxes(iChart.id),
        indicatorsCount = indicatorsDissimilerToBaseAxes.length, heightPercent = 0;

    infChart.util.forEach(indicatorsDissimilerToBaseAxes, function (i, indicatorId) {
        var indicator = infChart.indicatorMgr.getIndicatorById(iChart.id, indicatorId);
        if (indicator.heightPercent) {
            heightPercent += (indicator.heightPercent - 100);
        }
    });

    if (indicatorsCount > 0 || (yAxis && yAxis.height != chart.plotHeight)) {
        var tempHeightPercent = (heightPercent > defaultIndHPercent / 2) ? defaultIndHPercent / 2 : defaultIndHPercent - indicatorsCount;
        tempHeightPercent = (tempHeightPercent * indicatorsCount > maxIndicatorPercent) ? maxIndicatorPercent / indicatorsCount : tempHeightPercent;

        indicatorHeight = tempHeightPercent * height / 100;

        this.indicatorFrameHeight = indicatorHeight;
        mainHeight = height - indicatorHeight * indicatorsCount - indicatorHeight * heightPercent / 100;// - (indicatorsCount > 0 ? 20 : 0);
        pos = 0;
        var heightTotal = 0;

        infChart.util.forEach(indicatorsDissimilerToBaseAxes, function (i, indicatorId) {
            var indicator = infChart.indicatorMgr.getIndicatorById(iChart.id, indicatorId), indicatorYAxis = chart.get(indicator.getAxisId());
            var actualIndHeight = (indicator.heightPercent) ? indicatorHeight * indicator.heightPercent / 100 : indicatorHeight;
            if (indicatorYAxis) {
                indicatorYAxis.update({
                    top: mainHeight /*+ 20 */ + resizeHandlerHeight + heightTotal + chart.margin[0], // 20 - indicator title height, 4- indicator resize handler
                    height: actualIndHeight /*- 20*/ - resizeHandlerHeight
                }, false);
                heightTotal += actualIndHeight;
                pos++;
                infChart.util.forEach(indicator.series, function (i, series) {
                    series.update({}, false);
                });
            }
        });

        if (typeof redraw == 'undefined')
            redraw = false;

        yAxis.update({
            // top: 0,
            height: mainHeight
        }, false);

        //this.updateYAxis(chart.get('#1'), {
        //    // top: 0,
        //    height: mainHeight
        //}, false);


    }
    var parallelToBaseAxes = infChart.indicatorMgr.getParallelToBaseAxes(this.id);

    if (parallelToBaseAxes && parallelToBaseAxes.length > 0) {

        for (var i = 0, iLen = parallelToBaseAxes.length; i < iLen; i++) {

            var parallelAxis = chart.get(parallelToBaseAxes[i]),
                parallelAxisHeight = mainHeight * (parallelAxis.options.infHeightPercent || 0.3),
                topCorr = 1,
                parallelAxisTop = (chart.yAxis[0].top || 0) + mainHeight - parallelAxisHeight - topCorr;
            chart.get(parallelToBaseAxes[i]).update({
                top: parallelAxisTop,
                //bottom: mainHeight,
                height: parallelAxisHeight
            }, false);
        }
    }

    if (redraw) {
        chart.redraw();
    }

    this._onPropertyChange("indicatorFrames", true);

};

infChart.StockChart.prototype.removeAllIndicators = function (isPropertyChange) {
    if (infChart.indicatorMgr && this.chart) {
        var chart = this, indicators = infChart.indicatorMgr.getIndicators(chart.id);
        infChart.util.forEach(indicators, function (i, indicator) {
            chart.removeIndicator(indicator, isPropertyChange);
        });
    }
};

/**
 * Set axis labels
 */
infChart.StockChart.prototype._setLabels = function () {
    var that = this;
    if (infChart.indicatorMgr) {
        var indicatorsDissimilerToBaseAxes = infChart.indicatorMgr.getIndicatorsDissimilarToBaseAxes(this.id);
        infChart.util.forEach(indicatorsDissimilerToBaseAxes, function (key, indicatorId) {
            var indicator = infChart.indicatorMgr.getIndicatorById(that.id, indicatorId);
            var axis = that.chart && that.chart.get(indicator.getAxisId());
            if (axis) {
                that._plotter(indicator);
            }
        });
    }
    this.adjustPriceLineLabels();
};

/**
 * Re calculate indicator values from the given index or all.
 * @param redraw
 * @param startIdx if specified, processing starts from this number
 * @param {array} recalculateTypes
 * @private
 */
infChart.StockChart.prototype._recalculateIndicators = function (redraw, startIdx, recalculateTypes) {
    if (infChart.indicatorMgr) {
        var that = this, indicators = infChart.indicatorMgr.getIndicators(that.id);
        infChart.util.forEach(indicators, function (key, indicator) {

            var indData = that.getDataForIndicators(indicator, startIdx, recalculateTypes),
                baseData = indData.base && indData.base.ohlcv && indData.base,
                hasRecalData = false;

            recalculateTypes && recalculateTypes.forEach(function (type) {
                if (indData.hasOwnProperty(type)) {
                    hasRecalData = true;
                }
            });

            if ((!recalculateTypes || hasRecalData) && baseData && baseData.ohlcv && baseData.data && baseData.data.length) {
                indicator.calculate(baseData.ohlcv, baseData.data, redraw, undefined, indData);
            }
        });
    }
};

/**
 * Re calculate indicator values from the given index or all.
 * @param redraw
 * @param startIdx if specified, processing starts from this number
 * @private
 */
infChart.StockChart.prototype._recalculateDynamicIndicators = function (redraw, startIdx, recalculateTypes, extremes) {
    if (infChart.indicatorMgr) {
        var that = this, indicators = infChart.indicatorMgr.getIndicators(that.id);
        infChart.util.forEach(indicators, function (key, indicator) {

            if (indicator.isDynamic) {
                var indData = that.getDataForIndicators(indicator, startIdx, recalculateTypes),
                    baseData = indData.base && indData.base.ohlcv && indData.base,
                    hasRecalData = false;

                recalculateTypes && recalculateTypes.forEach(function (type) {
                    if (indData.hasOwnProperty(type)) {
                        hasRecalData = true;
                    }
                });

                if ((!recalculateTypes || hasRecalData) && baseData && baseData.ohlcv && baseData.data && baseData.data.length)
                    indicator.calculate(baseData.ohlcv, baseData.data, redraw, undefined, indData, extremes);
            }
        });
    }
};

/**
 * Returns the ohlcv data for the given indicator (if it is in the base axis proceed data will be provided)
 * @param indicator
 * @param recalStartIdx Process data from the given index if previous data available
 * @returns {{ohlcv: *, data: Array}}
 */
infChart.StockChart.prototype.getDataForIndicators = function (indicator, recalStartIdx, recalculateTypes) {
    var iChart = this,
        ohlcvOrg = iChart.rangeData.ohlcv,
        rangeData = iChart.rangeData.data,
        compareRangeData = iChart.rangeData.compareData,
        ohlcv,
        isNormal = !(iChart.isLog || iChart.isCompare || iChart.isPercent),
        axisId = indicator.getAxisId(),
        requiredDataTypes = indicator.getRequiredDataTypes(),
        data = {},
        recalBase = !recalculateTypes || !!(recalculateTypes.length),
        recalCompare = !recalculateTypes || recalculateTypes.indexOf("compare") >= 0;

    infChart.util.forEach(requiredDataTypes, function (i, type) {
        if (type == "base" && recalBase) {
            if (!isNormal && infChart.util.isSeriesInBaseAxis(axisId)) {// && !infChart.util.isSeriesParallelToBaseAxis(iChart.chart.get(axisId))
                //if (!iChart.processedData.ohlcv) {
                //    // no ohlcv data available and process from the beginning
                //    ohlcv = iChart.processedData.ohlcv = iChart.dataManager.getOHLCV(iChart.processedData.data);
                //} else {
                //    // processd ohlcv data available
                //    if (recalStartIdx) {
                //        // processed new data and return all
                //        var tempOhlcv = iChart.dataManager.getOHLCV(iChart.processedData.data, recalStartIdx);
                //        infChart.util.forEach(tempOhlcv, function (i, val) {
                //            if (iChart.processedData.ohlcv[i]) {
                //                if (recalStartIdx <= (iChart.processedData.ohlcv[i].length - 1)) {
                //                    iChart.processedData.ohlcv[i].splice(recalStartIdx, iChart.processedData.ohlcv[i].length - recalStartIdx);
                //                }
                //                iChart.processedData.ohlcv[i] = iChart.processedData.ohlcv[i].concat(val);
                //            } else {
                //                iChart.processedData.ohlcv[i] = val;
                //            }
                //        });
                //    }
                //    ohlcv = iChart.processedData.ohlcv;
                //}
                ohlcv = iChart.processedData.ohlcv;
            } else {
                ohlcv = ohlcvOrg;
            }
            data[type] = {ohlcv: ohlcv, data: rangeData};
        } else if (type == "compare" && recalCompare) {
            if (!isNormal && infChart.util.isSeriesInBaseAxis(axisId) && !infChart.util.isSeriesParallelToBaseAxis(iChart.chart.get(axisId))) {
                //TODO :: set processed ohlcv data
            } else {
                // TODO  :: set ohlcv
                //ohlcv = ohlcvOrg;
            }
            data[type] = {data: compareRangeData};
        }
    });

    return data;
};

//endregion===

//region =====================loading icon==============================================================================

infChart.StockChart.prototype.setLoading = function (isLoading) {
    infChart.manager.setLoadingStatus(this.chartId, isLoading);
    if (isLoading) {
        //this.chart.showLoading();
        var loadingHTML = infChart.util.getLoadingMessage();
        $(this.getContainer()).mask(loadingHTML);   
    } else {
            //this.chart.hideLoading();
            $(this.getContainer()).unmask();


    }
};

infChart.StockChart.prototype.isLoading = function () {
    return infChart.manager.getLoadingStatus(this.chartId);
};

//endregion

//region =====================no data===================================================================================

infChart.StockChart.prototype._hasData = function () {
    var hasData = false;
    if (!this.rangeData.data || !this.rangeData.data.length) {
        infChart.util.forEach(this.rangeData.compareData, function (i, val) {
            if (val && val.length) {
                hasData = true;
                return true;
            }
        });
    } else {
        hasData = true;
    }
    return hasData;
};

/**
 * show no data msg
 * based on highcharts no data plugin : http://code.highcharts.com/modules/no-data-to-display.js
 * to customize add noData section to {@link infChart.config}
 * @param noData
 */
infChart.StockChart.prototype._showNoData = function (noData) {
    if (noData && !this._hasData()) {
        var chart = this.chart;
        if (chart) {
            this._setDepthVisibility(false);
            var options = this._getNoDataLabelOptions();
            if (!this.noDataLabel) {
                this.noDataLabel = chart.renderer.label(options.msg, chart.plotWidth / 2, chart.plotHeight / 2, null, null, null, options.useHTML, null, "no-data").attr({
                    zIndex: chart.seriesGroup.zIndex - 1
                }).add();
            }
            this._resizeNoDataLabel(options);

            infChart.structureManager.settings.hideAllSettingsPopups(true);
        }
    } else {
        this._setDepthVisibility(true);
        this._destroyNoDataLabel();
    }
};

infChart.StockChart.prototype._setDepthVisibility = function (dataAvailable) {
    if (infChart.depthManager && !(this.destroying === true || this.destroyed === true)) {
        infChart.depthManager.onNoData(this.id, infChart.structureManager.getContainer(this.getContainer(), 'chartContainer'), !dataAvailable);
        if (!dataAvailable) {
            this.resizeChart();
        }
    }
};

/**
 * get no data label options
 * @returns {Object} noData options
 */
infChart.StockChart.prototype._getNoDataLabelOptions = function () {
    var noDataTheme = infChart.themeManager.getTheme().noData;
    var backgroundColorFromConfig = this.chart.options.chart.noDataBackgroundColor;
    var options = {
        msg: 'Data Not Available',
        useHTML: false,
        position: {align: 'center', verticalAlign: 'bottom'},
        style: {color: '#4572A7', fontWeight: 'bold', fontSize: 16, backgroundColor: '#121212'}
    };

    options = $.extend(options, this.chart && this.chart.options.noData || {});

    options.msg = infChart.structureManager.common.getNoDataMsg(options.msg);

    options.style = $.extend(options.style, noDataTheme || {});
    options.style.backgroundColor = backgroundColorFromConfig ? backgroundColorFromConfig : options.style.backgroundColor;
    return options;
};

/**
 * resize nodata label. set x and y
 * @param {Object} options - no data label config/options object
 */
infChart.StockChart.prototype._resizeNoDataLabel = function (options) {
    var chart = this.chart, noDataLabel = this.noDataLabel;
    if (chart && noDataLabel) {
        var width = noDataLabel.element.getBBox().width, text = noDataLabel.text.textStr;
        var axisHeight = this.getMainYAxis().height || chart.plotHeight;
        var fontsize = chart.plotWidth > width && ((axisHeight / 4) * text.length) < chart.plotWidth ?
        axisHeight / 4 : chart.plotWidth / (text.length);

        fontsize = Math.min(fontsize, options.style.fontSize);
        noDataLabel.css($.extend(options.style, {
            "fontSize": fontsize && Math.floor(fontsize) || options.style.fontSize
        }));

        noDataLabel.attr({
            zIndex: chart.seriesGroup.zIndex - 1,
            x: 0,
            y: 0,
            text: text
        });
        infChart.structureManager.common.resizeAndSetColour(this.getContainer(), options.style.backgroundColor);
    }
};

infChart.StockChart.prototype._destroyNoDataLabel = function () {
    if (this.noDataLabel) {
        this.noDataLabel.destroy();
        this.noDataLabel = undefined;
    }
};

infChart.StockChart.prototype.resizeNoData = function () {
    if (this.chart && this.noDataLabel) {
        var options = this._getNoDataLabelOptions();
        this._resizeNoDataLabel(options);
    }
};

//endregion=============================================================================================================

//region News

infChart.StockChart.prototype._initNews = function (config) {
    this.news.click = (config) ? config.click : undefined;

};

infChart.StockChart.prototype.showNews = function () {
    var mainSeries = this.getMainSeries(),
        id = mainSeries.options.id + "_news",
        seriesProperties = {
            "onSeries": mainSeries.options.id,
            "onClick": this.news.click
        };
    var properties = {
        symbol: this.symbol,
        interval: this.interval,
        period: this.period
    };
    this.addSeries(id, "news", seriesProperties, false);
    this.setLoading(true);
    this.dataManager.getNews(properties, this.onLoadNews, this)
};

infChart.StockChart.prototype.onLoadNews = function (data, properties) {
    var mainSeries = this.getMainSeries();
    var newsData = data;
    var series = this.chart.get(mainSeries.options.id + "_news");
    series.setData(newsData, true, false, false);
    this.setLoading(false);
};

/**
 * news tooltip
 * @param point
 * @returns {tooltipData}
 */
infChart.StockChart.prototype.getNewsTooltipValue = function (point) {
    return {
        'raw': point.options.infItem.headline,
        'formatted': point.options.infItem.headline,
        'label': 'news'
    };
};

//endregion

//region ===========Flags=================

/*infChart.StockChart.prototype.initFlags = function(config){
 this.news.click = (config)? config.click: undefined;

 };*/

infChart.StockChart.prototype.setFlags = function (flagType, enabled) {
    var flagIndex = this.flags.enabled.indexOf(flagType);

    if (enabled && flagIndex < 0) {
        this.toggleFlags(flagType);
    } else if (!enabled && flagIndex >= 0) {
        this.toggleFlags(flagType);
    }

    if (this._isToolbarEnabled()) {
        infChart.toolbar.setSelectedControls(this.id, 'flags', this.flags.enabled);
    }
};

infChart.StockChart.prototype.showFlags = function (flagType) {
    if (!this.symbol) {
        return;
    }
    var properties = {
        symbol: this.symbol,
        interval: this.interval,
        period: this.period,
        flagType: flagType
    };
    var chart = this;
    if (flagType) {
        this.addFlags(flagType, properties);
    } else {
        infChart.util.forEach(this.flags.enabled, function (i, flag) {
            properties = {
                symbol: chart.symbol,
                interval: chart.interval,
                period: chart.period,
                flagType: flag
            };
            chart.addFlags(flag, properties);
        });
    }

};

infChart.StockChart.prototype.addFlags = function (flagType, properties) {
    var serviceConfig = this.dataManager.getFlagService(flagType),
        mainSeries = this.getMainSeries(),
        id = mainSeries.options.id + "_" + flagType,
        seriesProperties = {
            "title": serviceConfig.symbol,
            "flagType": flagType,
            "onSeries": mainSeries.options.id,
            "shape": serviceConfig.shape ? serviceConfig.shape : "circlepin",
            "fillColor": serviceConfig.fillColor ? serviceConfig.fillColor : '#9258b3',
            "lineColor": serviceConfig.lineColor ? serviceConfig.lineColor : "#000000"
        };
    if (typeof serviceConfig.onclick === 'function') {
        seriesProperties.onClick = function (event) {
            serviceConfig.onclick.apply(this, [event, event.currentTarget.infItem]);
        };
    }
    this.addSeries(id, "flags", seriesProperties, false);
    this.setLoading(true);
    this.dataManager.getFlagsData(properties, this.onLoadFlags, this)
};

infChart.StockChart.prototype.onLoadFlags = function (data, properties) {
    var mainSeries = this.getMainSeries();
    var flagData = data;
    var series = this.chart.get(mainSeries.options.id + "_" + properties.flagType);
    series.setData(flagData, true, false, false);
    this.setLoading(false);
};

/**
 * flag tooltip
 * @param point
 * @returns {tooltipData}
 */
infChart.StockChart.prototype.getFlagToolTipValue = function (point) {
    var series = point.series, data = point.options.infItem;
    var flagService = this.dataManager.getFlagService(series.options.infFlagType);
    var label = flagService.symbol;
    if (flagService.tooltipFormatter) {
        label = flagService.tooltipFormatter(data);
    }
    return {
        'raw': label,
        'formatted': label,
        'color': series.options.fillColor,
        'label': 'flags'
    };
};

//endregion

/**
 * Set the scale factors that applies on the chart parent considering its all parents' scaling
 * These factors will be used to track mouse positions
 *
 */
infChart.StockChart.prototype.setScaleFactors = function () {
    var scaleFactorX = 1, scaleFactorY = 1, transform, matrix;
    var scalers = $("#" + this.chartId).parents().filter(function () {
        transform = $(this).css('transform');
        if (transform != "none") {
            matrix = transform.match(/-?[\d\.]+/g);
            if (matrix.length >= 4) {
                scaleFactorX = scaleFactorX * Math.sqrt(parseFloat(matrix[0]) * parseFloat(matrix[0]) + parseFloat(matrix[1]) * parseFloat(matrix[1]));
                scaleFactorY = scaleFactorY * Math.sqrt(parseFloat(matrix[2]) * parseFloat(matrix[2]) + parseFloat(matrix[3]) * parseFloat(matrix[3]));
            }
            return true;
        } else {
            return false;
        }
    });

    if (this.chart) {
        this.chart.infScaleX = scaleFactorX;
        this.chart.infScaleY = scaleFactorY;
    }
};

/**
 * retuns scale Factors
 *
 */
infChart.StockChart.prototype.getScaleFactors = function () {
    return {
        infScaleX: this && this.chart && this.chart.infScaleX,
        infScaleY: this && this.chart && this.chart.infScaleY
    };
};

/**
 *
 */
infChart.StockChart.prototype.setMaxZoom = function (resetControls) {
    var extremes = this.getRange(),
        maxZoom = this.getMaxZoomRange(),
        diff = extremes.max - extremes.min;
    if (maxZoom && maxZoom < diff) {
        var prevMid = extremes.min + (extremes.max - extremes.min) / 2;

        var startTime = extremes.max == extremes.dataMax ? extremes.max - maxZoom : Math.max(prevMid - maxZoom / 2, extremes.dataMin),
            endTime = extremes.min == extremes.dataMin ? startTime + maxZoom : Math.min(prevMid + maxZoom / 2, extremes.dataMax);

        this.setXAxisExtremes(startTime, endTime, true, false);
        // this.setRange(startTime, endTime);
        // if (resetControls) {
        //     this.clearToolbarControls("period", true);
        // }
    }
};

/**
 * Resize chart to fix it to the container dimensions
 */
infChart.StockChart.prototype.resizeChart = function () {
    console.debug("chart Resize :: from core");
    this.adjustChartSize(undefined, undefined, true);
};

/**
 * Returns true if chart size is no set properly
 * @returns {*}
 */
infChart.StockChart.prototype.isResizeRequired = function () {
    return (!this.destroying && !this.destroyed) && infChart.structureManager.isResizeRequired(this.id, this.getContainer());
};

infChart.StockChart.prototype.adjustChartSize = function (advChartEnablingWidth, advChartEnablingHeight, isAdvcht, callback, onDisplay) {
    var _self = this;

    if (this.isResizeRequired() || onDisplay) {
        console.debug("chart Resize :: adjustChartSize called");

        function adjustSize() {
            if (_self.chart) {
                var startTime = (new Date()).getTime();
                var conternerEl = _self.getContainer();
                // $container = $(conternerEl);
                var size = infChart.structureManager.rearrangeStructure(_self.id, conternerEl),
                    prevWidth = _self.chart.chartWidth;

                //this was
                // var chartHeight = size.height - 5, legendHeight = $container.find("[inf-legend]").outerHeight(true);

                //if (legendHeight && _self.chart.series != undefined && _self.chart.series.length > 0) {
                //    var yPadding = 2 * legendHeight / chartHeight;
                //    _self.getMainYAxis().update({maxPadding: yPadding}, true);
                //}
                //var adjustDrawings = !this.getMainYAxis().height;
                var adjustDrawings = !_self.getMainYAxis().height;


                console.debug("chart Resize :: adjustChartSize : reflow");
                _self.chart.reflow();

                if (!_self._isCustomPeriod() && size && prevWidth > size.width) {
                    _self.setMaxZoom(true);
                }

                //if (_self.chart && _self.chart.annotations) {
                //    _self.scaleDrawings(_self.id);
                //}

                _self.updateMinMax();

                _self._setLabels();
                if (_self.chart.redrawWaterMark) {
                    _self.chart.redrawWaterMark();
                }

                if (_self.loaded) {
                    //_self.loaded = false;
                    _self._updateNavigatorHeight();
                    clearTimeout(_self.resizeTimer);
                    _self.resizeTimer = undefined;
                }

                _self.setScaleFactors();
                // _self._adjustRangeSelectorPosition();
                _self.resizeNoData();

                //if (infChart.depthManager) {
                //    infChart.depthManager.resize(_self.id);
                //}
                if (callback && typeof callback == "function") {
                    callback.call(_self);
                }

                if (adjustDrawings) {
                    _self._fireEventListeners('afterYSetExtremes');
                }
                if(_self.chart.selectedAnnotation && _self.chart.selectedAnnotation.options && typeof infChart.drawingsManager !== 'undefined'){
                    var drawingId = _self.chart.selectedAnnotation.options.id;
                    var drawingObject = infChart.drawingsManager.getDrawingObject(_self.id, drawingId);
                    if(!drawingObject.isQuickSetting){
                        infChart.drawingsManager.toggleSettings(drawingObject, false);
                    }
                }
                _self._fireEventListeners("resize");
                console.debug("performance :: adjustSize : " + ((new Date()).getTime() - startTime) + ", startTime : " + startTime);
            }
            _self.adjustOnResizeTimeout = false;
        }

        if (_self.resizeTimer) {
            _self.adjustOnResizeTimeout = true;
        } else {
            adjustSize();
            _self.resizeTimer = setTimeout(function () {
                if (_self.adjustOnResizeTimeout) {
                    adjustSize();
                }
                _self.resizeTimer = undefined;
            }, _self.settings.config.maxResizeDelay);
        }
    }
};

infChart.StockChart.prototype.enableToolbarPanels = function (options) {
    var containerElem = $(this.getContainer());
    if (options.upper == false) {
        containerElem.find('[inf-pnl=tb-upper]').hide();
    } else if (options.upper) {
        containerElem.find('[inf-pnl=tb-upper]').show();
    }

    if (options.left == false) {
        containerElem.find('div[inf-pnl=tb-left]').hide();
    } else if (options.left) {
        containerElem.find('div[inf-pnl=tb-left]').show();
    }

    if (options.top == false) {
        containerElem.find('nav[inf-pnl=tb-top]').hide();
    } else if (options.top) {
        containerElem.find('nav[inf-pnl=tb-top]').show();
    }
};

// /**
//  * Get color for a new series
//  * @param index
//  * @returns {*}
//  * @private
//  */
// infChart.StockChart.prototype._getSeriesColor = function (index) {
//     var colors = Highcharts.theme && Highcharts.theme.seriesColorMap || ["#fbf201", "#00aeff", "#ff15af", "#8aff00", "#9f37ff"];
//     var colorMapLength = colors.length;
//     var indexOfColorMap = this.colorIndex % colorMapLength;
//     this.colorIndex++;
//     return colors && colors[indexOfColorMap] || "#FFFFFF";
// };

///**
// * Add listners for full screen state changes
// * @param type
// * @param listener
// * @private
// */
//infChart.StockChart.prototype._addFullscreenListeners = function (type, listener) {
//    this.fsListeners[type].xPush(listener);
//};

///**
// * executes the fullscreen listeners
// * @param type
// * @returns {*}
// * @private
// */
//infChart.StockChart.prototype.executeFullscreenListeners = function (type) {
//    var listeners = this.fsListeners[type];
//    this.fsListeners[type] = [];
//    infChart.util.forEach(listeners, function (i, fn) {
//        fn();
//    });
//};

infChart.StockChart.prototype.getDecimalPlaces = function (symbol) {
    return symbol && !isNaN(symbol.dp) ? symbol.dp : (this.settings && this.settings.config && !isNaN(this.settings.config.defaultDp)) ? this.settings.config.defaultDp : 2;
};

//region ========================== performance check ==================================================================

infChart.StockChart.prototype._checkPerformance = function (noOfcalls) {
    var stime = Date.now(),
        chart = this;
    for (var i = 0; i < noOfcalls; i++) {
        chart.chart.redraw();
    }
    var etime = Date.now();
    console.debug("### chart redraw time " + (etime - stime) + " no of redraws " + i);
};

infChart.StockChart.prototype._resetPerformance = function () {
    this.chart.userOptions.redrawAvg = 0;
    this.chart.userOptions.redrawcount = 0;
};

//endregion ========================== end of performance check ========================================================

infChart.StockChart.prototype._onPropertyChange = function (propertyName, value) {
    var config = infChart.manager.getProperties(this.id, infChart.constants.fileTemplateTypes.all);
    this._fireEventListeners('onPropertyChange', [propertyName, config, value ? value : config[propertyName]]);
};

/**
 * notify before changing any property
 * for now called before period or interval changes
 * @param propertyName
 * @param newValue
 * @private
 */
infChart.StockChart.prototype._onBeforePropertyChange = function (propertyName, newValue) {
    var config = infChart.manager.getProperties(this.id);
    this._fireEventListeners('onBeforePropertyChange', [propertyName, config[propertyName], newValue]);
};

/**
 * fire registered method
 * does not return anything(void fn) - should be replaced with event listeners
 * @param eventName
 * @param args
 * @private
 * @deprecated
 */
infChart.StockChart.prototype._fireRegisteredMethod = function (eventName, args) {
    if (this._hasRegisteredMethod(eventName)) {
        this.settings.registeredMethods[eventName].apply(this, args);
    }
};

infChart.StockChart.prototype._hasRegisteredMethod = function (eventName) {
    return this.settings && this.settings.registeredMethods && typeof this.settings.registeredMethods[eventName] === 'function';
};

infChart.StockChart.prototype.registerForEvents = function (methodName, callback, initialArgs) {
    var eventListeners = this.eventListeners || {},
        methodOptions = eventListeners[methodName] || {count: 0, callbacks: {}};
    eventListeners[methodName] = methodOptions;
    methodOptions.count++;
    methodOptions.callbacks[methodOptions.count] = {callback: callback, initialArgs: initialArgs};
    this.eventListeners = eventListeners;
    return methodOptions.count;
};

infChart.StockChart.prototype.removeRegisteredEvent = function (methodName, id) {
    var eventListeners = this.eventListeners || {},
        methodOptions = eventListeners && eventListeners[methodName];

    if (methodOptions && methodOptions.callbacks[id]) {
        delete methodOptions.callbacks[id];
    }
};

infChart.StockChart.prototype._fireEventListeners = function (methodName, args, skipRegeistered) {
    var iChart = this;
    if (iChart.eventListeners && iChart.eventListeners[methodName]) {
        infChart.util.forEach(iChart.eventListeners[methodName].callbacks, function (key, val) {
            var argsToSet = val.initialArgs || [],
                eventArgs = args ? Array.isArray(args) ? args : [args] : [];
            val.callback && val.callback.apply(iChart, eventArgs.concat(argsToSet));
        });
    }
    if (!skipRegeistered) {
        iChart._fireRegisteredMethod(methodName, args);
    }
};

infChart.StockChart.prototype.pointClick = function (point) {
    if (point) {
        this._fireEventListeners('pointClick');
        if (this._hasRegisteredMethod('pointClick')) {
            this._fireRegisteredMethod('pointClick', [point, this.dataManager.getTimeZone(this.interval)]);
        } else {
            return true;
        }
    } else {
        return true;
    }
};

/**
 * Executes when mouse pointer is over the given series and doing following things
 * 1.highlights the legend of the series
 * @param series
 */
infChart.StockChart.prototype.onSeriesMouseOver = function (series) {
    if (series) {
        infChart.structureManager.legend.onSeriesMouseOver(this.id, series.options.id, series.options.infType, this.isTooltipEnabled());
    }
};

/**
 * Executes when mouse  is leaving the given series and doing following things
 * 1. de-highlights the legend of the series
 * @param series
 */
infChart.StockChart.prototype.onSeriesMouseOut = function (series) {
    if (series) {
        infChart.structureManager.legend.onSeriesMouseOut(this.id, series.options.id, series.options.infType, this.isTooltipEnabled());
    }
};

infChart.StockChart.prototype.onBaseAxisResize = function () {
    var hchart = this.chart;
    if (hchart.redrawWaterMark) {
        hchart.redrawWaterMark();
    }
    this._fireEventListeners('onBaseAxisResize');
    //this._fireRegisteredMethod('onBaseAxisResize');
};

infChart.StockChart.prototype.onBaseAxisScaled = function () {
    this._fireEventListeners('onBaseAxisScaled');
    //this._fireRegisteredMethod('onBaseAxisScaled');
};

infChart.StockChart.prototype.onBeforeResetYAxis = function () {
    this._fireEventListeners('onBeforeResetYAxis');
    //this._fireRegisteredMethod('onBeforeResetYAxis');
};

/**
 * Set tooltip options of the highcharts object
 */
infChart.StockChart.prototype.setToolTipOptions = function () {
    this.chart.tooltip.options.enabled = !!this.tooltip;
};

/**
 * Show/ hide navigator
 * @param {boolean} isPropertyChange
 * @returns {boolean}
 * @private
 */
infChart.StockChart.prototype._toggleNavigator = function (isPropertyChange) {
    var chart = this.chart, enabled = !(chart.options.navigator.height > 0),
        baseSeries = ( chart.navigator && chart.navigator.baseSeries && chart.navigator.baseSeries[0] ) || this.getMainSeries(),
        baseData = baseSeries && baseSeries.options && baseSeries.options.data,
        xAxisUpdate = {},
        conternerEl = this.getContainer();


    var navigatorHeight = this.settings.config.navigatorHeight ? this.settings.config.navigatorHeight : infChart.util.getNavigatorHeight(chart.chartHeight, chart.options);

    navigatorHeight = enabled? navigatorHeight : 0;

    if (baseData && baseData.length > 1) {
        xAxisUpdate.min = baseData[0][0];
        xAxisUpdate.max = baseData[baseData.length - 1][0];
    }

    chart.update({navigator: {height: navigatorHeight, xAxis: xAxisUpdate}}, true);

    if(enabled) {
        $(conternerEl).removeClass("hide-navigator");
    } else {
        $(conternerEl).addClass("hide-navigator");
    }

    // hide-navigator

    if (this.rangeSelectorEl) {
        if (enabled) {
            this.rangeSelectorEl.show();
            this._adjustRangeSelectorMinMax();
            this._setRangeSelectorValues();
        } else {
            this.rangeSelectorEl.hide();
        }
    } else {
        this._setRangeSelectorValues();
    }

    if (isPropertyChange) {
        this._onPropertyChange("navigator");
    }
    if (this._isToolbarEnabled()) {
        infChart.toolbar.setSelectedControls(this.id, 'navigator', enabled);
    }
    return enabled;
};

infChart.StockChart.prototype._updateNavigatorHeight = function () {
    var chart = this.chart, enabled = this.isHistoryEnabled();
    if (enabled) {
        if ((chart.scroller.height < chart.options.navigator.infMaxHeight && (chart.scroller.height / chart.chartHeight) < 0.1) ||
            (chart.scroller.height > chart.options.navigator.infMinHeight && (chart.scroller.height / chart.chartHeight) > 0.1)) {
            var navigatorHeight = infChart.util.getNavigatorHeight(chart.chartHeight, chart.options);
            chart.update({navigator: {height: navigatorHeight}}, true);
        }
        if (this.rangeSelectorEl) {//from _setRangeSelectorValues
            this._adjustRangeSelectorPosition();
        }
    }
};

//region Chart-core-api - integration with toolbar

/**
 * toggle flags
 * @param {string} flagType
 * @param {boolean} isPropertyChange
 * @returns {Array<string>}
 */
infChart.StockChart.prototype.toggleFlags = function (flagType, isPropertyChange) {
    var mainSeries = this.getMainSeries();
    if (flagType) {
        var flagIndex = this.flags.enabled.indexOf(flagType);
        if (flagIndex >= 0) {
            this.flags.enabled.splice(flagIndex, 1);
            // remove series
            if (mainSeries) {
                this.removeSeries(mainSeries.options.id + "_" + flagType);
            }
        }
        else {
            this.flags.enabled.xPush(flagType);
            this.showFlags(flagType);
        }

    } else {
        if (this.flags.enabled.length == 0) {
            this.flags.enabled = $.extend([], this.flagTypes);
            this.showFlags();
        } else {
            var flags = this.flags.enabled;
            this.flags.enabled = [];
            var chart = this;
            if (mainSeries) {
                infChart.util.forEach(flags, function (i, type) {
                    chart.removeSeries(mainSeries.options.id + "_" + type);
                });
            }
        }

    }
    return this.flags.enabled;
};

/**
 * change chart data mode
 * @param {('percent'|'log')} type
 * @param {true} isPropertyChange
 * @returns {boolean}
 */
infChart.StockChart.prototype.toggleChartDataMode = function (type, isPropertyChange) {
    var enabled = false;
    switch (type) {
        case 'percent':
            if (this.isPercent) {
                type = 'percentToNormal';
            } else if (this.isLog) {
                type = 'logToPercent';
                enabled = true;
            } else {
                enabled = true;
            }
            this.setChartDataMode(type, true, isPropertyChange);
            break;
        case 'log':
            if (this.isLog) {
                type = 'logToNormal';
            } else if (this.isPercent) {
                type = 'percentToLog';
                enabled = true;
            } else {
                enabled = true;
            }
            this.setChartDataMode(type, true, isPropertyChange);
            break;
        default:
            break;
    }
    return enabled;
};

/**
 * toggle crosshair
 * @param {('last'|'all')} type
 * @param {boolean} isPropertyChange
 * @returns {boolean}
 */
infChart.StockChart.prototype.toggleCrosshair = function (type, isPropertyChange) {

    if (this.crosshair.type === type) {
        this.crosshair.enabled = !this.crosshair.enabled;
    } else if (type === 'none') {
        this.crosshair.enabled = false;
    } else {
        this.crosshair.enabled = true;
        if (this.crosshair.type === 'last') {
            this.crosshair.type = 'all';
        } else if (this.crosshair.type === 'all') {
            this.crosshair.type = 'last';
        } else {
            this.crosshair.type = type;
        }
    }
    if (isPropertyChange) {
        this._onPropertyChange("crosshair");
    }
    return this.crosshair.enabled;
};

/**
 * change chart depth side
 * @param {('right'|'bottom')} side
 * @param {boolean}isPropertyChange
 * @returns {boolean}
 */
infChart.StockChart.prototype.changeDepthSide = function (side, isPropertyChange) {
    var enabled = false;
    if (infChart.depthManager) {
        var depthProperties = infChart.depthManager.changeSide(this.id, infChart.structureManager.getContainer(this.getContainer(), 'chartContainer'), side);
        enabled = {
            value: depthProperties.side,
            enabled: depthProperties.show
        };

        if (!this.noData) {
            if (isPropertyChange) {
                this._onPropertyChange('depth', depthProperties);
            }

            this.resizeChart();

        }
        }
    return enabled;
};

/**
 * show hide last line
 * @param {boolean} isPropertyChange
 * @returns {boolean}
 */
infChart.StockChart.prototype.toggleLastLine = function (isPropertyChange) {
    if (!this.hasLastLine) {
        this._drawLastLine();
    } else if (this.hasLastLine) {
        this._removeLastLine();
    }
    if (isPropertyChange) {
        this._onPropertyChange("last", this.hasLastLine);
    }
    if(this.settings.config.lastLabelAlign == "right") {
        if(!this.hasLastLine || this.getMaxLastLabelWidth() > this.getMainYAxis().maxLabelLength) {
            this.getMainYAxis().isDirty = true;
            this.chart.redraw();
        }
    }
    return this.hasLastLine;
};

/**
 * show hide previous close line
 * @param {boolean} isPropertyChange
 * @returns {boolean}
 */
infChart.StockChart.prototype.togglePreviousCloseLine = function (isPropertyChange) {
    if (!this.hasPreviousCloseLine) {
        this._enablePreviousCloseLine(true);
    } else if (this.hasPreviousCloseLine) {
        this._removePreviousCloseLine(false);
        if(this.settings.config.previousCloseLabelAlign === "right") {
            if(!this.hasPreviousCloseLine || this.getMaxLastLabelWidth() > this.getMainYAxis().maxLabelLength) {
                this.getMainYAxis().isDirty = true;
                this.chart.redraw();
            }
        }
    }
    if (isPropertyChange) {
        this._onPropertyChange("preClose", this.hasPreviousCloseLine);
    }

    return this.hasPreviousCloseLine;
};

infChart.StockChart.prototype.toggleSingletonIndicatorByType = function (indicatorType, isPropertyChange, isEnable, redraw) {
    if(typeof redraw === 'undefined') {
        redraw = true;
    } 
    var controlName;
    switch(indicatorType){
        case 'VOLUME':
        case 'VOLUME_PNL':
            controlName = "volume";
            if (typeof isEnable === 'undefined') {
                isEnable = !this.volume;
            } 
            this.volume = isEnable;
            break;
        case 'SPREAD':
            controlName = "spread";
            if (typeof isEnable === 'undefined') {
                isEnable = !this.spread;
            } 
            this.spread = isEnable;
            break;
        case 'BAH':
            controlName = "bidAskHistory";
            if (typeof isEnable === 'undefined') {
                isEnable = !this.bidAskHistory;
            } 
            this.bidAskHistory = isEnable;
            break; 
    }
    this._toggleSingletonIndicator(indicatorType, isEnable, undefined, redraw, isPropertyChange, controlName);
    return isEnable;
};

/**
 * Show/hide chart tooltip
 * @param {boolean} isPropertyChange
 * @returns {boolean}
 */
infChart.StockChart.prototype.toggleToolTip = function (isPropertyChange) {
    var container = $(this.getContainer());

    if (this.tooltip) {
        this.tooltip = false;
        this.chart.tooltip.hide();
        container.find("[inf-tt-date]").hide();
        container.find("[inf-tooltip]").hide();
        this.setToolTipOptions();
    }
    else {
        this.tooltip = true;
        container.find("[inf-tt-date]").show();
        container.find("[inf-tooltip]").show();
        this.setToolTipOptions();
        this.updateTooltipToLastPoint(true);

    }

    infChart.structureManager.tooltip.toggleTooltip(this.id, this.tooltip);

    if (isPropertyChange) {
        this._onPropertyChange("tooltip");
    }

    this.resizeChart();
    return this.tooltip;

};

infChart.StockChart.prototype.isTooltipEnabled = function () {
    return this.tooltip && !this.settings.config.hideSymbolTooltip;
};

/**
 * toggle display of navigator
 * @param {boolean} isPropertyChange
 * @returns {boolean}
 */
infChart.StockChart.prototype.toggleHistory = function (isPropertyChange) {
    this._toggleNavigator(isPropertyChange);
    //if (infChart.depthManager) {
    //    infChart.depthManager.onPlotHeightChange(this.id);
    //}
    return this.isHistoryEnabled();
};

infChart.StockChart.prototype.isHistoryEnabled = function () {
    return this.chart.options.navigator.height > 0;
}

/**
 * toggle display of min max labels
 * @param {boolean} isPropertyChange
 * @returns {boolean}
 */
infChart.StockChart.prototype.toggleShowMinMax = function (isPropertyChange) {

    var mainSeries = this.getMainSeries();
    if (this.minMax.enabled) {
        this.minMax.axisAdjusted = false;
        /* mainSeries.yAxis.update({
         "startOnTick": false,
         "endOnTick": false
         }, true);*/
        this._hideMinMax();
    } else {
        this.minMax.axisAdjusted = true;
        /*mainSeries.yAxis.update({
         "startOnTick": true,
         "endOnTick": true
         }, true);*/
        this._showMinMax();
    }
    //this.scaleDrawings(this.id);
    this.adjustPriceLineLabels();

    if (isPropertyChange) {
        this._onPropertyChange("minMax");
    }
    return this.minMax.enabled;

};

/**
 * toggle news
 * @param {boolean} isPropertyChange
 * @returns {boolean}
 */
infChart.StockChart.prototype.toggleNews = function (isPropertyChange) {
    if (this.news.enabled) {
        var mainSeries = this.getMainSeries();
        this.news.enabled = false;
        // remove series
        this.removeSeries(mainSeries.options.id + "_news");
    } else {
        this.news.enabled = true;
        this.showNews();
    }
    return this.news.enabled;
};

/**
 * toggle display of order book history
 * @param {boolean} isPropertyChange
 * @returns {boolean}
 */
infChart.StockChart.prototype.toggleOrderBookHistory = function (isPropertyChange) {

    var mainSeries = this.getMainSeries();
    this.orderBookHistory = !this.orderBookHistory;
    this.regularIntervalsOnUpdate = this.orderBookHistory;

    if (isPropertyChange) {
        this._onPropertyChange("orderBookHistory", this.orderBookHistory);
    }

    this.refreshSeries(mainSeries.options.id);

    return this.orderBookHistory;
};

infChart.StockChart.prototype._getSettingsPanel = function () {
    return $(infChart.structureManager.getContainer(this.getContainer(), 'settingsPanel'));
};

/**
 * toggle right panel
 * @param container
 * @param {Boolean} isPropertyChange
 * @returns {Boolean}
 */
infChart.StockChart.prototype.toggleRightPanel = function (container, isPropertyChange) {
    var isVisible, rightPanel = this._getSettingsPanel();
    isVisible = this._togglePanel(rightPanel, isPropertyChange);
    this.toggleGridSettingPanel();
    return isVisible;
};

infChart.StockChart.prototype.toggleGridSettingPanel = function () {
    var chartId = this.chartId;
    var rightPanel = this._getSettingsPanel();
    var gridSettingPanel = rightPanel.find('[inf-row-item-rel="' + chartId + '"] ').find("[inf-ref=grid-settings]");
    var xGridlineColorPicker = gridSettingPanel.find("[inf-ctrl-val='xgridLine']").closest("[inf-col-pick-container]");
    var yGridlineColorPicker = gridSettingPanel.find("[inf-ctrl-val='ygridLine']").closest("[inf-col-pick-container]");

    if (this.gridType === "none") {
        gridSettingPanel.hide();
    } else {
        gridSettingPanel.show();

        if (this.gridType === "vertical") {
            yGridlineColorPicker.hide();
            xGridlineColorPicker.show();
        }
        if (this.gridType === "horizontal") {
            xGridlineColorPicker.hide();
            yGridlineColorPicker.show();
        }
        if (this.gridType === "all"){
            xGridlineColorPicker.show();
            yGridlineColorPicker.show();
        }
    }

}

/**
 * Hiding the right panel
 * @param container
 * @param setControl
 * @param isPropertyChange
 * @returns {*}
 */
infChart.StockChart.prototype.hideRightPanel = function (container, setControl, isPropertyChange) {
    var isVisible, rightPanel = this._getSettingsPanel();

    if (this.isRightPanelOpen()) {
        isVisible = this._togglePanel(rightPanel, isPropertyChange);
        if (setControl && this._isToolbarEnabled()) {
            infChart.toolbar.setSelectedControls(this.id, "rightPanel", false);
        }
    }
    return isVisible;
};

/**
 * Toggle the panel and resize the chart
 * @param panel
 * @isPropertyChange isPropertyChange
 * @private
 */
infChart.StockChart.prototype._togglePanel = function (panel, isPropertyChange) {
    panel.toggle();
    var isVisible = panel.is(":visible");
    if (isVisible) {
        this.container.xAddClass("right-panel-opened");
    } else {
        this.container.xRemoveClass("right-panel-opened");
    }
    this.adjustChartSize();

    if (isPropertyChange) {
        this._onPropertyChange("rightPanel", this.isRightPanelOpen());
    }
    return isVisible;
};

/**
 * returns true if right panel is visible
 * @returns {Boolean}
 */
infChart.StockChart.prototype.isRightPanelOpen = function () {
    var rightPanel = this._getSettingsPanel();
    return rightPanel.is(":visible");
};

/**
 * Display right panel and open given tab
 * @param tabId
 */
infChart.StockChart.prototype.showRightPanelWithTab = function (tabId) {
    var rightPanel = this._getSettingsPanel();
    if (!this.isRightPanelOpen()) {
        this._togglePanel(rightPanel, true);
    }
    rightPanel.find("li[tab-id=" + tabId + "] a").tab("show");
};

/**
 * get active settings tab options in right panel
 * @returns {object} active settings tab options
 */
infChart.StockChart.prototype.getActiveSettingsTabOptions = function () {
    var rightPanel = this._getSettingsPanel();
    var tabId = rightPanel.find("ul.nav.nav-tabs li.active").attr("tab-id");
    var activeTabPane = rightPanel.find("div[rel=" + tabId + "]");
    var activeTabPaneIndex = -1;
    activeTabPane.children().children().each(function(i){
        if($(this).is('.active')) activeTabPaneIndex = i;
    });

    return {
        tabId: tabId,
        activeTabPaneIndex: activeTabPaneIndex
    }
};

/**
 * show active section in right panel
 * @param {string} tabId - selected tab id
 * @param {number} sectionIndex - selected section index
 */
infChart.StockChart.prototype.showActiveSctionInRightPanel = function (tabId, sectionIndex) {
    var rightPanel = this._getSettingsPanel();
    var activeTabPane = rightPanel.find("div[rel=" + tabId + "]");
    var item;
    var currentActiveIndex = -1;
    activeTabPane.children().children().each(function(i){
        if($(this).is('.active')) currentActiveIndex = i;
    });
    if (sectionIndex === -1) {
        item = activeTabPane.children().find("div.panel.panel-default.active a");
        setTimeout(function(){ $(item).trigger('click')}, 250);
    } else {
        if (activeTabPane.children().children().length > 1 && sectionIndex !== currentActiveIndex) {
            item = activeTabPane.children().children().eq(sectionIndex).find('div.panel-heading a');
            setTimeout(function(){ $(item).trigger('click')}, 250);
        }
    }
};

//infChart.StockChart.prototype.toggleFullScreen = function (container) {
//    infChart.manager.handleFullscreen(container);
//};

/**
 * toggle pin/unpin of the selected interval
 */
infChart.StockChart.prototype.togglePinInterval = function (isPropertyChange) {
    if (this.pinInterval) {
        this.pinInterval = false;
    } else {
        this.pinInterval = true;
    }

    if (isPropertyChange) {
        this._onPropertyChange("pinInterval");
    }
    return this.pinInterval;
};

//endregion

infChart.StockChart.prototype.getColorsForChartType = function (series, chartType) {
    var self = this, colors = {}, seriesId = series.options.id;
    var seriesSavedColorOptions = self.getSeriesOptionsOnChartTypeChange(series, chartType);
    switch (chartType) {
        case 'hlc':
        case 'ohlc':
        case 'candlestick':
        case 'heikinashi':
        case 'point':
        case 'equivolume':
        case 'customCandle':
        case 'engulfingCandles':
            var upColor = (series.type == chartType && series.options.upColor) ? series.options.upColor :
                          seriesSavedColorOptions.upColor || seriesSavedColorOptions.color || series.color;
            var downColor = (series.type == chartType && series.options.color) ? series.options.color :
                            seriesSavedColorOptions.color || series.color;

            colors = {'colUp': upColor, 'colDown': downColor};
            break;
        case 'area':
            var areaUpColor, areaDownColor, areaUpFillColor, areaDownColorFillColor;
            if (series.options.negativeFillColor || seriesSavedColorOptions.negativeFillColor) {
                //area up color should be seriesTemp.options.color
                areaUpFillColor = series.type === chartType && series.options.fillColor ?
                                  series.options.fillColor : seriesSavedColorOptions.fillColor || series.options.fillColor;
                areaUpColor = areaUpFillColor ?
                              infChart.util.getColorFromColorObj(areaUpFillColor, "up") : series.type === chartType ? series.options.color : seriesSavedColorOptions.color || series.options.color;

                areaDownColor = series.type === chartType && series.options.negativeFillColor ? series.options.negativeFillColor : seriesSavedColorOptions.negativeFillColor || series.options.negativeFillColor;
                colors = {'colUp': areaUpColor, 'colDown': areaDownColor};
            } else {
                if (series.type == chartType && series.options.fillColor) {
                    areaUpColor = infChart.util.getColorFromColorObj(series.options.fillColor, "up");
                    areaDownColor = infChart.util.getColorFromColorObj(series.options.fillColor, "down");
                } else if (seriesSavedColorOptions.fillColor) {
                    areaUpColor = infChart.util.getColorFromColorObj(seriesSavedColorOptions.fillColor, "up");
                    areaDownColor = infChart.util.getColorFromColorObj(seriesSavedColorOptions.fillColor, "down");
                } else {
                    areaUpColor = seriesSavedColorOptions.color || series.color || series.options.color;
                    areaDownColor = seriesSavedColorOptions.color || series.color || series.options.color;
                }
                colors = {'up': areaUpColor, 'down': areaDownColor};
            }
            break;
        case 'line':
        case 'step':
            colors = {'color': (series.type == chartType) ? series.color : seriesSavedColorOptions.lineColor || seriesSavedColorOptions.color || series.color};
            // colors = {'color': (series.type == chartType) ? series.color : (seriesColorOptions && seriesColorOptions.color) ? seriesColorOptions.color : series.color};
            break;
        case 'dash':
            colors = {'color': (series.type == chartType) ? series.color : seriesSavedColorOptions.lineColor || seriesSavedColorOptions.color || series.chart.options.plotOptions.line.lineColor || series.chart.options.plotOptions.line.color};
            break;
        case 'column':
            if (series.options.hasColumnNegative && (series.options.negativeColor || seriesSavedColorOptions.negativeColor)) {
                var colUpColor = series.type == chartType ? series.options.color : seriesSavedColorOptions.color || series.options.color;
                var colDownColor = (series.type == chartType && series.options.negativeColor) ? series.options.negativeColor :
                                   seriesSavedColorOptions.negativeColor || seriesSavedColorOptions.color || series.color;
                colors = {'colUp': colUpColor, 'colDown': colDownColor};
            } else {
                colors = {'color': (series.type == chartType) ? series.color : seriesSavedColorOptions.color || series.color};
                // colors = {'color': (series.type == chartType) ? series.color : (seriesColorOptions && seriesColorOptions.color) ? seriesColorOptions.color : series.color};
                colors.opacity = seriesSavedColorOptions.fillOpacity ? seriesSavedColorOptions.fillOpacity : infChart.util.getOpacityFromRGBA(colors.color);
            }
            break;
        case 'volume':
            if (series.options.hasColumnNegative && (series.options.upColor || seriesSavedColorOptions.upColor)) {
                var volUpColor = (series.type == chartType && series.options.upColor) ? series.options.upColor :
                                 seriesSavedColorOptions.upColor || seriesSavedColorOptions.color || series.color;
                var volDownColor = (series.type == chartType && series.options.color) ? series.options.color :
                                   seriesSavedColorOptions.color || series.color;

                colors = {'colUp': volUpColor, 'colDown': volDownColor};
                colors.opacity = (seriesSavedColorOptions && seriesSavedColorOptions.fillOpacity) ? seriesSavedColorOptions.fillOpacity : infChart.util.getOpacityFromRGBA(colors.color);

            } else {
                colors = {'color': (series.type == chartType) ? series.color : self._hasSeriesColorOptions(seriesId, "column") ? self.getSeriesOptionsOnChartTypeChange(series, "column").color : seriesSavedColorOptions.color || series.color};
                // colors = {'color': (series.type == chartType) ? series.color : (seriesColorOptions && seriesColorOptions.color) ? seriesColorOptions.color : series.color};
                colors.opacity = (seriesSavedColorOptions && seriesSavedColorOptions.fillOpacity) ? seriesSavedColorOptions.fillOpacity : infChart.util.getOpacityFromRGBA(colors.color);
            }
            break;
        case 'arearange':
            colors = {'color': (series.type == chartType) ? series.color : seriesSavedColorOptions.color || series.color};
            colors.opacity = (seriesSavedColorOptions && seriesSavedColorOptions.fillOpacity) ? seriesSavedColorOptions.fillOpacity : (infChart.util.getOpacityFromRGBA(colors.color) == null) ? series.options.fillOpacity : infChart.util.getOpacityFromRGBA(colors.color);
            break;
        case 'flags':
        case 'infsignal':
        case 'infUDSignal':
        case 'plotrange':
            colors = {'color': seriesSavedColorOptions.color || series.color};
            // colors = {'color': (seriesColorOptions && seriesColorOptions.color) ? seriesColorOptions.color : series.color};
            colors.opacity = (seriesSavedColorOptions && seriesSavedColorOptions.fillOpacity) ? seriesSavedColorOptions.fillOpacity : infChart.util.getOpacityFromRGBA(colors.color);
            break;
        default:
            break;
    }
    return colors;
};

infChart.StockChart.prototype.formatValue = function (value, dp, symbol, isYvalue, isAxisLabel, specificDp) {
    var formatted;
    if (this.settings && this.settings.registeredMethods && this.settings.registeredMethods.fixedDigitsFormatter) {
        formatted = this.settings.registeredMethods.fixedDigitsFormatter(value, 'number', dp, undefined, symbol || this.symbol, specificDp);
    } else {
        if(isYvalue) {
            formatted = this.getYLabel(value, isAxisLabel);
        } else {
            formatted = infChart.util.formatNumber(value, dp);
        }
    }
    return formatted;
};

infChart.StockChart.prototype.formatVolume = function (value, symbol) {
    var formatted;
    if (this.settings && this.settings.registeredMethods && this.settings.registeredMethods.volumeFormatter) {
        formatted = this.settings.registeredMethods.volumeFormatter(value, symbol || this.symbol);
    } else {
        formatted = infChart.util.formatWithNumericSymbols(value, infChart.settings.defaults.volumeDp || 0);
    }
    return formatted;
};

//region ===================== Watermark ===============================================================================

infChart.StockChart.prototype.getWatermarkContent = function () {
    var chart = this.chart,
        currentWatermark = chart.options.watermark ? chart.options.watermark : {type: "text"};

    var externalWatermark;
    if (this.settings && this.settings.registeredMethods && this.settings.registeredMethods.getWatermark) {
        externalWatermark = this.settings.registeredMethods.getWatermark(this.symbol);
    }
    return $.extend(currentWatermark, {text: this.symbol.symbol}, externalWatermark);
};

//endregion ===================== end of Watermark =====================================================================

infChart.StockChart.prototype.onUrlChange = function (newUrl) {
    this.chart && this.chart.xOnUrlChange && this.chart.xOnUrlChange(newUrl);
};

/**
 * Returns an array of times which has a point on the chart
 * @returns {Array}
 */
infChart.StockChart.prototype.getPointPositions = function () {
    return this.processedData.pointPositions;
};

/**
 * Removing reference to given series in the time map and remove record if there is no references
 * @param seriesId
 */
infChart.StockChart.prototype.removeSeriesFromTimeMap = function (seriesId) {
    var timeMap = this.processedData.timeMap;

    infChart.util.forEach(timeMap, function (k, val) {
        if (val && val.indexOf(seriesId) >= 0) {
            val.splice(val.indexOf(seriesId), 1);
            if (!val.length) {
                delete timeMap[k];
            }
        }
    })

};

/**
 * Add given time to the map of time which keeps track of points added
 * @param time
 * @param seriesId
 * @param timeMap
 */
infChart.StockChart.prototype.addValueToTimeMap = function (time, seriesId, timeMap) {

    timeMap = timeMap || this.processedData.timeMap;

    if (!timeMap[time]) {
        timeMap[time] = [seriesId];
    } else if (timeMap[time].indexOf(seriesId) < 0) {
        timeMap[time].push(seriesId);
    }

};
/**
 * Retruns the time map
 * @returns {infChart.StockChart.processedData.timeMap|{}} time map
 */
infChart.StockChart.prototype.getAllTimeTicks = function () {
    return this.processedData.timeMap;
};

/**
 * Returns true if market of the main symbol is open 24 hours
 * @returns {boolean} linearity
 */
infChart.StockChart.prototype.isLinearData = function () {
    return !this.symbol || this.dataManager.isLinearData(this.symbol);
};

infChart.StockChart.prototype._isToolbarEnabled = function () {
    return this.settings.toolbar && this.settings.toolbar.enable && typeof infChart.toolbar === 'object';
};

infChart.StockChart.prototype._isOHLCRequired = function () {
    var required = false;
    switch (this.type) {
        case 'candlestick':
        case 'ohlc':
        case 'hlc':
        case 'heikinashi':
        case 'customCandle':
        case 'engulfingCandles':
            required = true;
            break;
        default :
            break;
    }
    return required;
};

/**
 * check chart period is custom
 * @returns {boolean}
 */
infChart.StockChart.prototype._isCustomPeriod = function () {
    return this.period == "C";
};


/**
 * data provider manager
 * based on provider type
 * Created by hasarinda on 11/2/15.
 */
var infChart = window.infChart || {};

infChart.dataProviderManager = (function () {

    var _managers = {};

    var _createDataManager = function (providerObj) {
        var dataManager;
        var type = providerObj.type,
            source = providerObj.source,
            timeZoneOffset = providerObj.timeZoneOffset;

        if (_managers[type] && _managers[type]) {
            dataManager = _managers[type];
        } else {
            switch (type) {
                case 'WEBFG' :
                    dataManager = new infChart.dataManager(new infChart.webfgDataProvider(source, timeZoneOffset), timeZoneOffset);
                    break;
                case 'infinit':
                    dataManager = new infChart.dataManager(new infChart.xinDataProvider(source, timeZoneOffset, providerObj.webSocketEvents, providerObj.ignoreTimeConversionIntervals), timeZoneOffset, providerObj.ignoreTimeConversionIntervals);
                    break;
                default :
                    dataManager = new infChart.dataManager(new infChart.mockDataProvider(source, timeZoneOffset, providerObj.ignoreTimeConversionIntervals), timeZoneOffset, providerObj.ignoreTimeConversionIntervals);
                    break;
            }

            _managers[type] = dataManager;
            dataManager.cleanCache();
        }

        return dataManager;
    };

    return {
        createDataManager: _createDataManager
    }
})();

infChart.dataManager = function (dataProvider, timeZoneOffset, ignoreTimeConversionIntervals) {
    this.ticks = {};
    this.tickData = {};
    this.customData = {};
    this.data = {};
    this.news = {};
    this.flags = {};
    this.flagServices = {};
    this.delayedObjects = {};
    this.latestCacheKeys = {};
    this.cacheReferences = {};
    this.timeZoneOffset = timeZoneOffset;
    this.requestInprogress = {};
    this.ignoreTimeConversionIntervals = ignoreTimeConversionIntervals;

    this.dataProvider = dataProvider;

    var self = this;
    setTimeout(function () {
        self._setCacheCleaner();
    }, 600000);
};

infChart.dataManager.prototype._setCacheCleaner = function () {

    var self = this;
    self.cleanCache(undefined, undefined, undefined, true); // TODO :: FIX this issue in the dev

    setTimeout(function () {
        self._setCacheCleaner();
    }, 600000);
};

infChart.dataManager.prototype._getKey = function (symbol, interval, regularIntervalsOnUpdate) {
    var prefix = regularIntervalsOnUpdate ? "reg|" : "|";
    return (prefix + symbol.symbolId + "|" + interval + "|" + this.dataProvider._vendor);
};

infChart.dataManager.prototype.getDurationDates = function(interval, maxPeriod, fromDate, toDate, scope) {
    var stockChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(scope.chartId));
    var minDate, now = isNaN(toDate) ? stockChart.getCurrentTime() : new Date(this.getChartTime(toDate, this.getTimeZone(interval), interval));

    if (isNaN(fromDate)) {
        if (!maxPeriod) {
            switch (interval) {
                case 'T':
                    maxPeriod = 'D_3';
                    break;
                case 'I_1':
                case 'I_2':
                case 'I_3':
                case 'I_5':
                case 'I_10':
                case 'I_15':
                case 'I_30':
                case 'I_60':
                    maxPeriod = 'M_3';
                    break;
                default :
                    maxPeriod = 'Y_10';
                    break;
            }
        }
        minDate = this.getMinDate(maxPeriod, now, scope);
    } else {
        minDate = new Date(this.getChartTime(fromDate, this.getTimeZone(interval), interval));
    }
    now = isNaN(toDate) ? undefined : now;
    return {from: minDate, to: now};
};

///**
// * @Deprecated - not used
// * @param data
// * @param index
// * @returns {Array}
// */
//infChart.dataManager.prototype._extract = function (data, index) {
//    //var data = this.data;
//    var retval = new Array(data.length), i;
//    for (i = 0; i < data.length; i++)
//        retval[i] = data[i][index];
//    return retval;
//};

/**
 * Returns list of arrays of ohlcv data. process from the start index if specified
 * @param data
 * @param startIdx
 * @returns {{o: Array, h: Array, l: Array, c: Array, v: Array, b: Array, a: Array}}
 */
infChart.dataManager.prototype.getOHLCV = function (data, startIdx) {
    var ohlcvData = {o: [], h: [], l: [], c: [], v: [], b: [], a: [], ah: [], bl: []},
        i,
        openArr = ohlcvData.o,
        highArr = ohlcvData.h,
        lowArr = ohlcvData.l,
        closeArr = ohlcvData.c,
        volumeArr = ohlcvData.v,
        bidArr = ohlcvData.b,
        askArr = ohlcvData.a,
        askHighArr = ohlcvData.ah,
        bidLowArr = ohlcvData.bl,
        currentIdx = 0;
    startIdx = startIdx || 0;

    for (i = startIdx; i < data.length; i++) {
        currentIdx = i - startIdx;
        openArr[currentIdx] = data[i][1];
        highArr[currentIdx] = data[i][2];
        lowArr[currentIdx] = data[i][3];
        closeArr[currentIdx] = data[i][4];
        volumeArr[currentIdx] = data[i][5];
        bidArr[currentIdx] = data[i][6];
        askArr[currentIdx] = data[i][7];
        askHighArr[currentIdx] = data[i][8];
        bidLowArr[currentIdx] = data[i][9];
    }

    return ohlcvData;
};

/**
 * merge given indices data series and returns
 * @param data
 * @param indices
 * @returns {Array}
 */
infChart.dataManager.prototype.merge = function (data, indices) {
    //var data = this.data;
    var retval = new Array(data.length), i;
    for (i = 0; i < data.length; i++) {
        //var index = indices.length;
        retval[i] = [];
        for (var index = 0, len = indices.length; index < len; index++) {
            retval[i][index] = data[i][indices[index]];
        }
    }
    return retval;
};

/**
 * Get history data from data provider
 * @param symbol
 * @param interval
 * @param fromTime
 * @param toTime
 * @param onSuccessFunction
 * @param onErrorFunction
 * @param regularIntervalsOnUpdate
 * @param requestColumns
 * @param requestWithMinutes
 */
infChart.dataManager.prototype.getHistoryData = function (symbol, interval, fromTime, toTime, onSuccessFunction, onErrorFunction, regularIntervalsOnUpdate, requestColumns, requestWithMinutes) {
    this.dataProvider.getHistoryData(symbol, interval, fromTime, toTime, onSuccessFunction, onErrorFunction, regularIntervalsOnUpdate, requestColumns, requestWithMinutes);
}

/**
 * get history data
 * @param {object} properties - properties to load data
 * @param {function} callback - invoke callback once data received
 * @param {object} scope - chart object - used when invoking callback to set context
 */
infChart.dataManager.prototype.readHistoryData = function (properties, callback, scope) {
    var key = this._getKey(properties.symbol, properties.interval, properties.regularIntervalsOnUpdate),
        cacheKey = this._getCacheKey(key, properties.interval, properties.fromDate, properties.toDate),
        that = this;

    var data = this._getFromCache(cacheKey, properties.interval);

    that.requestInprogress[key + scope.id] = {status : true, ticks:[]};

    if (properties.data) {

        var cacheObj = {
            data: properties.data.data,
            dataMap: properties.data.dataMap,
            symbol: properties.symbol.symbolId,
            interval: properties.interval,
            cacheKey: cacheKey,
            hasOpenHighLow : properties.data.hasOpenHighLow
        };

        if (properties.interval !== 'T') {
            if (cacheObj.data && cacheObj.data.length > 0) {
                that._addToCache(key, cacheKey, cacheObj, properties.interval, true, scope && scope.id);
            }
        } else {
            that.tickData[key] = cacheObj;
        }
        delete that.requestInprogress[key + scope.id];
        callback.call(scope, cacheObj, properties);
    } else if (!properties.reload && properties.interval !== 'T' && data && (!properties.fromDate && !properties.toDate)) {
        delete that.requestInprogress[key + scope.id];
        // TODO :: check convert timezone before sending
        callback.call(scope, data, properties);

        /*if (this.data[key]) {
         delete this.data[key];
         }*/
    } else {

        var onSuccess = function (dataObj, customProperties) {
            var cacheObj = {
                data: dataObj.data,
                dataMap: dataObj.dataMap,
                symbol: properties.symbol.symbolId,
                interval: properties.interval,
                cacheKey: cacheKey,
                hasOpenHighLow: dataObj.hasOpenHighLow
            };

            that.cleanCache(properties.interval, undefined, key);

            if (properties.interval !== 'T') {
                if (cacheObj.data && cacheObj.data.length > 0) {
                    that._addToCache(key, cacheKey, cacheObj, properties.interval, typeof properties.fromDate !== 'undefined' || typeof properties.toDate !== 'undefined', scope.id);
                }
            } else {
                that.tickData[key] = cacheObj;
            }

            that._updateTicks(key, properties.interval, properties.regularIntervalsOnUpdate, properties.fromDate, properties.toDate, cacheObj,scope.id);
            var latestCacheKey = that._getLatestKey(key, properties.interval),
                latestData = that._getFromCache(latestCacheKey, properties.interval),
                retVal;

            if(!latestData) {
                retVal = infChart.util.merge({}, cacheObj );
            } else {
                retVal = infChart.util.merge({}, latestData );
            }

            if(customProperties) {
                infChart.util.merge(properties, customProperties);
            }

            callback.call(scope, retVal, properties);
        };

        var onError = function () {
            var errorData = {
                data: [],
                dataMap: {},
                symbol: properties.symbol.symbolId,
                interval: properties.interval,
                cacheKey: cacheKey
            };

            if (properties.mockData) {
                errorData = properties.mockData;
            }

            that._updateTicks(key, properties.interval, properties.regularIntervalsOnUpdate, properties.fromDate, properties.toDate, {},scope.id);

            var latestCacheKey = that._getLatestKey(key, properties.interval),
                dataObj = that._getFromCache(latestCacheKey, properties.interval),
                hasData = (dataObj && dataObj.data && dataObj.data.length > 0);

            callback.call(scope, (hasData? dataObj : errorData), properties);
        };

        var periodDates = this.getDurationDates(properties.interval, properties.maxPeriod, properties.fromDate, properties.toDate, scope);
        this.getHistoryData(properties.symbol, properties.interval, periodDates.from, periodDates.to, onSuccess, onError, properties.regularIntervalsOnUpdate, properties.requestColums);
    }
};

/**
 * Merge real-time updates received while requesting history data
 * @param {string} key - key
 * @param {string} interval - chart data interval
 * @param {boolean} regularIntervalsOnUpdate
 * @param {string} fromDate - period is custom and period start date
 * @param {string} toDate - period is custom and period end date
 * @param {object} cacheObj - current data
 * @param {string} refId - reference(chart id)
 * @private
 */
infChart.dataManager.prototype._updateTicks = function (key, interval, regularIntervalsOnUpdate, fromDate, toDate, cacheObj, refId) {
    var requestInProgressKey = key + refId;
    var newTicks = this.requestInprogress[requestInProgressKey] && this.requestInprogress[requestInProgressKey].ticks;
    delete this.requestInprogress[requestInProgressKey];

    if(newTicks) {
        for (var i = 0, len = newTicks.length; i < len; i++) {
            this.addTick(newTicks[i], fromDate, toDate, interval, regularIntervalsOnUpdate, cacheObj, refId);
        }
    }

};

/**
 * get cache key
 * @param {string} key - key using symbol
 * @param {string} interval - data interval
 * @param {string} fromDate - custom period start date
 * @param {string} toDate - custom period end date
 * @return {string} - cache key
 * @private
 */
infChart.dataManager.prototype._getCacheKey = function (key, interval, fromDate, toDate) {
    var periodKey;

    if(typeof fromDate !== 'undefined' || typeof toDate !== 'undefined') {
        var dateArray = [];
        if (typeof fromDate !== 'undefined') {
            dateArray.push(fromDate);
        }
        if (typeof toDate !== 'undefined') {
            dateArray.push(toDate);
        }
        dateArray.push(key);
        periodKey = dateArray.join('_');
    }else{
        var currentDate = new Date(),
            millis = currentDate.getTime() + (currentDate.getTimezoneOffset() * 60000),
            tickTime = this.getNextTickTime(millis, interval);
        periodKey = infChart.util.getDateStringFromTime(tickTime, this._getLastUnitFromInterval(interval));
    }

    return "DATA_" + periodKey + "~" + key;
};

infChart.dataManager.prototype._removeFromCacheRef = function (referenceId, cacheKey) {
    if (cacheKey && referenceId) {
        if (this.cacheReferences[cacheKey]) {
            this.cacheReferences[cacheKey].ref.infRemove(referenceId);
            this.cacheReferences[cacheKey].count--;
        }
    } else if (referenceId) {
        for (var key in this.cacheReferences) {
            if (this.cacheReferences.hasOwnProperty(key) && this.cacheReferences[key].ref.indexOf(referenceId) >= 0) {
                this.cacheReferences[key].ref.infRemove(referenceId);
                this.cacheReferences[key].count--;
            }
        }
    }
};

//richard requested to stop caching data in local storage - server already caches data
//scenario - if user doesn't have permissions still we might serve him with cached data
//todo : set caching true or false using provider properties passed to data provider manager
/**
 * add data to cache
 * @param {string} key - key
 * @param {string} cacheKey - cache key
 * @param {object} cacheObj - current data
 * @param {string} interval - chart data interval
 * @param {boolean} isCustom - period is custom
 * @param {string} referenceId - reference(chart id)
 * @private
 */
infChart.dataManager.prototype._addToCache = function (key, cacheKey, cacheObj, interval, isCustom, referenceId) {

    //var cacheKey = this._getCacheKey(key, interval);

    this._removeFromCacheRef(referenceId);

    if (interval == 'T') {
        this.tickData[cacheKey] = cacheObj;
    }

    if (!this.latestCacheKeys[key]) {
        this.latestCacheKeys[key] = {};
    }

    this.latestCacheKeys[key][interval] = cacheKey;

    if (this.cacheReferences) {
        this.cacheReferences[cacheKey] = {count: 0, ref: []};
    }

    if (this.cacheReferences[cacheKey].ref.indexOf(referenceId) < 0) {
        this.cacheReferences[cacheKey].count++;
        this.cacheReferences[cacheKey].ref[this.cacheReferences[cacheKey].ref.length] = referenceId;
    }

    if (isCustom) {
        this.customData[cacheKey] = cacheObj;
    } else {
        this.data[cacheKey] = cacheObj;
        if (this.delaySaving) {
            this.delayedObjects[cacheKey] = cacheObj;
        } else {
            this.delaySaving = true;
            //infChart.util.saveData(cacheKey, cacheObj);
            var self = this;
            setTimeout(function () {
                for (var k in self.delayedObjects) {
                    if (self.delayedObjects.hasOwnProperty(k)) {
                        //infChart.util.saveData(k, self.delayedObjects[k]);
                        delete self.delayedObjects[k];
                    }
                }
                self.delaySaving = false;
            }, 5000);
        }
    }
};

infChart.dataManager.prototype._getLatestKey = function (key, interval) {
    return this.latestCacheKeys[key] && this.latestCacheKeys[key][interval];
    /*prevKeysInTheChain = prevKeysInTheChain ? prevKeysInTheChain : [];

     if (this.cacheReferences[cacheKey] && this.cacheReferences[cacheKey].newKey && prevKeysInTheChain.indexOf(cacheKey) >= 0) {

     prevKeysInTheChain = prevKeysInTheChain ? prevKeysInTheChain : [];
     prevKeysInTheChain.push(cacheKey);
     return this._getLatestKey(this.cacheReferences[cacheKey].newKey, prevKeysInTheChain);


     } else if (this.cacheReferences[cacheKey] && !this.cacheReferences[cacheKey].newKey) {
     return cacheKey;
     }*/
};

/**
 * Check whether matching data is available for the nearest interval and return if available delete data for the interval if not available
 * @param key
 * @param interval
 * @returns {*}
 */
infChart.dataManager.prototype._getFromCache = function (key, interval) {
    var data,
    //cacheKey = this._getCacheKey(key, interval);
        cacheKey = key;

    if (interval == 'T' && this.tickData[cacheKey]) {
        data = this.tickData[cacheKey];
    } else {
        data = this.customData[key];
        if (!data) {
            data = this.data[cacheKey];
            if (!data) {
                data = infChart.util.getData(cacheKey);
            }
        }
    }
    if (data) {
        data = infChart.util.merge({}, data);
    }
    //if (!data) {

    // clean only if there are no listeners
    //this.cleanCache(interval);
    //}
    return data;
};

infChart.dataManager.prototype._hasRefForCacheKey = function (cacheKey, deepClean) {

    var hasRef = this.cacheReferences[cacheKey] && this.cacheReferences[cacheKey].count &&
        this.cacheReferences[cacheKey].count > 0;

    if (hasRef && deepClean) {
        var refs = this.cacheReferences[cacheKey].ref;
        for (var i = 0; i < refs.length; i++) {
            var hasLink = false;
            if ($("#" + refs[i]).length < 0) {
                refs.infRemove(refs[i]);
                i--;
            } else {
                hasLink = true;
            }
            this.cacheReferences[cacheKey].count = refs.length;
        }
        return hasLink;
    } else {
        return hasRef;
    }
};

infChart.dataManager.prototype._isExpiredKey = function (cacheKey, deepClean) {

    if (cacheKey && cacheKey.indexOf("DATA_") >= 0 && !this._hasRefForCacheKey(cacheKey, deepClean)) {

        var cacheKeyArr = cacheKey.split('|'),
            interval = cacheKeyArr[cacheKeyArr.length - 1],
            currentDate = new Date(),
            millis = currentDate.getTime() + (currentDate.getTimezoneOffset() * 60000),
            tickTime = this.getNextTickTime(millis, interval),
            today = infChart.util.getDateStringFromTime(tickTime, this._getLastUnitFromInterval(interval));

        return cacheKey.indexOf("DATA_" + today) < 0;
    }
    return false;
};

infChart.dataManager.prototype.cleanCache = function (interval, cacheKey, key, deepClean) {
    var localCache = this.data,
        i;

    if (cacheKey) {

        delete this.data[cacheKey];
        delete this.cacheReferences[cacheKey];
        //infChart.util.removeData("DATA_" + cacheKey, undefined, false);
        infChart.util.removeDataByKey(cacheKey);


    } else {
        var patterns = [],
            ignorePatterns = [];
        if (interval) {


            var currentDate = new Date(),
                millis = currentDate.getTime() + (currentDate.getTimezoneOffset() * 60000),
                tickTime = this.getNextTickTime(millis, interval),
                today = infChart.util.getDateStringFromTime(tickTime, this._getLastUnitFromInterval(interval));

            patterns = ["DATA_", "|" + interval, key || ""];
            ignorePatterns = !key ? "DATA_" + today : undefined;
            //infChart.util.removeData(["DATA_", "|" + interval, key || ""], ["DATA_" + today], false);


            for (i = localStorage.length - 1; i >= 0; i--) {
                var keyTemp = localStorage.key(i);
                if (infChart.util.hasAllPatterns(keyTemp, patterns) && (!ignorePatterns || (ignorePatterns && !infChart.util.hasPattern(keyTemp, ignorePatterns) )) && (this._isExpiredKey(keyTemp, deepClean) /*|| newKey*/)) {
                    if (localCache[keyTemp]) {
                        delete localCache[keyTemp];
                    }

                    infChart.util.removeDataByKey(keyTemp);
                    if (this.cacheReferences[keyTemp] && this.cacheReferences[keyTemp].count > 0) {
                        //this.cacheReferences[keyTemp].newKey = newKey;
                    }
                }
            }

            for (i in localCache) {
                if (localCache.hasOwnProperty(i)) {
                    if (infChart.util.hasAllPatterns(i, patterns) && (!ignorePatterns || (ignorePatterns && !infChart.util.hasPattern(i, ignorePatterns) )) && (this._isExpiredKey(keyTemp, deepClean) /*|| newKey*/)) {

                        if (localCache[i]) {
                            delete localCache[i];
                        }

                        if (this.cacheReferences[keyTemp] && this.cacheReferences[keyTemp].count > 0) {
                            //this.cacheReferences[keyTemp].newKey = newKey;
                        }
                    }

                }
            }

        } else {

            // Remove the all expired cache objects from localstorage and local cache
            /* patterns = "DATA_";
             infChart.util.removeData("DATA_", undefined, false); */

            for (i = localStorage.length - 1; i >= 0; i--) {
                var keyTemp2 = localStorage.key(i);
                if (this._isExpiredKey(keyTemp2, deepClean)) {
                    if (localCache[keyTemp2]) {
                        delete localCache[keyTemp2];
                    }
                    infChart.util.removeDataByKey(keyTemp2);
                }
            }

            for (i in localCache) {
                if (localCache.hasOwnProperty(i)) {
                    if (this._isExpiredKey(i, deepClean)) {
                        if (localCache[i]) {
                            delete localCache[i];
                        }
                    }
                }
            }
        }


    }
};

infChart.dataManager.prototype.getMinDate = function (period, lastTime, scope) {

    var typeArr = (period) ? period.split('_') : undefined;
    var type = (typeArr) ? typeArr[0] : undefined;
    var units = typeArr.length >= 2 ? typeArr[1] : 1;
    var newdate = new Date(lastTime);
    switch (type) {
        case 'D' :
            newDate = this.getValidMinDate(newdate, units, scope);
            break;
        case 'M':
            newdate.setMonth(newdate.getMonth() - units);
            break;
        case 'Y':
            newdate.setYear(newdate.getFullYear() - units);
            break;
        case 'W':
            newDate = this.getValidMinDate(newdate, units *7, scope);
            
            break;

    }
    return newdate;
};
infChart.dataManager.prototype.getValidMinDate = function (newdate, periodUnit, scope) {
    var noOfDays = 0,
    tempDay = new Date(newdate.valueOf());
    if (!this.isLinearData(scope.symbol)) {
        tempDay.setDate(tempDay.getDate() - 1);
        do {
            if (!(tempDay.getDay() % 6 === 0)) {  
                if (scope._hasRegisteredMethod('getHolidaysList')) {
                    var holidaysList = scope.settings.registeredMethods.getHolidaysList.call(scope);
                    var month = (tempDay.getMonth() + 1 < 10 ? "0" : "") + (tempDay.getMonth() + 1);
                    var date = (tempDay.getDate() < 10 ? "0" : "") + tempDay.getDate();
                    var convertedTimeStamp = tempDay.getUTCFullYear() + month + date;
                    if (holidaysList.indexOf(convertedTimeStamp) === -1) { 
                        periodUnit -- ;
                    }
                } else {
                    periodUnit -- ;
                }
            }
            noOfDays++ ;
            tempDay.setDate(tempDay.getDate() - 1);
        } while (0 < periodUnit);
    } else {
        noOfDays = periodUnit;
    }
    return newdate.setDate(newdate.getDate() - noOfDays);
}

infChart.dataManager.prototype._getIntervalDate = function (time, interval) {
    if (time && !isNaN(new Date(time))) {
        switch (interval) {
            case 'Y':
                time = infChart.util.getFirstDayOfYear(time);
                break;
            case 'M':
                time = infChart.util.getFirstDayOfMonth(time);
                break;
            case 'W' :
                time = infChart.util.getFirstDayOfWeek(time);
                break;
            default :
                break;
        }
        return time;
    }
};

infChart.dataManager.prototype.getTimeZone = function (interval) {
    return (this.ignoreTimeConversionIntervals && this.ignoreTimeConversionIntervals.indexOf(interval) !== -1)? 0: this.timeZoneOffset;
};

infChart.dataManager.prototype.getNextTickTime = function (time, interval) {
    var gmtToGetFormattedTime = this.getGMTTime(time, this.getTimeZone(interval)),
        dt = Highcharts.dateFormat('%Y-%m-%d-%H-%M-%S', gmtToGetFormattedTime).split('-');
    var year = parseInt(dt[0]), month = parseInt(dt[1]) - 1, day = parseInt(dt[2]), hour = parseInt(dt[3]), minute = parseInt(dt[4]);
    var noOfUnits, mins, hrs, tickDt, tickTime, remainder;

    switch (interval) {
        case 'T':
            tickTime =  time;
            break;
        case 'I_1':
            tickTime =  Date.UTC(year, month, day, hour, minute, 0, 0);
            break;
        case 'I_3':
            noOfUnits = parseInt(minute / 3);
            remainder = minute % 3;
            mins = (remainder == 0 ) ? minute : (noOfUnits + 1) * 3;
            tickTime = Date.UTC(year, month, day, hour, mins, 0, 0);
            break;
        case 'I_5':
            noOfUnits = parseInt(minute / 5);
            remainder = minute % 5;
            mins = (remainder == 0 ) ? minute : (noOfUnits + 1) * 5;
            tickTime =  Date.UTC(year, month, day, hour, mins, 0, 0);
            break;
        case 'I_15':
            noOfUnits = parseInt(minute / 15);
            remainder = minute % 15;
            mins = (remainder == 0) ? minute : (noOfUnits + 1) * 15;
            tickTime =  Date.UTC(year, month, day, hour, mins, 0, 0);
            break;
        case 'I_30':
            noOfUnits = parseInt(minute / 30);
            remainder = minute % 30;
            mins = (remainder == 0) ? minute : (noOfUnits + 1) * 30;
            tickTime =  Date.UTC(year, month, day, hour, mins, 0, 0);
            break;
        case 'I_60':
            noOfUnits = hour;
            hrs = minute == 0 ? noOfUnits : (noOfUnits + 1) * 1;
            tickTime =  Date.UTC(year, month, day, hrs, 0, 0, 0);
            break;
        case 'I_120':
            noOfUnits = parseInt(hour / 2);
            remainder = hour % 2;
            hrs = (remainder == 0 && minute == 0 ) ? (noOfUnits) * 2 : (noOfUnits + 1) * 2;
            tickTime =  Date.UTC(year, month, day, hrs, 0, 0, 0);
            break;
        case 'I_240':
            noOfUnits = parseInt(hour / 4);
            remainder = hour % 4;
            hrs = (remainder == 0 && minute == 0 ) ? (noOfUnits) * 4 : (noOfUnits + 1) * 4;
            tickTime =  Date.UTC(year, month, day, hrs, 0, 0, 0);
            break;
        case 'I_360':
            noOfUnits = parseInt(hour / 6);
            remainder = hour % 6;
            hrs = (remainder == 0 && minute == 0 ) ? (noOfUnits) * 6 : (noOfUnits + 1) * 6;
            tickTime =  Date.UTC(year, month, day, hrs, 0, 0, 0);
            break;
        case 'D' :
            tickTime = Date.UTC(year, month, day, 0, 0, 0, 0);
            /*if(!isNaN(lastTickDt)){
             if(tickDt.getFullYear() == lastTickDt.getFullYear() && tickDt.getMonth() == lastTickDt.getMonth() && tickDt.getDate() == lastTickDt.getDate()){
             tickTime = lastTickDt.getTime();
             }
             }*/
            break;
        case 'W' :

            tickTime = this._getIntervalDate(time, interval);
            //tickDt = new Date(tickTime);
            /*if(!isNaN(lastTickDt)){
             if(tickDt.getFullYear() == lastTickDt.getFullYear() && tickDt.getMonth() == lastTickDt.getMonth() && tickDt.getDate() == lastTickDt.getDate()){
             tickTime = lastTickDt.getTime();
             }
             }*/
            break;
        case 'M' :
            tickTime = this._getIntervalDate(time, interval);
            //tickDt = new Date(tickTime);
            /*if(!isNaN(lastTickDt)){
             if(tickDt.getFullYear() == lastTickDt.getFullYear() && tickDt.getMonth() == lastTickDt.getMonth()){
             tickTime = lastTickDt.getTime();
             }
             }*/
            break;
        case 'Y' :
            tickTime = this._getIntervalDate(time, interval);
            //tickDt = new Date(tickTime);
            /*if(!isNaN(lastTickDt)){
             if(tickDt.getFullYear() == lastTickDt.getFullYear()){
             tickTime = lastTickDt.getTime();
             }
             }*/
            break;
    }
    if(tickTime){
        return this.getChartTime(tickTime, this.getTimeZone(interval), interval);
    }
    return tickTime;
};

infChart.dataManager.prototype._isIntraday = function (interval) {
    return (interval == 'T' || interval.indexOf('I') == 0)
};

infChart.dataManager.prototype._hasData = function (time, open, high, low, close) {
    return (!isNaN(time) && !isNaN(open) && !isNaN(high) && !isNaN(low) && !isNaN(close));
};

infChart.dataManager.prototype.getChartTime = function (tickTime, timeZoneOffset, interval) {
    if (timeZoneOffset && !(this.ignoreTimeConversionIntervals && this.ignoreTimeConversionIntervals.indexOf(interval) !== -1)) {
        if (!isNaN(tickTime)) {
            return +(tickTime) + +(timeZoneOffset) * 60 * 60000;
        }
    } else {
        return +(tickTime);
    }
};

infChart.dataManager.prototype.getGMTTime = function (time, timeZoneOffset) {
    if (timeZoneOffset) {
        if (!isNaN(time)) {
            return +(time) - +(timeZoneOffset) * 60 * 60000;
        }
    } else {
        return +(time);
    }
};

/**
 * add new tick data to cache
 * @param {object} data - tick data
 * @param {string} fromDate - period is custom and period start date
 * @param {string} toDate - period is custom and period end date
 * @param {string} interval - chart data interval
 * @param {boolean} regularIntervalsOnUpdate
 * @param {object} currentData
 * @param {string} refId - reference(chart id)
 */
infChart.dataManager.prototype.addTick = function (data, fromDate, toDate, interval, regularIntervalsOnUpdate, currentData, refId) {
    var key = this._getKey(data, interval, regularIntervalsOnUpdate);
    if(this.isRequestInProgress(data,interval,regularIntervalsOnUpdate, refId)){
        this.requestInprogress[key + refId].ticks.xPush(data);
    } else if (this._isValidTick(data, interval)) {

        var currentCacheKey = currentData && currentData.cacheKey,
            cacheKey = this._getCacheKey(key, interval, fromDate, toDate),
            latestCacheKey = this._getLatestKey(key, interval), // This is to check for the latest data set
            dataObj;

        if (latestCacheKey != currentCacheKey) {
            // when there is a new data in the cache than the current key
            // remove reference to current key and set new key as the cache key of the reference chart
            this._removeFromCacheRef(refId, currentCacheKey);
        }
        if (latestCacheKey && latestCacheKey != cacheKey) {
            this._removeFromCacheRef(refId, cacheKey);
        }

        dataObj = this._getFromCache(latestCacheKey, interval);
        if (!dataObj && currentData) {
            dataObj = infChart.util.merge({ symbol : data.symbolId, interval : interval}, currentData);
        }

        var lastData = (dataObj && dataObj.data && dataObj.data.length > 0) ? dataObj.data[dataObj.data.length - 1] : undefined;
        var lastTime = lastData ? lastData[0] : undefined;
        var prevLastTime = (dataObj && dataObj.data && dataObj.data.length > 1) ? dataObj.data[dataObj.data.length - 2][0] : undefined;

        if (!this.ticks[cacheKey]) {
            this.ticks[cacheKey] = [];
        }

        var chartTime = this.getChartTime(data.dateTime, data.timeZoneOffset || this.getTimeZone(interval), interval);
        var lastTimeNextTick = lastTime && this.getNextTickTime(lastTime, interval, prevLastTime);
        var tickTime = this.getNextTickTime(+(chartTime), interval, lastTime),
            lastTick,
            chartTimeInData = regularIntervalsOnUpdate ? tickTime : chartTime;

        var open = data.open != undefined ? data.open : data.close;
        var high = data.high != undefined ? data.high : data.close;
        var low = data.low != undefined ? data.low : data.close;
        var close = data.close;
        var volume = !isNaN(data.volume) ? data.volume : null,
            bid = data.bid ? data.bid : lastData ? lastData[6] : undefined,
            ask = data.ask ? data.ask : lastData ? lastData[7] : undefined,
            dataAr, i;


        if (dataObj && this._hasData(chartTimeInData, open, high, low, close)) {
            if (!dataObj.tickTimeMap) {
                dataObj.tickTimeMap = {};
            }
            var realTickTime = dataObj.tickTimeMap[tickTime];
            dataAr = dataObj.data;
            if (realTickTime && dataObj.dataMap[realTickTime]) {
                for (i = dataAr.length - 1; i >= 0; i--) {
                    if (dataAr[i][0] == realTickTime) {
                        lastTick = dataAr[i];
                        dataAr[i][0] = +(chartTimeInData);
                        lastTick[1] = data.open !== undefined ? data.open : lastTick[1];
                        lastTick[2] = lastTick[2] < high ? high : lastTick[2];
                        lastTick[3] = lastTick[3] > low ? low : lastTick[3];
                        lastTick[4] = close;
                        lastTick[5] = volume ? lastTick[5] + volume : lastTick[5] || null;
                        lastTick[6] = bid;
                        lastTick[7] = ask;
                        lastTick[8] = lastTick[8] ? lastTick[8] < ask ? ask : lastTick[8] : ask;
                        lastTick[9] = lastTick[9] ? lastTick[9] > bid ? bid : lastTick[9] : bid;
                        delete dataObj.dataMap[realTickTime];
                        dataObj.dataMap[chartTimeInData] = lastTick;
                        dataObj.tickTimeMap[tickTime] = +(chartTimeInData);
                        break;
                    }
                }
            }
            if (!realTickTime && lastTimeNextTick == tickTime) {
                for (i = dataAr.length - 1; i >= 0; i--) {
                    if (dataAr[i][0] == lastTime) {
                        lastTick = dataAr[i];
                        dataAr[i][0] = +(chartTimeInData);
                        lastTick[1] = data.open !== undefined ? data.open : lastTick[1];
                        lastTick[2] = lastTick[2] < high ? high : lastTick[2];
                        lastTick[3] = lastTick[3] > low ? low : lastTick[3];
                        lastTick[4] = close;
                        lastTick[5] = volume ? lastTick[5] + volume : lastTick[5] || null;
                        lastTick[6] = bid;
                        lastTick[7] = ask;
                        lastTick[8] = lastTick[8] ? lastTick[8] < ask ? ask : lastTick[8] : ask;
                        lastTick[9] = lastTick[9] ? lastTick[9] > bid ? bid : lastTick[9] : bid;
                        delete dataObj.dataMap[lastTime];
                        dataObj.dataMap[chartTimeInData] = lastTick;
                        dataObj.tickTimeMap[tickTime] = +(chartTimeInData);
                        break;
                    }
                }
            } else if (!realTickTime && lastTimeNextTick < tickTime) {
                if (dataObj.tickTimeMap[lastTimeNextTick] && this._isIntraday(interval)) {
                    for (i = dataAr.length - 1; i >= 0; i--) {
                        if (dataAr[i][0] == lastTime) {
                            lastTick = dataAr[i];
                            dataAr[i][0] = lastTimeNextTick;
                            delete dataObj.dataMap[lastTime];
                            dataObj.dataMap[lastTimeNextTick] = lastTick;
                            dataObj.tickTimeMap[lastTimeNextTick] = lastTimeNextTick;
                            break;
                        }
                    }
                }
                var tempRow = [chartTimeInData, open, high, low, close, volume, bid, ask, ask, bid];
                dataObj.data[dataObj.data.length] = tempRow;
                dataObj.dataMap[chartTimeInData] = tempRow;
                dataObj.tickTimeMap[tickTime] = +(chartTimeInData);
            } else if(!realTickTime && !lastTimeNextTick){

                var tempRow = [chartTimeInData, open, high, low, close, volume, bid, ask, ask, bid];
                dataObj.data = [tempRow];
                dataObj.dataMap = {};
                dataObj.dataMap[chartTimeInData] = tempRow;
                dataObj.tickTimeMap[tickTime] = +(chartTimeInData);
                //dataObj.interval = interval;
            }
            //this.ticks[key].push({tickTime: chartTimeInData, period: period, interval: interval});
            if (dataObj.data && dataObj.data.length > 0) {

                dataObj.cacheKey = cacheKey;

                this._addToCache(key, cacheKey, dataObj, interval, typeof fromDate !== 'undefined' || typeof toDate !== 'undefined', refId);

                // clean previous cache keys from the cache since new data set is available
                if (currentCacheKey != cacheKey) {
                    this.cleanCache(interval, currentCacheKey, undefined);
                }

                if (latestCacheKey != cacheKey) {
                    this.cleanCache(interval, latestCacheKey, undefined);
                }

            }
        }
    }
};

infChart.dataManager.prototype.isRequestInProgress = function (symbol, interval, regularIntervalsOnUpdate, refId) {
    var key = this._getKey(symbol, interval, regularIntervalsOnUpdate);
    return this.requestInprogress[key + refId]? true : false;
};

infChart.dataManager.prototype._isValidTick = function (data, interval) {
    return ( !isNaN(data.close) && !isNaN(this.getChartTime(data.dateTime, data.timeZoneOffset || this.getTimeZone(interval), interval)));
};

infChart.dataManager.prototype.getPreviousClose = function (data) {
    var preClose;
    if (data && data.length > 0) {
        if (infChart.util.isToday(new Date(data[data.length - 1][0])) && data.length > 1) {
            preClose = {idx: data.length - 2, row: data[data.length - 2], value: data[data.length - 2][4]};
        }
        else {
            preClose = {idx: data.length - 1, row: data[data.length - 1], value: data[data.length - 1][4]};
        }
    }
    return preClose;
};

infChart.dataManager.prototype.getNewTicks = function (lastTime, interval, symbols, regularIntervalsOnUpdate) {

    lastTime = lastTime || 0;

    this.ticks = {};
    var i,
        count,
        oneBeforeLast,
        resultData = {};

    for (i in symbols) {

        if (symbols.hasOwnProperty(i)) {

            var key = this._getKey(symbols[i], interval, regularIntervalsOnUpdate),
                cacheKey = this._getLatestKey(key,interval) || key,
                data = this._getFromCache(cacheKey, interval),
                dataArr = data && data.data,
                newTickTimeArr = [],
                symLastTime = symbols[i].prevLastTime || lastTime,
                newCount = 0;

            if (data && dataArr && dataArr.length && data.interval == interval) {

                count = dataArr.length - 1;
                oneBeforeLast = false;

                while (count >= 0 && ( symLastTime <= dataArr[count][0] ) ) {
                    newTickTimeArr[newCount] = dataArr[count][0];
                    newCount++;
                    count--;
                }
                if (newTickTimeArr.length > 0) {
                    resultData[i] = {symbol: symbols[i], data: data, newTicks: newTickTimeArr.reverse()};
                }
            }
        }
    }

    return resultData;
};

infChart.dataManager.prototype._getNewsCacheKey = function (symbol) {
    return symbol.symbolId;
};

infChart.dataManager.prototype.getNews = function (properties, callback, scope) {

    var key = this._getNewsCacheKey(properties.symbol), that = this;

    if (this.news[key] && !properties.reload) {
        callback.call(scope, this.news[key], properties);
        if (properties.interval == 'T') {
            delete this.news[key];
        }
    } else {
        var dates = this.getDurationDates(properties.interval, properties.maxPeriod, properties.fromDate, properties.toDate);

        var onSuccess = function (dataObj) {
            that.news[key] = dataObj;
            callback.call(scope, dataObj, properties);
        };

        var onError = function () {
            callback.call(scope, [], properties);
        };

        this.dataProvider.getNewsData(properties.symbol, properties.interval, dates.from, dates.to, onSuccess, onError);
    }
};

infChart.dataManager.prototype.getFlagService = function (type) {
    return this.flagServices[type];
};

infChart.dataManager.prototype._getFlagCacheKey = function (symbol, interval, flagType) {
    return flagType + '|' + symbol.symbolId + '|' + interval;
};

infChart.dataManager.prototype.getFlagsData = function (properties, callback, scope) {

    var key = this._getFlagCacheKey(properties.symbol.symbolId, properties.interval, properties.flagType), that = this;

    if (this.flags[key] && !properties.reload) {
        callback.call(scope, this.flags[key].data, properties);
        if (properties.interval == 'T') {
            delete this.flags[key];
        }
    } else {
        var dates = this.getDurationDates(properties.interval, properties.maxPeriod, properties.fromDate, properties.toDate);

        var onSuccess = function (dataObj) {
            that.flags[key] = {data: dataObj, symbol: properties.symbol.symbolId};
            callback.call(scope, dataObj, properties);
        };

        var onError = function () {
            callback.call(scope, [], properties);
        };

        this.dataProvider.getFlagsData(properties.symbol, properties.interval, properties.flagType, dates.from, dates.to, onSuccess, onError);
    }
};

//endregion

infChart.dataManager.prototype._getLastUnitFromInterval = function(interval){
    switch (interval) {
        case 'T':
        case 'I_1':
        case 'I_3':
        case 'I_5':
        case 'I_15':
        case 'I_30':
            return "m";
        case 'I_60':
        case 'I_120':
        case 'I_240':
        case 'I_360':
            return 'h';
        default :
            return 'd';
    }
};

infChart.dataManager.prototype.getMarketOpenTimes = function (symbol) {
    return this.dataProvider.getMarketOpenTimes(symbol);
};

/**
 * Check whether the given symbol is linear or not
 * @param {object} symbol symbol to check the linearity
 * @returns {boolean} linearity
 */
infChart.dataManager.prototype.isLinearData = function (symbol) {
    return this.dataProvider.isLinearData(symbol);
};

/**
 * Scan patterns for the given data set
 * @param {string} data in csv format
 * @param {function} callback callback function to be executed when data is recived
 * @param {object} scope scope of the callback
 */
infChart.dataManager.prototype.scanPattern = function (data, callback, scope) {
    var onSuccess = function (dataObj) {
        callback.call(scope, dataObj);
    };

    var onError = function () {
        callback.call(scope, {});
    };

    return this.dataProvider.scanPattern(data, onSuccess, onError);
};


infChart.dataProvider = function (vendor, timezoneOffset) {
};

/**
 * Asynchronous method to get History data
 * @param {object} symbol chart symbol
 * @param {string} interval interval of the requesting data
 * @param {Date} fromDate from date
 * @param {Date} toDate to date
 * @param {function} onSuccess success callback
 * @param {function} onError error callback
 */
infChart.dataProvider.prototype.getHistoryData = function (symbol, interval, fromDate, toDate, onSuccess, onError) {
};

/**
 * Asynchronous method to get News data
 * @param {object} symbol chart symbol
 * @param {Date} fromDate from date
 * @param {Date} toDate to date
 * @param {function} onSuccess success callback
 * @param {function} onError error callback
 */
infChart.dataProvider.prototype.getNewsData = function (symbol, fromDate, toDate, onSuccess, onError) {
};

/**
 * Asynchronous method to get flag data
 * @param {object} symbol chart symbol
 * @param {Date} fromDate from date
 * @param {Date} toDate to date
 * @param {Date} flagType requesting data type
 * @param {function} onSuccess success callback
 * @param {function} onError error callback
 */
infChart.dataProvider.prototype.getFlagsData = function (symbol, fromDate, toDate, flagType, onSuccess, onError) {
};

/**
 * Method to get market status data :: No backend services yet
 * @param {object} symbol chart symbol
 */
infChart.dataProvider.prototype.getMarketOpenTimes = function (symbol) {
};

/**
 * Asynchronous method to get instruments on search
 * @param {string} searchText search text
 * @param {function} onSuccess success callback
 * @param {function} onError error callback
 */
infChart.dataProvider.prototype.getSymbols = function (searchText, onSuccess, onError) {
};

/**
 * Check the linearity of given instrument
 * @param {object} symbol chart symbol
 * @returns {boolean} linearity
 */
infChart.dataProvider.prototype.isLinearData = function (symbol) {
    return true;
};
var infChart = window.infChart || {};

infChart.themeManager = (function (Highcharts) {

    var _themes = {
        light: "light",
        dark: "dark"
    };
    
    /**
     * set highchart theme
     * @param {string} theme - chart theme dark/light
     */
    var _setTheme = function (theme) {
        Highcharts.theme = (theme === _themes.light) ? _getLightTheme() : _getDarkTheme();
        Highcharts.setOptions(Highcharts.theme);
    };
    
    /**
     * get light theme
     * @returns {object} light theme
     */
    var _getLightTheme = function () {
        return infChart.lightTheme;
    };
    
    /**
     * get dark theme
     * @returns {object} dark theme
     */
    var _getDarkTheme = function () {
        return infChart.darkTheme;
    };

    /**
     * get theme 
     * @returns {object} Highcharts.theme
     */
    var _getTheme = function () {
        return Highcharts.theme;
    };
    
    /**
     * get themes
     * @returns {object} themes 
     */
    var _getThemes = function () {
        return _themes;
    };

    /**
     * reset main series colors
     * @param {object} seriesOption 
     * @returns {object} reset object
     */
    var _resetMainSeriesColors = function (seriesOption) {
        for (var option in seriesOption) {
            switch(option) {
                case "color":
                case "lineColor":
                case "upColor":
                case "upLineColor":
                case "fillColor":
                    seriesOption[option] = undefined;
                    break;
                default: 
                    break;
            }
        }
        return seriesOption;
    };

    /**
     * get changed series theme colors. set undefined if theme color equals to series colors
     * @param {object} seriesOption - series options
     * @param {string} type - chart type
     * @returns 
     */
    var _getChangedSeriesThemeColors = function (seriesOption, type) {
        var themeOptions = _getTheme().plotOptions[type];
        for (var option in seriesOption) {
            switch(option) {
                case "color":
                case "lineColor":
                case "upColor":
                case "upLineColor":
                    if((themeOptions[option] === seriesOption[option])){
                        delete seriesOption[option];
                    }
                    break;
                case "fillColor":
                    var fill = _getChangedFillColor(themeOptions[option], seriesOption[option]);
                    if(typeof fill === 'undefined'){
                        delete seriesOption[option];
                    }
                    break;
                default: 
                    break;
            }
        }
        return seriesOption;
    };

    /**
     * get changed fill color
     * @param {Array<object>} themeColor - theme color
     * @param {Array<object>} seriesColor - series color
     * @returns {Array<object>} if has custom colors then undefined
     */
    var _getChangedFillColor = function (themeColor, seriesColor) {
        var isColorChanged = false;
        seriesColor.stops.forEach(function (colorItem) {
            var color = themeColor.stops[colorItem[0]][1]
            if(color !== colorItem[1]) {
                isColorChanged = true;
                return;
            } 
        });
        return (isColorChanged) ? seriesColor : undefined;
    };

    /**
     * get drawings fill color. 
     * @param {string} fillColor - drawing fill color
     * @param {string} shape - drawing shape
     * @returns {string} set undefined if fill color same as theme color
     */
    var _getDrawingsFillColor = function (fillColor, shape) {
        var theme = _getTheme();
        var themeColor = theme.drawing[shape] && theme.drawing[shape].fillColor ? theme.drawing[shape].fillColor : theme.drawing.base.fillColor;
        return (themeColor !== fillColor) ? fillColor : undefined;
    };

    /**
     * get drawing border color
     * @param {*} borderColor 
     * @param {*} shape 
     * @returns set undefined if fill color same as theme color
     */
    var _getDrawingsBorderColor = function (borderColor, shape) {
        var theme = _getTheme();
        var themeColor = theme.drawing[shape] && theme.drawing[shape].borderColor ? theme.drawing[shape].borderColor : theme.drawing.base.borderColor;
        return (themeColor !== borderColor) ? borderColor : undefined;
    };

    return {
        setTheme: _setTheme,
        getTheme: _getTheme,
        getThemes: _getThemes,
        getLightTheme: _getLightTheme,
        getDarkTheme: _getDarkTheme,
        getChangedSeriesThemeColors: _getChangedSeriesThemeColors,
        getDrawingsFillColor: _getDrawingsFillColor,
        getDrawingsBorderColor: _getDrawingsBorderColor,
        resetMainSeriesColors: _resetMainSeriesColors
    }
})(Highcharts);
/**
 * Created by dushani on 8/26/15.
 *
 * This is the api implementation which clients(outsiders from chart core) communicates with the inifinit chart.
 */
var infChart = window.infChart || {};

infChart.manager = infChart.manager || (function ($, H) {

        var _instance;
        var _charts = {};
        var _loadingMap = {};
        var _chartCustomSettings = {};
        var _defaultLanguage = 'en';
        //var _supportedLanguages = ['en'];
        var _localizationOptions = {
            language: _defaultLanguage, pathPrefix: "../js/lang", skipLanguage: "en-US",
            callback: function (data, element, defaultCallback, referenceId) {

                _updateLangTitles(element);
                var highChartsOpt = _getLabel("highchart");
                highChartsOpt.decimalPoint = (!highChartsOpt.decimalPoint) ? "." : highChartsOpt.decimalPoint;
                highChartsOpt.thousandsSep = (!highChartsOpt.thousandsSep) ? "," : highChartsOpt.thousandsSep;

                H.setOptions({
                    lang: highChartsOpt
                });
                defaultCallback(data, element);
                _afterLocalize(referenceId);
            }
            /*, fileExtension:'js'*/
        };
        var _fsListeners = {exit: [], enter: []};
        var _isFullScreen = false;
        var _sizeBeforeFullScreen = {};

        var _updateLangTitles = function (container) {
            container.find("[title*='label.']").each(function (i, el) {
                el.title = _getLabel(el.title);
            });

            // Fix for the bootstrap tooltip
            container.find("[adv-chart-tooltip*='label.']").each(function (i, el) {
                el.setAttribute("adv-chart-tooltip", _getLabel(el.getAttribute("adv-chart-tooltip")));
            });
        };

        var _renderChart = function (container, uniqueId, properties) {
            _chartCustomSettings[uniqueId] = properties;

            var settingsProperties = infChart.util.merge({}, infChart.settings, properties.settings);

            var config = $.extend(true, {}, infChart.config, properties.config);

            _generateContainers(container, uniqueId, settingsProperties.toolbar, settingsProperties, config);

            var dataManager = infChart.dataProviderManager.createDataManager(settingsProperties.dataProvider);
            var chartObj = new infChart.StockChart(uniqueId, dataManager, settingsProperties);
            _charts[uniqueId] = chartObj;
            chartObj.setProviderProperties(settingsProperties.dataProvider);
            _initializeChartComponents(uniqueId, container, settingsProperties);

            if (settingsProperties.toolbar.enable) {
                infChart.toolbar.createToolbar(container, uniqueId, settingsProperties.toolbar);
            }

            _localizationOptions = $.extend(true, {}, _localizationOptions, settingsProperties.lang);
            _localizationOptions.element = container;
            _localize(uniqueId);

            _createChart(container, uniqueId, config, settingsProperties);
            if (settingsProperties.toolbar.enable) {
                infChart.toolbar.initializeTooltips(container);
            }

            if ( chartObj.localized ) {
                //to re arrange tool bar after setting the initial values
                infChart.structureManager.rearrangeStructure(uniqueId, container[0]);
            }

            return _charts[uniqueId];
        };

        /**
         * generate chart
         * @param uniqueId id of chart container
         * @param properties chart properties {}
         * @private
         */
        var _initChart = function (uniqueId, properties) {
            var _initChartStartTime = (new Date()).getTime();
            var containerElem = $('#' + uniqueId);
            var chart = _renderChart(containerElem, uniqueId, properties);
            chart.performanceCheck["_initChart"] = (new Date()).getTime() - _initChartStartTime;
            return chart;
        };

        /**
         * change chart theme
         * @param {string} theme - chart theme dark/light
         */
        var _changeChartTheme = function (theme, setDefaultColors, colorChangedProperties) {
            var charts = {};
            for (var chartId in _charts) {
                if (_charts.hasOwnProperty(chartId)) {
                    charts[chartId] = _getChartCustomSettingsForThemeChange(chartId, theme, setDefaultColors, colorChangedProperties);
                }
            }
            _setChartTheme(theme);
            for(var chartId in charts) {
                if (charts.hasOwnProperty(chartId)) {
                    var newChartConfig = charts[chartId];
                    _onChangeChartTheme(chartId, newChartConfig);
                }
            }
        };
        
        var _changeChartThemeByChartId = function (chartId, theme) {
            var chartCustomSettings;
            if (chartId && _charts.hasOwnProperty(chartId)) {
                chartCustomSettings = _getChartCustomSettingsForThemeChange(chartId);
            }
            _setChartTheme(theme);
            _onChangeChartTheme(chartId, chartCustomSettings);
        };


        var _onChangeChartTheme = function (chartId, newChartConfig) {
            var containerElem = $('#' + chartId);
            var chart = _charts[chartId];
            _removeChart(chartId);
            var newChartInstance = infChart.manager.renderChart(containerElem, chartId, newChartConfig);
            newChartInstance.range = {};
            if (newChartConfig.settings.config.userExtremes && newChartConfig.settings.config.userExtremes.xAxis) {
                var xExtremes = newChartConfig.settings.config.userExtremes.xAxis;
                _setUserDefinedXAxisExtremes(chartId, xExtremes.userMin, xExtremes.userMax, true, true);
            }
            if (newChartConfig.settings.config.userExtremes && newChartConfig.settings.config.userExtremes.yAxis) {
                var yExtremes = newChartConfig.settings.config.userExtremes.yAxis;
                _setUserDefinedYAxisExtremes(chartId, yExtremes.userMin, yExtremes.userMax, true, true);
            }
            if (chart._hasRegisteredMethod('onThemeChange')) {
                chart._fireRegisteredMethod('onThemeChange', [newChartInstance]);
            }
        };

        var _updateChartAxisColors = function(chartId, theme) {
            var chart = _getChart(chartId);

            var darkTheme = infChart.themeManager.getDarkTheme();
            var lightTheme = infChart.themeManager.getLightTheme();

            var darkThemeXaxisLabelColor = darkTheme.xAxis.labels.style.color;
            var darkThemeYaxisLabelColor = darkTheme.yAxis.labels.style.color;

            var lightThemeXaxisLabelColor = lightTheme.xAxis.labels.style.color;
            var lightThemeYaxisLabelColor = lightTheme.yAxis.labels.style.color;

            var xAxisLabelColor = theme === "dark" ? darkThemeXaxisLabelColor : lightThemeXaxisLabelColor;
            var yAxisLabelColor = theme === "dark" ? darkThemeYaxisLabelColor : lightThemeYaxisLabelColor;

            if(chart) {
                chart.chart.xAxis[0].update({
                    labels: {
                        style: {
                            color: xAxisLabelColor
                        }
                    }
                }, false);
                chart.chart.yAxis[0].update({
                    labels: {
                        style: {
                            color: yAxisLabelColor
                        }
                    }
                }, false);

                chart.chart.redraw();
            }
        };

        /**
         * get chart custo settings for theme change
         * @param {string} chartId - chart Id
         * @returns {object} chart settings object
         */
        var _getChartCustomSettingsForThemeChange = function (chartId, theme, setDefaultColors, colorChangedProperties) {

            var chart = _getChart(chartId);
            var currentConfig = _getProperties(chartId, infChart.constants.fileTemplateTypes.all);
            var customSettings = _chartCustomSettings[chartId];
            customSettings.settings.config = infChart.util.merge({}, customSettings.settings.config, currentConfig);
            customSettings.settings.symbol = infChart.util.merge({}, customSettings.settings.symbol, currentConfig.mainSymbol);
            customSettings.settings.config.mainSeriesOptions = currentConfig.mainSeriesOptions;

            if(theme && setDefaultColors) {
                _removeSeriesColorProperties(currentConfig.mainSeriesOptions);
                if(customSettings.settings.config && customSettings.settings.config.indicators && infChart.indicatorMgr){
                    infChart.indicatorMgr.resetIndicatorsColors(customSettings.settings.config.indicators, themeData.indicator);
                }
                _removeCompareSeriesColors(currentConfig.compareSeriesOptions);

                customSettings.settings.config.backgroundColor = themeData.chart.backgroundColor;
                customSettings.settings.config.chartBgTopGradientColor = themeData.chart.chartBgTopGradientColor;
                customSettings.settings.config.chartBgBottomGradientColor = themeData.chart.chartBgBottomGradientColor;
                customSettings.settings.config.backgroundType = "solid";
                customSettings.settings.config.gridSettings.xGridLineColor = themeData.xAxis.gridLineColor;
                customSettings.settings.config.gridSettings.yGridLineColor = themeData.yAxis.gridLineColor;
            }

             if(!chart.customGridLineColorEnabled && colorChangedProperties && !colorChangedProperties.gridLineColor) {
                customSettings.settings.config.gridSettings.xGridLineColor = themeData.xAxis.gridLineColor;
                customSettings.settings.config.gridSettings.yGridLineColor = themeData.yAxis.gridLineColor;
            }

            customSettings.settings.config["userExtremes"] = {};
            customSettings.settings.config["selectedSettingTabOptions"] = {};

            if(!_isDefaultXAxisExtremes(chartId)) {
                var xExtremes = chart.getMainXAxis().getExtremes();
                customSettings.settings.config["userExtremes"]["xAxis"] = {
                    userMax: xExtremes.userMax,
                    userMin: xExtremes.userMin
                }
            }

            if(!_isDefaultYAxisExtremes(chartId)) {
                var yExtremes = chart.getMainYAxis().getExtremes();
                customSettings.settings.config["userExtremes"]["yAxis"] = {
                    userMax: yExtremes.userMax,
                    userMin: yExtremes.userMin
                }
            }

            if (customSettings.settings.config.rightPanel) {
                var tabOptions = chart.getActiveSettingsTabOptions();
                customSettings.settings.config["selectedSettingTabOptions"] = tabOptions;
            }

            return customSettings;
        };

        var _removeSeriesColorProperties = function(mainSeriesOptions) {

            if(mainSeriesOptions.color){
                delete mainSeriesOptions.color;
            }
            if(mainSeriesOptions.fillColor){
                delete mainSeriesOptions.fillColor;
            }
            if(mainSeriesOptions.lineColor){
                delete mainSeriesOptions.lineColor;
            }
            if(mainSeriesOptions.upColor){
                delete mainSeriesOptions.upColor;
            }
            if(mainSeriesOptions.upLineColor){
                delete mainSeriesOptions.upLineColor;
            }

        };

        var _removeCompareSeriesColors = function(compareSeries) {
                compareSeries.forEach(function(series){
                    if(series.color){
                        delete series.color;
                    }
                    if(series.fillColor){
                        delete series.fillColor;
                    }
                    if(series.lineColor){
                        delete series.lineColor;
                    }
                })
        };

        /**
         * set chart theme
         * @param {string} theme - chart theme dark/light
         */
        var _setChartTheme = function (theme) {
            infChart.themeManager.setTheme(theme);
        };

        var _setSelectToolbarIconOnReset = function (uniqueId, container) {
            if( infChart.drawingsManager){
                 infChart.drawingsManager.setSelectToolbarIconOnReset(uniqueId, container);
            }
        };

        /**
         * create highcharts
         * @param containerElem chart container
         * @param containerId container id of chart container
         * @param config chart properties object
         * @param settings chart settings object
         * @private
         */
        var _createChart = function (containerElem, containerId, config, settings) {
            var chartObj = _charts[containerId];
            try {
                var chartId = _getChartId(containerId), chartContainer = document.getElementById(chartId);

                if (chartContainer) {
                    //mouseWheelController, hasEmpty = false, dummyIds = [];

                    //config.chart.renderTo = chartContainer;
                    //config.chart.infContainer = containerId;
                    //config.chart.infChart = true;
                    //config.chart.infScalable = settings.config.scalable;
                    //config.navigator.enabled = settings.config.navigator;
                    //var chartH = chartContainer.offsetHeight;
                    //config.navigator.height = (chartH) ? infChart.util.getNavigatorHeight(chartH, config) :
                    //    settings.config.navigatorHeight ? settings.config.navigatorHeight : config.navigator.height;
                    //
                    //
                    //// copy the plot options of the main yAxis to all indicator yAxis
                    //infChart.util.forEach(config.yAxis, function (index, axis) {
                    //    $.extend(axis, config.plotOptions.yAxis);
                    //});
                    //
                    ////// set empty data
                    //infChart.util.forEach(config.series, function (index, series) {
                    //
                    //    if (series.infType == 'base') {
                    //        series.infRefresh = settings.config.refreshBtn;
                    //    } else if (series.infType == 'dummy') {
                    //        hasEmpty = true;
                    //        dummyIds.xPush(series.id);
                    //    }
                    //
                    //    if (!series.data) {
                    //        $.extend(series, {data: []});
                    //    }
                    //    series.infHideClose = settings.config.hideClose;
                    //    series.infHideSettings = typeof settings.config.hideSettings !== 'undefined' ? settings.config.hideSettings :  false;
                    //});
                    //
                    //
                    //if (settings.config.displayAllIntervals && dummyIds.indexOf(infChart.constants.dummySeries.missingId) < 0) {
                    //    config.series.xPush(infChart.util.getDummySeriesConfig(infChart.constants.dummySeries.missingId));
                    //}
                    //
                    //if (settings.config.panToFuture && dummyIds.indexOf(infChart.constants.dummySeries.forwardId) < 0) {
                    //    config.series.xPush(infChart.util.getDummySeriesConfig(infChart.constants.dummySeries.forwardId));
                    //}
                    //
                    //if (settings.config.panToPast && dummyIds.indexOf(infChart.constants.dummySeries.backwardId) < 0) {
                    //    config.series.xPush(infChart.util.getDummySeriesConfig(infChart.constants.dummySeries.backwardId));
                    //}

                    /*
                     //  var dataManager = infChart.dataProviderManager.createDataManager(settings.dataProvider.type, settings.dataProvider.url, settings.dataProvider.source,);
                     var dataManager = infChart.dataProviderManager.createDataManager(settings.dataProvider);*/

                    //IMPORTANT :: need to rearrangeStructure before creating Highcharts.StockChart to fix the issue of displaying chart area under the left tool bar when loading
                    var size = infChart.structureManager.rearrangeStructure(containerId, containerElem[0]);
                    infChart.util.console.debug('chart :: height => ' + (( size && size.height) || "undefined") + ', width => ' + ((size && size.width) || "undefined"));

                    //chart = new H.StockChart(config);
                    //
                    //if (settings.config.mouseWheelController /*&& settings.config.navigator*/) {
                    //    mouseWheelController = new infChart.MouseWheelController(chart);
                    //}

                    chartObj.createHighchartInstance(chartId, chartContainer, config, settings);

                    containerElem.data("infChart", chartObj);

                    //if (settings.config.mouseWheelController /*&& settings.config.navigator*/) {
                    //    mouseWheelController.initialize();
                    //}

                    //$("#" + chartId + " .highcharts-container").append('<div class="tt_panelDiv" style="overflow : hidden; position: absolute; margin: 0px !important; top: 0px; left: 0px; width: 854px; height: 273px; z-index: -10"></div>');
                    //chartObj.setProviderProperties(settings.dataProvider);
//                chartObj.setProperties(settings.config);

                    //_initializeFullScreen();

                    //if (settings.toolbar.enable) {
                    //    infChart.toolbar.createToolbar(containerElem, containerId, settings.toolbar);
                    //}

//                if (infChart.toolbar) {
//                    infChart.toolbar.setDefaultValues(containerElem, settings.config);
//                }
                    _setSymbol(containerId, settings.symbol, settings.config, true);

                    //if (settings.toolbar && settings.toolbar.config) {
                    //    chartObj.setMinMaxOptions(settings.toolbar.config.minMax);
                    //    chartObj.initNews(settings.toolbar.config.news);
                    //    settings.toolbar.config.interval && chartObj.setIntervalOptions(settings.toolbar.config.interval.options);
                    //}
                    //
                    //chartObj.updateMinMax();
                    //chartObj.updatePriceLines();
                }
            }
            catch (ex) {
                infChart.util.console.error(ex);
                //} finally {
                //    if(chartObj.localized) {
                //         to re arrange tool bar after setting the initial values
                //infChart.structureManager.rearrangeStructure(containerId, containerElem[0]);
                //}
            }
        };

        var _setSymbol = function (containerId, symbol, config, reset, setDefaultChartSettings) {
            if (reset) {
                config.setProperties = true;
            }
            if(config.setProperties){
                if (typeof infChart.drawingsManager !== 'undefined') {
                    infChart.drawingsManager.removeAllDrawings(containerId);
                }
            }
            var chart = _charts[containerId];
            if (chart) {
                chart.setSymbol(symbol, true, false, config, setDefaultChartSettings);
            }
            
        };

        //var _updateChartObj = function (containerId, chart, chartId, mouseWheelController, settings) {
        //    if (_charts[containerId]) {
        //        _charts[containerId].resetProperties(chart, mouseWheelController, settings);
        //    } else {
        //        var dataManager = infChart.dataProviderManager.createDataManager(settings.dataProvider);
        //        var chartObj = new infChart.StockChart(containerId, chart, chartId, dataManager, mouseWheelController, settings);
        //        _charts[containerId] = chartObj;
        //    }
        //};

        var _initializeChartComponents = function (containerId, containerElem, settings) {
            if (settings.config.trading && infChart.tradingManager) {
                infChart.tradingManager.createTrader(containerId, settings.dataProvider.tradingService, settings.tradingOptions);
                if (settings.toolbar.enable && settings.toolbar.tradingTb) {
                    infChart.tradingManager.createTradingToolbar(containerElem, containerId, settings.toolbar);
                }
            }

            if (infChart.drawingsManager) {
                infChart.drawingsManager.initialize(containerId, settings.dataProvider.drawingService, settings.config.disableDrawingSettingsPanel);
                if (settings.toolbar.enable && settings.toolbar.leftTb) {
                    infChart.drawingsManager.createDrawingToolbar(containerElem, containerId, settings.toolbar.leftTb, settings.toolbar.config, settings.toolbar.left, settings.config.showDrawingToolbarButtons, false);
                    if(settings.config.favoriteMenuEnabled){
                        infChart.drawingsManager.createDrawingToolbar(containerElem, containerId, settings.toolbar.leftTb, settings.toolbar.config, settings.toolbar.left, settings.config.showDrawingToolbarButtons, true);
                    }
                }
            }

            if (infChart.indicatorMgr) {
                infChart.indicatorMgr.initialize(containerId, settings.indicatorOptions);
            }

            if (infChart.depthManager) {
                var depthToolbarCfg = settings && settings.toolbar && settings.toolbar.config && settings.toolbar.config.depth;
                infChart.depthManager.initialize(containerId, containerElem[0], depthToolbarCfg, settings.config.depth);

            }

            if (settings.config.alert && infChart.alertManager ) {
                infChart.alertManager.initialize(containerId, settings.dataProvider.alertService, settings.alertOptions);
            }

            if (infChart.templatesManager) {
                infChart.templatesManager.initialize(containerId, settings.dataProvider.templateService);
            }
        };

        /**
         * generate chart container and other containers related to chart
         * @param containerElem
         * @param uniqueId
         * @param toolbarProperties
         * @param settings
         * @param config
         * @private
         */
        var _generateContainers = function (containerElem, uniqueId, toolbarProperties, settings, config) {
            containerElem[0].setAttribute("inf-unique-id", uniqueId);

            var toolbarEnabled = toolbarProperties && toolbarProperties.enable === true && infChart.toolbar;
            containerElem.html(infChart.structureManager.getStructure(toolbarEnabled, toolbarProperties));

            var legendHtml = '';
            if (config && config.legend && config.legend.enabled) {
                legendHtml = infChart.structureManager.legend.getStructureHTML();
            }

            containerElem.find('div[inf-container="chart_top"]').html(legendHtml);

            if (toolbarEnabled) {
                infChart.toolbar.setHTML(containerElem, toolbarProperties, uniqueId, settings.config);
                containerElem.find('div[inf-ref="chart_row"]').addClass(toolbarProperties.left ? 'left-toolbar' : 'no-left-toolbar');
                containerElem.addClass("full-screen-container");
            }

            containerElem.find('div[inf-container="chart"]').addClass('mainchart_chart clearfix');
            containerElem.find('div[inf-container="chart"]').attr('id', _getChartId(uniqueId));
            containerElem.addClass("inf-chart");
        };

        /**
         * Generate and return chart container ID
         * @param uniqueId
         * @returns {string}
         * @private
         */
        var _getChartId = function (uniqueId) {
            return uniqueId + '_chart';
        };

        var _getContainerIdFromChart = function (chartId) {

            return chartId.indexOf("_") >= 0 ? chartId.slice(0, chartId.lastIndexOf("_")) : chartId;
        };

        /**
         * Returns chart highstock chart object
         * @param container
         * @returns {*}
         * @private
         */
        var _getChart = function (container) {
            return _charts[container]
        };

        /**
         * Returns all chart objects available
         * @returns {object} array of charts
         * @private
         */
        var _getAllAvailableCharts = function () {
            return _charts;
        };

        var _exportChart = function (containerId, exportType, afterPrintCallback) {
            if (infChart.util.isSafari() && _isFullScreen) {
                _addFullScreenListeners(containerId, "exit", function () {
                    _export(containerId, exportType, afterPrintCallback);
                });
                _exitFullscreen();
            } else {
                _export(containerId, exportType, afterPrintCallback);
            }
        };

        /**
         * export chart as binary data
         * @param {string} containerId - chart id
         * @returns {string} - binary data
         */
        var _exportChartAsBinaryData = function (containerId) {
            var chart = _charts[containerId], exportData;
            if (chart) {
                exportData = chart.exportChartAsBinaryData();
            }
            return exportData;
        };

        var _export = function (containerId, exportType, afterPrintCallback) {
            var chart = _charts[containerId];
            if (chart) {
                switch (exportType) {
                    case 'print':
                        chart.printChart(afterPrintCallback);
                        break;
                    default:
                        chart.exportChartToImage(exportType);
                        break;
                }
            }
        };

        /***
         * Removes the given series from given chart instance
         * @param event
         * @param chartId
         * @param seriesId
         * @param type
         * @private
         */
        var _removeSeries = function (chartId, seriesId, type, event) {
            var contId = _getContainerIdFromChart(chartId);
            var chart = _charts[contId];
            if (chart) {
                chart.removeSeriesFromChart(seriesId, type);
            }
            if (event) {
                event.stopPropagation();
            }
        };

        /***
         * Refresh the given series of given chart instance
         * @param event
         * @param chartId
         * @param seriesId
         * @private
         */
        var _refreshSeries = function (event, chartId, seriesId) {
            _charts[_getContainerIdFromChart(chartId)].refreshSeries(seriesId);
            event.stopPropagation();
        };
        /***
         * Reload given chart instance
         * @param event
         * @param chartId
         * @param seriesId
         * @private
         */
        var _reloadData = function (chartId) {
            var iChart = _charts[_getContainerIdFromChart(chartId)];
            iChart && iChart.reloadData();
        };

        // /**
        //  * Update tool tip of given series
        //  * @param chartId
        //  * @param seriesId
        //  * @param x
        //  * @private
        //  */
        // var _updateSeriesToolTip = function (chartId, seriesId, x) {
        //     _charts[_getContainerIdFromChart(chartId)].updateToolTip(seriesId, x);
        // };

        /**
         * get legend for series
         * @param {object} series - series
         * @returns {string} '' - used this method as labelFormatter in legend(HC). And this method needs to return string value
         * @private
         */
        var _getLegend = function (series) {
            _setLegend(series);
            return '';
        };

        /**
         * set series legend
         * @param {object} series - series
         */
        var _setLegend = function (series) {
            if (infChart.util.isLegendAvailable(series.options)) {
                var chartId = series.chart.renderTo.id,
                    containerId = _getContainerIdFromChart(chartId),
                    seriesId = series.options.id,
                    seriesInfType = series.options.infType,
                    title = _getLegendTitle(chartId, series, seriesInfType),
                    color = series.color,
                    seriesType = series.type,
                    showSettings = !series.options.infHideSettings,
                    showRefresh = seriesInfType == 'base' && series.options.infRefresh,
                    showClose = seriesInfType != 'base',
                    iChart = _getChart(_getContainerIdFromChart(chartId));

                var onSettingsClick, onRefreshClick, onClose, onSymbolTitleLegendClicked;
                if (showSettings) {
                    onSettingsClick = function () {
                        _legendSeriesClick(chartId, seriesId, seriesInfType);
                        if (infChart.toolbar) {
                            infChart.toolbar.setSelectedControls(containerId, "rightPanel", true);
                        }
                    };
                }
                if (showRefresh) {
                    onRefreshClick = function (e) {
                        _refreshSeries(e, chartId, seriesId, seriesInfType);
                    };
                }
                if (showClose) {
                    onClose = function (e) {
                        _removeSeries(chartId, seriesId, seriesInfType, e);
                    };
                }
                if (title === undefined) {
                    title = "";
                }
                onSymbolTitleLegendClicked = function(event) {
                    var ichart = _charts[_getContainerIdFromChart(chartId)];
                    ichart._fireRegisteredMethod('onClickLegendSymbolTitle', [event]);
                }
                infChart.structureManager.legend.setLegendForSeries(containerId, seriesId, seriesInfType, title, color, seriesType, onSettingsClick, onRefreshClick, onClose, iChart.isTooltipEnabled(), onSymbolTitleLegendClicked);
            }
        };

        /**
         * get description to show in legend
         * @param chartId
         * @param series series object
         * @param type series type
         * @returns {*}
         * @private
         */
        var _getLegendTitle = function (chartId, series, type) {
            var containerId = _getContainerIdFromChart(chartId);
            var title;
            if (type === 'indicator') {
                title = infChart.indicatorMgr.getLegendTitle(containerId, series);
            } else {
                var chart = _charts[containerId];
                if (chart) {
                    title = chart.getLegendTitle(series);
                } else {
                    title = series.options.name;
                }
            }
            
            return  (!title) ? "" : title;
        };

        /**
         * update cross hair line
         * @param chartId
         * @param x
         * @param y
         * @param points
         * @returns {*}
         * @private
         */
        var _updateCrosshair = function (chartId, x, y, points) {
            return _charts[_getContainerIdFromChart(chartId)].updateCrosshair(x, y, points);
        };

        /**
         * update cross hair line
         * @param chartId
         * @param x
         * @param y
         * @param points
         * @returns {*}
         * @private
         */
        var _updateCrosshairFromToolTip = function (chartId, x, y, points) {
            return _charts[_getContainerIdFromChart(chartId)].updateCrosshairFromToolTip(x, y, points);
        };

        /**
         * set cross hair visibility
         * @param {Highcharts} chart - highcharts obj
         * @private
         */
        var _chartMouseOutEvent = function (chart) {
            var chartId = chart.renderTo.id,
                ichart = _charts[_getContainerIdFromChart(chartId)];

            ichart.showCrosshair(false);
            if (ichart._hasRegisteredMethod('onChartMouseOut')) {
                ichart._fireRegisteredMethod('onChartMouseOut');
            }
            _updateTooltipToLastPoint(ichart);
        };

        /**
         * Executes when mouse is leaving a a series
         * @param {Highcharts} chart - highcharts obj
         * @param {string} eventType - event type
         * @param {object} target - target object of the event type
         * @private
         */
        var _seriesMouseOutEvent = function (chart, eventType, target) {
            var chartId = chart.renderTo.id,
                ichart = _charts[_getContainerIdFromChart(chartId)];

            if (eventType == "series") {
                ichart.onSeriesMouseOut(target)
            }
        };

        /**
         * Execute on mouse over of a series
         * @param chart
         * @param series
         * @returns {*}
         * @private
         */
        var _seriesMouseOverEvent = function (chart, series) {
            var chartId = chart.renderTo.id,
                ichart = _charts[_getContainerIdFromChart(chartId)];

            ichart.onSeriesMouseOver(series);
        };

        /**
         * Returns the list of point aligned with given  point or point array
         * @param pointObj
         * @returns {Array}
         * @private
         */
        var _getPointsOfToolTip = function (pointObj) {
            var point = pointObj.points && pointObj.points[0] && pointObj.points[0].point || pointObj.point,
                series = point && point.series, basePoint;
            var points = [], pointHash = {};
            if (pointObj.points && pointObj.points.length > 0) {
                infChart.util.forEach(pointObj.points, function (indx, value) {
                    pointHash[value.series.index] = indx;
                    points.xPush(value.point);
                    if (value.series.options.infType == "base") {
                        basePoint = value.point ? value.point : value;
                    }

                });
            } else if (point) {
                points.xPush(point);
            }
            /*if (point && series.options.type == "flags" && series.options.type == "infsignal"  ) {
             series.chart.series.forEach(function (sr, indx) {
             if (pointHash[sr.index] == undefined && sr.index != series.index && sr.name.toLowerCase().indexOf("navigator") < 0) {
             var pointIdx = sr.processedXData.indexOf(pointObj.x);
             if (pointIdx != -1 && sr.points && sr.points[pointIdx]) {
             points.push(sr.points[pointIdx]);
             }
             }
             });
             } else */
            if (point && (
                (series.chart.options.navigator.enabled && points.length != series.chart.series.length - series.chart.options.navigator.series.length ) ||
                (!series.chart.options.navigator.enabled && points.length != series.chart.series.length) )) {
                infChart.util.forEach(series.chart.series, function (indx, sr) {
                    if (sr && pointHash[sr.index] == undefined && sr.index != series.index && sr.name.toLowerCase().indexOf("navigator") < 0) {
                        var pointIdx = sr.processedXData && sr.processedXData.indexOf(pointObj.x);
                        if (pointIdx >= 0 && sr.points && sr.points[pointIdx] && !sr.points[pointIdx].isNull) {
                            points.xPush(sr.points[pointIdx]);
                            if (sr.options.infType == "base") {
                                basePoint = sr.points[pointIdx];
                            }
                        } else if (sr.points && basePoint && basePoint.series.hasGroupedData && basePoint.dataGroup) {
                            var basePointGrp = basePoint.dataGroup;
                            for (var i = basePointGrp.start; i < (basePointGrp.start + basePointGrp.length); i++) {
                                var srIndx = sr.processedXData && sr.processedXData.indexOf(basePoint.series.xData[i]);
                                if (srIndx >= 0 && !sr.points[srIndx].isNull) {
                                    points.xPush(sr.points[srIndx]);
                                }
                            }
                        }
                    }
                });
            }
            return points;
        };

        /**
         * Update the tooltip data of symbols with the last point
         * @private
         */
        var _updateTooltipToLastPoint = function (chart, force) {
            chart && chart.updateTooltipToLastPoint(force);
        };

        /**
         * get value for tooltips for given point
         * @param pointObj tooltip point
         * @returns {*}
         * @private
         */
        var _getTooltipValue = function (pointObj) {
            var chart, baseSymbolData = {}, compareSymData = {}, indicatorData = {};

            var points = _getPointsOfToolTip(pointObj);

            if (points) {
                infChart.util.forEach(points, function (i, point) {
                    if (typeof chart === 'undefined') {
                        chart = _charts[_getContainerIdFromChart(point.series.chart.renderTo.id)];
                    }
                    if (point.series) {
                        switch (point.series.options.infType) {
                            case 'news':
                                infChart.util.console.log(point);
                                //newsHtml.push(chart.getNewsTooltipValue(point));
                                break;
                            case 'flags':
                                infChart.util.console.log(point);
                                //newsHtml.push(chart.getFlagTooltipValue(point));
                                break;
                            case 'indicator':
                                if (!point.series.options.hideToolTip) {
                                    indicatorData[point.series.options.id] = chart.getIndicatorTooltipValue(point);
                                }
                                break;
                            case 'compare':
                                compareSymData[point.series.options.id] = chart.getTooltipValue(point, false);
                                break;
                            case 'base':
                                baseSymbolData = chart.getTooltipValue(point, true);
                                break;
                            case 'dummy':
                                if (point.series.options.id == infChart.constants.dummySeries.forwardId) {
                                    var lastPoint = chart.getLastPoint();
                                    if (lastPoint) {
                                        baseSymbolData = chart.getTooltipValue(chart.getLastPoint(), true);
                                    }
                                }
                                break;
                            default :
                                break;

                        }
                    }
                });
            }
            return {
                base: baseSymbolData,
                compare: compareSymData,
                indicator: indicatorData
            };
        };

        /**
         * get value for tooltips for given point
         * @param tooltipData tooltip data
         * @returns {*}
         * @private
         */
        var _getTooltipHTML = function (tooltipData) {
            var baseHtmlMap = {};
            if (tooltipData.base && tooltipData.base.formatted !== 'undefined') {
                var isPositiveChange;
                if (tooltipData.base.raw && tooltipData.base.raw.open && tooltipData.base.raw.close) {
                    isPositiveChange = tooltipData.base.raw.open < tooltipData.base.raw.close;
                }

                tooltipData.base.displayItems &&
                infChart.util.forEach(tooltipData.base.displayItems, function (i, value) {
                    baseHtmlMap[value] = infChart.structureManager.tooltip.getTooltipValueItemHtml(value, tooltipData.base.formatted[value], isPositiveChange);
                });

            }

            var compareSymHtmlMap = {};
            if (tooltipData.compare) {
                for (var compareSymbol in tooltipData.compare) {
                    if (tooltipData.compare.hasOwnProperty(compareSymbol)) {
                        var compareData = tooltipData.compare[compareSymbol];
                        if (compareData && compareData.formatted !== 'undefined') {
                            var htmlMap = {};
                            var isComparePositiveChange;
                            /*if (compareData.raw && compareData.raw.open && compareData.raw.close) {
                             isComparePositiveChange = compareData.raw.open < compareData.raw.close;
                             }*/
                            compareData.displayItems && infChart.util.forEach(compareData.displayItems, function (i, value) {
                                if (value == "volume") {
                                    htmlMap[value] = infChart.structureManager.tooltip.getTooltipValueItemHtml(value, compareData.formatted[value], isComparePositiveChange, false, true);
                                } else {
                                    htmlMap[value] = infChart.structureManager.tooltip.getTooltipValueItemHtml(value, compareData.formatted[value], isComparePositiveChange, true);
                                }
                            });
                            compareSymHtmlMap[compareSymbol] = htmlMap;
                        }
                    }
                }
            }

            var indicatorHtmlMap = {};
            if (tooltipData.indicator) {
                for (var indicator in tooltipData.indicator) {
                    if (tooltipData.indicator.hasOwnProperty(indicator)) {
                        var indicatorData = tooltipData.indicator[indicator];
                        if (indicatorData && typeof indicatorData.formatted !== 'undefined') {
                            if (indicatorData.formatted.time) {
                                indicatorHtmlMap['time'] = infChart.structureManager.tooltip.getIndicatorTooltipValueItemHtml('time', indicatorData.formatted.time);
                            }
                            if (indicatorData.formatted.value) {
                                indicatorHtmlMap[indicatorData.label] = infChart.structureManager.tooltip.getIndicatorTooltipValueItemHtml(indicatorData.label, indicatorData.formatted.value, indicatorData.color);
                            }
                        }
                    }
                }
            }

            //infChart.structureManager.getNewsTooltipValueItemHtml(this.getNewsTooltipValue(point).formatted);

            //var tooltipData = this.getFlagToolTipValue(point);
            //return infChart.structureManager.getFlagsTooltipValueItemHtml(tooltipData.formatted, tooltipData.color);

            return {
                baseHTML: baseHtmlMap,
                compareSymHTML: compareSymHtmlMap,
                indHTML: indicatorHtmlMap
            };
        };

        var _localize = function (referenceId) {
            infChart.langManager.localize(_getLocalizationOptions(referenceId));
        };

        var _getLocalizationOptions = function (referenceId) {
            return $.extend(_localizationOptions, {referenceId: referenceId});
        };

        ////todo : remove
        //var _setLanguage = function (lang) {
        //    if (_supportedLanguages.indexOf(lang) >= 0) {
        //        _localizationOptions.language = lang;
        //        _localize();
        //    }
        //};

        /**
         * rearrange structure after localize
         * @param referenceId
         * @private
         */
        var _afterLocalize = function (referenceId) {

            function rearrangeStructure(uniqueId) {
                _charts[uniqueId].localized = true;
                var containerElem = $('#' + uniqueId);
                infChart.structureManager.rearrangeStructure(uniqueId, containerElem[0]);
            }

            if (referenceId) {
                if (_charts[referenceId]) {
                    rearrangeStructure(referenceId);
                }
            } else {
                for (var uniqueId in _charts) {
                    if (_charts.hasOwnProperty(uniqueId)) {
                        rearrangeStructure(uniqueId);
                    }
                }
            }
        };

        var _legendSeriesClick = function (chartId, seriesId, infType) {
            if (infType === 'indicator') {
                infChart.indicatorMgr.indicatorLegendClick(_getContainerIdFromChart(chartId), seriesId);
            } else {
                _charts[_getContainerIdFromChart(chartId)].seriesLegendClick(seriesId, infType);
            }
        };

        var _afterRedraw = function (chartId) {
            var iChart = _charts[_getContainerIdFromChart(chartId)];

            if (iChart && iChart.afterRedraw && iChart.isAfterRedrawRequired()) {
                setTimeout(function () {
                    iChart.afterRedraw(chartId);
                }, 1);
            }
        };

        /**
         * Save Chart as a template
         * @param chartId
         * @param name
         * @param type
         * @private
         */
        var _saveTemplate = function (chartId, name, type) {
            var containerId = _getContainerIdFromChart(chartId);
            var properties = _getProperties(containerId, type);
            var templates = _getTemplates(type, chartId);
            templates = (templates) ? templates : {};
            name = (type == infChart.constants.fileTemplateTypes.file) ? containerId : name;
            templates[name] = properties;
            infChart.templatesManager.saveChartTemplates(chartId, type, templates);
        };

        var _getProperties = function (containerId, type) {
            var properties = {}, chart = _charts[containerId];
            if (chart) {
                properties = chart.getProperties();
                var indicators = [];
                if (typeof infChart.indicatorMgr !== "undefined") {
                    indicators = infChart.indicatorMgr.getAllIndicatorProperties(containerId);
                }
                properties.indicators = indicators;
                if (typeof infChart.drawingsManager !== "undefined") {
                    if (type == infChart.constants.fileTemplateTypes.all) {
                        properties.drawings = infChart.drawingsManager.getAllDrawingProperties(containerId);
                    }
                    properties.showDrawingToolbarButtons = infChart.drawingsManager.getDrawingToolbarProperties(containerId);
                }
                if (typeof infChart.depthManager !== "undefined") {
                    properties.depth = infChart.depthManager.getProperties(containerId);
                }
            }
            return properties;
        };

        var _updateProperties = function (containerId, properties, setDefaultChartSettings) {
            var chart = _charts[containerId];
            var settingsProperties = infChart.util.merge({}, infChart.settings.config, properties); //CCA-3038
            _chartCustomSettings[containerId].settings.config = settingsProperties;
            if (chart) {
                if (typeof infChart.drawingsManager !== 'undefined') {
                    infChart.drawingsManager.removeAllDrawings(containerId);
                }
                chart.updateProperties(settingsProperties, setDefaultChartSettings);
                if (infChart.depthManager) {
                    var container = $('#' + containerId)[0];
                    var resizeRequired = infChart.depthManager.setProperties(containerId, infChart.structureManager.getContainer(container, 'chartContainer'), properties.depth);
                    if (resizeRequired) { //&& !this.isFirstLoadInprogress()
                        chart.resizeChart();
                    }
                }
            }
        };

        /**
         * Load given template
         * @param chartId
         * @param name
         * @param type
         * @param template
         * @private
         */
        var _loadTemplate = function (chartId, name, type, template) {
            var containerId = _getContainerIdFromChart(chartId),
                chart = _charts[containerId],
                customSettings = _chartCustomSettings[containerId];

            if (!template) {
                if (type === infChart.constants.fileTemplateTypes.file) {
                    name = containerId;
                }
                var templates = _getTemplates(type, chartId);
                template = (templates) ? templates[name] : undefined;
            }
            

            if (template) {
                // var toolbarEnabled = (typeof infChart.toolbar !== 'undefined');
                // var navigator = template.navigator;
                // template.navigator = false;
                // template = infChart.util.merge({}, infChart.settings.config, template);

                var properties = $.extend(true, {}, chart.settings, {
                    config: template,
                    symbol: template.useMainSymbol ? template.mainSymbol : chart.symbol
                });

                if(chart.interval){
                    properties.config.interval = chart.interval;
                }

                if(chart.period){
                    properties.config.period = chart.period;
                }

                if (chart.mouseWheelController) { //CCA-3353
                    properties.config.mouseWheelController = true;
                }

                if (type !== infChart.constants.fileTemplateTypes.all) {
                    properties.config.drawings = infChart.drawingsManager.getAllDrawingProperties(containerId);
                }

                var currentIndicators = infChart.indicatorMgr.getAllIndicatorProperties(chartId);
                var currentIndicatorTypes = currentIndicators.map(indicator=>indicator.type);                
                var templateIndicatorTypes = template.indicators.map(indicator=>indicator.type);

                var indicators = template.indicators;

                if (template.hasOwnProperty("replaceIndicators")) {
                    if (!template.replaceIndicators) {
                        var commonIndicators = _.intersection(currentIndicatorTypes, templateIndicatorTypes);
                        var filteredCurrentIndicators = currentIndicators.filter(function (indicator) {
                            return !commonIndicators.includes(indicator.type);
                        });
                        indicators = [].concat(filteredCurrentIndicators, template.indicators);
                    }
                } else {
                    if (currentIndicators.length === 0 || template.indicators.length === 0) {
                        indicators = [].concat(currentIndicators, template.indicators);
                    }
                }
                
                properties.config.indicators = indicators;

                var currentCompareSymbols = chart.getProperties().compareSymbols;
                var allCompareSymbols = [].concat(currentCompareSymbols, template.compareSymbols);
                properties.config.compareSymbols = allCompareSymbols;

                // var xAxis, yAxis, series;
                // if ((chart.chart && chart.chart.userOptions && chart.chart.userOptions.xAxis)) {
                //     xAxis = infChart.util.merge({}, infChart.config.xAxis, chart.chart.userOptions.xAxis[0]);
                // }
                // if ((chart.chart && chart.chart.userOptions && chart.chart.userOptions.yAxis)) {
                //     yAxis = [];
                //     for (var i = 0, iLen = infChart.config.yAxis.length; i < iLen; i++) {
                //         yAxis[i] = infChart.util.merge({}, infChart.config.yAxis[i], chart.chart.userOptions.yAxis[i]);
                //     }
                // }
                // series = (chart.chart && chart.chart.userOptions.series) ? chart.chart.userOptions.series[0] : util({}, infChart.config.series[0]);

                //var config = infChart.util.merge({}, infChart.config, customSettings.config);//(chart.chart && chart.chart.userOptions) || {}
                var config = $.extend(true, {}, infChart.config, customSettings.config);

                // config.xAxis = xAxis;
                // config.yAxis = yAxis;
                // config.series = [series];

                // config.navigator.enabled = false;
                // template.navigatorHeight = chart.settings.config.navigatorHeight;

                //chart.reLoading = true;
                chart.destroy(true);

                chart._setDefaultProperties(true);

                // var containerId = _getContainerIdFromChart(chartId);
                //chart.forcedLoad = true;
                _createChart($('#' + containerId), containerId, config, properties);
                //chart.reLoading = false;
                //chart.forcedLoad = false;
                //  if (navigator) {
                // TODO ::there is an issue when loading a template with navigator and then hiding the navigator and changing the periods. this
                // fix has been done to avoid loading templated with the navigator. This is not a proper solution. Need to address the root course later
                //_toggleNavigator(chartId);
                // }
                chart._onPropertyChange("loadTemplate",type);
            }
            
        };

        /**
         * returns template saved by given name
         * @param type
         * @returns {*}
         * @private
         */
        var _getTemplates = function (type, chartId) {
            return infChart.templatesManager.getChartTemplates(chartId, type);
        };

        /**
         * returns an array of all the saved templates for the given type
         * @param type
         * @returns {Array}
         * @private
         */
        var _getTemplateNames = function (type, chartId) {
            var templates = _getTemplates(type, chartId);
            var templateNames = [];
            if (templates) {
                infChart.util.forEach(templates, function (i) {
                    templateNames.xPush(i);
                });
            }
            return templateNames;
        };

        /**
         * Delete given template from chart
         * @param container
         * @param textName
         * @param type
         * @private
         */
        var _deleteTemplate = function (container, textName, type) {
            var templates = _getTemplates(type, container);
            if (templates) {
                var name;
                switch (type) {
                    case infChart.constants.fileTemplateTypes.file:
                        name = container;
                        break;
                    default :
                        name = textName;
                        break;
                }
                if (templates[name]) {
                    delete templates[name];
                    infChart.templatesManager.saveChartTemplates(container, type, templates);
                }
            }
        };

        // /**
        //  * Show/ hide navigator
        //  * @param chartId
        //  * @returns {boolean}
        //  * @private
        //  */
        // var _toggleNavigator = function (chartId, isSizeChange, isPropertyChange) {
        //     var containerId = _getContainerIdFromChart(chartId);
        //     var chart = _charts[containerId];
        //     var enabled = (isSizeChange) ? chart.chart.options.navigator.enabled : !(chart.chart.options.navigator.enabled);

        //     if (chart) {

        //         var navigatorHeight = chart.settings.config.navigatorHeight ? chart.settings.config.navigatorHeight :
        //             chart.navigator ? chart.navigator.height : infChart.util.getNavigatorHeight(chart.chart.chartHeight, chart.chart.options);

        //         chart.chart.update({navigator: {enabled: enabled, height: navigatorHeight}}, true);

        //         if (chart.rangeSelectorEl) {
        //             if (enabled) {
        //                 chart.rangeSelectorEl.show();
        //                 chart.adjustRangeSelectorMinMax();
        //                 chart.setRangeSelectorValues();
        //             } else {
        //                 chart.rangeSelectorEl.hide();
        //             }
        //         } else {
        //             chart.setRangeSelectorValues();
        //         }

        //         if (isPropertyChange) {
        //             chart._onPropertyChange("navigator");
        //         }
        //     }
        //     return enabled;
        // };

        var _getLabel = function (key) {
            return infChart.langManager.getLabel(_getLocalizationOptions().language, key)
        };

        var _removeChart = function (containerId) {
            var chart = _charts[containerId];
            if (chart) {
                _removeChartComponents(containerId);
                chart.destroy();
                delete _chartCustomSettings[containerId];
                delete _charts[containerId];
                $("[inf-unique-id='" + containerId + "']").removeData("infChart");
            }
        };

        var _removeChartComponents = function (containerId) {
            if (infChart.indicatorMgr) {
                infChart.indicatorMgr.destroy(containerId);
            }
            if (infChart.drawingsManager) {
                infChart.drawingsManager.destroy(containerId);
            }
            if (infChart.tradingManager) {
                infChart.tradingManager.destroyTrader(containerId);
            }
            if (infChart.depthManager) {
                infChart.depthManager.destroy(containerId);
            }
        };

        var _getMaxZoomRange = function (hchart) {
            var chartId = hchart.renderTo.id,
                iChart = _charts[_getContainerIdFromChart(chartId)];
            return iChart && iChart.getMaxZoomRange();

        };

        /**
         * Returns the maximums zoom range in pixels which will be benifitted in non-linear axes
         * @param {Highcharts} hchart highcharts object
         * @returns {number|undefined} range in pixels
         */
        var getMaxZoomRangePx = function (hchart) {
            var chartId = hchart.renderTo.id,
                iChart = _charts[_getContainerIdFromChart(chartId)];
            return iChart && iChart.getMaxZoomRangePx();
        };

        /**
         * Returns the time ticks map of the chart
         * @param {Highcharts} hchart highcharts object
         * @returns {object} time map
         */
        var getAllTimeTicks = function (hchart) {
            var chartId = hchart.renderTo.id,
                iChart = _charts[_getContainerIdFromChart(chartId)];
            return iChart && iChart.getAllTimeTicks();
        };

        /**
         * Returns the maximums number of points that can be shown in the current display space
         * @param {Highcharts} hchart highcharts object
         * @returns {number|undefined} number of points
         */
        var getMaxPointCount = function (hchart) {
            var chartId = hchart.renderTo.id,
                iChart = _charts[_getContainerIdFromChart(chartId)];
            return iChart && iChart._getMaxPointCount();
        };

        /**
         * Retusn whehter the chart is linear or not
         * @param {Highcharts} hchart highcharts object
         * @returns {boolean} linearity
         */
        var isLinearData = function (hchart) {
            var chartId = hchart.renderTo.id,
                iChart = _charts[_getContainerIdFromChart(chartId)];
            return iChart && iChart.isLinearData();
        };

        //region =================== Highcharts Events/Methods==========================================================
        /**
         * Handles the chart click event here
         * @param hchart
         * @param event
         * @private
         */
        var _chartClick = function (hchart, event) {

            var chartId = hchart.renderTo.id,
                containerId = _getContainerIdFromChart(chartId),
                iChart = _charts[containerId],
                zoom = false;

            if (event.point) {
                zoom = iChart.pointClick(event.point);
            }

            if (zoom) {
                // Zoom in on ctrl + mouse click
                if (event.ctrlKey || event.metaKey) {
                    var zoomInExtremes = iChart.getZoomExtremesOnCtrlClick(event);
                    if (zoomInExtremes.min && zoomInExtremes.max) {
                        _setUserDefinedXAxisExtremes(chartId, zoomInExtremes.min, zoomInExtremes.max, true);
                    }
                }
                // Zoom out on alt + mouse click
                else if (event.altKey) {
                    var zoomOutExtremes = iChart.getZoomExtremes(false);
                    if (zoomOutExtremes.min && zoomOutExtremes.max) {
                        _setUserDefinedXAxisExtremes(chartId, zoomOutExtremes.min, zoomOutExtremes.max, true);
                    }
                    // iChart.zoomOutOnAltlClick(event);
                }
            }
        };

        /**
         * Set positions of the tooltip
         * @param chart
         * @param labelWidth
         * @param labelHeight
         * @param point
         * @returns {{x: *, y: (number|*)}}
         * @private
         */
        var _tooltipPositioner = function (chart, labelWidth, labelHeight, point) {

            var tooltipX,
                tooltipY;

            if (point.plotX > chart.plotWidth - labelWidth) {
                tooltipX = chart.plotLeft;
            } else {
                tooltipX = chart.plotLeft + chart.plotWidth - labelWidth;
            }

            tooltipY = chart.plotTop + chart.plotHeight - labelHeight;

            return {
                x: tooltipX,
                y: tooltipY
            };
        };

        /**
         * Creates the tooltip
         * @param pointObj
         * @param tooltip
         * @returns {*}
         * @private
         */
        var _tooltipFormatter = function (pointObj, tooltip) {
            var chartId = tooltip.chart.renderTo.id,
                containerId = _getContainerIdFromChart(chartId),
                chart = _getChart(containerId);

            if (!chart) {
                return;
            }

            if (chart.tooltip ) {
                if(!chart.isUserInteractionInprogress()) {
                    chart.unRegisterLastPointTooltipEvents();
                    var tooltipObj = _getTooltipValue(pointObj), tooltipHtml = _getTooltipHTML(tooltipObj),
                        container = $('#' + containerId)[0];
                    infChart.structureManager.legend.updateSymbolDataInLegend($(infChart.structureManager.getContainer(container, 'chart_top')), tooltipHtml.baseHTML, tooltipHtml.compareSymHTML);
                    return infChart.settings.indicatorOptions.disableIndicatorToolTip ? '' : infChart.structureManager.tooltip.getIndicatorTooltipHtml(tooltipHtml.indHTML);
                } else {
                    return "";
                }
            }
        };

        /**
         * Returns the xAxis' tick positions if specific logic available for the period or interval
         * @param axis
         * @param min
         * @param max
         * @returns {*}
         * @private
         */
        var _xAxisTickPositioner = function (axis, min, max) {

            var chartId = axis.chart.renderTo.id,
                ichart = _getChart(_getContainerIdFromChart(chartId));

            if (ichart) {
                return ichart.xAxisTickPositioner(axis, min, max);
            }
        };

        /**
         * Returns the yAxis' tick positions
         * @param axis
         * @param min
         * @param max
         * @returns {*}
         * @private
         */
        var _yAxisTickPositioner = function (axis, min, max) {

            var chartId = axis.chart.renderTo.id,
                ichart = _getChart(_getContainerIdFromChart(chartId));

            if (ichart) {
                return ichart.yAxisTickPositioner(axis, min, max);
            }
        };

        /**
         * Return the x Axis label for given value
         * @param labelObj
         * @private
         */
        var _xAxisLabelFormatter = function (labelObj) {

            var chartId = labelObj.chart.renderTo.id,
                ichart = _getChart(_getContainerIdFromChart(chartId));

            if (ichart) {
                return ichart.getXAxisLabel(labelObj);
            }
        };

        /**
         * Return the y Axis label for given value
         * @param labelObj
         * @param isAxis
         * @private
         */
        var _yAxisLabelFormatter = function (labelObj, isAxis) {

            var chartId = labelObj.chart.renderTo.id,
                ichart = _getChart(_getContainerIdFromChart(chartId));

            if (ichart) {
                return ichart.getYAxisLabel(labelObj, isAxis);
            }
        };

        /**
         * get cross hair label
         * @param {string} chartContainerId - container id
         * @param {number} value - y value
         * @returns {string} formatted label
         */
        var _getMainYAxisCrosshairLabel = function(chartContainerId, value){
            var labelValue = "";
            if(!isNaN(value)){
                var chartId = _getContainerIdFromChart(chartContainerId), 
                    chart = _getChart(chartId), labelValue;
                if(chart){
                    if(infChart.alertManager && infChart.alertManager.overrideCrosshairLabelValue(chartId)){
                        labelValue = infChart.alertManager.getCrosshairLabelValue(chartId, value);
                    } else{
                        labelValue = chart.formatValue(value, chart.getMainSeries().options.dp, undefined, true, false);
                    }
                }
            }
            return labelValue;
        };

        /**
         * Returns y Label for given actual y Value
         * @param hchart
         * @param yValue
         * @param isAxisLabel
         * @returns {*}
         * @private
         */
        var _getYLabel = function (hchart, yValue, isAxisLabel) {

            var chartId = hchart.renderTo.id,
                ichart = _getChart(_getContainerIdFromChart(chartId));

            if (ichart) {
                return ichart.getYLabel(yValue, isAxisLabel);
            }
        };

        /**
         * Executes after y axis extremes are set by highcharts
         * @param chartId
         * @param yAxis
         * @private
         */
        var _afterYSetExtremes = function (chartId, yAxis) {
            var containerId = _getContainerIdFromChart(chartId),
                chartObj = _getChart(containerId),
                ext = yAxis.getExtremes();

            chartObj.afterYSetExtremes(ext);
        };

        /**
         * Executes after x axis extremes are set by highcharts
         * @param chartId
         * @param xAxis
         * @private
         */
        var _afterXSetExtremes = function (chartId, xAxis) {
            var containerId = _getContainerIdFromChart(chartId),
                chartObj = _getChart(containerId),
                ext = xAxis.getExtremes();

            chartObj.afterSetExtremes(ext);
        };

        // /**
        //  * Executes before scaling starts when dragging the chart container
        //  * @param chartId
        //  * @private
        //  */
        // var _beforeScalingAxis = function (chartId) {
        //     var chartObj = _getChart(_getContainerIdFromChart(chartId));
        //     _pauseScaleDrawings(chartId);
        //     chartObj.beforeScalingAxis();
        // };

        // /**
        //  * Executes after scaling the chart by dragging the chart container
        //  * @param chartId
        //  * @param args
        //  * @private
        //  */
        // var _afterScalingAxis = function (chartId, args) {
        //     var chartObj = _getChart(_getContainerIdFromChart(chartId));
        //     _unPauseScaleDrawings(chartId);
        //     chartObj.afterScalingAxis(args);
        // };

        var _isDefaultXAxisExtremes = function (chartId) {
            //var chartObj = _getChart(_getContainerIdFromChart(chartId));
            //return ext ? chartObj.isDefaultXAxisExtremes(ext) : false;
            var status = false, containerId = _getContainerIdFromChart(chartId);
            var chart = _charts[containerId];
            if (chart) {
                status = chart.isUserDefinedXAxisExtremes();
            }
            return !status || (chart && chart.isDefaultXAxisExtremes());
        };

        var _setUserDefinedXAxisExtremes = function (chartId, userMin, userMax, redraw, userInteraction) {
            var containerId = _getContainerIdFromChart(chartId);
            var chart = _charts[containerId];
            if (chart) {
                if (typeof userInteraction === "undefined") {
                    userInteraction = true;
                }
                chart.setXAxisExtremes(userMin, userMax, redraw, userInteraction);
                if (userInteraction) {
                    chart._onPropertyChange("userXAxisExtremes", {userMin: userMin, userMax: userMax});
                }
            }
        };

        var _resetUserDefinedXAxisExtremes = function (chartId) {
            var containerId = _getContainerIdFromChart(chartId);
            var chart = _charts[containerId];
            if (chart) {
                chart.resetXAxisExtremesToDefault();
                chart._onPropertyChange("resetUserXAxisExtremes");
            }
        };

        var _isDefaultYAxisExtremes = function (chartId) {
            var status = false, containerId = _getContainerIdFromChart(chartId);
            var chart = _charts[containerId];
            if (chart) {
                status = chart.isUserDefinedYAxisExtremes();
            }
            return !status;
        };

        /**
         * set y axis extremes by zooming
         * mouse wheel or scalable axis
         * @param {string} chartId unique chart id
         * @param {number} userMin new min
         * @param {number} userMax new max
         * @param {boolean} redraw redraw required or not
         * @param {boolean|undefined} isUserInteraction user interacted action or not
         */
        var _setUserDefinedYAxisExtremes = function (chartId, userMin, userMax, redraw, isUserInteraction) {
            var containerId = _getContainerIdFromChart(chartId);
            var chart = _charts[containerId];
            if (chart) {
                chart.setUserDefinedYAxisExtremes(userMin, userMax, redraw, isUserInteraction);
                if (isUserInteraction) {
                    chart._onPropertyChange("userYAxisExtremes", {userMin: userMin, userMax: userMax});
                }
            }
        };

        var _resetUserDefinedYAxisExtremes = function (chartId, redraw) {
            var containerId = _getContainerIdFromChart(chartId);
            var chart = _charts[containerId];
            if (chart) {
                chart.resetYAxisExtremes(redraw);
                chart._onPropertyChange("resetUserYAxisExtremes");
            }
        };

        //endregion

        /**
         * Method to get actual min/max of the given series or whole chart
         * @param chartId
         * @param seriesId
         * @private
         */
        var _getSeriesActualExtremes = function (chartId, seriesId) {

            var containerId = infChart.manager.getContainerIdFromChart(chartId),
                chartObj = _getChart(containerId);
            return chartObj && chartObj.getSeriesActualExtremes(seriesId);
        };

        //endregion =================== Highcharts Events/Methods==========================================================

        var _enableMouseWheel = function (chartId, enable) {
            var containerId = _getContainerIdFromChart(chartId);
            var chart = _charts[containerId];
            if (chart) {
                chart.setMouseWheel(enable);
            }
        };

        //region full screen

        var _bindEnterKeyToCancelFullScreen = function (e) {
            switch (e.keyCode) {
                case 13: // ENTER. ESC should also take you out of fullscreen by default.
                    e.preventDefault();
                    _exitFullscreen(); // explicitly go out of fs.
                    break;
                /*case 70: // f
                 enterFullscreen();
                 break;*/
            }
        };

        var _onFullScreenEnter = function (event) {
            infChart.util.console.log("onFullScreenEnter*******");
            _isFullScreen = true;
            document.onwebkitfullscreenchange = _onFullScreenExit;
            document.onmozfullscreenchange = _onFullScreenExit;
            document.onfullscreenchange = _onFullScreenExit;
            document.onmsfullscreenchange = _onFullScreenExit;

            var targetEl;
            if (document.webkitFullscreenElement) {
                targetEl = document.webkitFullscreenElement;
            } else if (document.mozFullScreenElement) {
                targetEl = document.mozFullScreenElement;
            } else if (document.msFullscreenElement) {
                targetEl = document.msFullscreenElement;
            } else {
                targetEl = event.target;
            }

            document.addEventListener('keydown', _bindEnterKeyToCancelFullScreen, false);

            _sizeBeforeFullScreen.height = targetEl.style.height;
            $(targetEl).css('height', "100%");
            _resizeChartOnFullScreen(targetEl);
            if (_fsListeners['enter'].length > 0) {
                _fsListeners['enter'].forEach(function (callback) {
                    callback();
                });
                _fsListeners['enter'] = [];
            }
            if (infChart.toolbar) {
                infChart.toolbar.setSelectedControls(targetEl.id, 'full-screen', true);
            }
        };

        var _resizeChartOnFullScreen = function (container) {
            var chartContainerEl = $(container);
            if (!isNaN(chartContainerEl.data("infFSTimer"))) {
                clearTimeout(chartContainerEl.data("infFSTimer"));
                chartContainerEl.removeData("infFSTimer")
            }
            chartContainerEl.data("infFSTimer", setTimeout(function () {
                var chart = _getChart(container.id);
                chart.resizeChart();
            }, 200));
        };

        // Called whenever the browser exits fullscreen.
        var _onFullScreenExit = function (event) {
            infChart.util.console.log("onFullScreenExit*******");
            _isFullScreen = false;//chart is in full screen
            var targetEl;
            if (document.webkitFullscreenElement) {
                targetEl = document.webkitFullscreenElement;
            } else if (document.mozFullScreenElement) {
                targetEl = document.mozFullScreenElement;
            } else if (document.msFullscreenElement) {
                targetEl = document.msFullscreenElement;
                //} else if (document.infFullScreenEl) {
                //    targetEl = document.infFullScreenEl;
            } else {
                targetEl = event.target;
            }
            document.removeEventListener('keydown', _bindEnterKeyToCancelFullScreen, false);

            $(targetEl).css('height', _sizeBeforeFullScreen.height);
            _sizeBeforeFullScreen = {};
            _resizeChartOnFullScreen(targetEl);
            if (_fsListeners['exit'].length > 0) {
                _fsListeners['exit'].forEach(function (callback) {
                    callback();
                });
                _fsListeners['exit'] = [];
            }
            if (infChart.toolbar) {
                infChart.toolbar.setSelectedControls(targetEl.id, 'full-screen', false);
            }
        };

        // Note: FF nightly needs about:config full-screen-api.enabled set to true.
        var _enterFullscreen = function (elem) {
            document.onwebkitfullscreenchange = _onFullScreenEnter;
            document.onmozfullscreenchange = _onFullScreenEnter;
            document.onfullscreenchange = _onFullScreenEnter;
            document.onmsfullscreenchange = _onFullScreenEnter;

            if (elem[0].requestFullscreen) {
                elem[0].requestFullscreen();
            } else if (elem[0].webkitRequestFullscreen) {
                elem[0].webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                //Safari silent fails with the above, use workaround:
                setTimeout(function () {
                    if (!document.webkitCurrentFullScreenElement) {
                        elem[0].webkitRequestFullScreen();
                    }
                }, 200);
            } else if (elem[0].mozRequestFullScreen) {
                elem[0].mozRequestFullScreen();
            } else if (elem[0].msRequestFullscreen) {
                elem[0].msRequestFullscreen();
            } else {
                infChart.util.console.log('full screen not supported');
            }
            //document.infFullScreenEl = elem[0];
        };

        var _exitFullscreen = function () {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        };

        var _handleFullscreen = function (element) {
            if (_isFullScreen) {
                _exitFullscreen();
            } else {
                _enterFullscreen(element);
            }
        };

        var _addFullScreenListeners = function (containerId, action, callbackFn) {
            _fsListeners[action].push(callbackFn);
        };

        //endregion

        var _onUrlChange = function (chartId, newUrl) {
            var containerId = _getContainerIdFromChart(chartId);
            var chart = _charts[containerId];
            if (chart) {
                chart.onUrlChange(newUrl);
            }
        };

        //var _pauseScaleDrawings = function (chartId) {
        //    if (infChart.drawingsManager) {
        //        infChart.drawingsManager.pauseScaleDrawings(chartId);
        //    }
        //};
        //
        //var _unPauseScaleDrawings = function (chartId) {
        //    if (infChart.drawingsManager) {
        //        infChart.drawingsManager.unPauseScaleDrawings(chartId);
        //    }
        //};

        var _onAnnotationStore = function (chartId, drawing) {
            var containerId = _getContainerIdFromChart(chartId);
            var chart = _charts[containerId];
            if (chart) {
                if (infChart.tradingManager) {
                    infChart.tradingManager.onAnnotationStore(containerId, drawing);
                }
                if (infChart.alertManager) {
                    infChart.alertManager.onAnnotationStore(containerId, drawing);
                }
            }
        };

        var _onAnnotationRelease = function (chartId, drawing) {
            var containerId = _getContainerIdFromChart(chartId);
            var chart = _charts[containerId];
            if (chart) {
                chart.onAnnotationRelease();
                if (infChart.tradingManager) {
                    infChart.tradingManager.onAnnotationRelease(containerId, drawing);
                }
                if (infChart.alertManager) {
                    infChart.alertManager.onAnnotationRelease(containerId, drawing);
                }
            }
        };

        var _getMainSeries = function (containerId) {
            var series, chart = _charts[containerId];
            if (chart) {
                series = chart.getMainSeries();
            }
            return series;
        };

        var _getCompareSeriesBySymbol = function (containerId, symbol) {
            var series, chart = _charts[containerId];
            if (chart) {
                series = chart.getCompareSeriesFromId(chart.getCompareSeriesId(symbol));
            }
            return series;
        };

        /**
         * add compare symbol to the chart
         * @param {string} containerId - chart container id
         * @param {object} symbol - symbol object
         * @param {object} config - config
         * @param {boolean} isPropertyChange - true, if property change
         */
        var _addCompareSymbol = function (containerId, symbol, config, isPropertyChange) {
            var chart = _charts[containerId];
            if (chart) {
                chart.addCompareSymbol(symbol, config, !!isPropertyChange);
            }
        };

        /**
         * remove compare symbol from the chart
         * @param {string} containerId - chart container id
         * @param {object} symbol - symbol object
         */
        var _removeCompareSymbol = function (containerId, symbol) {
            var chart = _charts[containerId];
            if (chart) {
                chart.removeCompareSymbol(symbol, true);
            }
        };

        /**
         * add indicator to the chart
         * @param {string} containerId - chart container id
         * @param {string} indicatorType - indicator type
         */
        var _addIndicator = function (containerId, indicatorType) {
            var chart = _charts[containerId];
            if (chart) {
                if (infChart.indicatorMgr) {
                    var maxCount = (chart.settings && chart.settings.config.maxIndicatorCount);
                    if (infChart.indicatorMgr.hasMaxIndicatorCountReached(containerId, maxCount, indicatorType)) {
                        infChart.util.showMessage(containerId, _getLabel("msg.indicatorLimitExceeded").replace("{0}", maxCount));
                    } else {
                        var indicator = infChart.indicatorMgr.createIndicator(containerId, indicatorType);

                        var indData = chart.getDataForIndicators(indicator),
                            baseData = indData.base && indData.base.ohlcv && indData.base;

                        if (baseData && baseData.ohlcv && baseData.data && baseData.data.length) {
                            indicator.calculate(baseData.ohlcv, baseData.data, true, undefined, indData);
                        }

                        chart._onPropertyChange("indicators", {id: indicator.id, type: indicator.type, action: 'add'});
                    }
                }
            }
        };

        /**
         * remove given indicator from the chart
         * @param {string} containerId - chart container id
         * @param {string} indicatorId - indicator id
         */
        var _removeIndicator = function (containerId, indicatorId) {
            var chart = _charts[containerId];
            if (chart) {
                if (infChart.indicatorMgr) {
                    var indicator = infChart.indicatorMgr.getIndicatorById(containerId, indicatorId);
                    //infChart.structureManager.legend.removeLegendItem(containerId, indicator.id, 'indicator');
                    infChart.indicatorMgr.removeIndicator(containerId, indicator.id);
                    _updateChartOnIndicatorRemove(containerId, indicator);
                }
            }
        };

        var _resizeMainYAxis = function (containerId, height) {
            var chart = _charts[containerId];
            if (chart) {
                chart.resizeMainYAxis(height);
            }
        };

        var _updateChartOnIndicatorRemove = function (containerId, indicator) {
            var chart = _charts[containerId];
            chart._onPropertyChange("indicators", {id: indicator.id, type: indicator.type, action: 'remove'});
        };

        var _setPeriod = function (containerId, period) {
            var chart = _charts[containerId];
            if (chart) {
                chart.setPeriod(period, true, false, undefined, true);
            }
        };

        var _setChartStyle = function (containerId, type) {
            var chartObj = _charts[containerId];
            chartObj.isManualChartType = true;
            chartObj.setChartStyle(type, true, true);
        };

        var _zoom = function (containerId, val) {
            var chartObj = _charts[containerId];
            if (chartObj) {
                var isZoomIn = val === "in";
                var extremes = chartObj.getZoomExtremes(isZoomIn);
                if (extremes.min && extremes.max) {
                    _setUserDefinedXAxisExtremes(chartObj.chartId, extremes.min, extremes.max, true);
                }
            }
        };

        /**
         * To check whether the given symbol is a compare symbol or not
         * @param containerId
         * @param symbol
         * @returns {*|boolean}
         * @private
         */
        var _isCompareSymbol = function (containerId, symbol) {
            var chartObj = _charts[containerId];
            return chartObj && chartObj._isCompareSymbol(symbol);
        };

        /**
         * Re apply tooltip formatters or which ever the listeners listen to 'onReApplyFormatters' when pocked from outside
         * @param containerId
         * @returns {*}
         * @private
         */
        var _reApplyFormatters = function (containerId) {
            var chartObj = _charts[containerId];
            return chartObj && chartObj.reApplyFormatters();
        };

        /**
         * Returns the Axis label offset that occupies from the drawing tools
         * @param containerId chart id
         * @param axis  Axis which need the offset
         * @returns {*|number}
         * @private
         */
        var _getAxisLabelOffset = function (containerId, axis) {
            var chartObj = _charts[containerId];
            var drawingOffset = infChart.drawingsManager && infChart.drawingsManager.getAxisLabelOffset(containerId, axis);
            var labelOffset = chartObj && chartObj.getMaxLastLabelWidth();
            return Math.max(drawingOffset, labelOffset);
        };

        /**
         * adjust chart of provided id
         * @param {string} containerId - chart id
         * @private
         */
        var _adjustChart = function (containerId) {
            var chartInstance = _charts[containerId];
            if (chartInstance) {
                chartInstance.adjustChartSize();
            }
        };

        /**
         * set chart interval
         * @param {string} containerId - chart container id
         * @param {string} interval - chart interval
         * @param {boolean} isFixedPeriod - true, if period is fixed
         * @param {string} period - - chart period
         */
        var _setInterval = function (containerId, interval, isFixedPeriod, period) {
            var chartInstance = _charts[containerId];
            if (chartInstance) {
                chartInstance.setInterval(interval, undefined, true, isFixedPeriod, period);
            }
        };

        /**
         * Set interval while selecting the best suited period automatically
         * @param {string} containerId - chart container id
         * @param {string} interval - chart interval
         */
        var _setIntervalManually = function (containerId, interval) {
            var chartInstance = _charts[containerId];
            if (chartInstance) {
                chartInstance.setIntervalManually(interval, undefined, true);
            }
        };

        /**
         * Set period and a predefined interval (used in mini chart of index overview)
         * @param {string} containerId - chart container id
         * @param {string} period - chart period
         * @param {string} interval - chart interval
         * @public
         */
        var _setPeriodAndIntervalManually = function (containerId, period, interval) {
            var chartInstance = _charts[containerId];
            if (chartInstance) {
                chartInstance.setPeriodAndIntervalManually(period, interval, true);
            }
        };

        /**
         * Set chart mode
         * @param {string} containerId - chart container id
         * @param {string} type - chart mode
         * @param {boolean} enable - if given mode is enabled
         * @public
         */
        var _setChartMode = function (containerId, type, enable) {
            var chartInstance = _charts[containerId];
            if (chartInstance) {
                chartInstance.setChartMode(type, enable);
            }
        };

        /**
         * update chart series options
         * @param {string} containerId - chart container id
         * @param {object} series - series object
         * @param {object} options - options
         * @param {object} options
         */
        var _updateChartSeriesOptions = function (containerId, series, options) {
            var chartInstance = _charts[containerId];
            if (chartInstance && series) {
                chartInstance.updateSeriesOptions(series, options);
            }
        };

        /**
         * Set scaling factor of the chart after scaling
         * @param {string} containerId - chart container id
         * @public
         */
        var _applyScaling = function (containerId) {
            var chartInstance = _charts[containerId];
            if (chartInstance) {
                chartInstance.setScaleFactors();
            }
        };

        /**
         * get current chart data of the provided symbol
         * @param {string} containerId - chart container id
         * @param {object} symbol - symbol object
         * @param symbol
         */
        var _getCurrentData = function (containerId, symbol) {
            var currentData;
            var chartInstance = _charts[containerId];
            if (chartInstance) {
                currentData = chartInstance.getCurrentData(symbol);
            }
            return currentData;
        };

        /**
         * add chart tick
         * @param {string} containerId - chart container id
         * @param {object} data - data
         */
        var _addTick = function (containerId, data) {
            var chartInstance = _charts[containerId];
            if (chartInstance) {
                chartInstance.addTick(data);
            }
        };

        /**
         * remove all drawing from the chart
         * @param {string} containerId - chart container id
         */
        var _removeAllDrawings = function (containerId) {
            if (typeof infChart.drawingsManager !== 'undefined') {
                infChart.drawingsManager.removeAllDrawings(containerId);
            }
        };

        /**
         * check if depth chart available
         * @param {string} containerId - chart container id
         * @returns boolean
         */
        var _isDepthAvailable = function (containerId) {
            var available = false;
            if (infChart.depthManager) {
                available = infChart.depthManager.isDepthAvailable(containerId);
            }
            return available;
        };

        /**
         * update chart depth data
         * @param {string} containerId - chart container id
         * @param {object} data - depth data
         */
        var _updateDepthData = function (containerId, data) {
            if (_isDepthAvailable(containerId)) {
                infChart.depthManager.updateData(containerId, data);
            }
        };

        /**
         * get depth extremes
         * @param {string} containerId - chart container id
         * @returns object
         */
        var _getDepthExtremes = function (containerId) {
            var extremes;
            if (_isDepthAvailable(containerId)) {
                extremes = infChart.depthManager.getExtremes(containerId);
            }
            return extremes;
        };

        /**
         * get depth extremes
         * @param {string} containerId - chart container id
         * @param {object} extremes - depth extremes
         * @returns object
         */
        var _setDepthExtremes = function (containerId, extremes) {
            if (_isDepthAvailable(containerId)) {
                infChart.depthManager.setExtremes(containerId, extremes);
            }
        };

        var _setLoadingStatus = function(chartId, isLoading) {    
            _loadingMap[chartId] = isLoading;
        }
        
        var _getLoadingStatus = function(chartId) {   
            return _loadingMap[chartId];
        }

        var _openContextMenu = function (containerId, event) {
            let chartId = _getContainerIdFromChart(containerId);
            if (infChart.contextMenuManager.isContextMenuEnabled(chartId)) {
                if (_getChart(chartId).settings.contextMenu.default.enabled) {
                    infChart.contextMenuManager.openContextMenu(chartId, {
                        top: event.clientY,
                        left: event.clientX
                    }, infChart.constants.contextMenuTypes.default, {}, event);
                }
            }

            event.stopPropagation();
            event.preventDefault();
        };

        var _getDefaultContextMenuOptions = function (chartId, event) {
            let chart = _getChart(chartId);
            let options = chart.settings.contextMenu.default.options;
            var contextMenu =  {
                "showSettings" : {
                    icon : options.settings.icon,
                    displayText :options.settings.displayText,
                    action : function () {
                        _legendSeriesClick(chartId, chart.chart.series[0].options.id, "base");
                        if (infChart.toolbar) {
                            infChart.toolbar.setSelectedControls(_getContainerIdFromChart(chartId), "rightPanel", true);
                        }
                    }
                },
                "gridLines": {
                    icon : options.gridLines.icon,
                    displayText :options.gridLines.displayText,
                    disabled: false,
                    subMenus: [
                        {
                            type: "all",
                            icon: options.gridLines.all.icon,
                            displayText: options.gridLines.all.displayText,
                            disabled: chart.gridType === "all",
                            action: function (event, value) {
                                chart.setGridType(value, true, true);
                            }
                        },
                        {
                            type: "horizontal",
                            icon: options.gridLines.horizontal.icon,
                            displayText: options.gridLines.horizontal.displayText,
                            disabled: chart.gridType === "horizontal",
                            action: function (event, value) {
                                chart.setGridType(value, true, true);
                            }
                        },
                        {
                            type: "vertical",
                            icon: options.gridLines.vertical.icon,
                            displayText: options.gridLines.vertical.displayText,
                            disabled: chart.gridType === "vertical",
                            action: function (event, value) {
                                chart.setGridType(value, true, true);
                            }
                        },
                        {
                            type: "none",
                            icon: options.gridLines.none.icon,
                            displayText: options.gridLines.none.displayText,
                            disabled: chart.gridType === "none",
                            action: function (event, value) {
                                chart.setGridType(value, true, true);
                            }
                        }
                    ]
                },
                "resetX": {
                    icon : options.resetX.icon,
                    displayText :options.resetX.displayText,
                    disabled: infChart.manager.isDefaultXAxisExtremes(chartId),
                    action : function () {
                        infChart.manager.resetUserDefinedXAxisExtremes(chartId);
                    }
                },
                "resetY": {
                    icon : options.resetY.icon,
                    displayText :options.resetY.displayText,
                    disabled: infChart.manager.isDefaultYAxisExtremes(chartId),
                    action : function () {
                        infChart.manager.resetUserDefinedYAxisExtremes(chartId);
                    }
                },
                "eraseDrawings": {
                    icon : options.eraseDrawings.icon,
                    displayText :options.eraseDrawings.displayText,
                    disabled: !infChart.drawingsManager.isDrawnDrawingsAvailable(chartId),
                    action : function () {
                        _removeAllDrawings(chartId);
                    }
                },
                "removeIndicators": {
                    icon : options.removeIndicators.icon,
                    displayText :options.removeIndicators.displayText,
                    disabled: !infChart.indicatorMgr.isAddedIndicatorsAvailable(chartId),
                    action : function (event) {
                        infChart.indicatorMgr.removeAllIndicators(chartId, ["VOLUME"]);
                        chart._setIndicatorFrames(true);
                    }
                }
            };
            if(infChart.drawingsManager.getIsActiveEraseMode(chartId)){
                var eraseModeOFF = {
                    icon : options.eraseModeOFF.icon,
                    displayText : options.eraseModeOFF.displayText,
                    disabled: !infChart.drawingsManager.isDrawnDrawingsAvailable(chartId),
                    action : function () {
                        infChart.drawingsManager.offDeleteMode(chartId);
                    }
                };
                contextMenu["eraseModeOFF"] = eraseModeOFF;
            } else {
                var eraseModeON = {
                    icon : options.eraseModeON.icon,
                    displayText : options.eraseModeON.displayText,
                    disabled: !infChart.drawingsManager.isDrawnDrawingsAvailable(chartId),
                    action : function () {
                        infChart.drawingsManager.setDeleteMode(chartId);
                    }
                };
                contextMenu["eraseModeON"] = eraseModeON;
            }
            contextMenu = _reorderContextMenu(contextMenu);
            return contextMenu;
        };

        var _reorderContextMenu = function(contextMenu){
            var newContextMenu = {};
            var contextMenuOrder = ["eraseModeON", "eraseModeOFF", "gridLines", "resetX", "resetY", "eraseDrawings", "removeIndicators", "showSettings"];
            $.each(contextMenuOrder, function (key, menuItem) {
                if(contextMenu[menuItem]){
                    newContextMenu[menuItem] = contextMenu[menuItem];
                }
            });
            return newContextMenu;
        };

        var _getNearestXDataPointWithGaps = function (chartId, xValue, seriesIndex, useAllXDataToFindNearestPoint, useFutureDate, gapCandles) {
            let stockChart = _getChart(chartId);
            let hChart = stockChart.chart;
            let nearestXDataPoint = infChart.math.findNearestDataPoint(hChart, xValue, seriesIndex, useAllXDataToFindNearestPoint, useFutureDate);
            let totalPoints = _getTotalPoints(hChart);
            let nearestXDataPointWithGap
            if (gapCandles && totalPoints[nearestXDataPoint.dataIndex + gapCandles]) {
                nearestXDataPointWithGap = parseInt(totalPoints[nearestXDataPoint.dataIndex + gapCandles]);
            } else {
                nearestXDataPointWithGap = parseInt(totalPoints[nearestXDataPoint.dataIndex]);
            }
            return {
                nearestXDataPoint: nearestXDataPoint,
                nearestXDataPointWithGap: nearestXDataPointWithGap
            }
        };

        var _getYAxisExtremes = function (chartId) {
            let chart = _getChart(chartId);
            return chart.getMainYAxis().getExtremes();
        };

        var _getTotalPoints = function (chart) {
            var stockChart = chart && infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chart.renderTo.id));
            var totalPoints = stockChart.calculateTotalPoints(chart);
            return totalPoints;
        }

        var _alignChartPosition = function(chartId){
            var chart = _charts[chartId];
            if(chart){
                var minYValue = chart.chart.userOptions.chart.viewBoxMinY;
                chart.chart.renderer.box.viewBox.baseVal.y = minYValue;
            }
        };

        var _createInstance = function () {
            return {
                initChart: _initChart,
                renderChart: _renderChart,
                changeChartTheme: _changeChartTheme,
                changeChartThemeByChartId: _changeChartThemeByChartId,
                setChartTheme: _setChartTheme,
                getChart: _getChart,
                getAllAvailableCharts: _getAllAvailableCharts,
                exportChart: _exportChart,
                exportChartAsBinaryData: _exportChartAsBinaryData,
                removeSeries: _removeSeries,
                getContainerIdFromChart: _getContainerIdFromChart,
                getLegend: _getLegend,
                setLegend:_setLegend,
                getTooltipValue: _getTooltipValue,
                getTooltipHTML: _getTooltipHTML,
                getLabel: _getLabel,
                getLocalizationOptions: _getLocalizationOptions,
                getYLabel: _getYLabel,
                getMainYAxisCrosshairLabel: _getMainYAxisCrosshairLabel,
                afterRedraw: _afterRedraw,
                getTemplateNames: _getTemplateNames,
                saveTemplate: _saveTemplate,
                loadTemplate: _loadTemplate,
                deleteTemplate: _deleteTemplate,
                updateCrosshair: _updateCrosshair,
                updateCrosshairFromToolTip: _updateCrosshairFromToolTip,
                seriesMouseOutEvent: _seriesMouseOutEvent,
                seriesMouseOverEvent: _seriesMouseOverEvent,
                removeChart: _removeChart,
                chartClick: _chartClick,
                tooltipPositioner: _tooltipPositioner,
                tooltipFormatter: _tooltipFormatter,
                xAxisTickPositioner: _xAxisTickPositioner,
                yAxisTickPositioner: _yAxisTickPositioner,
                xAxisLabelFormatter: _xAxisLabelFormatter,
                yAxisLabelFormatter: _yAxisLabelFormatter,
                getMaxZoomRange: _getMaxZoomRange,
                enableMouseWheel: _enableMouseWheel,
                afterYSetExtremes: _afterYSetExtremes,
                afterXSetExtremes: _afterXSetExtremes,
                getSeriesActualExtremes: _getSeriesActualExtremes,
                handleFullscreen: _handleFullscreen,
                onUrlChange: _onUrlChange,
                onAnnotationStore: _onAnnotationStore,
                onAnnotationRelease: _onAnnotationRelease,
                isDefaultXAxisExtremes: _isDefaultXAxisExtremes,
                resetUserDefinedXAxisExtremes: _resetUserDefinedXAxisExtremes,
                setUserDefinedXAxisExtremes: _setUserDefinedXAxisExtremes,
                isDefaultYAxisExtremes: _isDefaultYAxisExtremes,
                resetUserDefinedYAxisExtremes: _resetUserDefinedYAxisExtremes,
                setUserDefinedYAxisExtremes: _setUserDefinedYAxisExtremes,
                getMainSeries: _getMainSeries,
                getCompareSeriesBySymbol: _getCompareSeriesBySymbol,
                setSymbol: _setSymbol,
                setPeriod: _setPeriod,
                addCompareSymbol: _addCompareSymbol,
                removeCompareSymbol: _removeCompareSymbol,
                getProperties: _getProperties,
                updateProperties: _updateProperties,
                setChartStyle: _setChartStyle,
                zoom: _zoom,
                removeIndicator: _removeIndicator,
                addIndicator: _addIndicator,
                reloadData: _reloadData,
                isCompareSymbol: _isCompareSymbol,
                reApplyFormatters: _reApplyFormatters,
                getAxisLabelOffset: _getAxisLabelOffset,
                chartMouseOutEvent: _chartMouseOutEvent,
                getMaxZoomRangePx: getMaxZoomRangePx,
                getAllTimeTicks: getAllTimeTicks,
                getMaxPointCount: getMaxPointCount,
                isLinearData: isLinearData,
                adjustChart: _adjustChart,
                setInterval : _setInterval,
                setIntervalManually : _setIntervalManually,
                setPeriodAndIntervalManually : _setPeriodAndIntervalManually,
                setChartMode : _setChartMode,
                updateChartSeriesOptions : _updateChartSeriesOptions,
                applyScaling : _applyScaling,
                getCurrentData : _getCurrentData,
                addTick : _addTick,
                isDepthAvailable : _isDepthAvailable,
                updateDepthData : _updateDepthData,
                getDepthExtremes : _getDepthExtremes,
                setDepthExtremes : _setDepthExtremes,
                removeAllDrawings : _removeAllDrawings,
                setLoadingStatus: _setLoadingStatus,
                getLoadingStatus: _getLoadingStatus,
                getTotalPoints: _getTotalPoints,
                openContextMenu: _openContextMenu,
                getDefaultContextMenuOptions: _getDefaultContextMenuOptions,
                setSelectToolbarIconOnReset: _setSelectToolbarIconOnReset,
                alignChartPosition: _alignChartPosition,
                updateChartAxisColors: _updateChartAxisColors,
                getNearestXDataPointWithGaps: _getNearestXDataPointWithGaps,
                getYAxisExtremes: _getYAxisExtremes
            };
        };

        var _getInstance = function () {
            if (!_instance) {
                _instance = _createInstance();
                //$("[data-localize]").localize("lang", _localizationOptions);
            }
            return _instance;
        };

        return _getInstance();
})(jQuery, Highcharts);

window.infChart = window.infChart || {};

(function (infChart, $, H) {

    var UNDEFINED,
        Point = H.Point,
        seriesType = H.seriesType,
        seriesTypes = H.seriesTypes;

    //region ===============================================  Util =====================================================

    /**
     * Returns the StockChart object of the given container
     * @param chartContainerId
     * @returns {*}
     * @private
     */
    var _getChartObj = function (chartContainerId) {
        return infChart.manager.getChart(infChart.manager.getContainerIdFromChart(chartContainerId));
    };

    /**
     * Returns the compare value of the main series when comparison symbols are added.
     * @param chart
     * @returns {number}
     * @private
     */
    var _getMainSeriesCompareValue = function (chart) {

        var chartObj = _getChartObj(chart.renderTo.id),
            mainseries = (chartObj && chartObj.getMainSeries()) || chart.series[0],
            diff = 0;

        if (mainseries) {
            diff = mainseries.compareValue;
        }

        return diff;
    };

    /**
     * Check whether series is an indicator with in the base axis with a comparison symbol
     * @param series
     * @returns {*|boolean}
     * @private
     */
    var _isIndicatorWithComparison = function (series) {
        var chart = series.chart;

        return ( chart.series[0].modifyValue && series.options.infType == 'indicator' && infChart.util.isSeriesInBaseAxis(series.yAxis.options.id));
    };

    /**
     * Check whether series is a dummy series  in the base axis with a comparison symbol
     * @param series
     * @returns {*|boolean}
     * @private
     */
    var _isDummyWithComparison = function (series) {
        var chart = series.chart;

        return ( chart.series[0].modifyValue && series.options.infType == 'dummy' && infChart.util.isSeriesInBaseAxis(series.yAxis.options.id));
    };

    /**
     * Check whether the chart is a x-chart
     * @param chart
     * @returns {*}
     * @private
     */
    var _isXChart = function (chart) {
        return chart && chart.userOptions.chart && chart.userOptions.chart.infChart;
        // return chart && chart.userOptions.chart.infChart;
    };

    /**
     * Returns the actual pixel width which a point need to be drawn without overlapping.
     * @param series
     * @returns {*|number}
     * @private
     */
    var _getPointWidthByType = function (series) {
        var type = series && series.type,
            minPointGap = 0;
        switch (type) {
            case 'candlestick' :
            case 'hlc' :
            case 'heikinashi' :
            case 'equivolume' :
            case 'volume' :
            case 'engulfingCandles' :
            case 'customCandle' :
                var graphic = series && series.chart.renderer.path(),
                    crispCorr = (graphic && (graphic.strokeWidth() % 2) / 2) || .5, // adding the max possible corr
                    // series.barW is not taken into account to fix https://xinfiit.atlassian.net/projects/CCA/issues/CCA-3638
                    pointWidth = series.options.dataGrouping.groupPixelWidth,//(series.barW && Math.ceil(series.barW))||3, // since highcharts takes the half width from the rounded value of a point width need a correction to that
                    pointWidthCorr = Math.ceil(pointWidth /*+ crispCorr + .5*/);

                return pointWidthCorr + minPointGap * 2;
            default :
                return (series && series.options.dataGrouping.groupPixelWidth + minPointGap * 2 ) || 5;
        }
    };

    /**
     * Determine whether the given series should display points in compacted shape or not
     * @param series
     * @returns {*}
     * @private
     */
    var _isCompactedShape = function (series) {
        var points = series.points,
            chart = series.chart,
            navigator = chart.navigator,
            iChart = chart && _getChartObj(chart.renderTo.id),
            groupedPixelWidth = _getPointWidthByType(series),
            maxPointsCount = Math.floor(chart.plotSizeX / groupedPixelWidth),
            pointCountForCurrentDisplaySpace = iChart && iChart.getPointsCountForCurrentDisplaySpace(),
            isCompactedShape;

        if (pointCountForCurrentDisplaySpace && (chart.mouseIsDown == "mousedown" && !chart.onXAxisLabelsDrag) && (( navigator && !navigator.hasDragged ) || !navigator ) && typeof series.xIsCompactedShape != "undefined"){
            isCompactedShape = series.xIsCompactedShape;
        }
        else{
            isCompactedShape = (maxPointsCount < points.length || maxPointsCount < pointCountForCurrentDisplaySpace);
        }

        series.xIsCompactedShape = isCompactedShape;

        return isCompactedShape;
    };

    //endregion ========================================= end of Util ==================================================

    /**
     * Inside this method overwrite Highcharts' default functionality
     * @private
     */
    var _extendHighCharts = function () {

        // Wrappers for Highcharts
        var H = Highcharts,
            NUMBER = 'number',
            UNDEFINED,
            NORMAL_STATE = '';

        H.wrap(H, 'numberFormat', function (proceed, number, decimals, decimalPoint, thousandsSep) {

            var val = proceed.call(this, number, decimals, decimalPoint, thousandsSep);
            if (val.split("e-")[1]) {
                var decimal = decimals < 0 ? parseInt(val.split("e-")[1]) : decimals;
                val = number.toFixed(decimal);
            }
            return val;
        });

        /**
         * Wrapped SVGElement's destroy event to fix the issue occurs when destroying lowerStateMarkerGraphic property of arearange chart
         */
        H.wrap(H.SVGElement.prototype, 'destroy', function (proceed) {
            if (this.renderer) {
                return proceed.call(this);
            } else {
                return null;
            }
        });

        //region ======================================Wrapping up the Chart============================================

        /**
         * Wrapped this method to change the reset button UI
         */
        H.wrap(H.Chart.prototype, 'showResetZoom', function (proceed, e) {

            if (!_isXChart(this.chart)) {
                return proceed.call(this, e);
            }

            if (!this.infHasDragged && this.hasDragged) {

                var iChart = _getChartObj(this.chart.renderTo.id);

                if (typeof iChart !== "undefined") {
                    iChart.onNavigatorScrollStart(this);
                }

                this.infHasDragged = true;
            }

            return proceed.call(this, e);

        });

        /**
         * Wrapping up the Chart.redraw method to keep previous offset before changing from Axis.getOffset.
         * This is used to determine whether plot area is resized or not
         */
        H.wrap(H.Chart.prototype, 'redraw', function (proceed, e) {

            if (_isXChart(this)) {
                this.infPrevAxisOffset = this.axisOffset;
            }

            return proceed.call(this, e);

        });

        /**
         * Wrappping up this method to set the axesOffsets when there are labels that need more space than axis width.
         *
         * When margin is initially defined axesOffsets are not taken into account in the library. so manually set those to null
         * to use axesOffsets calculated considering all the labels (Check 'getAxisOffset' method which is wrapped up in the axis section)
         */
        H.wrap(H.Chart.prototype, 'getAxisMargins', function (proceed) {

            if (_isXChart(this)) {

                var iChart = _getChartObj(this.renderTo.id),
                    yAxis = iChart.getMainYAxis(),
                    hChart = this,
                    offset = infChart.manager.getAxisLabelOffset(iChart.id, yAxis);

                if (offset) {

                    if (typeof hChart.infInitialMargin == "undefined") {
                        hChart.infInitialMargin = this.margin[yAxis.side];
                    }

                    this.margin[yAxis.side] = undefined;
                    this[H.marginNames[yAxis.side]] = 0;

                } else if (typeof hChart.infInitialMargin != "undefined") {
                    //clear the margin which is set for axis labels
                    this.margin[yAxis.side] = hChart.infInitialMargin;
                    this[H.marginNames[yAxis.side]] = hChart.infInitialMargin || 0;
                    delete hChart.infInitialMargin;
                }
            }

            return proceed.call(this);

        });

        //endregion =================================end of Wrapping up the Chart=======================================

        //region ======================================Wrapping up the Axis=============================================

        /**
         * Wrapped this method to fix the issue with dragging
         */
        H.wrap(H.Axis.prototype, 'setExtremes', function (proceed, newMin, newMax, redraw, animation, eventArguments) {

            var chart = this.chart,
                iChart = chart && _getChartObj(chart.renderTo.id),
                prevMin = chart && chart.prevMin,
                prevMax = chart && chart.prevMax
            ;

            if (prevMin && prevMax && prevMin == newMin && prevMax == newMax) {
                return;
            }

            if (iChart && eventArguments && eventArguments["trigger"] == "navigator") {
                chart.infManualExtreme = true;
            }

            if (iChart && prevMin != newMin && this.isXAxis) {
                iChart._recalculateDynamicIndicators(false, undefined, ["compare", "base"], {
                    min: newMin,
                    max: newMax || prevMax
                });
            }
            // if (chartX > plotLeft) {
            proceed.call(this, newMin, newMax, redraw, animation, eventArguments);
            //  }
            chart.prevMin = newMin;
            chart.prevMax = newMax;
        });

        H.wrap(H.Axis.prototype, 'drawCrosshair', function (proceed, e, point) {

            proceed.call(this, e, point);

            var chart = _getChartObj(this.chart.renderTo.id);

            if ("undefined" === typeof chart || !chart.chart) {
                // proceed.call(this, e, point);
                return;
            }

            if (e && (this.chart.mouseIsDown != "mousedown" || this.chart.infManualCrosshair) && ("undefined" === typeof chart || chart.isCrosshairEnabled())) {
                if (this.crossLabel) {
                    //if (this.crossLabel.parentGroup) {
                    //    //https://xinfiit.atlassian.net/browse/CCA-2544
                    //    // this.crossLabel.parentGroup.toFront();
                    //    this.crossLabel.toFront(); // TODO : check in dev with saved settings
                    //} else {
                    this.crossLabel.toFront();
                    //}
                }
                if (chart && chart.isDefaultCrosshairEnabled(this) && (this.isXAxis || (!this.isXAxis && this.top < e.chartY && (this.top + this.height) > e.chartY))) {
                    // proceed.call(this, e, point);
                    if (e && !this.isXAxis && this.crossLabel && this.crossLabel.attr) {
                        // this.crossLabel.attr({
                        //     y: e.chartY - this.crossLabel.height / 2,
                        //     x: this.left + this.width + this.crossLabel.width + this.crossLabel.height / 4 - 1,
                        //     hAlign: 'right'
                        // });
                    }
                } else {
                    this.hideCrosshair();
                    // if (this.crossLabel) {//hide crosshair internally hides the label
                    //     this.crossLabel.hide();
                    // }
                }
                var yAxis = chart.getMainYAxis();
                if(!this.isXAxis && this.options.id === yAxis.options.id){
                    if (chart.isLastCrosshair()) {
                        if(e){
                            chart.updateCrosshair(e.offsetX, e.offsetY, point, this, e);
                        }
                    } else {
                        chart.showCrosshair(false);
                    }
                }
            } else {
                this.hideCrosshair();
                // if (this.crossLabel) {//hide crosshair internally hides the label
                //     this.crossLabel.hide();
                // }
            }
        });

        /**
         * Wrapping getSeriesExtremes method for https://xinfiit.atlassian.net/browse/CCA-2815
         */
        H.wrap(H.Axis.prototype, 'getSeriesExtremes', function (proceed, e) {

            var overwrite = false,
                axis = this,
                chart = axis.chart,
                bidAskSeriesArr = [];

            if (!axis.isXAxis) {
                if (_isXChart(chart)) {
                    var chartObj = _getChartObj(chart.renderTo.id);
                    if (chartObj) {
                        if (infChart.indicatorMgr && infChart.indicatorMgr.isBidAskEnabled(chartObj.id)) {
                            overwrite = true;
                        }
                    }
                }
            }

            if (!overwrite) {
                proceed.call(this, e);
            } else {
                axis.hasVisibleSeries = false;

                // Reset properties in case we're redrawing (#3353)
                axis.dataMin = axis.dataMax = axis.threshold = null;
                axis.softThreshold = true;

                if (axis.buildStacks) {
                    axis.buildStacks();
                }

                function _setSeriesExtremes(series) {
                    var seriesOptions = series.options,
                        threshold = seriesOptions.threshold,
                        seriesDataMin,
                        seriesDataMax;

                    axis.hasVisibleSeries = true;

                    // Validate threshold in logarithmic axes
                    if (axis.positiveValuesOnly && threshold <= 0) {
                        threshold = null;
                    }

                    // Get this particular series extremes
                    series.getExtremes();
                    seriesDataMax = series.dataMax;
                    seriesDataMin = series.dataMin;

                    // Get the dataMin and dataMax so far. If percentage is
                    // used, the min and max are always 0 and 100. If
                    // seriesDataMin and seriesDataMax is null, then series
                    // doesn't have active y data, we continue with nulls
                    if (H.defined(seriesDataMin) && H.defined(seriesDataMax)) {
                        axis.dataMin = Math.min(H.pick(axis.dataMin, seriesDataMin), seriesDataMin);
                        axis.dataMax = Math.max(H.pick(axis.dataMax, seriesDataMax), seriesDataMax);
                    }

                    // Adjust to threshold
                    if (H.defined(threshold)) {
                        axis.threshold = threshold;
                    }
                    // If any series has a hard threshold, it takes precedence
                    if (!seriesOptions.softThreshold || axis.positiveValuesOnly) {
                        axis.softThreshold = false;
                    }
                }

                // loop through this axis' series
                axis.series.forEach(function (series) {
                    if (series.visible || !chart.options.chart.ignoreHiddenSeries) {

                        var isBidAskSeries = (infChart.indicatorMgr && infChart.indicatorMgr.isSeriesInBidAskHistory(series));

                        if (!isBidAskSeries) {
                            _setSeriesExtremes(series);
                        } else {
                            bidAskSeriesArr.xPush(series);
                        }
                    }
                });

                // to fix https://xinfiit.atlassian.net/browse/CCA-3401
                if (!H.isNumber(axis.dataMin) || !H.isNumber(axis.dataMax) || axis.dataMin == axis.dataMax) {
                    bidAskSeriesArr.forEach(function (series) {
                        _setSeriesExtremes(series);
                    });
                }

            }
        });

        //endregion ======================================end of Wrapping up the Axis===================================

        //region ======================================Wrapping up Pointer==============================================

        /**
         * Set custom dom events
         */
        H.wrap(H.Pointer.prototype, 'setDOMEvents', function (proceed, mouseEvent) {
            proceed.call(this, mouseEvent);

            let vm = this;
            let chart = this.chart;

            function _onContainerClick (e) {
                let hoverPoint = chart.hoverPoint;
                let plotLeft = chart.plotLeft;
                let plotTop = chart.plotTop;

                e = vm.normalize(e);

                if (!chart.cancelClick) {
                    // On tracker right click, fire the series and point events.
                    let isMainChart = hoverPoint && hoverPoint.series.options.id === "c0";
                    let isCompare = hoverPoint && hoverPoint.series.options.infType === "compare";

                    if (!isCompare && (!isMainChart || vm.inClass(e.target, "highcharts-markers")) && vm.inClass(e.target, 'highcharts-series-group')) {
                        // the series right click event
                        if (hoverPoint) {
                            H.fireEvent(hoverPoint.series, 'contextmenu', H.extend(e, {
                                seriesPoint: hoverPoint
                            }));
                        }
                    } else {
                        H.extend(e, vm.getCoordinates(e));

                        // fire a right click event in the chart
                        if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
                            H.fireEvent(chart, 'contextmenu', e);
                        }
                    }
                }
            }

            chart.container.oncontextmenu = function (e) {
                _onContainerClick(e);
            }
        });

        /**
         * Wrapped this method to catch the event on mouse up for navigator drag handle
         */
        H.wrap(H.Pointer.prototype, 'onDocumentMouseUp', function (proceed, e) {

            var retrunObj = proceed.call(this, e);
            var iChart = H.charts && H.charts[H.hoverChartIndex] && _getChartObj(H.charts[H.hoverChartIndex].renderTo.id);

            if (typeof iChart !== "undefined") {
                iChart.onDocumentMouseUp(this);
            }
            return retrunObj;
        });

        H.wrap(H.Pointer.prototype, 'onContainerMouseDown', function (proceed, e) {

            var retrunObj = proceed.call(this, e);
            this.chart.infDragE = e;
            this.chart.infDragExtremes = this.chart.xAxis[0].getExtremes();
            return retrunObj;
        });

        H.wrap(H.Pointer.prototype, 'drag', function (proceed, e) {

            var chart = this.chart;

            // This property is used when used to keep the current extremes on tick updates after user manually changed the extremes.
            // Need to be reset when changing the data set of the chart
            chart.infManualExtreme = true;
            //chart.infDragE = e;
            //chart.infDragExtremes = chart.xAxis[0].getExtremes();
            proceed.call(this, e);
        });

        /**
         * To fix the issues having with the pointer position when one of the patent div is scaled
         */
        H.wrap(H.Pointer.prototype, 'normalize', function (proceed, points, e, selected, accumulate) {
            var chart = this.chart;
            var event = proceed.call(this, points, e);

            if (typeof chart === "undefined") {
                return;
            }

            if (chart.infScaleX) {
                event.chartX = event.chartX / chart.infScaleX;
            }

            if (chart.infScaleY) {
                event.chartY = event.chartY / chart.infScaleY;
            }
            return event;
        });

        H.wrap(H.Pointer.prototype, 'runPointActions', function (proceed) {
            if (this.chart.isChartDragging) {
                return; // stop pointer events if chart.pointerEventsEnabled is false
            }
            proceed.apply(this, Array.prototype.slice.call(arguments, 1)); // call the original runPointActions method
        });

        //endregion ======================================Wrapping up Pointer===========================================

        //region ======================================Wrapping up Series===============================================


        H.wrap(H.Series.prototype, 'setCompare', function (proceed, compare) {

            proceed.call(this, compare);

            if (!_isXChart(this.chart)) {
                return;
            }

            var series = this,
                options = series.options,
                customModifyValue = series.options.customModifyValue;

            // Set or unset the modifyValue method
            series.modifyValue = (compare === 'infCustom' && customModifyValue) ? customModifyValue : series.modifyValue;
        });

        /**
         * Wrapping up 'processData' to fix the error occured when there is only one point for compare symbols
         */
        H.wrap(H.Series.prototype, 'processData', function (proceed) {


            proceed.apply(this, [].slice.call(arguments, 1));

            if (_isXChart(this.chart) && !H.isNumber(this.compareValue) && this.processedYData && this.processedYData.length == 1) {

                var series = this,
                    i,
                    keyIndex = -1,
                    processedXData,
                    processedYData,
                    length,
                    compareValue;

                processedXData = series.processedXData;
                processedYData = series.processedYData;
                length = processedYData.length;

                // For series with more than one value (range, OHLC etc), compare against
                // close or the pointValKey (#4922, #3112)
                if (series.pointArrayMap) {
                    // Use close if present (#3112)
                    keyIndex = H.inArray('close', series.pointArrayMap);
                    if (keyIndex === -1) {
                        keyIndex = H.inArray(series.pointValKey || 'y', series.pointArrayMap);
                    }
                }

                // find the first value for comparison
                for (i = 0; i <= (length - 1); i++) {
                    compareValue = processedYData[i] && keyIndex > -1 ?
                        processedYData[i][keyIndex] :
                        processedYData[i];

                    if (H.isNumber(compareValue) &&
                        ((processedXData[i + 1] && processedXData[i + 1] >= series.xAxis.min) || (processedXData[i] && processedXData[i] >= series.xAxis.min) )
                        && compareValue !== 0) {
                        series.compareValue = compareValue;
                        break;
                    }
                }
            }
        });

        /**
         * Wrapped up this to fix the issue of not displaying cross hair when chart is moved away from the series data
         * https://xinfiit.atlassian.net/browse/CCA-3574
         */
        H.wrap(H.Series.prototype, 'init', function (proceed) {
            proceed.apply(this, [].slice.call(arguments, 1));
            var series = this,
                hChart = series.chart,
                iChart = hChart && _getChartObj(hChart.renderTo.id);

            if (typeof iChart != "undefined") {
                series.directTouch = true;
            }
        });

        //endregion ======================================end of Wrapping up Series========================================

        //region ======================================wrapping up Navigator ===========================================

        /**
         * Wrapped this method to catch the event on mouse up for navigator drag handle
         */
        H.wrap(H.Navigator.prototype, 'onMouseUp', function (proceed, e) {

            var navigator = this,
                retrunObj = proceed.call(this, e),
                chart = this.chart;

            if (navigator.infHasDragged && !chart.hasDragged && e.type === "mouseup") {

                var iChart = _getChartObj(this.chart.renderTo.id);

                if (typeof iChart !== "undefined") {
                    iChart.onNavigatorScrollStop(this);
                }
                if (this.xAxis && this.xAxis.options.infEvents && this.xAxis.options.infEvents.onNavigatorScrollStop) {
                    this.xAxis.options.infEvents.onNavigatorScrollStop(this);
                }

                navigator.infHasDragged = false;
            }
            return retrunObj;
        });


        /**
         * Wrapped navigator to restrict the zooming not to overlap the points. Aborted the mouse move event when maximum zoom range is reached
         */
        H.wrap(H.Navigator.prototype, 'onMouseMove', function (proceed, e) {

            var navigator = this,
                chart = navigator.chart,
                inverted = chart.inverted,
                chartX,
                proceedEvent = true,
                iChart = _getChartObj(this.chart.renderTo.id);

            if (!navigator.infHasDragged && navigator.hasDragged) {
                if (typeof iChart !== "undefined") {
                    iChart.onNavigatorScrollStart(this);
                    // infChart.manager.afterScalingAxis(this.chart.renderTo.id, {
                    //     xAxis: true,
                    //     yAxis: false
                    // });
                }

                navigator.infHasDragged = true;
            }

            // In iOS, a mousemove event with e.pageX === 0 is fired when holding the finger
            // down in the center of the scrollbar. This should be ignored.
            if ((navigator.grabbedLeft || navigator.grabbedRight || navigator.grabbedCenter) && chart.userOptions.chart.infChart && (!e.touches || e.touches[0].pageX !== 0)) { // #4696, scrollbar failed on Android
                var maxZoom = infChart.manager.getMaxZoomRange(chart),
                    maxZoomPx = infChart.manager.getMaxZoomRangePx(chart);

                e = chart.pointer.normalize(e);
                chartX = e.chartX;

                // Swap some options for inverted chart
                if (inverted) {
                    chartX = e.chartY;
                }

                chart.infDragE = e;
                var currentX = navigator.xAxis.toValue(chartX),
                    currentZoom = Math.abs(navigator.fixedExtreme - currentX),
                    currentZoomPx = Math.abs(navigator.xAxis.toPixels(navigator.fixedExtreme) - chartX),
                    baseXAxis = chart.xAxis[0],
                    // For reversed axes, min and max are chagned,
                    // so the other extreme should be stored
                    reverse = (chart.inverted && !baseXAxis.reversed) ||
                        (!chart.inverted && baseXAxis.reversed),
                    xAxis = navigator.xAxis,
                    isLinearData = iChart.isLinearData(),
                    isNonLinearMax = !isLinearData && (maxZoomPx && maxZoomPx < currentZoomPx);

                if ((isLinearData && maxZoom && maxZoom < currentZoom) || isNonLinearMax) {

                    if (navigator.fixedExtreme > currentX) {
                        // grabbed left is not used since when handles are crossed other end should be the left
                        // Grab the left handle and set the extreme limit that chart can be zoomed without exceeding the max zoom
                        navigator.fixedExtreme = reverse ? isNonLinearMax ? navigator.xAxis.toValue(chartX - maxZoomPx) : currentX - maxZoom : isNonLinearMax ? navigator.xAxis.toValue(chartX + maxZoomPx) : currentX + maxZoom;
                        navigator.otherHandlePos = xAxis.toPixels(navigator.fixedExtreme, true);

                    } else {
                        // Grab the right handle and set the extreme limit that chart can be zoomed without exceeding the max zoom
                        navigator.fixedExtreme = reverse ? isNonLinearMax ? navigator.xAxis.toValue(chartX + maxZoomPx) : currentX + maxZoom : isNonLinearMax ? navigator.xAxis.toValue(chartX - maxZoomPx) : currentX - maxZoom;
                        navigator.otherHandlePos = xAxis.toPixels(navigator.fixedExtreme, true);
                    }

                }

                if (proceedEvent) {
                    proceed.call(this, e);
                }
            }else{
                proceed.call(this, e);
            }

        });

        /**
         * Extending to avoid the empty spaces shown for future times(dummy series)
         * https://xinfiit.atlassian.net/browse/CCA-3722
         */
        H.wrap(H.Navigator.prototype, 'modifyNavigatorAxisExtremes', function (proceed) {

            var iChart = _getChartObj(this.chart.renderTo.id),
                xAxis = this.xAxis,
                proceedEvent = true;

            if (xAxis.getExtremes) {

                if (typeof iChart !== "undefined") {

                    var extremes = iChart.getExtremesForNavigator();
                    if (extremes) {
                        if (extremes && (extremes.min !== xAxis.min || extremes.max !== xAxis.max)) {
                            xAxis.min = extremes.min;
                            xAxis.max = extremes.max;
                        }
                        proceedEvent = false;
                    }
                }
            }
            proceedEvent && proceed.call(this);
        });

        //endregion =====================================end of wrapping up Navigator ==================================

    };

    /**
     * Adds custom chart types for highcharts by extending Highcharts.seriesTypes
     * @private
     */
    var _extendHighChartsForCustomChartTypes = function () {


        // 1 - Set default options
        var defaultPlotOptions = H.getOptions().plotOptions;

        //region ************** hlc type *********************************

        seriesType('hlc', 'ohlc', H.merge(defaultPlotOptions.ohlc, defaultPlotOptions.hlc, {
                dataGrouping: {

                    approximation: 'ohlc'
                }
            }), /** @lends seriesTypes.hlc */ {
            /**
             * Draw the data points
             */
            drawPoints: function () {
                var series = this,
                    points = series.points,
                    chart = series.chart,
                    isCompactedShape = _isCompactedShape(series);


                points.forEach(function (point) {
                    var plotClose,
                        crispCorr,
                        halfWidth,
                        path,
                        graphic = point.graphic,
                        crispX,
                        isNew = !graphic;

                    if (point.plotY !== undefined) {

                        // Create and/or update the graphic
                        if (!graphic) {
                            point.graphic = graphic = chart.renderer.path()
                                .add(series.group);
                        }


                        graphic.attr(series.pointAttribs(point, point.selected && 'select')).shadow(series.options.shadow); // #3897


                        // crisp vector coordinates
                        crispCorr = (graphic.strokeWidth() % 2) / 2;
                        crispX = Math.round(point.plotX) - crispCorr; // #2596
                        halfWidth = Math.round(point.shapeArgs.width / 2);

                        var bottom = Math.round(point.yBottom),
                            top = Math.round(point.plotHigh);


                        // the vertical stem
                        path = [
                            'M',
                            crispX, bottom,
                            'L',
                            crispX, bottom == top ? top - crispCorr : top
                        ];

                        if (!isCompactedShape) {

                            // close
                            if (point.close !== null) {
                                plotClose = Math.round(point.plotClose) + crispCorr;
                                path.push(
                                    'M',
                                    crispX,
                                    plotClose,
                                    'L',
                                    crispX + halfWidth,
                                    plotClose
                                );
                            }
                        }

                        graphic[isNew ? 'attr' : 'animate']({
                            d: path
                        })
                            .addClass(point.getClassName(), true);

                    }


                });

            },

            animate: null // Disable animation

        }, /** @lends seriesTypes.hlc.prototype.pointClass.prototype */ {
            /**
             * Extend the parent method by adding up or down to the class name.
             */
            getClassName: function () {
                return Point.prototype.getClassName.call(this) +
                    (this.open < this.close ? ' highcharts-point-up' : ' highcharts-point-down');
            }
        });
        //endregion ************** end of hlc type *********************************

        //region ************** dash type *********************************

        seriesType('dash', 'column', H.merge(defaultPlotOptions.column, defaultPlotOptions.dash, {
            states: {
                hover: {
                    lineWidth: 2
                }
            },
            dataGrouping: {

                approximation: 'average'
            },
            threshold: null
            //upColor: undefined
        }), /** @lends seriesTypes.ohlc */ {
            pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
                stroke: 'color',
                'stroke-width': 'lineWidth'
            },

            /**
             * Draw the data points
             */
            drawPoints: function () {
                var series = this,
                    points = series.points,
                    chart = series.chart;


                points.forEach(function (point) {
                    var crispCorr,
                        halfWidth,
                        path,
                        graphic = point.graphic,
                        crispX,
                        isNew = !graphic;

                    if (point.plotY !== undefined) {

                        // Create and/or update the graphic
                        if (!graphic) {
                            point.graphic = graphic = chart.renderer.path()
                                .add(series.group);
                        }


                        graphic.attr(series.pointAttribs(point, point.selected && 'select')); // #3897


                        // crisp vector coordinates
                        crispCorr = (graphic.strokeWidth() % 2) / 2;
                        crispX = Math.round(point.plotX) - crispCorr; // #2596
                        halfWidth = Math.round(point.shapeArgs.width / 2);

                        path = [];
                        path.push(
                            'M',
                            crispX - halfWidth,
                            Math.round(point.plotY),
                            'L',
                            crispX + halfWidth,
                            Math.round(point.plotY)
                        );


                        graphic[isNew ? 'attr' : 'animate']({
                            d: path
                        })
                            .addClass(point.getClassName(), true);

                    }


                });

            },

            animate: null // Disable animation

            /**
             * @constructor seriesTypes.ohlc.prototype.pointClass
             * @extends {Point}
             */
        }, /** @lends seriesTypes.ohlc.prototype.pointClass.prototype */ {});
        //endregion  ****************end of dash type************************

        //region *********************volume type***************************

        seriesType('volume', 'column', H.merge(defaultPlotOptions.column, defaultPlotOptions.volume, {
            lineWidth: 0,
            states: {
                hover: {
                    lineWidth: 1
                }
            },
            dataGrouping: {
                approximation: function (volume, open, close) {

                    var NUMBER = 'number';

                    var approximations = {
                        sum: function (arr) {
                            var len = arr.length,
                                ret;

                            // 1. it consists of nulls exclusively
                            if (!len && arr.hasNulls) {
                                ret = null;
                                // 2. it has a length and real values
                            } else if (len) {
                                ret = 0;
                                while (len--) {
                                    ret += arr[len];
                                }
                            }
                            // 3. it has zero length, so just return undefined
                            // => doNothing()

                            return ret;
                        },
                        average: function (arr) {
                            var len = arr.length,
                                ret = approximations.sum(arr);

                            // If we have a number, return it divided by the length. If not, return
                            // null or undefined based on what the sum method finds.
                            if (typeof ret === NUMBER && len) {
                                ret = ret / len;
                            }

                            return ret;
                        },
                        open: function (arr) {
                            return arr.length ? arr[0] : (arr.hasNulls ? null : UNDEFINED);
                        },
                        close: function (arr) {
                            return arr.length ? arr[arr.length - 1] : (arr.hasNulls ? null : UNDEFINED);
                        }
                    };

                    open = approximations.open(open);
                    close = approximations.close(close);
                    volume = approximations.average(volume);
                    if (typeof open === NUMBER || typeof close === NUMBER || typeof volume == NUMBER) {
                        return [volume, open, close];
                    }

                },

                // the first one is the point or start value, the second is the start value if we're dealing with range,
                // the third one is the end value if dealing with a range
                dateTimeLabelFormats: {
                    millisecond: ['%A, %b %e, %H:%M:%S.%L', '%A, %b %e, %H:%M:%S.%L', '-%H:%M:%S.%L'],
                    second: ['%A, %b %e, %H:%M:%S', '%A, %b %e, %H:%M:%S', '-%H:%M:%S'],
                    minute: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
                    hour: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
                    day: ['%A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
                    week: ['Week from %A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
                    month: ['%B %Y', '%B', '-%B %Y'],
                    year: ['%Y', '%Y', '-%Y']
                }
                // smoothed = false, // enable this for navigator series only
            }
        }), /** @lends seriesTypes.volume */ {
            directTouch: false,
            pointArrayMap: ['volume', 'open', 'close'], // array point configs are mapped to this
            toYData: function (point) { // return a plain array for speedy calculation
                return [point.volume];
            },
            pointValKey: 'volume',

            pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
                fill: 'color',
                stroke: 'lineColor',
                'stroke-width': 'lineWidth'
            },
            upColorProp: 'fill',

            /**
             * Postprocess mapping between options and SVG attributes
             */
            pointAttribs: function (point, state) {
                var attribs = seriesTypes.column.prototype.pointAttribs.call(
                    this,
                    point,
                    state
                );
                if(this.chart.isChartDragging) {
                    return attribs;
                }

                var options = this.options, stateOptions = options.states,
                    upLineColor = options.upColor || options.color,
                    hoverStroke = stateOptions.hover.upColor || upLineColor,
                    selectStroke = stateOptions.select.upColor || upLineColor;

                if (point.open < point.close) {

                    // If an individual line color is set, we need to merge the
                    // point attributes, because they are shared between all up
                    // points by inheritance from OHCLSeries.
                    if (point.lineColor) {
                        //point.pointAttr = H.merge(point.pointAttr);
                        upLineColor = point.lineColor;
                    }

                    attribs.stroke = upLineColor;
                    attribs.fill = upLineColor;
                }

                return attribs;
            },
            // uncomment this section if there is a borderWidth for the volume bars
            /*
             drawPoints: function() {
             var series = this,
             points = series.points,
             chart = this.chart,
             options = series.options,
             renderer = chart.renderer,
             animationLimit = options.animationLimit || 250,
             shapeArgs,
             groupedPixelWidth = this.options.dataGrouping.groupPixelWidth || 3,
             maxDataCount = Math.floor(this.chart.plotSizeX / groupedPixelWidth),
             isCompactedShape = (maxDataCount < points.length);

             if(isCompactedShape) {
             // draw the columns
             each(series.points, function (point) {
             var plotY = point.plotY,
             graphic = point.graphic;

             if (H.isNumber(plotY) && point.y !== null) {
             shapeArgs = point.shapeArgs;

             shapeArgs.width = 1;

             if (graphic) { // update
             graphic[chart.pointCount < animationLimit ? 'animate' : 'attr'](
             H.merge(shapeArgs)
             );

             } else {
             point.graphic = graphic = renderer[point.shapeType](shapeArgs)
             .add(point.group || series.group);
             }

             // Border radius is not stylable (#6900)
             if (options.borderRadius) {
             graphic.attr({
             r: options.borderRadius
             });
             }


             // Presentational
             graphic
             .attr(series.pointAttribs(point, point.selected && 'select'))
             .shadow(options.shadow, null, options.stacking && !options.borderRadius);


             graphic.addClass(point.getClassName(), true);


             } else if (graphic) {
             point.graphic = graphic.destroy(); // #1269
             }
             });
             } else {
             seriesTypes.column.prototype.drawPoints.call(this);
             }
             },*/
            animate: null // Disable animation

            /**
             * @constructor seriesTypes.ohlc.prototype.pointClass
             * @extends {Point}
             */
        }, /** @lends seriesTypes.ohlc.prototype.pointClass.prototype */ {
            /**
             * Extend the parent method by adding up or down to the class name.
             */
            /*getClassName: function() {
             return Point.prototype.getClassName.call(this) +
             (this.open < this.close ? ' highcharts-point-up' : ' highcharts-point-down');
             }*/
        });

        //endregion ************volume type******************************************

        //region ************** Heikin Ashi type *********************************
        seriesType('heikinashi', 'candlestick', H.merge(defaultPlotOptions.candlestick, defaultPlotOptions.heikinashi,
            {
                dataGrouping: {

                    approximation: 'ohlc'
                }
            }), /** @lends seriesTypes.ohlc */ {
            directTouch: false,
            pointArrayMap: ['open', 'high', 'low', 'close'], // array point configs are mapped to this
            toYData: function (point) { // return a plain array for speedy calculation
                return [point.open, point.high, point.low, point.close];
            },
            pointValKey: 'close',

            /**
             * Postprocess mapping between options and SVG attributes
             */
            pointAttribs: function (point, state) {
                var attribs = seriesTypes.column.prototype.pointAttribs.call(
                        this,
                        point,
                        state
                    ),
                    options = this.options,
                    upColor = options.upColor || options.color,
                    upColorProp = options.upColorProp,
                    upLineColor = options.upLineColor || options.lineColor,
                    stateOptions;

                attribs[upColorProp] = upColor;

                if (!point.options.color &&
                    options.upColor &&
                    point.open < point.close
                ) {
                    attribs.fill = options.upColor;
                    attribs.stroke = options.upColor;
                }

                var prevPoint = this.prevPoint[point.index];
                var pointOpen = prevPoint.xPoint.open,
                    pointClose = prevPoint.xPoint.close

                if (pointOpen < pointClose) {

                    /* If an individual line color is set, we need to merge the
                     point attributes, because they are shared between all up
                     points by inheritance from OHCLSeries.*/
                    if (point.lineColor) {
                        upLineColor = point.lineColor;
                    }

                    attribs.stroke = upLineColor;
                    attribs.fill = upColor;
                }
                point.infData = { xOpen: pointOpen, close: pointClose };

                if(state) {
                    stateOptions = options.states[state];
                    attribs.fill = stateOptions.color || attribs.fill;
                    attribs.stroke = stateOptions.lineColor || attribs.stroke;
                    attribs['stroke-width'] = stateOptions.lineWidth || attribs['stroke-width'];
                }
                return attribs;
            },
            /**
             * Calculate the open, close, high, low values for a single point
             */
            calculateSingleDataPoint: function (i) {
                var series = this,
                    chart = series.chart,
                    chartObj = _getChartObj(chart.renderTo.id),
                    prevPointOpen,
                    prevPointClose;
                var dataArray = series.yData[i];
                var currentPoint = { open: dataArray[0], close: dataArray[3], high: dataArray[1], low: dataArray[2] };

                rawOpen = (i == 0) ? (chartObj.getsBaseValueFromProcessedValue(currentPoint.open) + chartObj.getsBaseValueFromProcessedValue(currentPoint.close)) / 2 :
                    (chartObj.getsBaseValueFromProcessedValue(series.prevPoint[i - 1].xPoint.open) + chartObj.getsBaseValueFromProcessedValue(series.prevPoint[i - 1].xPoint.close)) / 2;
                prevPointOpen = chartObj.getProcessedValue(series, rawOpen);

                rawClose = (chartObj.getsBaseValueFromProcessedValue(currentPoint.close) + chartObj.getsBaseValueFromProcessedValue(currentPoint.open) +
                    chartObj.getsBaseValueFromProcessedValue(currentPoint.high) + chartObj.getsBaseValueFromProcessedValue(currentPoint.low)) / 4;
                prevPointClose = chartObj.getProcessedValue(series, rawClose);

                currentPoint.xPoint = {
                    open: prevPointOpen, close: prevPointClose,
                    high: Math.max(currentPoint.high, prevPointOpen, prevPointClose),
                    low: Math.min(currentPoint.low, prevPointOpen, prevPointClose)
                };

                series.prevPoint[i] = currentPoint;
            },
            /**
             * calculate open, close, high, low values for the series
             */
            calculateDataPoints: function () {
                var series = this;

                series.prevPoint = [];
                for (var i = 0; i < series.yData.length; i++) {
                    this.calculateSingleDataPoint(i);
                }
            },
            /**
             * Translate the actual values into plot values
             */
            translate: function () {
                var series = this,
                    yAxis = series.yAxis,
                    hasModifyValue = !!series.modifyValue,
                    translated = ['plotOpen', 'plotHigh', 'plotLow', 'plotClose', 'yBottom'], // translate OHLC for
                    translatedRaw = ['infRawPlotOpen', 'infRawPlotHigh', 'infRawPlotLow', 'infRawPlotClose', 'infRawYbottom'], // translate actual OHLC for
                    points,
                    chart = series.chart,
                    chartObj = _getChartObj(chart.renderTo.id),
                    rawPlotY,
                    rawPlotYBottom,
                    pointOpen,
                    plotOpen,
                    plotClose,
                    pointClose;

                seriesTypes.column.prototype.translate.apply(series);
                points = series.points;
                this.calculateDataPoints();

                // Do the translation
                points.forEach(function (point) {
                    if (!series.prevPoint[point.index]) {
                        series.calculateSingleDataPoint(point.index);
                    }
                    [point.open, point.high, point.low, point.close, point.low].forEach(function (value, i) {
                        if (value !== null) {
                            if (hasModifyValue) {
                                value = series.modifyValue(value);
                            }
                            point[translated[i]] = yAxis.toPixels(value, true);
                            point[translatedRaw[i]] = point[translated[i]]; // keep actual plot values here to be used in calculations even if plot values changes due to boundaries
                        }

                    });

                    rawPlotY = H.isNumber(point.infRawPlotY) ? point.infRawPlotY : point.plotY;
                    rawPlotYBottom = H.isNumber(point.infRawYbottom) ? point.infRawYbottom : point.yBottom;

                    var j = point.index;
                    pointOpen = series.prevPoint[j].xPoint.open;
                    pointClose = series.prevPoint[j].xPoint.close;
                    pointHigh = series.prevPoint[j].xPoint.high;
                    pointLow = series.prevPoint[j].xPoint.low;

                    if (typeof chartObj !== "undefined" && chartObj.isPercent && chartObj.isCompare) {
                        pointOpen = chartObj.convertBaseYValue(pointOpen, chartObj.isLog, chartObj.isPercent, chartObj.isPercent);
                        pointClose = chartObj.convertBaseYValue(pointClose, chartObj.isLog, chartObj.isPercent, chartObj.isPercent);
                        pointHigh = chartObj.convertBaseYValue(pointHigh, chartObj.isLog, chartObj.isPercent, chartObj.isPercent);
                        pointLow = chartObj.convertBaseYValue(pointLow, chartObj.isLog, chartObj.isPercent, chartObj.isPercent);
                    }

                    point.plotOpen = point.xOpen = plotOpen = yAxis.toPixels(pointOpen);
                    point.plotClose = plotClose = yAxis.toPixels(pointClose);
                    point.plotY = point.plotHigh = yAxis.toPixels(pointHigh);
                    point.yBottom = point.plotLow = yAxis.toPixels(pointLow);

                    point.isInside =
                        point.plotY !== undefined &&
                        point.plotHigh >= 0 &&
                        point.plotLow <= yAxis.len && // #3519
                        point.plotX >= 0 &&
                        point.plotX <= series.xAxis.len;


                    /**
                     * If point is not inside the clip box change the plot values accordingly
                     */
                    if (!point.isInside) {

                        if (point.plotLow > yAxis.len && point.plotHigh < yAxis.len) {
                            point.plotLow = yAxis.len;
                            point.plotClose = Math.min(point.plotClose, yAxis.len);
                            point.plotOpen = Math.min(point.plotOpen, yAxis.len);
                            //point.plotY = point.plotClose;
                            point.yBottom = yAxis.len;
                        } else if (point.plotHigh < 0 && point.plotLow > 0) {
                            point.plotHigh = 0;
                            point.plotClose = point.plotClose < 0 ? (point.plotClose < point.plotOpen && point.plotOpen > 0) ? 0 : undefined : point.plotClose;
                            point.plotOpen = point.plotOpen < 0 ? (point.plotClose > point.plotOpen && point.plotClose > 0) ? 0 : undefined : point.plotOpen;
                            point.plotY = 0;
                        } else {
                            point.plotY = undefined;
                            point.graphic && point.graphic.destroy && point.graphic.destroy();
                            point.graphic = undefined;
                        }
                    }

                    point.xPoint = series.prevPoint[j].xPoint;

                    // Align the tooltip to the high value to avoid covering the point
                    point.tooltipPos[1] =
                        point.plotHigh + yAxis.pos - series.chart.plotTop;
                });
            },
            /**
             * Draw the data points
             */
            drawPoints: function () {

                var series = this,
                    points = series.points,
                    chart = series.chart,
                    prevPoint,
                    isCompactedShape = _isCompactedShape(series);

                points.forEach(function (point) {

                    var graphic = point.graphic,
                        plotOpen = point.plotOpen,
                        plotClose = point.plotClose,
                        plotHigh = point.plotHigh,
                        plotLow = point.plotLow,
                        topBox,
                        bottomBox,
                        hasTopWhisker,
                        hasBottomWhisker,
                        crispCorr,
                        crispX,
                        path,
                        halfWidth,
                        isNew = !graphic;


                    if (point.plotY !== undefined) {

                        if (!graphic) {
                            point.graphic = graphic = chart.renderer.path()
                                .add(series.group);
                        }
                        graphic
                            .attr(series.pointAttribs(point, point.selected && 'select')) // #3897
                            .shadow(series.options.shadow);


                        // Crisp vector coordinates
                        crispCorr = (graphic.strokeWidth() % 2) / 2;
                        crispX = Math.round(point.plotX) - crispCorr; // #2596

                        // Create the path. Due to a bug in Chrome 49, the path is first instanciated
                        // with no values, then the values pushed. For unknown reasons, instanciated
                        // the path array with all the values would lead to a crash when updating
                        // frequently (#5193).
                        path = [];

                        if (!isCompactedShape && plotOpen != undefined && plotClose != undefined) {
                            topBox = Math.min(plotOpen, plotClose);
                            bottomBox = Math.max(plotOpen, plotClose);
                            halfWidth = Math.round(point.shapeArgs.width / 2);
                            hasTopWhisker = Math.round(topBox) !== Math.round(point.plotY);
                            hasBottomWhisker = bottomBox !== point.yBottom;
                            topBox = Math.round(topBox) + crispCorr;
                            bottomBox = Math.round(bottomBox) + crispCorr;
                            path.push('M',
                                crispX - halfWidth, bottomBox,
                                'L',
                                crispX - halfWidth, topBox,
                                'L',
                                crispX + halfWidth, topBox,
                                'L',
                                crispX + halfWidth, bottomBox,
                                'Z',
                                // Use a close statement to ensure a nice rectangle #2602
                                'M',
                                crispX, topBox,
                                'L',
                                crispX, hasTopWhisker ? Math.round(point.plotHigh) : topBox, // #460, #2094
                                'M',
                                crispX, bottomBox,
                                'L',
                                crispX, hasBottomWhisker ? Math.round(point.yBottom) : bottomBox // #460, #2094
                            );
                        } else {
                            // drawing a line only when plot open and plot close is not available
                            topBox = plotHigh;
                            bottomBox = plotLow;
                            topBox = Math.round(topBox) + crispCorr;
                            bottomBox = Math.round(bottomBox) + crispCorr;
                            path.push(
                                'M',
                                crispX, topBox,
                                'L',
                                crispX, topBox == bottomBox ? topBox + crispCorr : bottomBox
                            );
                        }

                        graphic[isNew ? 'attr' : 'animate']({
                            d: path
                        })
                            .addClass(point.getClassName(), true);
                    }
                    prevPoint = point;
                });

            },

            animate: null // Disable animation

            /**
             * @constructor seriesTypes.ohlc.prototype.pointClass
             * @extends {Point}
             */
        }, /** @lends seriesTypes.ohlc.prototype.pointClass.prototype */ {});

        //endregion ************** end of Heikin Ashi type *********************************

        // region ************** Engulfing Candles type *********************************
        seriesType('engulfingCandles', 'candlestick', H.merge(defaultPlotOptions.candlestick, defaultPlotOptions.engulfingCandles),
            /** @lends seriesTypes.ohlc */
            {
                /**
                 * Postprocess mapping between options and SVG attributes
                 */
                pointAttribs: function (point, state) {
                    var attribs = seriesTypes.column.prototype.pointAttribs.call(
                            this,
                            point,
                            state
                        ),
                        options = this.options,
                        upColorProp = options.upColorProp,
                        stateOptions;

                    attribs[upColorProp] = options.upColor || options.color;

                    if (!point.options.color &&
                        options.upColor &&
                        point.open < point.close
                    ) {
                        attribs.fill = options.upColor;
                        attribs.stroke = options.upColor;
                    }

                    var prevPoint = point.series.data[point.index -1];

                    if (prevPoint) {
                        if (point.open < point.close && prevPoint.open > prevPoint.close && point.close > prevPoint.open && point.open < prevPoint.close) {
                            // bullish engulfing
                            attribs.fill = options.bullish;
                            attribs.stroke = options.bullish;
                        }

                        if (point.open > point.close && prevPoint.open < prevPoint.close && point.close < prevPoint.open && point.open > prevPoint.close) {
                            // bearish engulfing
                            attribs.fill = options.bearish;
                            attribs.stroke = options.bearish;
                        }
                    }

                    if(state) {
                        stateOptions = options.states[state];
                        attribs.fill = stateOptions.color || attribs.fill;
                        attribs.stroke = stateOptions.lineColor || attribs.stroke;
                        attribs['stroke-width'] = stateOptions.lineWidth || attribs['stroke-width'];
                    }
                    return attribs;
                }

                /**
                 * @constructor seriesTypes.ohlc.prototype.pointClass
                 * @extends {Point}
                 */
            }, /** @lends seriesTypes.ohlc.prototype.pointClass.prototype */ {});

        //endregion ************** end of Heikin Ashi type *********************************

        //region ************** Custom Candle type *********************************
        seriesType('customCandle', 'candlestick', H.merge(defaultPlotOptions.candlestick, defaultPlotOptions.customCandle, {
                dataGrouping: {

                    approximation: 'ohlc'
                }
            }),
            {
                /**
                 * Postprocess mapping between options and SVG attributes
                 */
                pointAttribs: function (proceed, point, state) {
                    var attribs = seriesTypes.column.prototype.pointAttribs.call(this, point, state),
                        options = this.options,
                        // isUp = point.open < point.close,
                        isUp = point.open < point.close ,
                        stroke = options.lineColor || this.color,
                        stateOptions;

                    attribs['stroke-width'] = options.lineWidth;

                    attribs.fill = point.options.color || (isUp ? (options.upColor || this.color) : this.color);
                    attribs.stroke = point.lineColor || (isUp ? (options.upLineColor || stroke) : stroke);

                    // Select or hover states
                    if (state) {
                        stateOptions = options.states[state];
                        attribs.fill = stateOptions.color || attribs.fill;
                        attribs.stroke = stateOptions.lineColor || attribs.stroke;
                        attribs['stroke-width'] =
                            stateOptions.lineWidth || attribs['stroke-width'];
                    }

                    return attribs;
                }
                /**
                 * @constructor seriesTypes.ohlc.prototype.pointClass
                 * @extends {Point}
                 */
            }, /** @lends seriesTypes.ohlc.prototype.pointClass.prototype */ {});

        //endregion ************** end of Custom Candle type *********************************

        //region ************** step type *********************************

        seriesType('step', 'line', H.merge(defaultPlotOptions.line, defaultPlotOptions.step, {
            dataGrouping: {

                approximation: 'average'
            }
        }), /** @lends seriesTypes.step.prototype */ {
            /**
             * Get the spline segment from a given point's previous neighbour to the given point
             */
            getPointSpline: function (points, point, i) {
                var
                    plotX = point.plotX,
                    plotY = point.plotY,
                    lastPoint = points[i - 1],
                    ret;

                // find control points
                if (lastPoint) {

                    var lastX = lastPoint.plotX,
                        lastY = lastPoint.plotY,
                        currentX = point.plotX,
                        currentY = point.plotY,
                        midX = (lastX + currentX) / 2;


                }

                // moveTo or lineTo
                if (!i) {
                    ret = ['M', plotX, plotY];
                } else { // curve from last point to this
                    ret = [
                        'M',
                        lastX, lastY,
                        'L',
                        midX, lastY,
                        'L',
                        midX, currentY,
                        'L',
                        currentX, currentY
                    ];
                }
                return ret;
            }
        });


        //endregion  ****************end of step type************************

        //region ************** Point type *********************************

        seriesType('point', 'candlestick', H.merge(defaultPlotOptions.candlestick, defaultPlotOptions.point,
            {
                dataGrouping: {

                    approximation: 'ohlc'
                }
            }), /** @lends seriesTypes.point */ {

            translate: function () {
                var series = this,
                    yAxis = series.yAxis,
                    points,
                    chart = series.chart,
                    rawPlotY,
                    rawPlotYBottom,
                    halfWidth,
                    value,
                    hasModifyValue = !!series.modifyValue;

                seriesTypes.column.prototype.translate.apply(series);

                points = series.points;

                // Do the translation
                points.forEach(function (point) {

                    halfWidth = Math.round(point.shapeArgs.width);

                    if (point.close != null) {
                        value = point.close;
                        if (hasModifyValue) {
                            value = series.modifyValue(value);
                        }
                        point.plotClose = yAxis.toPixels(value, true);
                        point.infRawPlotClose = point.plotClose;

                    }
                    rawPlotY = H.isNumber(point.infRawPlotY) ? point.infRawPlotY : point.plotY;
                    rawPlotYBottom = H.isNumber(point.infRawYbottom) ? point.infRawYbottom : point.yBottom;

                    point.isInside =
                        point.plotY !== undefined &&
                        (point.plotClose - halfWidth) >= 0 &&
                        (point.plotClose + halfWidth) <= yAxis.len && // #3519
                        point.plotX >= 0 &&
                        point.plotX <= series.xAxis.len;


                    /**
                     * If point is not inside the clip box change the plot values accordingly
                     */
                    if (!point.isInside) {
                        if (!((point.plotClose - halfWidth) < yAxis.len || (point.plotClose + halfWidth) >= 0)) {
                            point.plotY = undefined;
                            point.graphic && point.graphic.destroy && point.graphic.destroy();
                            point.graphic = undefined;
                        }
                    }

                    // Align the tooltip to the high value to avoid covering the point
                    point.tooltipPos[1] =
                        point.plotHigh + yAxis.pos - series.chart.plotTop;
                });
            },
            /**
             * Draw the data points
             */
            drawPoints: function () {
                var series = this,
                    points = series.points,
                    chart = series.chart,
                    yAxis = series.yAxis,
                    graphic,
                    fullWidth,
                    halfWidth,
                    isNew;


                points.forEach(function (point) {

                    graphic = point.graphic;
                    isNew = !graphic;

                    if (point.plotY !== undefined) {

                        if (!graphic) {
                            point.graphic = graphic = chart.renderer.path()
                                .add(series.group);
                        }

                        graphic
                            .attr(series.pointAttribs(point, point.selected && 'select')) // #3897
                            .shadow(series.options.shadow);


                        fullWidth = Math.round(point.shapeArgs.width);
                        halfWidth = fullWidth / 2;

                        point.xMinMaxKey = 'close';
                        point.xPlotMax = point.plotClose - halfWidth;
                        point.xPlotMin = point.plotClose + halfWidth;
                        point.plotHigh = point.xPlotMax;
                        point.plotLow = point.xPlotMin;
                        var plotClose = point.plotClose,
                            path = [],
                            xWidth;

                        if (plotClose < 0) {
                            // center of the point is above the zero
                            xWidth = Math.sin(Math.acos((((-1) * plotClose ) / (halfWidth)))) * (halfWidth);
                            path.push('M', point.plotX - xWidth, 0,
                                'A', halfWidth, halfWidth, 0, 0, 0, point.plotX + xWidth, 0,
                                'Z');

                        } else if ((plotClose - halfWidth) < 0) {
                            // center of the point is below zero but upper edge of the point is above the zero
                            xWidth = Math.sin(Math.acos((( plotClose ) / (halfWidth)))) * (halfWidth);
                            path.push('M', point.plotX - xWidth, 0,
                                'A', halfWidth, halfWidth, 0, 1, 0, point.plotX + xWidth, 0,
                                'Z');

                        } else if (plotClose > yAxis.len) {
                            // center of the point is below the yAxis
                            xWidth = Math.sin(Math.acos(((plotClose - yAxis.len  ) / (halfWidth)))) * (halfWidth);
                            path.push('M', point.plotX - xWidth, yAxis.len,
                                'A', halfWidth, halfWidth, 0, 0, 1, point.plotX + xWidth, yAxis.len,
                                'Z');

                        } else if (( plotClose + halfWidth ) > yAxis.len) {
                            // center of the point is in side the yAxis but lower edge is below the y Axis
                            xWidth = Math.sin(Math.acos(((yAxis.len - plotClose) / (halfWidth)))) * (halfWidth);
                            path.push('M', point.plotX - xWidth, yAxis.len,
                                'A', halfWidth, halfWidth, 0, 1, 1, point.plotX + xWidth, yAxis.len,
                                'Z');
                        } else {
                            // pint is inside the y Axis
                            path = chart.renderer.symbols.circle(point.plotX - halfWidth, point.plotClose - halfWidth, fullWidth, fullWidth);
                        }


                        graphic[isNew ? 'attr' : 'animate']({
                            d: path
                        }).addClass(point.getClassName(), true);

                    }
                });

            },

            animate: null // Disable animation

            /**
             * @constructor seriesTypes.point.prototype.pointClass
             * @extends {Point}
             */
        }, /** @lends seriesTypes.point.prototype.pointClass.prototype */ {});
        //endregion ************** end of Point type *********************************

        //region **************  Equi Volume type *********************************

        seriesType('equivolume', 'candlestick', H.merge(defaultPlotOptions.candlestick,
            {
                dataGrouping: {

                    approximation: 'ohlc'
                }
            }), /** @lends seriesTypes.equivolume */ {

            pointAttrToOptions: {
                'stroke': 'color',
                'stroke-width': 'lineWidth'
            },

            /**
             * Postprocess mapping between options and SVG attributes
             */
            pointAttribs: function (point, state) {
                var attribs = seriesTypes.candlestick.prototype.pointAttribs.call(
                    this,
                    point,
                    state
                );
                /*,
                 options = this.options;
                 var upColor = options.upColor || options.color ,
                 upColorProp = options.upColorProp,
                 upLineColor = options.upLineColor || options.lineColor;
                 if(upColorProp)
                 attribs[upColorProp] = upColor;*/

                delete attribs.fill;

                /* var prevPoint = (point.index>0)? point.series.hasGroupedData ? point.series.groupedData[point.index -1] : point.series.data[point.index -1 ] : undefined;
                 var prevClose  = (prevPoint)?prevPoint.close: point.close;
                 if (point.close >= prevClose && !point.options.color) {
                 /!* If an individual line color is set, we need to merge the
                 point attributes, because they are shared between all up
                 points by inheritance from OHCLSeries.*!/
                 if (point.lineColor) {
                 upLineColor = point.lineColor;
                 }

                 attribs.stroke = upLineColor;
                 }*/
                return attribs;
            },
            /**
             * Translate the actual values into plot values
             */
            translate: function () {
                var series = this,
                    yAxis = series.yAxis,
                    points,
                    hasModifyValue = !!series.modifyValue,
                    chartObj = _getChartObj(this.chart.renderTo.id),
                    prevPoint,
                    translated = ['plotOpen', 'plotHigh', 'plotLow', 'plotClose', 'yBottom'], // translate OHLC for
                    pointVolume,
                    volumeMax,
                    seriesData,
                    count = 0;

                seriesTypes.column.prototype.translate.apply(series);

                points = series.points;


                if (series.groupedData && series.infVolume && series.infVolume.length > 0) {
                    volumeMax = series.infVolume.infMax();
                } else {

                    if ("undefined" !== typeof chartObj) {
                        seriesData = chartObj.getSeriesData(series, true);
                        if (seriesData) {
                            seriesData = seriesData.slice(series.cropStart, series.cropStart + points.length);
                            if (seriesData.length > 0)
                                volumeMax = seriesData.infMax(5);
                        }
                    }

                }

                points.forEach(function (point) {
                    [point.open, point.high, point.low, point.close, point.low].forEach(function (value, i) {

                        if (value !== null) {
                            if (hasModifyValue) {
                                value = series.modifyValue(value);
                            }
                            point[translated[i]] = yAxis.toPixels(value, true);
                        }

                    });

                    point.plotOpen = point.xOpen = (prevPoint) ? (prevPoint.xOpen + point.plotClose) / 2 : point.plotOpen;
                    point.plotClose = (point.plotClose + point.plotOpen + point.plotHigh + point.plotLow) / 4;
                    point.plotHigh = Math.min(point.plotHigh, point.plotOpen, point.plotClose);
                    point.plotLow = Math.max(point.plotLow, point.plotOpen, point.plotClose);

                    if ("undefined" !== typeof chartObj && chartObj.isLog) {
                        pointVolume = (series.groupedData && series.infVolume) ? chartObj.getYLabel(series.infVolume[count], false, true, true) : chartObj.getYLabel(seriesData[count][5], false, true, true);
                        point.xpointWidth = (point.shapeArgs.width / chartObj.getYLabel(volumeMax, false, true, true)) * pointVolume;
                    }
                    else {
                        pointVolume = (series.groupedData && series.infVolume) ? series.infVolume[count] : seriesData[count][5];
                        point.xpointWidth = (point.shapeArgs.width / volumeMax) * pointVolume;
                    }

                    point.isInside =
                        point.plotY !== undefined &&
                        point.plotHigh >= 0 &&
                        point.plotLow <= yAxis.len && // #3519
                        point.plotX >= 0 &&
                        point.plotX <= series.xAxis.len;


                    /**
                     * If point is not inside the clip box change the plot values accordingly
                     */
                    if (!point.isInside) {
                        if (!((point.plotLow > yAxis.len && point.plotHigh < yAxis.len) || (point.plotHigh < 0 && point.plotLow > 0) )) {
                            point.plotY = undefined;
                            point.graphic && point.graphic.destroy && point.graphic.destroy();
                            point.graphic = undefined;
                        }
                    }

                    prevPoint = point;
                    count++;

                });

            },
            /**
             * Draw the data points
             */
            drawPoints: function () {
                var series = this,
                    points = series.points,
                    chart = series.chart,
                    yAxis = series.yAxis,
                    yAxisLen = yAxis.len,
                    pointWidth,
                    topBox,
                    bottomBox,
                    crispCorr,
                    crispX,
                    path,
                    halfWidth,
                    isNew,
                    plotHigh,
                    plotLow,
                    graphic,
                    isCompactedShape = _isCompactedShape(series);

                points.forEach(function (point) {

                    graphic = point.graphic;
                    isNew = !graphic;

                    if (point.plotY !== undefined) {

                        if (!graphic) {
                            point.graphic = graphic = chart.renderer.path()
                                .add(series.group);
                        }

                        graphic
                            .attr(series.pointAttribs(point, point.selected && 'select')) // #3897
                            .shadow(series.options.shadow);

                        pointWidth = point.xpointWidth;
                        plotLow = point.plotLow;
                        plotHigh = point.plotHigh;

                        // Crisp vector coordinates
                        crispCorr = (graphic.strokeWidth() % 2) / 2;
                        crispX = Math.round(point.plotX) - crispCorr; // #2596

                        topBox = Math.min(plotLow, plotHigh);
                        bottomBox = Math.max(plotLow, plotHigh);

                        halfWidth = Math.round(pointWidth / 2);
                        topBox = Math.round(topBox) + crispCorr;
                        bottomBox = Math.round(bottomBox) + crispCorr;
                        point.shapeArgs.height = halfWidth * 2;

                        if (bottomBox > yAxisLen) {
                            bottomBox = yAxisLen;
                        } else if (topBox < 0) {
                            topBox = 0;
                        }

                        if (isCompactedShape) {
                            path = [
                                'M',
                                crispX, bottomBox,
                                'L',
                                crispX, topBox,
                                'Z' // Use a close statement to ensure a nice rectangle #2602

                            ];
                        } else {
                            path = [
                                'M',
                                crispX - halfWidth, bottomBox,
                                'L',
                                crispX - halfWidth, topBox,
                                'L',
                                crispX + halfWidth, topBox,
                                'L',
                                crispX + halfWidth, bottomBox,
                                'Z' // Use a close statement to ensure a nice rectangle #2602

                            ];
                        }

                        graphic[isNew ? 'attr' : 'animate']({
                            d: path
                        }).addClass(point.getClassName(), true);
                    }
                });
            },

            animate: null // Disable animation

            /**
             * @constructor seriesTypes.ohlc.prototype.pointClass
             * @extends {Point}
             */
        }, /** @lends seriesTypes.ohlc.prototype.pointClass.prototype */ {});
        //endregion ************** end of Equi Volume type *********************************

        //region **************  Signal type *********************************

        seriesType('infUDSignal', 'flags', H.merge(defaultPlotOptions.flags, defaultPlotOptions.infUDSignal,
            {
                "dataGrouping": {
                    approximation: "average"
                }

            }), /** @lends seriesTypes.column */ {
            translate: function () {

                seriesTypes.column.prototype.translate.apply(this);

                var series = this,
                    options = series.options,
                    chart = series.chart,
                    points = series.points,
                    cursor = points.length - 1,
                    point,
                    lastPoint,
                    optionsOnSeries = options.onSeries,
                    onSeries = optionsOnSeries && chart.get(optionsOnSeries),
                    onKey = options.onKey || 'y',
                    step = onSeries && onSeries.options.step,
                    onData = onSeries && onSeries.points,
                    i = onData && onData.length,
                    xAxis = series.xAxis,
                    yAxis = series.yAxis,
                    xAxisExt = xAxis.getExtremes(),
                    xOffset = 0,
                    leftPoint,
                    lastX,
                    rightPoint,
                    currentDataGrouping;

                // relate to a master series
                if (onSeries && onSeries.visible && i) {
                    xOffset = (onSeries.pointXOffset || 0) + (onSeries.barW || 0) / 2;
                    currentDataGrouping = onSeries.currentDataGrouping;
                    lastX = onData[i - 1].x + (currentDataGrouping ? currentDataGrouping.totalRange : 0); // #2374

                    // sort the data points
                    H.stableSort(points, function (a, b) {
                        return (a.x - b.x);
                    });

                    onKey = 'plot' + onKey[0].toUpperCase() + onKey.substr(1);
                    while (i-- && points[cursor]) {
                        point = points[cursor];
                        leftPoint = onData[i];
                        if (leftPoint.x <= point.x && leftPoint[onKey] !== undefined) {
                            if (point.x <= lastX) { // #803

                                point.plotY = leftPoint[onKey];
                                point.plotX = leftPoint.plotX;
                                /* // interpolate between points, #666
                                 if (leftPoint.x < point.x && !step) {
                                 rightPoint = onData[i + 1];
                                 if (rightPoint && rightPoint[onKey] !== undefined) {
                                 point.plotY +=
                                 ((point.x - leftPoint.x) / (rightPoint.x - leftPoint.x)) * // the distance ratio, between 0 and 1
                                 (rightPoint[onKey] - leftPoint[onKey]); // the y distance
                                 }
                                 }*/
                            }
                            cursor--;
                            i++; // check again for points in the same x position
                            if (cursor < 0) {
                                break;
                            }
                        }
                    }
                }

                // Add plotY position and handle stacking
                points.forEach(function (point, i) {

                    var stackIndex;

                    // Undefined plotY means the point is either on axis, outside series
                    // range or hidden series. If the series is outside the range of the
                    // x axis it should fall through with an undefined plotY, but then
                    // we must remove the shapeArgs (#847).
                    if (point.plotY === undefined) {
                        if (point.x >= xAxisExt.min && point.x <= xAxisExt.max) {
                            // we're inside xAxis range
                            point.plotY = chart.chartHeight - xAxis.bottom -
                                (xAxis.opposite ? xAxis.height : 0) +
                                xAxis.offset - yAxis.top; // #3517
                        } else {
                            point.shapeArgs = {}; // 847
                        }
                    }
                    point.plotX += xOffset; // #2049
                    // if multiple flags appear at the same x, order them into a stack
                    lastPoint = points[i - 1];
                    if (lastPoint && lastPoint.plotX === point.plotX) {
                        if (lastPoint.stackIndex === undefined) {
                            lastPoint.stackIndex = 0;
                        }
                        stackIndex = lastPoint.stackIndex + 1;
                    }
                    point.stackIndex = stackIndex; // #3639
                });


            },

            sorted: false,
            noSharedTooltip: false,
            allowDG: false,
            takeOrdinalPosition: false, // #1074
            trackerGroups: ['markerGroup'],
            forceCrop: true,
            animate: null // Disable animation

            /**
             * @constructor seriesTypes.ohlc.prototype.pointClass
             * @extends {Point}
             */
        }, /** @lends seriesTypes.ohlc.prototype.pointClass.prototype */ {});
        //endregion ************** end of Signal type *********************************

        //region **************  Signal type *********************************

        seriesType('infsignal', 'flags', H.merge(defaultPlotOptions.flags, defaultPlotOptions.infsignal,
            {
                "dataGrouping": {
                    approximation: "average"
                }

            }), /** @lends seriesTypes.equivolume */ {

            sorted: false,
            noSharedTooltip: true,
            allowDG: false,
            takeOrdinalPosition: false, // #1074
            trackerGroups: ['markerGroup'],
            forceCrop: true,
            translate: function () {

                seriesTypes.column.prototype.translate.apply(this);

                var series = this,
                    options = series.options,
                    chart = series.chart,
                    points = series.points,
                    cursor = points.length - 1,
                    point,
                    lastPoint,
                    optionsOnSeries = options.onSeries,
                    onSeries = optionsOnSeries && chart.get(optionsOnSeries),
                    onKey = options.onKey || 'y',
                    step = onSeries && onSeries.options.step,
                    onData = onSeries && onSeries.points,
                    i = onData && onData.length,
                    xAxis = series.xAxis,
                    yAxis = series.yAxis,
                    xAxisExt = xAxis.getExtremes(),
                    xOffset = 0,
                    leftPoint,
                    lastX,
                    rightPoint,
                    currentDataGrouping;

                // relate to a master series
                if (onSeries && onSeries.visible && i) {
                    xOffset = (onSeries.pointXOffset || 0) + (onSeries.barW || 0) / 2;
                    currentDataGrouping = onSeries.currentDataGrouping;
                    lastX = onData[i - 1].x + (currentDataGrouping ? currentDataGrouping.totalRange : 0); // #2374

                    // sort the data points
                    H.stableSort(points, function (a, b) {
                        return (a.x - b.x);
                    });

                    onKey = 'plot' + onKey[0].toUpperCase() + onKey.substr(1);
                    while (i-- && points[cursor]) {
                        point = points[cursor];
                        leftPoint = onData[i];
                        if (leftPoint.x <= point.x && leftPoint[onKey] !== undefined) {
                            if (point.x <= lastX) { // #803

                                point.plotY = leftPoint[onKey];
                                point.plotX = leftPoint.plotX;
                                /* // interpolate between points, #666
                                 if (leftPoint.x < point.x && !step) {
                                 rightPoint = onData[i + 1];
                                 if (rightPoint && rightPoint[onKey] !== undefined) {
                                 point.plotY +=
                                 ((point.x - leftPoint.x) / (rightPoint.x - leftPoint.x)) * // the distance ratio, between 0 and 1
                                 (rightPoint[onKey] - leftPoint[onKey]); // the y distance
                                 }
                                 }*/
                            }
                            cursor--;
                            i++; // check again for points in the same x position
                            if (cursor < 0) {
                                break;
                            }
                        }
                    }
                }

                // Add plotY position and handle stacking
                points.forEach(function (point, i) {

                    var stackIndex;

                    // Undefined plotY means the point is either on axis, outside series
                    // range or hidden series. If the series is outside the range of the
                    // x axis it should fall through with an undefined plotY, but then
                    // we must remove the shapeArgs (#847).
                    if (point.plotY === undefined) {
                        if (point.x >= xAxisExt.min && point.x <= xAxisExt.max) {
                            // we're inside xAxis range
                            point.plotY = chart.chartHeight - xAxis.bottom -
                                (xAxis.opposite ? xAxis.height : 0) +
                                xAxis.offset - yAxis.top; // #3517
                        } else {
                            point.shapeArgs = {}; // 847
                        }
                    }
                    // point.plotX += xOffset; // #2049
                    // if multiple flags appear at the same x, order them into a stack
                    /*lastPoint = points[i - 1];
                     if (lastPoint && lastPoint.plotX === point.plotX) {
                     if (lastPoint.stackIndex === undefined) {
                     lastPoint.stackIndex = 0;
                     }
                     stackIndex = lastPoint.stackIndex + 1;
                     }
                     point.stackIndex = stackIndex; // #3639*/
                });


            },

            drawPoints: function () {
                var series = this,
                    points = series.points,
                    chart = series.chart,
                    renderer = chart.renderer,
                    plotX,
                    plotY,
                    options = series.options,
                    optionsY = options.y,
                    shape,
                    i,
                    point,
                    graphic,
                    stackIndex,
                    anchorX,
                    anchorY,
                    outsideRight,
                    yAxis = series.yAxis;

                i = points.length;
                while (i--) {
                    point = points[i];
                    outsideRight = point.plotX > series.xAxis.len;
                    plotX = point.plotX;
                    stackIndex = point.stackIndex;
                    shape = point.options.shape || options.shape;
                    plotY = point.plotY;

                    if (plotY !== undefined) {
                        plotY = point.plotY + optionsY - (stackIndex !== undefined && stackIndex * options.stackDistance);
                    }
                    anchorX = stackIndex ? undefined : point.plotX; // skip connectors for higher level stacked points
                    anchorY = stackIndex ? undefined : point.plotY;

                    graphic = point.graphic;

                    // Only draw the point if y is defined and the flag is within the visible area
                    if (plotY !== undefined && plotX >= 0 && !outsideRight) {

                        // Create the flag
                        if (!graphic) {
                            graphic = point.graphic = renderer.label(
                                '',
                                plotX,
                                plotY,
                                shape,
                                anchorX,
                                anchorY,
                                options.useHTML, true
                            )

                                .attr(series.pointAttribs(point))
                                .css(H.merge(options.style, point.style))

                                .attr({
                                    align: shape === 'flag' ? 'left' : 'center',
                                    width: options.width,
                                    height: options.height,
                                    'text-align': 'bottom'
                                })
                                .addClass('highcharts-point')
                                .add(series.markerGroup);

                            // Add reference to the point for tracker (#6303)
                            if (point.graphic.div) {
                                point.graphic.div.point = point;
                            }


                            graphic.shadow(options.shadow);

                        }

                        if (plotX > 0) { // #3119
                            plotX -= graphic.strokeWidth() % 2; // #4285
                        }

                        // Plant the flag
                        graphic.attr({
                            text: point.options.title || options.title || 'A',
                            x: plotX,
                            y: plotY,
                            anchorX: anchorX,
                            anchorY: anchorY
                        });

                        // Set the tooltip anchor position
                        point.tooltipPos = chart.inverted ? [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - plotX] : [plotX, plotY + yAxis.pos - chart.plotTop]; // #6327
                        if (series.options.shape == "uparw") {
                            graphic.text.attr("y", graphic.box.anchorY + graphic.box.height + parseInt(graphic.text.styles.fontSize));//$(graphic.element).position().top - anchorY); // To set y Label to the bottom
                        } else if (series.options.shape == "downarw") {
                            graphic.text.attr("y", graphic.box.anchorY - graphic.box.height - 1 /*+ parseInt(graphic.text.styles.fontSize)*/);//$(graphic.element).position().top - anchorY); // To set y Label to the bottom
                        }

                    } else if (graphic) {
                        point.graphic = graphic.destroy();
                    }

                }

                // Might be a mix of SVG and HTML and we need events for both (#6303)
                if (options.useHTML) {
                    H.wrap(series.markerGroup, 'on', function (proceed) {
                        return H.SVGElement.prototype.on.apply(
                            proceed.apply(this, [].slice.call(arguments, 1)), // for HTML
                            [].slice.call(arguments, 1)); // and for SVG
                    });
                }

            },
            animate: null // Disable animation

            /**
             * @constructor seriesTypes.ohlc.prototype.pointClass
             * @extends {Point}
             */
        }, /** @lends seriesTypes.ohlc.prototype.pointClass.prototype */ {});
        //endregion ************** end of Signal type *********************************

        //region **************  plot Range type *********************************
        var theme = Highcharts.theme && Highcharts.theme.plotOptions.plotrange || {};
        seriesType('plotarearange', 'arearange', H.merge(defaultPlotOptions.arearange, defaultPlotOptions.arearange, theme, {
            dataGrouping: {
                enabled: true,
                approximation: function (low, high) {

                    var NUMBER = 'number';

                    var sum = function (arr) {
                        var len = arr.length,
                            ret;

                        /* 1. it consists of nulls exclusively*/
                        if (!len && arr.hasNulls) {
                            ret = null;
                            /* 2. it has a length and real values*/
                        } else if (len) {
                            ret = 0;
                            while (len--) {
                                ret += arr[len];
                            }
                        }
                        /*3. it has zero length, so just return undefined
                         => doNothing()*/

                        return ret;
                    };

                    var len = low.length;
                    low = sum(low);

                    /*If we have a number, return it divided by the length. If not, return
                     null or undefined based on what the sum method finds.*/
                    if (typeof low === NUMBER && len) {
                        low = low / len;
                    }
                    len = high.length;
                    high = sum(high);

                    /*If we have a number, return it divided by the length. If not, return
                     null or undefined based on what the sum method finds.*/
                    if (typeof high === NUMBER && len) {
                        high = high / len;
                    }


                    if (typeof low === NUMBER || typeof high === NUMBER) {
                        return [low, high];
                    }
                    /* else, return is undefined*/
                }
            }
        }), /** @lends seriesTypes.equivolume */ {
            pointArrayMap: ['high', 'low'], // array point configs are mapped to this
            toYData: function (point) { // return a plain array for speedy calculation
                return [point.high, point.low];
            },
            pointValKey: 'high',
            /**
             * Extend the line series' getSegmentPath method by applying the segment
             * path to both lower and higher values of the range
             */
            getGraphPath: function (points) {

                var highPoints = [],
                    highAreaPoints = [],
                    i,
                    getGraphPath = seriesTypes.area.prototype.getGraphPath,
                    point,
                    pointShim,
                    linePath,
                    lowerPath,
                    options = this.options,
                    connectEnds = this.chart.polar && options.connectEnds !== false,
                    connectNulls = options.connectNulls,
                    step = options.step,
                    higherPath,
                    higherAreaPath,
                    keyIdx = H.inArray(this.pointValKey, this.pointArrayMap);

                points = points || this.points;
                i = points.length;

                // Create the top line and the top part of the area fill. The area fill compensates for
                // null points by drawing down to the lower graph, moving across the null gap and
                // starting again at the lower graph.
                i = points.length;
                var lowerPoints = (this.hasGroupedData) ? [] : points;
                while (i--) {
                    point = points[i];

                    var hasGrpNull = (point.dataGroup &&
                        (!options.data[point.dataGroup.start + point.dataGroup.length][keyIdx + 1] || !options.data[point.dataGroup.start + point.dataGroup.length + 1] || !options.data[point.dataGroup.start + point.dataGroup.length + 1][keyIdx + 1]));


                    if (this.hasGroupedData) {
                        lowerPoints.push(point);
                    }
                    if (!point.isNull && !connectEnds && !connectNulls &&
                        (!points[i + 1] || points[i + 1].isNull || hasGrpNull )
                    ) {
                        highAreaPoints.push({
                            plotX: point.plotX,
                            plotY: point.plotY,
                            doCurve: false // #5186, gaps in areasplinerange fill
                        });
                    }

                    pointShim = {
                        polarPlotY: point.polarPlotY,
                        rectPlotX: point.rectPlotX,
                        yBottom: point.yBottom,
                        plotX: H.pick(point.plotHighX, point.plotX), // plotHighX is for polar charts
                        plotY: point.plotHigh,
                        isNull: point.isNull
                    };

                    highAreaPoints.push(pointShim);

                    highPoints.push(pointShim);

                    hasGrpNull = (point.dataGroup &&
                        (!options.data[point.dataGroup.start][keyIdx + 1] || !options.data[point.dataGroup.start - 1] || !options.data[point.dataGroup.start - 1][keyIdx + 1]));
                    if (points[i - 1] && hasGrpNull) {
                        highAreaPoints.push({
                            plotX: point.plotX,
                            plotY: point.plotHigh,
                            doCurve: false // #5186, gaps in areasplinerange fill
                        });

                        pointShim = {
                            yBottom: null,
                            plotX: point.plotX - this.closestPointRangePx / 2, // plotHighX is for polar charts
                            plotY: null,
                            isNull: true
                        };

                        highAreaPoints.push(pointShim);

                        highPoints.push(pointShim);
                        lowerPoints.push(pointShim);
                    }

                    if (!hasGrpNull && !point.isNull && !connectEnds && !connectNulls &&
                        (!points[i - 1] || points[i - 1].isNull
                        )
                    ) {
                        highAreaPoints.push({
                            plotX: point.plotX,
                            plotY: point.plotY,
                            doCurve: false // #5186, gaps in areasplinerange fill
                        });
                    }
                }
                if (this.hasGroupedData) {
                    lowerPoints.reverse();
                }
                // Get the paths
                lowerPath = getGraphPath.call(this, lowerPoints);
                if (step) {
                    if (step === true) {
                        step = 'left';
                    }
                    options.step = {
                        left: 'right',
                        center: 'center',
                        right: 'left'
                    }[step]; // swap for reading in getGraphPath
                }
                higherPath = getGraphPath.call(this, highPoints);
                higherAreaPath = getGraphPath.call(this, highAreaPoints);
                options.step = step;

                // Create a line on both top and bottom of the range
                linePath = [].concat(lowerPath, higherPath);

                // For the area path, we need to change the 'move' statement into 'lineTo' or 'curveTo'
                if (!this.chart.polar && higherAreaPath[0] === 'M') {
                    higherAreaPath[0] = 'L'; // this probably doesn't work for spline
                }

                this.graphPath = linePath;
                this.areaPath = this.areaPath.concat(lowerPath, higherAreaPath);

                // Prepare for sideways animation
                linePath.isArea = true;
                linePath.xMap = lowerPath.xMap;
                this.areaPath.xMap = lowerPath.xMap;

                return linePath;
            },
            animate: null // Disable animation

            /**
             * @constructor seriesTypes.ohlc.prototype.pointClass
             * @extends {Point}
             */
        }, /** @lends seriesTypes.ohlc.prototype.pointClass.prototype */ {});
        //endregion ************** end of Plot Range type *********************************

        //region **************  plot Range type *********************************
        var theme = Highcharts.theme && Highcharts.theme.plotOptions.plotrange || {};
        seriesType('plotrange', 'columnrange', H.merge(defaultPlotOptions.columnrange, defaultPlotOptions.column, theme, {
            dataGrouping: {
                enabled: true,
                approximation: function (low, high) {

                    var NUMBER = 'number';

                    var sum = function (arr) {
                        var len = arr.length,
                            ret;

                        /* 1. it consists of nulls exclusively*/
                        if (!len && arr.hasNulls) {
                            ret = null;
                            /* 2. it has a length and real values*/
                        } else if (len) {
                            ret = 0;
                            while (len--) {
                                ret += arr[len];
                            }
                        }
                        /*3. it has zero length, so just return undefined
                         => doNothing()*/

                        return ret;
                    };

                    var len = low.length;
                    low = sum(low);

                    /*If we have a number, return it divided by the length. If not, return
                     null or undefined based on what the sum method finds.*/
                    if (typeof low === NUMBER && len) {
                        low = low / len;
                    }
                    len = high.length;
                    high = sum(high);

                    /*If we have a number, return it divided by the length. If not, return
                     null or undefined based on what the sum method finds.*/
                    if (typeof high === NUMBER && len) {
                        high = high / len;
                    }


                    if (typeof low === NUMBER || typeof high === NUMBER) {
                        return [low, high];
                    }
                    /* else, return is undefined*/
                }
            },
            states: {

                /**
                 */
                hover: {
                    enabled: false
                }
            }
        }), /** @lends seriesTypes.equivolume */ {
            pointArrayMap: ['high', 'low'], // array point configs are mapped to this
            toYData: function (point) { // return a plain array for speedy calculation
                return [point.high, point.low];
            },
            pointValKey: 'low',
            translate: function () {
                var series = this,
                    hchart = series.chart,
                    yAxis = series.yAxis,
                    colProto = seriesTypes.columnrange.prototype,
                    indWithComparision = (this.chart.series[0].modifyValue && this.options.infType == 'indicator' && infChart.util.isSeriesInBaseAxis(series.yAxis.options.id)),
                    grpdiff = 0,
                    diff = 0,
                    safeDistance = Math.max(hchart.chartWidth, hchart.chartHeight) + 999;

                colProto.translate.apply(series);

                if (indWithComparision) {
                    var chart = _getChartObj(this.chart.renderTo.id);
                    var cropStart = this.chart.series[0].cropStart;

                    if (chart.processedData.data.length > 0 && cropStart && chart.compareSymbols.count > 0) {

                        diff = chart.processedData.data[cropStart][4] - chart.processedData.data[0][4];

                    }
                }

                // Don't draw too far outside plot area (#6835)
                function safeBounds(pixelPos) {
                    return Math.min(Math.max(-safeDistance,
                        pixelPos
                    ), safeDistance);
                }

                // Set plotLow and plotHigh
                series.points.forEach(function (point) {
                    var low = point.low,
                        high = point.high,
                        plotY = point.plotY,
                        shapeArgs = point.shapeArgs;
                    if (H.isNumber(point.high)) {
                        if (series.chart.series[0].currentDataGrouping) {
                            high = point.high - diff;
                        }
                        else {
                            high = point.high - diff;
                            // point.high
                            point.plotHigh = yAxis.translate(point.high, 0, 1, 0, 1);
                        }
                    }
                    if (H.isNumber(point.low)) {
                        if (series.chart.series[0].currentDataGrouping) {
                            low = point.low + grpdiff;
                        }
                        else {
                            low = point.options.low - diff;
                        }
                    }
                    var yValue = point.y;
                    if (series.chart.series[0].currentDataGrouping) {
                        yValue = yValue - diff;
                    }
                    else {
                        yValue = yValue - diff;
                    }

                    point.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?
                        Math.min(Math.max(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201
                        UNDEFINED;
                    point.yBottom = point.plotY;

                    if (high === null && low === null) {
                        point.y = null;
                    } else if (low === null) {
                        point.plotLow = point.plotY = null;
                        point.plotHigh = safeBounds(
                            yAxis.translate(high, 0, 1, 0, 1)
                        );
                    } else if (high === null) {
                        point.plotLow = plotY;
                        point.plotHigh = null;
                    } else {
                        point.plotLow = plotY;
                        point.plotHigh = yAxis.translate(high, 0, 1, 0, 1);
                        shapeArgs.height = point.plotLow - point.plotHigh;
                        shapeArgs.y = point.plotHigh;
                    }

                });


            },
            drawPoints: function () {
                var series = this,
                    chart = this.chart,
                    options = series.options,
                    renderer = chart.renderer,
                    animationLimit = options.animationLimit || 250,
                    mainSeries = chart.series[0],
                    shapeArgs,
                    keyIdx = H.inArray(this.pointValKey, this.pointArrayMap),
                    prevPoint;

                // draw the columns
                series.points.forEach(function (point) {
                    var plotY = point.plotY,
                        graphic = point.graphic;

                    if (H.isNumber(plotY) && point.y !== null && H.isNumber(point.plotX) && point.x != null) {
                        shapeArgs = point.shapeArgs;

                        //if (Math.round(Math.abs(point.plotX - shapeArgs.x)) == shapeArgs.width) {
                        //shapeArgs.width = /*shapeArgs.width *2 - */Math.abs(point.plotX - shapeArgs.x) * 2;
                        var prevWidth = shapeArgs.width,
                            shapeMiddle = Math.min(series.xAxis.toPixels(point.x), point.plotX + prevWidth / 2);
                        shapeArgs.width = mainSeries.closestPointRangePx;
                        //}
                        //if (shapeArgs.x < point.plotX && ((!point.dataGroup && series.points[point.index + 1] && series.points[point.index + 1].isNull ) || (point.dataGroup &&point.dataGroup.length>1))) {
                        if (!point.dataGroup && prevPoint && !prevPoint.isNull) {
                            shapeArgs.x = prevPoint.shapeArgs.x + prevPoint.shapeArgs.width;
                        } else if (point.dataGroup && prevPoint && (point.dataGroup.start - (prevPoint.dataGroup.start + prevPoint.dataGroup.length) <= 1)) {
                            shapeArgs.x = prevPoint.shapeArgs.x + prevPoint.shapeArgs.width;
                        } else if ((shapeMiddle - shapeArgs.width / 2) < shapeArgs.x) {
                            shapeArgs.x = shapeMiddle - shapeArgs.width / 2;
                        }

                        //}
                        if (graphic) { // update
                            graphic[chart.pointCount < animationLimit ? 'animate' : 'attr'](
                                H.merge(shapeArgs)
                            );

                        } else {
                            point.graphic = graphic = renderer[point.shapeType](shapeArgs)
                                .add(point.group || series.group);
                        }


                        // Presentational
                        graphic
                            .attr(series.pointAttribs(point, point.selected && 'select'))
                            .shadow(options.shadow, null, options.stacking && !options.borderRadius);


                        graphic.addClass(point.getClassName(), true);

                    } else if (graphic) {
                        point.graphic = graphic.destroy(); // #1269
                    }
                    prevPoint = point;
                });
            },

            animate: null // Disable animation

            /**
             * @constructor seriesTypes.ohlc.prototype.pointClass
             * @extends {Point}
             */
        }, /** @lends seriesTypes.ohlc.prototype.pointClass.prototype */ {});
        //endregion ************** end of Plot Range type *********************************

        //region *************** Flag array symbol ***************

        Highcharts.SVGRenderer.prototype.symbols.arr = function (x, y, w, h, options) {
            var anchorX = options && options.anchorX || 0,
                anchorY = options && options.anchorY || 0,
                path;

            if (y > anchorY) {
                //points up
                path = ['M', anchorX, anchorY, 'L', anchorX + w / 2, anchorY + h, 'L', anchorX + w / 4, anchorY + h,
                    'L', anchorX + w / 4, y + h, 'L', anchorX - w / 4, y + h, 'L', anchorX - w / 4, anchorY + h, 'L', anchorX - w / 2, anchorY + h, 'L', anchorX, anchorY];

            } else {
                //points down
                y = Math.max(0, y);
                var maxWidth = Math.max(4, (anchorY - y) / 3);
                w = Math.min(maxWidth, w);
                path = ['M', anchorX - w / 2, anchorY - h, 'L', anchorX, anchorY, 'L', anchorX + w / 2, anchorY - h,
                    'L', anchorX + w / 4, anchorY - h, 'L', anchorX + w / 4, y, 'L', anchorX - w / 4, y,
                    'L', anchorX - w / 4, anchorY - h, 'L', anchorX - w / 2, anchorY - h];
            }

            return path;
        };
        if (Highcharts.VMLRenderer) {
            Highcharts.VMLRenderer.prototype.symbols.arr = Highcharts.SVGRenderer.prototype.symbols.arr;
        }

        Highcharts.SVGRenderer.prototype.symbols.uparw = function (x, y, w, h, options) {
            var anchorX = options && options.anchorX || 0,
                anchorY = options && options.anchorY || 0,
                path;

            //if (y > anchorY) {
            //points up
            //y = Math.min(0,y);
            var ytop = anchorY;
            //ytop = Math.max(ytop,0);
            var ybottom = Math.max(anchorY + h, y);
            var maxWidth = Math.max(4, (ybottom - ytop) / 2);
            w = Math.min(maxWidth, w);
            path = ['M', anchorX, ytop, 'L', anchorX + w / 2, ytop + h / 2, 'L', anchorX + w / 4, ytop + h / 2,
                'L', anchorX + w / 4, ybottom, 'L', anchorX - w / 4, ybottom, 'L', anchorX - w / 4, ytop + h / 2, 'L', anchorX - w / 2, ytop + h / 2, 'L', anchorX, ytop];
            //}

            return path;
        };

        if (Highcharts.VMLRenderer) {
            Highcharts.VMLRenderer.prototype.symbols.uparw = Highcharts.SVGRenderer.prototype.symbols.uparw;
        }
        Highcharts.SVGRenderer.prototype.symbols.downarw = function (x, y, w, h, options) {
            var anchorX = options && options.anchorX || 0,
                anchorY = options && options.anchorY || 0,
                path;

            //points down
            var yBottom = Math.max(anchorY, y + h);

            var ytop = Math.max(anchorY - h, 0, y);
            var maxWidth = Math.max(4, (yBottom - ytop) / 2);
            w = Math.min(maxWidth, w);
            path = ['M', anchorX - w / 2, yBottom - h / 2, 'L', anchorX, yBottom, 'L', anchorX + w / 2, yBottom - h / 2,
                'L', anchorX + w / 4, yBottom - h / 2, 'L', anchorX + w / 4, ytop, 'L', anchorX - w / 4, ytop,
                'L', anchorX - w / 4, yBottom - h / 2, 'L', anchorX - w / 2, yBottom - h / 2];
            return path;
        };

        if (Highcharts.VMLRenderer) {
            Highcharts.VMLRenderer.prototype.symbols.downarw = Highcharts.SVGRenderer.prototype.symbols.downarw;
        }

        //endregion *************** Flag array symbol ***************

    };

    var _extendDefaultCharTypes = function () {

        H.wrap(H.seriesTypes.column.prototype, 'pointAttribs', function (proceed, point, state) {
            let series = this;
            if (series.chart.isChartDragging) {
                let options = series.options;
                let p2o = series.pointAttrToOptions || {};
                let strokeWidthOption = p2o['stroke-width'] || 'borderWidth';
                let strokeOption = p2o.stroke || 'borderColor'
                return {
                    fill: point && point.color,
                    stroke: ((point && point[strokeOption]) || options[strokeOption] || fill),
                    'stroke-width': (point && point[strokeWidthOption]) || options[strokeWidthOption] || series[strokeWidthOption] || 0,
                    opacity: point.opacity
                }
            } else {
                return proceed.call(series, point, state);
            }
        });

        H.wrap(H.seriesTypes.candlestick.prototype, 'drawPoints', function (proceed) {
            var series = this, //state = series.state,
                points = series.points,
                chart = series.chart,
                reversedYAxis = series.yAxis.reversed,
                test,
                isCompactedShape = _isCompactedShape(series);

            if (isCompactedShape) {
                for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
                    var point = points_1[_i];
                    var graphic = point.graphic,
                        plotOpen = void 0,
                        plotClose = void 0,
                        topBox = void 0,
                        bottomBox = void 0,
                        hasTopWhisker = void 0,
                        hasBottomWhisker = void 0,
                        crispCorr = void 0,
                        crispX = void 0,
                        path = void 0,
                        halfWidth = void 0;
                    var isNew = !graphic;
                    if (typeof point.plotY !== 'undefined') {
                        if (!graphic) {
                            point.graphic = graphic = chart.renderer.path()
                                .add(series.group);
                        }
                        if (!series.chart.styledMode) {
                            graphic
                                .attr(series.pointAttribs(point, (point.selected && 'select'))) // #3897
                                .shadow(series.options.shadow);
                        }
                        // Crisp vector coordinates
                        crispCorr = (graphic.strokeWidth() % 2) / 2;
                        // #2596:
                        crispX = Math.round(point.plotX) - crispCorr;
                        plotOpen = point.plotOpen;
                        plotClose = point.plotClose;
                        topBox = Math.min(plotOpen, plotClose);
                        bottomBox = Math.max(plotOpen, plotClose);
                        halfWidth = Math.round(point.shapeArgs.width / 2);
                        hasTopWhisker = reversedYAxis ?
                            bottomBox !== point.yBottom :
                            Math.round(topBox) !==
                                Math.round(point.plotHigh);
                        hasBottomWhisker = reversedYAxis ?
                            Math.round(topBox) !==
                                Math.round(point.plotHigh) :
                            bottomBox !== point.yBottom;
                        topBox = Math.round(topBox) + crispCorr;
                        bottomBox = Math.round(bottomBox) + crispCorr;
                        // Create the path. Due to a bug in Chrome 49, the path is
                        // first instanciated with no values, then the values
                        // pushed. For unknown reasons, instanciating the path array
                        // with all the values would lead to a crash when updating
                        // frequently (#5193).
                        path = [];
                        var bottom = hasBottomWhisker ? Math.round(point.yBottom) : bottomBox,
                            top = hasTopWhisker ? Math.round(point.plotHigh) : topBox;

                        path.push(
                            'M',
                            crispX, bottom, // #460, #2094
                            'L',
                            crispX, bottom == top ? top - crispCorr : top, // #460, #2094
                            'Z' // Use a close statement to ensure a nice rectangle #260
                        );
                        graphic[isNew ? 'attr' : 'animate']({ d: path })
                            .addClass(point.getClassName(), true);
                    }
                }
            } else {
                proceed.call(this);
            }
        });

        H.wrap(H.seriesTypes.ohlc.prototype, 'pointAttribs', function (proceed, point, state) {
            var attribs = seriesTypes.column.prototype.pointAttribs.call(this, point, state),
                options = this.options,
                stateOptions;

            delete attribs.fill;
            if (!point.options.color && options.upColor && point.open < point.close) {
                attribs.stroke = options.upColor;
            }

            // Select or hover states
            if (state) {
                stateOptions = options.states[state];
                attribs.stroke = stateOptions.lineColor || attribs.stroke;
                attribs['stroke-width'] =
                    stateOptions.lineWidth || attribs['stroke-width'];
            }

            return attribs;
        });

        // modify arearange indicator plot values when there is a comparison since indicators are drawn below the main chart if not modified.
        H.wrap(H.seriesTypes.arearange.prototype, 'translate', function (proceed) {

            proceed.call(this);

            var series = this,
                yAxis = series.yAxis,
                hasModifyValue = !!series.modifyValue,
                parallelToBaseWithComparision = _isIndicatorWithComparison(series),
                grpdiff = 0, diff = 0,

                mainSeriesCompareValue = _getMainSeriesCompareValue(series.chart);


            H.seriesTypes.area.prototype.translate.apply(series);

            if (parallelToBaseWithComparision) {
                diff = _getMainSeriesCompareValue(series.chart);


                // Set plotLow and plotHigh
                series.points.forEach(function (point) {
                    var low = point.low,
                        high = point.high,
                        plotY = point.plotY;
                    if (H.isNumber(point.high)) {
                        if (series.chart.series[0].currentDataGrouping) {
                            high = (point.high / mainSeriesCompareValue - 1 ) * 100;
                        }
                        else {
                            high = (point.high / mainSeriesCompareValue - 1 ) * 100;
                            // point.high
                            point.plotHigh = yAxis.translate(high, 0, 1, 0, 1);
                        }
                    }
                    if (H.isNumber(point.low)) {
                        if (series.chart.series[0].currentDataGrouping) {
                            low = (point.low / mainSeriesCompareValue - 1 ) * 100;
                        }
                        else {
                            low = (point.options.low / mainSeriesCompareValue - 1 ) * 100;
                        }
                    }
                    var yValue = point.y;

                    if (series.chart.series[0].currentDataGrouping) {
                        yValue = (yValue / mainSeriesCompareValue - 1 ) * 100;
                    }
                    else {
                        yValue = (yValue / mainSeriesCompareValue - 1 ) * 100;
                    }

                    point.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?
                        Math.min(Math.max(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201
                        UNDEFINED;
                    point.yBottom = point.plotY;

                    if (high === null && low === null) {
                        point.y = null;
                    } else if (low === null) {
                        point.plotLow = point.plotY = null;
                        point.plotHigh = yAxis.translate(high, 0, 1, 0, 1);
                    } else if (high === null) {
                        yValue = low;
                        point.plotLow = yAxis.translate(low, 0, 1, 0, 1);
                        point.plotHigh = null;
                    } else {
                        yValue = low;
                        point.plotLow = yAxis.translate(low, 0, 1, 0, 1);
                        point.plotHigh = yAxis.translate(high, 0, 1, 0, 1);
                    }
                    point.negative = yValue < (series.options.threshold || 0);
                });

            }
            // Postprocess plotHigh
            if (this.chart.polar) {
                this.points.forEach(function (point) {
                    series.highToXY(point);
                });
            }
        });

        /**
         * Extended this to control the taking hidden points into account when calculating yAxis min/max
         * An issue occured in depth graph which half of the yAxis is empty due to
         * last hidden point which had a lager value was taken into account when calculating yAxis min/max.
         * However this fix kept on hold in the depth chart since it leads to line breaks inside the visible chart area (As per the requirement both lines should be drawn to both ends)
         */
        H.wrap(H.seriesTypes.line.prototype, 'init', function (proceed) {
            proceed.apply(this, [].slice.call(arguments, 1));
            if (this.options && !isNaN(this.options.cropShoulder)) {
                this.cropShoulder = this.options.cropShoulder;

            }
        });

    };

    var _extendHighChartsForAxisPositioning = function () {
        var H = Highcharts;

        /**
         * Wrapped up this method to set pixel interval of the y/x axis manually when needed
         */
        H.wrap(H.Axis.prototype, 'setTickInterval', function (proceed, secondPass) {

            var axis = this,
                ichart = _getChartObj(axis.chart.renderTo.id);

            if ("undefined" !== typeof ichart && ichart.chart) {
                ichart.setAxisPixelInterval(axis);
            }

            proceed.call(this, secondPass);


        });

        /**
         * Wrapped up this method to do things required to do before/after rendering axis labels
         */
        H.wrap(H.Axis.prototype, 'renderUnsquish', function (proceed) {
            var axis = this,
                ichart = _getChartObj(axis.chart.renderTo.id);

            //if (!axis.isXAxis && "undefined" !== typeof ichart && ichart.chart) {
            //    ichart._setYAxisWidthOnRedraw(axis);
            //}

            proceed.call(this);

            if ("undefined" !== typeof ichart && ichart.chart) {
                //if (!axis.isXAxis){
                //    ichart.setYAxisWidthOnRedraw(axis);
                //}
                ichart.afterRenderAxisLabels(axis);
            }

        });

        // Wrapping aup the Axis.getOffset method to adjust the axis labels width according to the drawing and other labels
        H.wrap(H.Axis.prototype, 'getOffset', function (proceed) {
            var axis = this,
                chart = axis.chart,
                side = axis.side,
                options = axis.options,
                xChart = _getChartObj(this.chart.renderTo.id),
                offset;
            proceed.call(this);

            if (!axis.isXAxis) {
                if (xChart && options.id === "#0") {
                    offset = infChart.manager.getAxisLabelOffset(xChart.id, this);
                    if (offset) {
                        chart.axisOffset[side] = offset;
                    }
                } else if (infChart.depthManager && infChart.depthManager.isDepthChart(chart)) {
                    offset = infChart.depthManager.getAxisLabelOffset(chart, this);
                    if (offset) {
                        chart.axisOffset[side] = offset;
                    }
                }
            }
        });
    };

    /**
     * Extend Highchart to show/hide tooltip according to xInfinit chart's tooltip property
     * @private
     */
    var _extendHighChartsForHideTooltip = function () {
        // Wrappers for Highcharts
        var H = Highcharts;
        H.wrap(H.Tooltip.prototype, 'refresh', function (proceed, pointOrPoints, mouseEvent) {
            var iChart = _getChartObj(this.chart.renderTo.id);
            if ("undefined" === typeof iChart || (pointOrPoints && pointOrPoints.length)) {
                proceed.call(this, pointOrPoints, mouseEvent);
            }
        });

        /**
         * Avoid mouse move functions when dragging an annotation
         */
        H.wrap(H.Pointer.prototype, 'onContainerMouseMove', function (proceed, mouseEvent) {
            var iChart = _getChartObj(this.chart.renderTo.id);
            var hChart = this.chart;

            hChart.infLastMouseMoveEvent = mouseEvent; // keep this to use in update ticks

            if (hChart.infTrackerHidden) {
                $(hChart.renderTo).find(".highcharts-tracker").show();
                hChart.infTrackerHidden = false;
            }
            // if ((!hChart.annotations || hChart.annotations.allowZoom) && ("undefined" === typeof iChart || !iChart.isLoading())) {
            //     proceed.call(this, mouseEvent);
            // }
            if (("undefined" === typeof iChart || !iChart.isLoading())) {
                proceed.call(this, mouseEvent);
            }
            hChart.infMouseIn = true;
            hChart.infMouseMoved = true;
        });

        /**
         * Set the mouse in false when leaving the mouse from the chart
         */
        H.wrap(H.Pointer.prototype, 'onContainerMouseLeave', function (proceed, mouseEvent) {
            var hChart = H.charts[H.hoverChartIndex];

            if (hChart) {
                delete hChart.infLastMouseMoveEvent; //  no need to keep this when mouse is left.
                hChart.infMouseIn = false;
                proceed.call(this, mouseEvent);

                if (_isXChart(hChart)) {
                    infChart.manager.chartMouseOutEvent(hChart);
                }
            } else {
                proceed.call(this, mouseEvent);
            }
        });

        /**
         * To avoid incorrect tooltip time on some signals whose width is greater than the pixel width between two base points
         */
        H.wrap(H.Point.prototype, 'onMouseOver', function (proceed, e) {
            var point = this,
                series = point.series,
                ichart = _getChartObj(series.chart.renderTo.id),
                hchart = series.chart;

            if ("undefined" !== typeof ichart && ( series && series.options.infAvoidToolTipSel || ichart.isLoading())) {
                hchart.hoverPoint = undefined;
                hchart.hoverSeries = undefined;
            } else {
                proceed.call(this, e);
            }
        });
    };

    /**
     * Extends svg renderer which is extended by Highcharts
     * @private
     */
    var _extendSVGRenderer = function () {

        /**
         * Since last labels crops when value is at extremes of y axis, made adjustments from the code and anchors are adjusted here.
         */
        H.wrap(H.SVGRenderer.prototype.symbols, 'callout', function (proceed, x, y, w, h, options) {
            if (options.parentGroup && options.parentGroup.attr("showHalfAnchor") === "true") {
                var arrowLength = 6,
                    halfDistance = 6,
                    r = Math.min((options && options.r) || 0, w, h),
                    safeDistance = r + halfDistance,
                    anchorX = options && options.anchorX,
                    anchorY = options && options.anchorY,
                    path,
                    newTopY;

                path = [
                    'M', x + r, y,
                    'L', x + w - r, y, // top side
                    'C', x + w, y, x + w, y, x + w, y + r, // top-right corner
                    'L', x + w, y + h - r, // right side
                    'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner
                    'L', x + r, y + h, // bottom side
                    'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner
                    'L', x, y + r, // left side
                    'C', x, y, x, y, x + r, y // top-left corner
                ];

                // Anchor on left side
                if (anchorX && anchorX > w) {

                    newTopY = (anchorY + halfDistance) > h ? h : undefined;
                    if (newTopY) {

                        path.splice(13, 3,
                            'L', x + w, anchorY - halfDistance,
                            x + w + arrowLength, anchorY,
                            x + w + (anchorY + halfDistance - h) * arrowLength * 2 / h, newTopY,
                            x + w, newTopY,
                            x + w, y + h - r
                        );

                        /*path.splice(13, 3,
                         'L', x + w, newTopY,
                         x - (arrowLength/halfDistance) * (-1) * anchorY , newTopY,
                         x + w + arrowLength, anchorY,
                         x + w, anchorY + halfDistance,
                         x + w, y + h - r
                         );*/
                    } else {
                        path.splice(13, 3,
                            'L', x + w, anchorY - halfDistance,
                            x + w + arrowLength, anchorY,
                            x + w, anchorY + halfDistance,
                            x + w, y + h - r
                        );
                    }


                    // Anchor on right side
                } else if (anchorX && anchorX < 0) {

                    newTopY = (anchorY + halfDistance) > h ? h : undefined;

                    if (newTopY) {
                        // Chevron
                        path.splice(33, 3,
                            'L', x, newTopY,
                            x - (anchorY + halfDistance - h) * arrowLength * 2 / h, newTopY,
                            x - arrowLength, anchorY,
                            x, anchorY - halfDistance,
                            x, y + r
                        );
                    } else {
                        path.splice(33, 3,
                            'L', x, anchorY + halfDistance,
                            x - arrowLength, anchorY,
                            x, anchorY - halfDistance,
                            x, y + r
                        );
                    }

                } else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom
                    path.splice(23, 3,
                        'L', anchorX + halfDistance, y + h,
                        anchorX, y + h + arrowLength,
                        anchorX - halfDistance, y + h,
                        x + r, y + h
                    );
                } else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top
                    path.splice(3, 3,
                        'L', anchorX - halfDistance, y,
                        anchorX, y - arrowLength,
                        anchorX + halfDistance, y,
                        w - r, y
                    );
                }

                return path;
            } else {
                return proceed.call(this, x, y, w, h, options);
            }
        });
    };

    /**
     * This is a fix for the issue of chart area is getting black if a gradient is used and url changes after loading.
     * @private
     */
    var _applyPathFixForMobile = function () {

        //if(/iP(ad|hone|od).+Version\/[\d\.]+.*Safari/i.test(navigator.userAgent)) {
        H.Chart.prototype.callbacks.push(function (chart) {
            chart.xOnUrlChange = function (newUrl) {
                if (newUrl == undefined) {
                    newUrl = ((H.isFirefox || H.isWebKit) && H.doc.getElementsByTagName('base').length ?
                        H.win.location.href
                            .replace(/#.*?$/, '') // remove the hash
                            .replace(/<[^>]*>/g, '') // wing cut HTML
                            .replace(/([\('\)])/g, '\\$1') // escape parantheses and quotes
                            .replace(/ /g, '%20') : // replace spaces (needed for Safari only)
                        '');
                }

                var currentUrl = chart.renderer.url;
                chart.renderer.url = newUrl;
                $(chart.container).find("[fill^='url(" + currentUrl + "']").each(function (key, value) {
                    var element = $(value),
                        fill = element.attr('fill'),
                        temp = fill.split("url(" + currentUrl);

                    $(value).attr("fill", temp.join("url(" + newUrl));
                });
            };
        });

        window.addEventListener("onpopstate", function () {
            var newUrl = infChart.util.getBaseURL() || "";

            H.charts.forEach(function (chart, index) {
                if (chart && chart.xOnUrlChange) {
                    chart.xOnUrlChange(newUrl);
                }
            });

        });
        //}
    };

    _extendHighCharts();
    _extendDefaultCharTypes();
    _extendHighChartsForCustomChartTypes();
    _extendHighChartsForAxisPositioning();
    _extendHighChartsForHideTooltip();
    _extendSVGRenderer();
    _applyPathFixForMobile();

})(infChart, jQuery, Highcharts);
var infChart = window.infChart || {};

infChart.langManager = infChart.langManager || (function () {

        var data = {}, pendingRequests = {}, defaultFileExtension = '.json', cachedLabels = {};

        var _getData = function (pathPrefix, file, callback) {
            var url = pathPrefix + '/' + file;
            $.getJSON(url, undefined, callback);
        };

        var _localizeElements = function (data, container) {
            container.find('[data-localize]').each(function (i, element) {
                var $el = $(element), key = $el.attr('data-localize'), value = _getLabelFromData(data, key);
                if ($el.prev().is("input")) {
                    $el.val(value);
                } else {
                    $el.html(value);
                }
            });
        };

        var _getLabelFromData = function (data, key) {
            var label = cachedLabels[key];
            if(!label) {
                var keyArr = key.split('.');

                function getInnerObj(obj, arr) {
                    if(!obj) {
                        return
                    }
                    if (arr.length === 1) {
                        return obj[arr[0]];
                    }
                    else {
                        var keyTemp = arr.splice(0, 1);
                        if (obj && keyTemp[0] && obj[keyTemp[0]]) {
                            return getInnerObj(obj[keyTemp[0]], arr);
                        }
                    }
                }

                label = getInnerObj(data, keyArr);

                if(label) {
                    cachedLabels[key] = label;
                } else {
                    label = (label) ? label : key;
                }


            }

            return label;
        };

        var _getLabel = function (lang, key) {
            return _getLabelFromData(data[lang], key);
        };

        var _invokeCallback = function (callback, lang, element, referenceId) {
            if (typeof callback === 'undefined') {
                _localizeElements(data[lang], element);
            } else {
                callback(data[lang], element, _localizeElements, referenceId);
            }
        };

        var _localize = function (options) {
            if (options.language) {
                if (data.hasOwnProperty(options.language)) {
                    _invokeCallback(options.callback, options.language, options.element, options.referenceId);
                } else {
                    if(pendingRequests.hasOwnProperty(options.language)){
                        infChart.util.console.info('waiting to resolve lang : ' + options.language);
                        pendingRequests[options.language].push(options);
                    }else{
                        pendingRequests[options.language] = [options];

                        var file = (options.file ? options.file : ('lang-' + options.language + defaultFileExtension));

                        var defaultCallback = function (langData) {
                            data[options.language] = langData;
                            pendingRequests[options.language].forEach(function(opt){
                                _invokeCallback(opt.callback, options.language, opt.element, opt.referenceId);
                            });
                            delete pendingRequests[options.language];
                        };

                        _getData(options.pathPrefix, file, defaultCallback);
                    }
                }
            } else {
                infChart.util.console.error('language not defined');
            }
        };

        return {
            localize: _localize,
            getLabel: _getLabel
        }
    })();



/**
 * Created by dushani on 9/2/15.
 * This section includes the implementation related to the chart tool bar
 */
var infChart = window.infChart || {};

infChart.toolbar = (function () {
    var _instance;
    var _chartManager;

    var selectedCSSClass = 'selected';

    /**
     * @typedef {object} toolbarConfig
     * @property {Array<object>} options
     * @property {boolean} [categorized=false] categorized
     * @property {string} [categoryLabelPrefix=undefined] categoryLabelPrefix - category header label prefix
     * @property {string} [display=undefined] display - comma separated keys to filter the options for display
     * @property {boolean} [shortLabel=false] shortLabel - display short description or long description
     * @property {string} [baseClass=undefined] baseClass - class for li
     * @property {string} [menuClass=undefined] menuClass - class for ul
     */

    //region toolbar

    /**
     * Base method
     * @param container container
     * @param {string} uniqueId unique id
     * @param {object} config
     * @private
     */
    var _createToolbar = function (container, uniqueId, config) {

        _chartManager = (_chartManager) ? _chartManager : infChart.manager;

        var toolbarParent;

        container.attr("inf-toolbar-type", "l");

        if (config.top && config.topTb) {
            toolbarParent = container.find('[inf-pnl="tb-top"]');
            _bindElements(container, uniqueId, toolbarParent, config.topTb, config.config);
        }
        if (config.upper && config.upperTb) {
            toolbarParent = container.find('[inf-pnl="tb-upper"]');
            _bindElements(container, uniqueId, toolbarParent, config.upperTb, config.config);
        }
        if (config.right && config.rightTb) {
            toolbarParent = container.find('[inf-pnl="tb-right"]');
            _bindElements(container, uniqueId, toolbarParent, config.rightTb, config.config);
            // binding the close button of the right panel
            _setSingleOptionControl(toolbarParent, "pnlClose", function () {
                var chart = _getChartInstance(uniqueId);
                chart.hideRightPanel(container, true, true);
            });
        }
        if (config.mobile && config.mobileTb) {
            toolbarParent = container.find('[inf-pnl="tb-mobile"]');
            _bindElements(container, uniqueId, toolbarParent, config.mobileTb, config.config);
        }
    };

    var _getChartInstance = function (uniqueId) {
        return _chartManager.getChart(uniqueId);
    };


    /**
     * bind elements
     * @param container
     * @param {string} uniqueId
     * @param toolbarParent
     * @param {Array<string>} buttons
     * @param {object} config
     * @private
     */
    var _bindElements = function (container, uniqueId, toolbarParent, buttons, config) {
        buttons.forEach(function (controlType) {
            var buttonConfig = config[controlType];
            switch (controlType) {
                case "comparison":
                    _setComparison(container, uniqueId, toolbarParent, config[controlType]);
                    break;
                case "period":
                    if (config[controlType].categorized) {
                        var categories = {};
                        infChart.util.forEach(config[controlType].options, function (i, option) {
                            if (!categories[option.category]) {
                                categories[option.category] = option;
                                _setSelectedValueInMultiOptionControlWithText(_getControlElement(toolbarParent, controlType), option.key, false);
                            }
                        });
                    }
                    _setMultiOptionControlWithText(toolbarParent, controlType, function (value) {
                        _getChartInstance(uniqueId).setPeriod(value, true, false, undefined, true);
                    });
                    break;
                case "indicator"://indicator dropdown in top toolbar
                    _setIndicatorControl(container, uniqueId, toolbarParent, config[controlType]);
                    break;
                case "rightPanel":
                    _setSingleOptionControl(toolbarParent, controlType, function () {
                        var chart = _getChartInstance(uniqueId);
                        var isVisible = chart.toggleRightPanel(container, true);
                        if (isVisible) {
                            var panel = _getSettingsContainer(uniqueId, 'indicatorPanelView');//show indicator panel by default

                            if (!panel.find('[inf-ctrl="indicator"]').find('div.panel-collapse').is(":visible")) {
                                panel.find('[inf-ctrl="indicator"]').find('div.panel-collapse').addClass('in');
                            }
                        }
                        return isVisible;
                    });
                    break;
                case "indicatorPanelView"://indicator panel
                    var panel = _getSettingsContainer(uniqueId, 'indicatorPanelView'), indicatorDropdownPanel = panel.find('[inf-ctrl="indicator"]');
                    var id = uniqueId + '-indicator-panel';
                    panel.attr('rel', id);
                    infChart.structureManager.indicator.bindIndicatorSearchPanel(indicatorDropdownPanel);
                    _setIndicatorControl(container, uniqueId, panel);
                    break;
                case "drawingToolPanelView":
                    var drawingPanel = _getSettingsContainer(uniqueId, 'drawingToolPanelView'),
                        drawingPanelId = uniqueId + '-drawing-panel';
                    drawingPanel.attr('rel', drawingPanelId);
                    break;
                case "symbolSettingsPanelView":
                    var symbolPanel = _getSettingsContainer(uniqueId, 'symbolSettingsPanelView'),
                        symbolPanelId = uniqueId + '-symbol-settings-panel';
                    symbolPanel.attr('rel', symbolPanelId);
                    break;
                case "adv" :
                    _setAdvanceChartControl(container, uniqueId, toolbarParent, config[controlType]);
                    break;
                case "flags" :
                    _setMultiOptionControlWithMultipleSelect(toolbarParent, controlType, function (value) {
                        return _getChartInstance(uniqueId).toggleFlags(value);
                    });
                    break;
                case "file" :
                    _setMultiOptionControlWithType(toolbarParent, controlType, function (value, type) {
                        if (value == "saveAsDefault") {
                            try {
                                infChart.manager.saveTemplate(uniqueId, "default", type);
                                infChart.util.showMessage(uniqueId, "Successfully Saved!");
                            }
                            catch (e) {
                                infChart.util.showMessage(uniqueId, "Error in Saving!");
                            }
                        } else if (value == "removeDefault") {
                            try {
                                infChart.manager.deleteTemplate(uniqueId, "default", type);
                                infChart.util.showMessage(uniqueId, "Successfully Removed!");
                            }
                            catch (e) {
                                infChart.util.showMessage(uniqueId, "Error in Removing!");
                            }
                        } else if(value == "loadDefault"){
                            try {
                                infChart.manager.loadTemplate(uniqueId, "default", type);
                                infChart.util.showMessage(uniqueId, "Successfully Load To Default!!");
                            } catch (error) {
                                infChart.util.showMessage(uniqueId, "Error in Load To Default!");
                            }
                        }
                         else {
                            _loadTemplatePopup(container, uniqueId, value, type);
                        }
                    });
                    break;
                case "interval" :
                    _setMultiOptionControlWithText(toolbarParent, controlType, function (value) {
                        container.find("[inf-ctrl=period] [inf-ctrl-type=interval].selected").removeClass('selected');//what is this??
                        _getChartInstance(uniqueId).setIntervalManually(value, undefined, true, undefined, true);
                    });
                    break;
                case "periodD":
                    buttonConfig && buttonConfig.compactShowOnly && _getControlElement(toolbarParent, 'period').addClass('compact-show');
                    _setMultiOptionControlWithText(toolbarParent, 'period', function (value) {
                        _getChartInstance(uniqueId).setPeriod(value, true, false, undefined, true);
                    });
                    break;
                case "intervalD":

                    buttonConfig && buttonConfig.compactShowOnly && _getControlElement(toolbarParent, 'interval').addClass('compact-show');
                    //_getControlElement(toolbarParent, 'interval').addClass('compact-show');
                    _setMultiOptionControlWithText(toolbarParent, 'interval', function (value) {
                        _getChartInstance(uniqueId).setIntervalManually(value, undefined, true, undefined, true);
                    });
                    break;
                case "chartType" :
                    _setMultiOptionControlWithIcon(toolbarParent, controlType, true, function (value) {
                        infChart.manager.setChartStyle(uniqueId, value);
                    });
                    break;
                case "grid" :
                    _setMultiOptionControlWithIcon(toolbarParent, controlType, true, function (value) {
                        _getChartInstance(uniqueId).setGridType(value, true, true);
                    });
                    break;
                case "crosshair" :
                    _setMultiOptionControl(toolbarParent, controlType, function (value) {
                        return _getChartInstance(uniqueId).toggleCrosshair(value, true);
                    });
                    break;
                case "depth" :
                    _setMultiOptionControl(toolbarParent, controlType, function (value) {
                        return _getChartInstance(uniqueId).changeDepthSide(value, true);
                    });
                    break;
                case "print" :
                    _setSelectedValueInMultiOption(_getControlElement(toolbarParent, controlType), 'print', false);
                    _setMultiOptionControlWithIcon(toolbarParent, controlType, false, function (value) {
                        var afterPrint = (config) ? config.afterPrint : undefined;
                        infChart.manager.exportChart(uniqueId, value, afterPrint);
                    });
                    break;
                case "zoom" :
                    infChart.structureManager.common.setSingleOptionControlWithoutStatus(toolbarParent, controlType, function (value) {
                        infChart.manager.zoom(uniqueId, value);
                    });
                    break;
                case "full-screen" :
                    infChart.structureManager.common.setSingleOptionControlWithoutStatus(toolbarParent, controlType, function () {
                        infChart.manager.handleFullscreen(container);
                    });
                    break;
                //case "reset":
                //    infChart.structureManager.common.setSingleOptionControlWithoutStatus(toolbarParent, controlType, function () {
                //        if (config[controlType] && typeof config[controlType].onClick === 'function') {
                //            config[controlType].onClick(uniqueId);
                //        }
                //    });
                //    break;
                case "volume":
                    _setSingleOptionControl(toolbarParent, controlType, function () {
                        var indicatorType = buttonConfig && buttonConfig.type ? buttonConfig.type : "VOLUME";
                        return _getChartInstance(uniqueId).toggleSingletonIndicatorByType(indicatorType, true);
                    });
                    break;
                case "spread":
                    _setSingleOptionControl(toolbarParent, controlType, function () {
                        var indicatorType = buttonConfig && buttonConfig.type ? buttonConfig.type : "SPREAD";
                        return _getChartInstance(uniqueId).toggleSingletonIndicatorByType(indicatorType, true);
                    });
                    break;
                case "bidAskHistory":
                    _setSingleOptionControl(toolbarParent, controlType, function () {
                        var indicatorType = buttonConfig && buttonConfig.type ? buttonConfig.type : "BAH";
                        return _getChartInstance(uniqueId).toggleSingletonIndicatorByType(indicatorType, true);
                    });
                    break;
                case "value" :
                    _setSingleOptionControl(toolbarParent, 'percent', function () {
                        return _getChartInstance(uniqueId).toggleChartDataMode('percent', true);
                    });
                    _setSingleOptionControl(toolbarParent, 'log', function () {
                        return _getChartInstance(uniqueId).toggleChartDataMode('log', true);
                    });
                    break;
                case "navigator" :
                    _setSingleOptionControl(toolbarParent, controlType, function () {
                        return _getChartInstance(uniqueId).toggleHistory(true);
                    });
                    break;
                case "tooltip" :
                    _setSingleOptionControl(toolbarParent, controlType, function () {
                        return _getChartInstance(uniqueId).toggleToolTip(true);
                    });
                    break;
                //case "tradingPanel" : NOW REMOVED
                //    _setSingleOptionControl(toolbarParent, controlType, function () {
                //        var chart = _getChartInstance(uniqueId);
                //        var isVisible = chart.showRightPanelWithTab(container, true);
                //        if (isVisible) {
                //            if (chart.trader) {
                //                chart.trader.showTradingView(isVisible, chart.settings.toolbar.trading);
                //            }
                //        }
                //        return isVisible;
                //    });
                //    break;
                case "news" :
                    _setSingleOptionControl(toolbarParent, controlType, function () {
                        return _getChartInstance(uniqueId).toggleNews(true);
                    });
                    break;
                case "last" :
                    _setSingleOptionControl(toolbarParent, controlType, function () {
                        return _getChartInstance(uniqueId).toggleLastLine(true);
                    });
                    break;
                case "preclose" :
                    _setSingleOptionControl(toolbarParent, controlType, function () {
                        return _getChartInstance(uniqueId).togglePreviousCloseLine(true);
                    });
                    break;
                case "minMax" :
                    _setSingleOptionControl(toolbarParent, controlType, function () {
                        return _getChartInstance(uniqueId).toggleShowMinMax(true);
                    });
                    break;
                case "orderBookHistory":
                    _setSingleOptionControl(toolbarParent, controlType, function () {
                        return _getChartInstance(uniqueId).toggleOrderBookHistory(true);
                    });
                    break;
                //case "buy":
                //case "sell":
                //    infChart.structureManager.common.setSingleOptionControlWithoutStatus(toolbarParent, controlType, function (value) {
                //        return infChart.tradingManager.onTradeControlUpdates(uniqueId, value);
                //    });
                //    break;
                case "tradeControlCompact":
                    _setDefaultMultiOptionControl(toolbarParent, controlType, function (value) {
                        return infChart.tradingManager.onTradeControlUpdates(uniqueId, value);
                    });
                    break;
                case "pinInterval" :
                    _setSingleOptionControl(toolbarParent, controlType, function () {
                        return _getChartInstance(uniqueId).togglePinInterval(true);
                    });
                    break;
                case "buy":
                case "sell":
                    buttonConfig && buttonConfig.compactShowOnly && _getControlElement(toolbarParent, controlType).addClass('compact-show');
                    infChart.structureManager.common.setSingleOptionControlWithoutStatus(toolbarParent, controlType, function (value) {
                        return infChart.tradingManager.onTradeControlUpdates(uniqueId, value);
                    });
                    break;
                case "undo":
                case "redo":
                    _setSingleOptionControl(toolbarParent, controlType, function () {
                        return infChart.commandsManager.executeCommand(uniqueId, controlType);
                    });
                    break;
                default :
                    if (config[controlType] && typeof config[controlType].onClick === 'function') {
                        infChart.structureManager.common.setSingleOptionControlWithoutStatus(toolbarParent, controlType, function () {
                            config[controlType].onClick(uniqueId);
                        });
                    }
                    break;
            }
        });
    };

    /**
     * This section applies the bootstrap tooltip and a workaround to deal with the issues encountered with dropdowns.
     * @private
     */
    var _initializeTooltips = function (contaner) {

        contaner.find("[x-tt-class]").each(function (i, el) {
            $(el).addClass($(el).attr('x-tt-class'));
        });

       /* var tooltips = $('[data-toggle="tooltip"]').tooltip();

        var onTooltipMouseMove,
            prevTT,
            currentTT;

        var onMouseMove = function (event) {

            /!*if (!$(event.target).is(tt) && tt.closest(".dropdown").is($(event.target).closest(".dropdown")) && $(event.target).attr('data-toggle') != "tooltip") {
             //tt.closest(".dropdown").removeClass("manual-hover");


             if(!$(event.target).closest('[data-toggle="tooltip"]').data('bs.tooltip').$tip.is(':visible')){
             $(event.target).closest('[data-toggle="tooltip"]').tooltip('show');
             }
             }*!/
            /!*if($(event.target).attr('data-toggle') != "tooltip"){
             alert('ok');
             }*!/
            //console.error("onMouseMove :: " +  currentTT.attr("data-original-title"));
            if (!currentTT.parents(".dropdown").has($(event.target)).length && !$(event.target).closest('[role="tooltip"]').length) {
                currentTT.parents(".dropdown").removeClass("manual-hover");

                console.error("onMouseMove removed :: " + currentTT.attr("data-original-title"));
            }
            $(document).off('mousemove', onMouseMove);
        };

        tooltips.on("shown.bs.tooltip", function () {
            var tt = $(this);
            if (!tt.is(currentTT)) {
                prevTT = currentTT;
            }
            currentTT = $(this);


            if (!currentTT.data('bs.tooltip').$tip.is(':visible')) {
                currentTT.tooltip('show');
                console.error('shown.bs.tooltip :: show :: ' + currentTT.attr("data-original-title"));
            }


            //$(document).off('mousemove', onMouseMove);
            $('[role="tooltip"]').off('mousemove').on('mousemove', function (event) {
                $(this).off('mousemove');
                // console.error('mousemove [role="tooltip"] :: ' + currentTT.attr("data-original-title"));
                event.stopPropagation();
                //tt.tooltip('hide');
                currentTT.parents(".dropdown").addClass("manual-hover"); // manually show the dropdown since it gets hide when mouse is moved to the tooltip area

                // However "manual-hover" class should be removed once mouse is moved again. other wise dropdown may not work naturally
                // So, that class is removed on the very first mouse move capture and unregistered from the event

                $(document).off('mousemove', onMouseMove);
                $(document).on('mousemove', onMouseMove);
                /!*var hoverFun = function(){
                 if(!$(this).data('bs.tooltip') || !$(this).data('bs.tooltip').$tip || !$(this).data('bs.tooltip').$tip.is(':visible')){
                 $(this).tooltip('show');
                 }
                 tt.closest(".dropdown").find("li").off('mousemove', hoverFun);
                 };
                 tt.closest(".dropdown").find("li").on('mousemove',hoverFun);
                 if($(document.elementFromPoint(event.clientX,event.clientY)))*!/
                var currentPointTT = $(document.elementFromPoint(event.clientX, event.clientY)).closest('[data-toggle="tooltip"]');
                currentPointTT.tooltip('show');
                if (currentPointTT) {
                    var ccData = currentPointTT.data('bs.tooltip');
                    (!ccData || !ccData.$tip || !ccData.$tip.is(':visible')) && currentPointTT.tooltip('show');
                }
            });
        });

        tooltips.on("hidden.bs.tooltip", function () {
            $(this).parents(".dropdown").removeClass("manual-hover"); // TODO : fix this issue check $('[role="tooltip"]') before remove
        });*/
    };

    //region multi

    /**
     * multi option - control
     * used for tradeControl
     * @param parent
     * @param {string} controlType
     * @param {function} fn
     * @private
     */
    var _setDefaultMultiOptionControl = function (parent, controlType, fn) {
        var control = _getControlElement(parent, controlType);
        _getOptionElementsForMultiOptions(control).click(function (event) {
            fn(_getValueFromAttribute(this));
            event.preventDefault();
        });
    };

    /**
     * multi option - control where selected icon is shown
     * used in chart types and grid types
     * @param parent
     * @param {string} controlType
     * @param {function} fn
     * @private
     */
    var _setMultiOptionControlWithIcon = function (parent, controlType, isControlHighlight, fn) {
        var control = _getControlElement(parent, controlType);
        _getOptionElementsForMultiOptions(control).click(function (event) {
            var value = _getValueFromAttribute(this);
            _setSelectedValueInMultiOptionControlWithIcon(control, value, isControlHighlight);
            fn(value);
            event.preventDefault();
        });
    };

    /**
     * multi option - control where selected text is shown
     * used for interval
     * @param parent
     * @param {string} controlType
     * @param {function} fn
     * @private
     */
    var _setMultiOptionControlWithText = function (parent, controlType, fn) {
        var control = _getControlElement(parent, controlType);
        _getOptionElementsForMultiOptions(control).click(function (event) {
            var value = _getValueFromAttribute(this);
            _setSelectedValueInMultiOptionControlWithText(control, value);
            fn(value);
            event.preventDefault();
        });
    };

    /**
     * multi option - control where selected icon is shown with status
     * used in depth, cross-hair
     * @param parent
     * @param controlType
     * @param fn
     * @private
     */
    var _setMultiOptionControl = function (parent, controlType, fn) {
        var control = _getControlElement(parent, controlType);
        _getOptionElementsForMultiOptions(control).click(function (event) {
            var value = _getValueFromAttribute(this);
            var enabled = fn(value);

            if (typeof enabled == "object") {
                value = enabled.value || value;
                enabled = enabled.enabled;
            }
            _setSelectedValueInMultiOption(control, value, enabled);
            event.preventDefault();
        });
    };

    /**
     * multi option - control where multiple items can be selected
     * used for flags
     * @param parent
     * @param {string} controlType
     * @param {function} fn
     * @private
     */
    var _setMultiOptionControlWithMultipleSelect = function (parent, controlType, fn) {
        var control = _getControlElement(parent, controlType);
        _getOptionElementsForMultiOptions(control).click(function (event) {
            var flagType = _getValueFromAttribute(this);
            var enabledFlags = fn(flagType);
            _setSelectedValuesInMultiOptionControlWithMultipleSelect(control, enabledFlags);
            event.preventDefault();
        });
    };

    /**
     * multi option with static text
     * used for file
     * @param parent
     * @param {string} controlType
     * @param {function} fn
     * @private
     */
    var _setMultiOptionControlWithType = function (parent, controlType, fn) {
        _getOptionElementsForMultiOptions(_getControlElement(parent, controlType)).click(function (event) {
            var action = _getValueFromAttribute(this);
            var templateType = $(this).attr('inf-temp-type');
            fn(action, templateType);
            event.preventDefault();
        });
    };

    /**
     * get bind element
     * @param control
     * @returns {*}
     * @private
     */
    var _getOptionElementsForMultiOptions = function (control) {
        return control.find('[inf-ctrl-value]');
    };

    //endregion

    //region single

    /**
     * single option with status
     * @param parent
     * @param {string} controlType
     * @param {function} fn
     * @private
     */
    var _setSingleOptionControl = function (parent, controlType, fn) {
        var control = _getControlElement(parent, controlType);
        control.click(function (event) {
            var attrValue = _getValueFromAttribute(this);
            var status = fn(attrValue);
            _setButtonStatus(control, status);
            event.preventDefault();
        });
    };

    /**
     * single option without status
     * used in zoom, reset, fullscreen
     * @param parent
     * @param {string} controlType
     * @param {function} fn
     * @private
     */
    // var _setSingleOptionControlWithoutStatus = function (parent, controlType, fn) {
    //     var control = _getControlElement(parent, controlType);
    //     control.click(function (event) {
    //         fn(_getValueFromAttribute(this));
    //         event.preventDefault();
    //     });
    // };

    //endregion

    /**
     * get control element
     * @param container
     * @param {string} controlType
     * @returns {*}
     * @private
     */
    var _getControlElement = function (container, controlType) {
        return container.find('[inf-ctrl="' + controlType + '"]');
    };

    /**
     * get selected element
     * @param control
     * @param {string} value
     * @returns {*}
     * @private
     */
    var _getSelectedElementFromValue = function (control, value) {
        return control.find('[inf-ctrl-value="' + value + '"]');
    };

    /**
     * get selected element icon
     * @param control
     * @param {string} value
     * @returns {string} - icon class
     * @private
     */
    var _getSelectedElementIconFromValue = function (control, value) {
        return _getSelectedElementFromValue(control, value).attr('inf-ico');
    };

    /**
     * get elements from item tag
     * @param control
     * @param {string} type
     * @returns {*}
     * @private
     */
    var _getElementsFromItem = function (control, type, cls) {
        return control.find('[inf-ctrl-item=' + type + ']' + ((cls && ("." + cls)) || ''));
    };

    /**
     * get value from element
     * @param element
     * @returns {string}
     * @private
     */
    var _getValueFromAttribute = function (element) {
        return $(element).attr('inf-ctrl-value');
    };

    /**
     * get top tt type html - ???
     * @param {string} type
     * @returns {string}
     * @private
     */
    var _getTopttItemHtml = function (type) {
        return ' top-tt-item="' + (type || "l") + '"';
    };

    /**
     * get inf-ctrl html
     * @param {string} type
     * @returns {string}
     * @private
     */
    // var _getCtrlTypeHtml = function (type) {
    //     return ' inf-ctrl="' + type + '"';
    // };

    /**
     * get inf-ctrl-value html
     * @param {string} value
     * @returns {string}
     * @private
     */
    // var _getCtrlValueHtml = function (value) {
    //     return ' inf-ctrl-value="' + value + '"';
    // };

    /**
     * get inf-ctrl-item html
     * @param {string} type
     * @returns {string}
     * @private
     */
    var _getCtrlItemHTML = function (type) {
        return ' inf-ctrl-item="' + type + '"';
    };

    /**
     * get inf-ico html
     * @param {string} icon
     * @returns {string}
     * @private
     */
    var _getCtrlIconHtml = function (icon) {
        return ' inf-ico="' + icon + '"';
    };

    /**
     * get inf-status html
     * @param {string} status
     * @returns {string}
     * @private
     */
    var _getCtrlStatusHtml = function (status) {
        return ' inf-status="' + (status ? 'on' : 'off') + '"';
    };

    var _getToolTipAttributes = function (title, direction) {
        return infChart.structureManager.toolbar.getToolTipAttributes(title, direction);
    };

    var _getCtrlTooltipHtml = function (label, shortLabel, isShortLabel, direction) {
        var text = isShortLabel && shortLabel ? shortLabel : label;
        return _getToolTipAttributes(text, direction);
    };

    var _getCtrlTextHtml = function (label, shortLabel, isShortLabel) {
        var text = isShortLabel && shortLabel ? shortLabel : label;
        return ' data-localize="' + text + '"';
    };

    /**
     * initialize chart comparison control
     * @param container
     * @param {string} uniqueId
     * @param parent
     * @param {object} config config options for comparison
     * @private
     */
    var _setComparison = function (container, uniqueId, parent, config) {
        var control = parent.find("li[inf-ctrl='comparison']");

        if (config) {
            if (config.symbolSearch) {
                var symbolSearchEle = control.find('input[data-inf-ctrl-rel="symbolSearch"]');
                symbolSearchEle.autocomplete(config.symbolSearch.options);
                if (config.symbolSearch.extensions) {
                    var extensionPoints = config.symbolSearch.extensions;
                    var instance = symbolSearchEle.autocomplete("instance");
                    if (extensionPoints._resizeMenu) {
                        instance._resizeMenu = extensionPoints._resizeMenu;
                    }
                    if (extensionPoints._renderMenu) {
                        instance._renderMenu = extensionPoints._renderMenu;
                    }
                    if (extensionPoints._renderItem) {
                        instance._renderItem = extensionPoints._renderItem;
                    }
                }
            } else {
                if (config.options && config.options.length > 0) {
                    control.find("li").click(function (event) {
                        infChart.manager.addCompareSymbol(uniqueId, JSON.parse(decodeURI($(this).attr('inf-ctrl-value'))));
                        event.preventDefault();
                    });
                }
            }
        }
    };

    var _setMobileSelectedPeriod = function (container, selectedPeriod) {
        var txt = container.find("[inf-pnl=tb-mobile] [inf-ctrl=period] [inf-ctrl-value=" + selectedPeriod + "]").text();
        container.find("[inf-pnl=tb-mobile] [inf-period-text=selected]").html(txt);
    };

    /**
     * initialize chart period change controls
     * @param container
     * @param uniqueId
     * @param parent
     * @private
     */
    var _setPeriod = function (container, uniqueId, parent) {

        var control = parent.find("[inf-ctrl=period]");

        var periods = control.find("[inf-ctrl-type=period]");
        var periodCategories = control.find("[inf-ctrl-type=period-cat]");

        periods.click(function (event) {
            var chart = _chartManager.getChart(uniqueId),
                selectedPeriod = _getValueFromAttribute($(this));

            chart.setPeriod(selectedPeriod, true, true, undefined, true);
            _setMobileSelectedPeriod(container, selectedPeriod);
            event.preventDefault();
        });

        if (periodCategories && periodCategories.length > 0) {
            periodCategories.click(function (event) {
                var chart = _chartManager.getChart(uniqueId),
                    selectedPeriod = _getValueFromAttribute($(this));
                chart.setPeriod(selectedPeriod, true, true, undefined, true);
                _setMobileSelectedPeriod(container, selectedPeriod);
                _setSelectedControlsGivenContainer(container, "period", selectedPeriod);
                $(this).parent().find("[inf-ctrl-type=period][inf-ctrl-value=" + selectedPeriod + "]").addClass("selected");
                event.preventDefault();
            });
        }
        var chart = _chartManager.getChart(uniqueId);

        periods.each(function (i, element) {
            var control = $(element).find("[inf-ctrl=interval]");

            if (control && control.length > 0) {
                var intervals = control.find("li");
                intervals.click(function (event) {
                    var chart = _chartManager.getChart(uniqueId);
                    var interval = _getValueFromAttribute($(this));
                    var period = $(this).attr('inf-period');
                    chart.setInterval(interval, undefined, true, true, period, undefined, true);
                    periods.find("[inf-ctrl-type=interval].selected").removeClass('selected');
                    $(this).addClass('selected');
                    event.stopPropagation();
                    event.preventDefault();
                });

                /*Validating user defined intervals for the period*/
                var today = (new Date()).getTime();
                var period = _getValueFromAttribute($(element));
                period = chart.isShortPeriod(period) ? 'D_3' : period;
                var minDate = chart.dataManager.getMinDate(period, today);

                $.each(intervals, function () {
                    var intervalOpt = chart.getIntervalOption(_getValueFromAttribute($(this)));
                    if (intervalOpt && intervalOpt.maxPeriod) {
                        var minIntervalDate = chart.dataManager.getMinDate(intervalOpt.maxPeriod, today);
                        if (minDate.getTime() < minIntervalDate.getTime()) {
                            $(this).remove();
                        }
                    }
                });
            }
        });
    };

    /**
     * initialize chart period change controls
     * @param container
     * @param uniqueId
     * @param parent
     * @private
     */
    var _setPeriodDropDown = function (container, uniqueId, parent) {

        var control = parent.find("ul[inf-ctrl=period]");

        var chart = _chartManager.getChart(uniqueId), periods = parent.find('li[inf-ctrl-type="period"]');

        if (control.length > 0) {
            /**
             * this is for periods with intervals
             * https://stackoverflow.com/questions/9758587/twitter-bootstrap-multilevel-dropdown-menu - [Twitter Bootstrap v3]
             */
            control.find("a[inf-ctrl-type='trigger']").on('click', function (event) {
                var current = $(this).next();
                var grandparent = $(this).parent().parent();
                if ($(this).hasClass('left-caret') || $(this).hasClass('right-caret'))
                    $(this).toggleClass('right-caret left-caret');
                grandparent.find('.left-caret').not(this).toggleClass('right-caret left-caret');
                grandparent.find(".sub-menu:visible").not(current).hide();
                current.toggle();
                event.stopPropagation();
                event.preventDefault();
            });

            control.find("a:not([inf-ctrl-type='trigger'])").on('click', function (event) {
                var chart = _chartManager.getChart(uniqueId),
                    dataElement = $(this).parent('li'),
                    type = dataElement.attr('inf-ctrl-type'),
                    value = _getValueFromAttribute(dataElement);
                if (type === 'interval') {
                    var period = dataElement.attr('inf-period');
                    dataElement.parent('ul').siblings('a').find('span[cntrl-role="text"]').text('-' + dataElement.find('a').text());
                    chart.setInterval(value, undefined, true, true, period, undefined, true);
                } else {
                    chart.setPeriod(value, true, true, undefined, true);
                }

                var root = $(this).closest('.dropdown');
                root.find('.left-caret').toggleClass('right-caret left-caret');
                root.find('.sub-menu:visible').hide();
                event.stopPropagation();
                event.preventDefault();
            });
        } else {
            periods.find("li[inf-ctrl-type=interval]").on('click', function (event) {
                var dataElement = $(this), value = _getValueFromAttribute(dataElement);
                var period = dataElement.attr('inf-period');
                dataElement.parent('ul').siblings('a').find('span[cntrl-role="text"]').text('-' + dataElement.find('a').text());
                chart.setInterval(value, undefined, true, true, period, undefined, true);
                event.stopPropagation();
                event.preventDefault();
            });
        }

        periods.each(function (i, element) {
            /*Validating user defined intervals for the period*/
            var today = (new Date()).getTime();
            var period = _getValueFromAttribute($(element));
            period = chart.isShortPeriod(period) ? 'D_3' : period;
            var minDate = chart.dataManager.getMinDate(period, today);

            var intervals = $(element).find("li[inf-ctrl-type=interval]");

            $.each(intervals, function () {
                var intervalOpt = chart.getIntervalOption(_getValueFromAttribute($(this)));
                if (intervalOpt && intervalOpt.maxPeriod) {
                    var minIntervalDate = chart.dataManager.getMinDate(intervalOpt.maxPeriod, today);
                    if (minDate.getTime() < minIntervalDate.getTime()) {
                        $(this).remove();
                    }
                }
            });
        });
    };

    var _setIndicatorControl = function (container, uniqueId, parent) {
        var control = parent.find("[inf-ctrl=indicator]");

        control.find("[inf-ctrl-value]").click(function (event) {
            var chart = _chartManager.getChart(uniqueId);
            chart.addIndicator(_getValueFromAttribute($(this)), undefined, true, true);
            //control.find(".dropdown-menu").dropdown("toggle");
            event.preventDefault();
        });

        /** Simple delay function that can wrap around an existing function and provides a callback. */
        var delay = (function () {
            var timer = 0;
            return function (callback, ms) {
                clearTimeout(timer);
                timer = setTimeout(callback, ms);
            };
        })();

        control.find("[inf-ctrl-ind=search]").bind('change keyup', function () {

            var search = $.trim($(this).val());
            var regex = new RegExp("\\b" + search.toUpperCase(), "gi");

            delay(function () {
                control.find("[inf-ctrl-value] a").each(function () {
                    if ($(this).text().toUpperCase().match(regex) === null) {
                        $(this.parentNode).hide();
                    } else {
                        $(this.parentNode).show();
                    }
                });

            }, 100);
        });


    };

    /**
     * change chart from basic to advance & vice versa
     * @param container top level container
     * @param uniqueId
     * @param parent control's parent element
     * @private
     */
    var _setAdvanceChartControl = function (container, uniqueId, parent) {
        var control = parent.find("li[inf-ctrl=adv]");

        if (container.find('div[inf-pnl=tb-left]').is(':visible') || container.find('div[inf-pnl=tb-top]').is(':visible')) {
            control.attr('inf-status', 'on');
            control.find('a:first-child').addClass("icon ico-indent-less");
            control.find('a:first-child').removeClass("icon ico-indent-more");
            container.addClass('chart-more');
        } else {
            control.attr('inf-status', 'off');
            control.find('a:first-child').addClass("icon ico-indent-more");
            control.find('a:first-child').removeClass("icon ico-indent-less");
            container.addClass('chart-less');
        }

        control.click(function (event) {
            var status = $(this).attr("inf-status");
            var chart = _chartManager.getChart(uniqueId);
            var chartContainerDiv = $('div#' + chart.chartId);
            var tradingPanelWidth = 0;

            if (status === "off") {
                $(this).attr('inf-status', 'on');
                $(this).find('a:first-child').addClass("icon ico-indent-less");
                $(this).find('a:first-child').removeClass("icon ico-indent-more");
                chartContainerDiv.addClass('mainchart_chart');
                container.find('div[inf-pnl=tb-left]').show();
                container.find('nav[inf-pnl=tb-top]').show();
                container.addClass('chart-more');
                container.removeClass('chart-less');

                if (container.find('nav[inf-pnl=tb-top]').find("li[inf-ctrl=tradingPanel]").attr('inf-status') == "on") {
                    tradingPanelWidth = container.find('div[inf-pnl=tb-right]').show().outerWidth();
                }
            } else {
                $(this).attr('inf-status', 'off');
                $(this).find('a:first-child').addClass("icon ico-indent-more");
                $(this).find('a:first-child').removeClass("icon ico-indent-less");
                chartContainerDiv.removeClass('mainchart_chart');
                container.find('div[inf-pnl=tb-left]').hide();
                container.find('div[inf-pnl=tb-right]').hide();
                container.find('nav[inf-pnl=tb-top]').hide();
                container.addClass('chart-less');
                container.removeClass('chart-more');
            }
            chart.setSize(chartContainerDiv.width() - tradingPanelWidth, chartContainerDiv.height(), false);
            event.preventDefault();
        });
    };

    //region file

    var _loadTemplatePopup = function (container, uniqueId, action, templateType) {
        infChart.structureManager.templateSettings.loadPopup(container, uniqueId, action, templateType, infChart.manager.getTemplateNames(templateType, uniqueId),
            function (fileActionPopup, clickAction, clickTemplateType, textName) {
                if (textName.trim() != '') {
                    switch (clickAction) {
                        case 'saveTemplate' :
                        case 'save' :
                            if (textName.length > 30) {
                                infChart.util.showMessage(uniqueId, "Maximum Character Length Exceeded!");
                            } else {
                                infChart.manager.saveTemplate(uniqueId, textName, clickTemplateType);
                                fileActionPopup.hide();
                            }
                            break;
                        case 'loadTemplate' :
                        case 'load' :
                            infChart.manager.loadTemplate(uniqueId, textName, clickTemplateType);
                            fileActionPopup.hide();
                            break;
                        case 'delete':
                            infChart.manager.deleteTemplate(uniqueId, textName, clickTemplateType);
                            _loadTemplateNames(fileActionPopup, templateType, uniqueId);
                            break;
                        default :
                            break;
                    }
                }
            });

    };

    var _loadTemplateNames = function (fileActionPopup, templateType, uniqueId) {
        var lis = '';

        var templates = infChart.manager.getTemplateNames(templateType, uniqueId);
        $.each(templates, function (i, val) {
            lis += '<li class="ui-widget-content">' + val + '</li>';
        });

        fileActionPopup.find("ol[inf-file-sel]").html(lis);
    };

    //endregion

    //endregion

    //endregion

    //endregion

    //region set selected values

    var _clearSelectedControls = function (containerId, type, applyFading) {
        var container = $('#' + containerId), control;
        switch (type) {
            case "period":
                control = _getControlElement(container, type);
                var periods = _getElementsFromItem(control, "period"),
                    activeItem = applyFading && _getElementsFromItem(control, "period", "active");

                periods.removeClass('active');

                if (activeItem && activeItem.length) {
                    periods.removeClass('active-dim');
                    activeItem.addClass('active-dim');
                }
                // TODO :: implement for period-cat when used
                // control.find("li[inf-ctrl=period-cat]").removeClass('active');


                break;
            default :
                break;
        }
    };

    /**
     * set selected values to control
     * @param {string} containerId
     * @param {string} type
     * @param {string} value
     * @param {string} subType
     * @param {string} params
     * @private
     */
    var _setSelectedControls = function (containerId, type, value, subType, params) {
        var container = $('#' + containerId);
        _setSelectedControlsGivenContainer(container, type, value, subType, params);
    };

    /**
     * set selected values to control
     * @param container
     * @param {string} type
     * @param {string} value
     * @param {string} subType
     * @param {string} params
     * @private
     */
    var _setSelectedControlsGivenContainer = function (container, type, value, subType, params) {
        var control, text = '';
        switch (type) {
            //case "period":
            //    control = container.find("[inf-ctrl=" + type + "]").filter(":visible");
            //    var periods = control.find("[inf-ctrl-type=period]");
            //    control.find("li[inf-ctrl=period-cat]").each(function(){
            //            var El = $(this);
            //            El.removeClass('active');
            //            var key = El.find("[inf-ctrl-type=period-cat]").attr("inf-default-label");
            //            El.find("[inf-ctrl-lbl=period-cat]").attr("data-localize", key).html(infChart.manager.getLabel(key));
            //
            //        }
            //    );
            //    periods.removeClass('active');
            //    var periodEl = control.find("[inf-ctrl-type=period][inf-ctrl-value=" + value + "]"),
            //        labelKey = periodEl.attr("inf-default-label"),
            //        catEl = periodEl.closest("li[inf-ctrl=period-cat]").addClass('active');
            //
            //    var selectedPrdEl = control.find("[inf-ctrl-type=period][inf-ctrl-value=" + value + "]");
            //    selectedPrdEl.addClass('active');
            //    labelKey = selectedPrdEl.attr("inf-default-label");
            //    if(labelKey && catEl) {
            //        catEl.find("[inf-ctrl-lbl=period-cat]").attr("data-localize", labelKey).html(infChart.manager.getLabel(labelKey))
            //    }
            //    periods.find("[inf-ctrl-type=period][inf-ctrl-type=interval].selected").removeClass('selected');
            //    control.find("[inf-ctrl-type=period][inf-ctrl-value=" + value + "] [inf-ctrl-type=interval][inf-ctrl-type=interval][inf-ctrl-value=" + params + "]").addClass('selected');
            //    _setMobileSelectedPeriod(container, value);
            //    if (subType && params) {
            //        _setSelectedControlsGivenContainer(container, subType, params);
            //    }
            //    break;
            case "period":
                control = _getControlElement(container, type);
                var i = 0, len = control.length;
                for (i; i < len; i++) {
                    var p = $(control[i]);
                    _setSelectedValueInMultiOptionControlWithText(p, value);
                }
                if (subType && params) {
                    _setSelectedControlsGivenContainer(container, subType, params);
                }
                break;
            case 'interval':
                control = _getControlElement(container, type);
                var j = 0, lenj = control.length;
                for (j; j < lenj; j++) {
                    var c = $(control[j]);
                    _setSelectedValueInMultiOptionControlWithText(c, value);
                }
                break;
            case "full-screen":
                if (value) {
                    _setSelectedIconInMultiOptionControlWithIcon(_getControlElement(container, type), 'icon ico-screen-normal');
                } else {
                    _setSelectedIconInMultiOptionControlWithIcon(_getControlElement(container, type), 'icon ico-screen-full');
                }
                break;
            case "flags" :
                _setSelectedValuesInMultiOptionControlWithMultipleSelect(_getControlElement(container, type), value);
                break;
            case 'crosshair':
                _setSelectedValueInMultiOption(_getControlElement(container, type), value, value !== 'none');
                break;
            case "depth":
                _setSelectedValueInMultiOption(_getControlElement(container, type), value.side, value.show);
                break;
            case 'chartType':
            case 'grid':
                _setSelectedValueInMultiOptionControlWithIcon(_getControlElement(container, type), value, true);
                break;
            case "value":
                _setButtonStatus(_getControlElement(container, subType), value);
                break;
            case "comparison":
            case "indicator": 
                control = _getControlElement(container, type);
                value ? control.addClass('active') : control.removeClass('active');
                break;
            case 'tradingPanel':
            case 'rightPanel':
            case 'news':
            case "tooltip":
            case "navigator":
            case "last":
            case "preclose":
            case "minMax":
            case "orderBookHistory":
            case "volume":
            case "bidAskHistory":
            case "spread":
            case "undo":
            case "redo":
                _setButtonStatus(_getControlElement(container, type), value);
                break;
            default :
                break;
        }
    };

    /**
     * set default values to controllers
     * @param container
     * @param {object} properties
     * @private
     */
    var _setDefaultValues = function (container, properties) {
        _setSelectedControlsGivenContainer(container, "period", properties.period, "interval", properties.interval);
        _setSelectedControlsGivenContainer(container, "interval", properties.interval);
        _setSelectedControlsGivenContainer(container, "chartType", properties.type);
        _setSelectedControlsGivenContainer(container, "last", properties.last);
        _setSelectedControlsGivenContainer(container, "preclose", properties.preClose);
        _setSelectedControlsGivenContainer(container, "minMax", properties.minMax);
        _setSelectedControlsGivenContainer(container, "tooltip", properties.tooltip);
        _setSelectedControlsGivenContainer(container, "value", properties.isLog, "log");
        _setSelectedControlsGivenContainer(container, "value", properties.isPercent, "percent");
        _setSelectedControlsGivenContainer(container, "crosshair", properties.crosshair);
        _setSelectedControlsGivenContainer(container, "navigator", properties.navigator);
        _setSelectedControlsGivenContainer(container, "flags", properties.flags ? properties.flags : []);
        _setSelectedControlsGivenContainer(container, "grid", properties.grid);
        _setSelectedControlsGivenContainer(container, "orderBookHistory", properties.orderBookHistory);
        if (properties.depth) {
            _setSelectedControlsGivenContainer(container, "depth", properties.depth);
        }
    };

    var _setVisibility = function (containerId, type, value, subType, params) {
        var container = $('#' + containerId),
            width, el,
            isRemove = false,
            prevVisible;
        switch (type) {
            case 'tradingPanel':
            case 'rightPanel':
            case 'news':
            case "tooltip":
            case "navigator":
            case "last":
            case "preclose":
            case "minMax":
            case "orderBookHistory":
            case "volume":
            case "bidAskHistory":
            case "spread":
                el = _getControlElement(container, type);
                prevVisible = el.is(":visible");
                if (value) {
                    el.show();
                    if (!prevVisible) {
                        width = el.outerWidth(true);
                    }
                } else {
                    if (prevVisible) {
                        width = el.outerWidth(true);
                    }
                    el.hide();
                    isRemove = true;
                }
                break;
            default :
                break;
        }

        if (width) {
            var tb = el.closest("[inf-pnl]");
            infChart.structureManager.adjustFullWidth(tb[0], width, isRemove);
            infChart.structureManager.rearrangeUpperLayerToolbar(containerId, container[0]);
        }
    };

    //region multi

    /**
     * set selected icon to multi select using the selected value
     * used in chart types and grid types
     * @param control
     * @param {string} value
     * @param {boolean} isControlHighlight - contorol highligh or not 
     * @private
     */
    var _setSelectedValueInMultiOptionControlWithIcon = function (control, value, isControlHighlight) {
        _setSelectedIconInMultiOptionControlWithIcon(control, _getSelectedElementIconFromValue(control, value), isControlHighlight);
    };

    /**
     * set selected icon to multi select
     * @param control
     * @param {string} iconClass
     * @param {boolean} isControlHighlight - contorol highligh or not 
     * @private
     */
    var _setSelectedIconInMultiOptionControlWithIcon = function (control, iconClass, isControlHighlight) {
        if (!iconClass) {
            iconClass = control.find('> ul > li:first').attr('inf-ico');
        }
        control.find('i[rel="icon"]').removeClass().addClass(iconClass);
        if (isControlHighlight) {
            control.addClass('active');
        }
    };

    /**
     * set selected text to multi select
     * used in interval, period
     * can handle categorized option
     * @param control
     * @param {string} value
     * @param {boolean} enabled
     * @private
     */
    var _setSelectedValueInMultiOptionControlWithText = function (control, value, enabled) {
        var selectedElement = _getSelectedElementFromValue(control, value);
        if (selectedElement && selectedElement.length > 0) {
            var parent = selectedElement.parent('ul').parent('li');
            if (parent && parent.length > 0) {
                parent.find('a span[ctrl-role="text"]').html(selectedElement.text());
                if (typeof enabled === 'undefined' || enabled === true) {
                    parent.addClass('active');
                }
            } else {
                if (typeof enabled === 'undefined' || enabled === true) {
                    _getOptionElementsForMultiOptions(control).removeClass('active active-dim');
                    selectedElement.addClass('active');//for single
                }
            }
        } else {
            $.each(control.find('li.active'), function (i, v) {
                var e = $(v);
                e.removeClass('active active-dim');
                _setSelectedValueInMultiOptionControlWithText(control, _getValueFromAttribute(e.find('> ul > li:first')), false);//categorized
            });

        }
    };

    /**
     * set selected icon to multi select with status
     * @param control
     * @param {string} value
     * @param {boolean} enabled
     * @private
     */
    var _setSelectedValueInMultiOption = function (control, value, enabled) {
        _setSelectedValueInMultiOptionControlWithIcon(control, value);
        if (enabled) {
            control.addClass(selectedCSSClass);
            _getOptionElementsForMultiOptions(control).removeClass(selectedCSSClass);
            _getSelectedElementFromValue(control, value).addClass(selectedCSSClass);
        } else {
            control.removeClass(selectedCSSClass);
        }
    };

    /**
     * set multiple values to multi select
     * used in flags
     * @param control
     * @param {string} values
     * @private
     */
    var _setSelectedValuesInMultiOptionControlWithMultipleSelect = function (control, values) {
        _getOptionElementsForMultiOptions(control).removeClass(selectedCSSClass);
        $.each(values, function (key, val) {
            _getSelectedElementFromValue(control, val).addClass(selectedCSSClass);
        });
    };

    //endregion

    /**
     * set button status
     * @param control
     * @param {boolean} status
     * @private
     */
    var _setButtonStatus = function (control, status) {
        if (status) {
            control.attr("inf-status", "on");
            control.addClass(selectedCSSClass);
        } else {
            control.attr("inf-status", "off");
            control.removeClass(selectedCSSClass);
        }
    };

    //endregion

    //region HTML

    //var _setTradingToolbarHTML = function (element, settings) {
    //    var container = element.find('div[inf-pnl="tb-trading"]');
    //    if (settings.tradingTb && settings.tradingTb.length > 0) {
    //        var html = '';
    //        infChart.util.forEach(settings.tradingTb, function (i, key) {
    //            html += _getOptionHtml(key, settings.config[key], settings, false);
    //        });
    //        container.addClass('chart-buy-sell-button clearfix');
    //        container.html(html);
    //    }
    //    if (!settings.trading) {
    //        container.hide();
    //    }
    //};

    var _setMobileToolbarHtml = function (element, settings) {
        if (settings.mobile && settings && settings.mobileTb && settings.mobileTb.length > 0) {
            var html = '', container = element.find('div[inf-pnl="tb-mobile"]');
            infChart.util.forEach(settings.mobileTb, function (i, key) {
                html += _getMobileOptionHtml(key, settings.config[key], settings);
            });
            container.addClass('chart-controllers-mobile clearfix');
            container.html(html);
        }
    };

    var _setUpperToolbarHtml = function (element, settings) {
        var container = element.find('div[inf-pnl="tb-upper"]');
        if (settings && settings.upper && settings.upperTb && settings.upperTb.length > 0) {
            var html = '';
            infChart.util.forEach(settings.upperTb, function (i, key) {
                html += _getOptionHtml(key, settings.config[key], settings, true);
            });
            container.addClass('navbar-header ad-chart-navbar-header');
            container.html(html);
        }
        if (!settings.upper) {
            container.hide();
        }
    };

    var _setTopToolbarHtml = function (element, settings) {
        var container = element.find('div[inf-pnl="tb-top"]');
        if (settings && settings.top && settings.topTb && settings.topTb.length > 0) {
            var html = '<ul class="nav navbar-nav chart-settings">';
            infChart.util.forEach(settings.topTb, function (i, key) {
                html += _getOptionHtml(key, settings.config[key], settings, false);
            });
            html += '</ul>';
            container.html(html);
        }
        if (!settings.top) {
            container.hide();
        }
    };

    var _setDrawingToolbarHtml = function (element, settings) {
        var container = element.find('div[inf-pnl="tb-left"]');
        if (settings && settings.leftTb && settings.leftTb.length > 0) {
            var html = '<div inf-container="drawing_settings"></div>';
            html += '<ul class="nav navbar-nav2 chart-drawing">';
            infChart.util.forEach(settings.leftTb, function (i, key) {
                html += _getDrawing(settings.config[key]);
            });
            html += '</ul>';
            container.addClass('chart-left-toolbar');
            container.html(html);
        }
        if (!settings.left) {
            container.hide();
        }
    };

    var _setRightToolbarHtml = function (element, settings, uniqueId, isDisableDrawingSettingsPanel) {
        var container = element.find('div[inf-pnl="tb-right"]');
        if (settings && settings.right && settings.rightTb && settings.rightTb.length > 0) {
            var rightTab = settings.rightTb;
            var html = '';

            var tabsPanel = '<span class="right-panel-close" inf-ctrl="pnlClose"><i class="fa fa-times"></i></span><ul class="nav nav-tabs">',
                tabPanes = '<div class="tab-content" color-picker-container>',
                tabId, tabCount = 0;
            if (isDisableDrawingSettingsPanel && rightTab.indexOf("drawingToolPanelView") > -1) {
                rightTab.splice(rightTab.indexOf("drawingToolPanelView"), 1);
            }
            infChart.util.forEach(rightTab, function (i, key) {
                tabId = uniqueId + '_' + key;
                tabsPanel += '<li role="presentation" tab-id="' + tabId + '"' + (tabCount === 0 ? 'class="active"' : '') + '>' +
                    '<a data-toggle="tab" data-target="div[rel=' + tabId + ']">' +
                    '<i class="' + settings.config[key].icon + '"></i>' +
                    '<span class="rp-tab-name" data-localize="' + settings.config[key].label + '">' + infChart.manager.getLabel(settings.config[key].label) + '</span>' +
                    '</a>' +
                    '</li>';
                tabPanes += '<div class="tab-pane' + (tabCount === 0 ? ' active' : '') + '" rel="' + tabId + '">' + _getOptionHtml(key, settings.config[key], settings, false, null) + '</div>';
                tabCount++;
            });

            tabsPanel += '</ul>';
            tabPanes += '</div>';
            html += tabsPanel + tabPanes;

            container.addClass('chart-right-panel');
            container.html(html);
        }
        container.hide();//hidden by default
    };

    //endregion

    // var _getDrawing = function (setting) {
    //     var span, visibleSpan, visibleShape, visibleSubType, category, options, link, linkClass, label = '';
    //     if (setting.options && setting.options.length > 0) {
    //         options = '<ul class="dropdown-menu" role="menu">';
    //         linkClass = 'dropdown-option';
    //         infChart.util.forEach(setting.options, function (i, obj) {
    //             span = '<span class="' + obj.cls + '"' + (obj.style ? 'style="' + obj.style + '"' : '' ) + '></span>';
    //             label = obj.label ? obj.label : "";
    //             if (obj.active === true) {
    //                 visibleSpan = span;
    //                 visibleShape = obj.shape;
    //                 visibleSubType = obj.subType;
    //                 options += '<li><a target="_self"  class="active" inf-ctrl="' + setting.role + '" inf-ctrl-shape="' + obj.shape + '" inf-ctrl-subType="' + obj.subType + '" drawing-cat="' + setting.cat + '" title="' + label + '">' + span + '</a></li>';
    //             } else {
    //                 options += '<li><a target="_self"  inf-ctrl="' + setting.role + '" inf-ctrl-shape="' + obj.shape + '" inf-ctrl-subType="' + obj.subType + '" drawing-cat="' + setting.cat + '" title="' + label + '"><span class="' + obj.cls + '"></span></a></li>';
    //             }
    //         });
    //         options += '</ul>';
    //     } else {
    //         options = '';
    //         if (setting.role === 'drawing' && setting.shape) {
    //             visibleShape = setting.shape;
    //         }
    //         if (setting.role === 'drawing' && setting.subType) {
    //             visibleSubType = setting.subType;
    //         }
    //         visibleSpan = '<span class="' + setting.cls + '"' + (setting.style ? 'style="' + setting.style + '"' : '' ) + '></span>';
    //     }
    //     if (setting.active === true) {
    //         linkClass = linkClass ? linkClass + ' active' : 'active';
    //     }
    //     label = setting.label ? setting.label : "";
    //     if (setting.role === 'drawing') {

    //         link = '<a  target="_self"  inf-ctrl="drawCat" inf-ctrl-role="' + setting.role + '" ' + ' draw-cat="' + setting.cat + '" inf-ctrl-shape="' + visibleShape + '"' +
    //             (visibleSubType ? ' inf-ctrl-subType="' + visibleSubType + '"' : '') + '  role="button" ' +
    //             (linkClass ? ' class="' + linkClass + '"' : '') + '   title="' + label + '" >' + visibleSpan + '</a>';
    //     } else {
    //         link = '<a target="_self"  inf-ctrl="drawCat" inf-ctrl-role="' + setting.role + '" ' + '" role="button" ' +
    //             (linkClass ? ' class="' + linkClass + '"' : '') + '  title="' + label + '" >' + visibleSpan + '</a>';
    //     }
    //     return '<li class="dropdown">' + link + options + '</li>';
    // };

    /**
     * set toolbar HTML
     * @param element chart container
     * @param {object} properties toolbarProperties
     * @param {string} uniqueId container id
     * @param {object} config - chart config
     * @returns {string}
     * @private
     */
    var _setHTML = function (element, properties, uniqueId, config) {
        var isDisableDrawingSettingsPanel = config && config.disableDrawingSettingsPanel ? config.disableDrawingSettingsPanel : false;
        // _setTradingToolbarHTML(element, settings);
        properties.mobile && _setMobileToolbarHtml(element, properties);
        properties.upper && _setUpperToolbarHtml(element, properties);
        properties.top && _setTopToolbarHtml(element, properties);
        // _setDrawingToolbarHtml(element, settings);
        properties.right && _setRightToolbarHtml(element, properties, uniqueId, isDisableDrawingSettingsPanel);
    };

    //region mobile

    var _getMobileOptionHtml = function (key, config, allSettings) {
        var html, label;
        switch (key) {
            case 'period':
                html = _getMobilePeriodHTML(config, allSettings);
                break;
            case "interval":
                html = _getMobileIntervalHTML(config);
                break;
            case "chartType" :
                html = _getMobileChartTypeHTML(config);
                break;
            case "indicator":
                html = _getMobileIndicatorsHTML(config);
                break;
            default :
                html = '';
                break;
        }
        return html;
    };

    /**
     * interval sub menu
     * @param config options to add
     * @returns {*}
     * @private
     */
    var _getMobileIntervalHTML = function (config) {
        var html;
        if (config && config.options && config.options.length > 0) {
            if (config.options.length === 1) {
                var obj = config.options[0];
                html = '<li inf-ctrl-value="' + obj.key + '" inf-ctrl-type="interval" ><a class="selected-el" target="_self"  data-localize="' + obj.shortDesc + '" >' + obj.shortDesc + '</a></li>';
            } else {
                var label = "label.periodType";
                html = '<ul class="control-item intervals">' +
                    '<li class="dropdown" inf-ctrl="interval">' +
                    '<a target="_self"  class="dropdown-toggle btn"  role="button" aria-expanded="false" title="' + label + '"><span cntrl-role="text" data-localize="label.interval">Interval</span><span class="caret"></span></a>' +
                    '<ul class="dropdown-menu" role="menu">';

                infChart.util.forEach(config.options, function (i, obj) {
                    html += '<li inf-ctrl-value="' + obj.key + '><a target="_self"  data-localize="' + obj.shortLabel + '" >' + obj.shortDesc + '</a></li>';
                });
                html += '</ul>' +
                    '</li>' +
                    '</ul>';
            }
        } else {
            html = '';
        }
        return html;
    };

    var _getMobileIndicatorsHTML = function (config) {
        var html;
        if (config && config.options && config.options.length > 0) {

            var label = "label.addIndicator";
            html = '<ul class="control-item indicators">' +
                '<li class="dropdown" inf-ctrl="indicator">' +
                '<a target="_self"  class="dropdown-toggle btn"  role="button" aria-expanded="false" title="' + label + '"><span ><i class="icon ico-graph-trend"></i></span> <span class="caret"></span></a>' +
                '<ul class="dropdown-menu" role="menu">';
            html += '<li ><div class="input-wrap"><input type="text" inf-ctrl-ind="search" /><div></li>';

            infChart.util.forEach(config.options, function (i, obj) {
                html += '<li inf-ctrl-value="' + obj.key + '"><a target="_self"  data-localize="' + obj.label + '" >' + obj.desc + '</a></li>';
            });
            html += '</ul>' +
                '</li>' +
                '</ul>';
        } else {
            html = '';
        }
        return html;
    };

    var _getMobileChartTypeHTML = function (config) {
        var html;
        if (config && config.options && config.options.length > 0) {
            var label = "label.chartType";
            html = '<ul class="control-item chart-types">' +
                '<li class="dropdown" inf-ctrl="chartType" >' +
                '<a target="_self"  class="dropdown-toggle btn"  role="button" aria-expanded="false" title="' + label + '">' +
                '<span cntrl-role="text" class="icon"  ></span><span class="caret"></span></a>' +
                '<ul class="ch_ul charttype dropdown-menu" role="menu">';

            infChart.util.forEach(config.options, function (i, obj) {
                label = obj.label;
                var cls = obj.ico ? obj.ico : 'ico-chart-' + obj.key;
                html += '<li inf-ctrl-value="' + obj.key + '"  inf-ctrl-type="charttype" class="icon ' + cls + '" title="' + label + '" inf-ico="' + cls + '" ></li>';
            });
            html += '</ul>' +
                '</li>' +
                '</ul>';
        } else {
            html = '';
        }
        return html;
    };

    var _getMobilePeriodHTML = function (config, setting) {
        var periodHtml;
        if (config && config.options && config.options.length > 0) {
            var intervalOpt = {};
            if (setting && setting.config && setting.config.interval && setting.config.interval.options && setting.config.interval.options.length > 0) {
                infChart.util.forEach(setting.config.interval.options, function (i, val) {
                    intervalOpt[val.key] = val;
                });
            }
            periodHtml = '<div class="control-item dropdown period" inf-ctrl="period">' +
                '<button class="btn  dropdown-toggle" type="button" aria-haspopup="true" aria-expanded="true">' +
                '<span inf-period-text="selected" >1Y</span>' +
                '<span class="caret"></span>' +
                '</button>' +
                '<ul class="dropdown-menu" >';

            var displyArr = (config.display) ? config.display.split(",") : undefined;
            infChart.util.forEach(config.options, function (i, obj) {
                if (!displyArr || displyArr.indexOf(obj.key) >= 0) {
                    periodHtml += '<li inf-ctrl-value="' + obj.key + '" ' + _getCtrlItemHTML("period") + ' inf-ctrl-type="period" >' +

                        '<a target="_self" >';
                    periodHtml += '<span data-localize="' + obj.shortLabel + '" class="lbl-short">' + obj.shortDesc + '</span>';

                    periodHtml += '</a>';
                    periodHtml += '</li>';
                }
            });
            periodHtml += '</ul></div>';
        } else {
            periodHtml = ''
        }
        return periodHtml;
    };

    //endregion

    // var _getButtonHtml = function (ctrlType, label, desc, value, btnClass, iconClass) {
    //     return '<button class="' + btnClass + '"' + _getCtrlTypeHtml(ctrlType) + _getCtrlValueHtml(value) + '>' +
    //         '<div class="bs-value" inf-ref="' + ctrlType + '"></div>' +
    //         '<div class="bs-text"><i class="' + iconClass + '"></i data-localize="' + label + '">' + desc + '</div>' +//
    //         '</button>';
    // };

    /**
     *
     * @param key
     * @param config
     * @param allSettings
     * @param displayHorizontal
     * @param type TODO :: remove type is not necessary
     * @returns {*}
     * @private
     */
    var _getOptionHtml = function (key, config, allSettings, displayHorizontal, type, isOptionMenu) {
        var html, label;
        switch (key) {
            case 'adv':
                html = '<ul class="nav navbar-nav FL"><li top-tt-item="' + (type || "l") + '" inf-ctrl="adv" inf-status="off" aria-hidden="true" role="button" aria-expanded="false"><a class="advance_chart_b" target="_self" ></a></li></ul>';
                break;
            case "zeroPoint":
                html = '<li class="icon ico-chart7 just_ico" aria-hidden="true" role="button" aria-expanded="false">   </li>';
                break;
            case 'settings':
                html = '<li class="dropdown"><a target="_self" class="dropdown-toggle ico-gear singleicon" role="button" aria-expanded="false"></a></li>';
                break;
            case "comparison" :
                html = _getCompareSymbolsHTML(key, 'label.comparison', 'Comparison', config, type);
                break;
            case "indicator"://indicator dropdown in top toolbar
                html = _getIndicatorsHTML(key, 'label.addIndicator', 'Indicators', config.options, type);
                break;
            case "rightPanel"://show/hide indicator panel view
                html = _getSingleOptionHTMLWithStatus(key, 'label.toggleRightPanel', 'fa fa-wrench', false, displayHorizontal, type, isOptionMenu? "top" : "bottom-left");
                break;
            case "indicatorPanelView"://indicator panel view
                html = _getIndicatorPanelHTML(key, allSettings.config['indicator']);
                break;
            case "symbolSettingsPanelView"://symbol settings panel view
                html = '<div inf-container="symbol_settings_panel" class="panel-group"></div>';
                break;
            case "drawingToolPanelView"://drawing tool settings panel view
                html = '<div inf-container="drawing_tools_panel" class="panel-group"></div>';
                break;
            case "period":
                html = _getMultiOptionWithCategoryWithHorizontalDropdownHTML(key, 'label.periodType', config, type);
                break;
            case "crosshair":
                html = _getMultiOptionHTML(key, 'label.crosshair', 'Crosshair', config.options, 'crosshair-type ch_ul', displayHorizontal, type);
                break;
            case "print":
                html = _getMultiOptionHTML(key, 'label.print', 'Print', config.options, 'print-type ch_ul', displayHorizontal, type);
                break;
            case 'depth':
                html = _getMultiOptionHTML(key, 'label.bookVolume', 'Book Volume', config.options, isOptionMenu ? 'ch_ul book-vol-options' : 'book-vol ch_ul', displayHorizontal, type, "bottom");
                break;
            case 'flags':
                html = _getMultiOptionDropdownHTMLWithFixedTitle(key, 'label.flagsDesc', "Flags", config.options, type);
                break;
            case 'file':
                html = _getMultiOptionDropdownHTMLWithFixedTitle(key, 'label.file', "File", config.options, type);
                break;
            case 'periodD':
                html = _getMultiOptionWithHorizontalDropdownHTML('period', 'label.periodType', allSettings.config['period'], type);
                break;
            case 'intervalD':
                html = _getMultiOptionWithHorizontalDropdownHTML('interval', 'label.interval', allSettings.config['interval'], type);
                break;
            case "interval":
                if (config.layout === "button") {
                    html = _getMultiOptionWithCategoryWithHorizontalDropdownHTML(key, 'label.interval', config, type);
                } else {
                    html = _getMultiOptionWithHorizontalDropdownHTML(key, 'label.interval', config, type);
                }
                break;
            case "chartType":
                html = _getMultiOptionWithDropdownHTML(key, 'label.chartType', 'Chart Type', config.options, 'charttype ch_ul', displayHorizontal, type, allSettings.verticalDropDown, isOptionMenu);
                break;
            case 'grid':
                html = _getMultiOptionWithDropdownHTML(key, 'label.gridType', 'Grid Type', config.options, 'gridtype ch_ul', displayHorizontal, type, allSettings.verticalDropDown);
                break;
            case "volume":
                html = _getSingleOptionHTMLWithStatusNText(key, 'label.indicatorDesc.VOLUME', 'label.showHideVolume', 'icon ico-chart-bar', 'VOLUME', false, displayHorizontal, type);
                break;
            case "spread":
                html = _getSingleOptionHTMLWithStatusNTextNCompactMode(key, 'label.indicatorDesc.SPREAD', 'label.showHideSpread', 'icon ico-chart-spread', 'SPREAD', false, displayHorizontal, type, true, "bottom-left");
                break;
            case "bidAskHistory":
                html = '<li class="just_ico show-bid-ask" inf-ctrl="bidAskHistory" ' + _getToolTipAttributes("Show/Hide Bid Ask History", "bottom-left") + ' inf-ctrl-value="BAH" role="button"><span class="bid-text">Bid </span><span class="ask-text" >Ask</span></li>';
                if (config && config.layout === 'button') {
                    html = '<ul class="show-bid-ask-wrapper">' + html + '</ul>';
                }
                break;
            case "value":
                html = _getSingleOptionHTMLWithStatus('percent', "label.relYaxis", 'icon ico-prec', false, displayHorizontal, type);
                html += _getSingleOptionHTMLWithStatus('log', "label.logYaxis", 'icon ico-log', false, displayHorizontal, type);
                break;
            case "zoom" :
                html = _getSingleOptionHTMLWithValue('zoom', "label.zoomIn", 'icon ico-zoom-in-1', 'in', displayHorizontal, type);
                html += _getSingleOptionHTMLWithValue('zoom', "label.zoomOut", 'icon ico-zoom-out-1', 'out', displayHorizontal, type);
                break;
            case 'reset':
                html = _getSingleOptionHTML(key, config.title, config.icon, (config.displayHorizontal) ? config.displayHorizontal : displayHorizontal, type, isOptionMenu? "top" : "bottom-left");
                break;
            case "full-screen":
                html = _getSingleOptionHTML(key, "label.fullScreen", 'icon ico-screen-full', displayHorizontal, type, isOptionMenu ? "top" : "bottom");
                break;
            case "navigator":
                html = _getSingleOptionHTMLWithStatus(key, 'label.showHistory', 'icon ico-nav-off', true, displayHorizontal, type);
                break;
            case "tooltip":
                html = _getSingleOptionHTMLWithStatus(key, 'label.showDataInfo', 'icon ico-data', true, displayHorizontal, type);
                break;
            case "trading":
                html = '<div inf-container="trading_panel"></div>';
                break;
            case "tradingPanel":
                html = _getSingleOptionHTMLWithStatus(key, 'label.showTrading', 'fa fa-wrench', false, displayHorizontal, type);
                break;
            case "news":
                html = _getSingleOptionHTMLWithStatus(key, 'label.showNews', 'icon ico-xnews', false, displayHorizontal, type);
                break;
            case "last":
                html = _getSingleOptionHTMLWithStatus(key, 'label.showLast', 'icon ico-chart8', false, displayHorizontal, type);
                break;
            case "preclose":
                html = _getSingleOptionHTMLWithStatus(key, 'label.showPrevClose', 'icon ico-prev', false, displayHorizontal, type);
                break;
            case "minMax":
                html = _getSingleOptionHTMLWithStatus(key, 'label.showMinMax', 'icon ico-min-max', false, displayHorizontal, type);
                break;
            case 'orderBookHistory':
                html = _getSingleOptionHTMLWithStatus(key, 'label.toggleOrderBookHistory', 'icon ico-orderbook-history', true, displayHorizontal, type);
                break;
            case 'optionsDropDown':
                html = _getOptionsHTML(config, key, allSettings, type);
                break;
            case 'buy':
            case 'sell':
                html = infChart.structureManager.trading.getTradingButtonHTML(config.ctrl, config.locLabel, config.btnText, config.key, config.btnClass, config.iconClass, true);
                break;
            case 'tradeControlCompact':
                html = _getMultiOptionDropdownHTMLWithCustomInnerHTML(key, 'label.trades', 'Trades', config, type);
                break;
            case "pinInterval":
                html = _getSingleOptionHTMLWithStatus(key, 'label.pinInterval', 'icon ico-data', true, displayHorizontal, type);
                break;
            default :
                if (config.title && config.icon) {
                    var ttDirOnInOptionMenu = config.optionMenuTooltipDir;
                    var ttDirDefault = config.tooltipDir;
                    html = _getSingleOptionHTML(key, config.title, config.icon, (config.displayHorizontal) ? config.displayHorizontal : displayHorizontal, type, isOptionMenu ? ttDirOnInOptionMenu : ttDirDefault, config.showIconOnly);
                } else {
                    html = '';
                }
                break;
        }
        return html;
    };

    /**
     * html for indicator panel
     * @param ctrlType
     * @param config
     * @returns {string}
     * @private
     */
    var _getIndicatorPanelHTML = function (ctrlType, config) {
        //todo : panels should move to structure
        return '<div inf-container="indicator_panel" class="panel-group">' +
            '<div class="panel panel-default" inf-ctrl="indicator">' +
            '<div class="panel-heading">' +
            '<h4 class="panel-title">' +
            '<a role="button" data-toggle="collapse" aria-expanded="true">' +
            '<span class="title-contents">Add Indicators</span><i class="fa fa-caret-down" aria-hidden="true"></i>' +
            '</a>' +
            '</h4>' +
            '</div>' +
            '<div class="panel-collapse collapse">' +
            '<div class="panel-body indicators-dropdown-wrapper">' +
            '<ul class="dropdown-menu indicators-dropdown" role="menu">' +
            '<li><input type="text" inf-ctrl-ind="search" class="symbol-search-input"></li>' +
            _getHorizontalDropdownOptionsHTML(config.options) +
            '</ul>' +
            '</div>' +
            '</div>' +
            '</div>' +
            '<div class="panel panel-default">' +
            '<div class="panel-heading panel-main-heading">' +
            '<h4 class="panel-title">' +
            'Added Indicators' +
            '</h4>' +
            '</div>' +
            '</div>' +
            '</div>';
    };

    /**
     * indicator sub menu
     * @param {string} ctrlType
     * @param {string} label
     * @param {string} desc
     * @param {Array} options
     * @param type ???
     * @returns {string}
     * @private
     */
    var _getIndicatorsHTML = function (ctrlType, label, desc, options, type) {
        var html;
        if (options && options.length > 0) {
            var ctrlTypeHtml = infChart.structureManager.common.getCtrlTypeHtml(ctrlType);
            html =
                '<li class="dropdown"' + _getTopttItemHtml(type) + ctrlTypeHtml + '>' +
                '<a target="_self" class="dropdown-toggle" role="button" aria-expanded="false" ' + _getToolTipAttributes(label) + '>' +
                '<span data-localize="' + label + '" >' + desc + '</span>' +
                '<span class="caret"></span>' +
                '</a>' +
                '<ul class="dropdown-menu indicators-dropdown" role="menu" inf-ctrl="dropdownMenu">';
            html += '<li class="indicator-search-box"><div class="input-wrap"><input type="text" inf-ctrl-ind="search" /></div></li>';
            html += '<li class="indicator-list" inf-ctrl="indicatorList"><ul>';
            html += _getHorizontalDropdownOptionsHTML(options);
            html += '</ul></li></ul></li>';
        } else {
            html = '';
        }
        return html;
    };

    /**
     * comparison sub menu
     * @param {string} ctrlType
     * @param {string} label
     * @param {string} desc
     * @param config symbols to add
     * @param type ??
     * @returns {string}
     * @private
     */
    var _getCompareSymbolsHTML = function (ctrlType, label, desc, config, type) {
        var html;
        var ctrlTypeHtml = infChart.structureManager.common.getCtrlTypeHtml(ctrlType);
        if (config) {
            html = '<li class="dropdown"' + _getTopttItemHtml(type) + ctrlTypeHtml + '>' +
                '<a target="_self" class="dropdown-toggle" role="button" aria-expanded="false" ' + _getToolTipAttributes("label.addComparisons") + '>' +
                '<span data-localize="' + label + '">' + desc + '</span><span class="caret"></span>' +
                '</a>' +
                '<ul class="dropdown-menu" role="menu">';
            if (config.symbolSearch) {
                html += '<li><input type="text" data-inf-ctrl-rel="symbolSearch"></li>';
                if (config.symbolSearch.options.appendTo) {
                    html += '<li class="symbol-search-dropdown-wrapper" id="' + config.symbolSearch.options.appendTo.substring(1) + '"></li>'
                }
            } else {
                var options = [],
                    count = 0;
                infChart.util.forEach(config.options, function (i, symbol) {
                    options[count] = {
                        key: encodeURI(JSON.stringify(symbol)),
                        desc: symbol.symbolDesc || symbol.name,
                        label: symbol.symbolDesc || symbol.name
                    };
                    count++;
                });
                html += _getHorizontalDropdownOptionsHTML(options);
            }
            html += '</ul></li>';
        }

        return html;
    };

    var _getOptionsHTML = function (config, key, allSettings, type) {
        var html =
            '<li class="dropdown inf-options" top-tt-item="' + (type || "l") + '">' +
            '<a class="dropdown-toggle">Options<b class="caret"></b></a>' +
            '<ul class="dropdown-menu">';

        infChart.util.forEach(config.options, function (i, option) {
            html += _getOptionHtml(option, allSettings.config[option], allSettings, true, type, true);
        });
        html += '</ul></li>';
        return html;
    };

    /**
     *
     * @param {string} ctrlType
     * @param {string} label
     * @param {toolbarConfig} config
     * @param {string} type
     * @returns {string}
     * @private
     */
    var _getMultiOptionWithCategoryWithHorizontalDropdownHTML = function (ctrlType, label, config, type) {
        var ctrlTypeHtml = infChart.structureManager.common.getCtrlTypeHtml(ctrlType);
        var html = '<ul class="nav navbar-nav ' + ctrlType + '"' + ctrlTypeHtml + '>';
        if (config.categorized) {
            var categories = {};
            infChart.util.forEach(config.options, function (i, option) {
                if (!categories[option.category]) {
                    categories[option.category] = [];
                }
                categories[option.category].xPush(option);
            });
            for (var category in categories) {
                if (categories.hasOwnProperty(category)) {
                    var categoryOptions = {
                        'options': categories[category],
                        'shortLabel': config.shortLabel,
                        'display': config.display
                    };
                    html += _getMultiOptionWithHorizontalDropdownHTML(category, config.categoryLabelPrefix + category, categoryOptions, type);
                }
            }
        } else {
            var displayOptions, itemCount = 0;
            if (config.display) {
                displayOptions = config.display.split(',');
            }
            infChart.util.forEach(config.options, function (i, option) {
                if (!displayOptions || displayOptions.indexOf(option.key) > -1) {
                    var lbl = config.shortLabel && option.shortLabel ? option.shortLabel : option.label;
                    html +=
                        '<li class="just_ico"' +
                        _getTopttItemHtml(type) +
                        _getCtrlItemHTML(ctrlType) +
                        infChart.structureManager.common.getCtrlValueHtml(option.key) +
                        '>' +
                        '<a target="_self" role="button" ' + _getToolTipAttributes(option.desc, itemCount ? "bottom" : "bottom-right") + ' data-localize="' + lbl + '"></a>' +
                        '</li>';
                    itemCount++;
                }
            });
        }
        html += '</ul>';
        return html;
    };

    //region single option

    /**
     * single element with on/off status
     * used for navigator, last, previous close, min max, tooltip, news, orderBookHistory, tradingPanel
     * @param {string} ctrlType
     * @param {string} label
     * @param {string} iconClass
     * @param {boolean} selected
     * @param {boolean} displayHorizontal
     * @param {string} type - ??
     * @returns {string}
     * @private
     */
    var _getSingleOptionHTMLWithStatus = function (ctrlType, label, iconClass, selected, displayHorizontal, type, tooltipDir) {
        return '<li class="just_ico ' + (selected ? selectedCSSClass : '') + (!displayHorizontal ? ' compact-hide' : '') + '" ' +
            _getTopttItemHtml(type) +
            infChart.structureManager.common.getCtrlTypeHtml(ctrlType) +
            _getCtrlStatusHtml(selected) +
            _getToolTipAttributes(label, tooltipDir) +
            'role="button">' + _getInnerHtmlForLI(label, iconClass, displayHorizontal) + '</li>';
    };

    /**
     * single element with on/off status and custom class
     * used for navigator, last, previous close, min max, tooltip, news, orderBookHistory, tradingPanel
     * @param {string} ctrlType
     * @param {string} label
     * @param {string} iconClass
     * @param {boolean} selected
     * @param {boolean} displayHorizontal
     * @param {string} type - ??
     * @param {string} customClasses
     * @returns {string}
     * @private
     */
    var _getSingleOptionHTMLWithStatusAndCustomClasses = function (ctrlType, label, iconClass, selected, displayHorizontal, type, customClasses) {
        return '<li class="just_ico ' + (selected ? selectedCSSClass : '') + (' ' + customClasses) + '" ' +
            _getTopttItemHtml(type) +
            infChart.structureManager.common.getCtrlTypeHtml(ctrlType) +
            _getCtrlStatusHtml(selected) +
            'title="' + label + '" ' +
            'role="button">' + _getInnerHtmlForLI(label, iconClass, displayHorizontal) + '</li>';
    };

    /**
     * single element with value
     * used zoom in, zoom out
     * @param {string} ctrlType
     * @param {string} label
     * @param {string} iconClass
     * @param {string} value
     * @param {boolean} displayHorizontal
     * @param {string} type - ??
     * @returns {string}
     * @private
     */
    var _getSingleOptionHTMLWithValue = function (ctrlType, label, iconClass, value, displayHorizontal, type) {
        return '<li class="just_ico' + (!displayHorizontal ? ' compact-hide' : '') + '" ' +
            _getTopttItemHtml(type) +
            infChart.structureManager.common.getCtrlTypeHtml(ctrlType) +
            infChart.structureManager.common.getCtrlValueHtml(value) +
            _getToolTipAttributes(label) +
            'role="button">' + _getInnerHtmlForLI(label, iconClass, displayHorizontal) + '</li>';
    };

    /**
     * single element
     * @param {string} ctrlType - key
     * @param {string} label - button label
     * @param {string} iconClass - button icon class
     * @param {boolean} displayHorizontal - if false then hide in compact mode
     * @param {string} type - ??
     * @param {tooltipDir} tooltipDir - tooltip direction
     * @param {boolean} showIconOnly - true if show icon only
     * @returns {string} option HTML
     * @private
     */
    var _getSingleOptionHTML = function (ctrlType, label, iconClass, displayHorizontal, type, tooltipDir, showIconOnly) {
        return '<li class="just_ico' + (!displayHorizontal ? ' compact-hide' : '') + '"' +
            _getTopttItemHtml(type) +
            infChart.structureManager.common.getCtrlTypeHtml(ctrlType) +
            _getToolTipAttributes(label, tooltipDir) +
            'role="button">' + _getInnerHtmlForLI(label, iconClass, displayHorizontal, showIconOnly) + '</li>';
    };

    /**
     * single element without icon
     * used for volume
     * @param {string} ctrlType
     * @param {string} label
     * @param {string} title
     * @param {string} iconClass
     * @param {string} value
     * @param {boolean} selected
     * @param {boolean} displayHorizontal
     * @param {string} type - ??
     * @returns {string}
     * @private
     */
    var _getSingleOptionHTMLWithStatusNText = function (ctrlType, label, title, iconClass, value, selected, displayHorizontal, type) {
        return '<li class="just_ico ' + (selected ? selectedCSSClass : '') + (!displayHorizontal ? ' compact-hide' : '') + '"' +
            _getTopttItemHtml(type) +
            infChart.structureManager.common.getCtrlTypeHtml(ctrlType) +
            infChart.structureManager.common.getCtrlValueHtml(value) +
            _getCtrlStatusHtml(selected) +
            _getToolTipAttributes(title) +
            '><a target="_self" role="button">' + ( displayHorizontal ? '<i class="' + iconClass + '"></i>' : '' ) + '<span data-localize="' + label + '"></span></a>' +
            '</li>';
    };

    /**
     * single element without icon and not hide in compact mode
     * used for spread
     * @param {string} ctrlType
     * @param {string} label
     * @param {string} title
     * @param {string} iconClass
     * @param {string} value
     * @param {boolean} selected
     * @param {boolean} displayHorizontal
     * @param {string} type - ??
     * @param {string} hideInitially
     * @param {string} tooltipDir
     * @param {string} hideInitially
     * @returns {string}
     * @private
     */
    var _getSingleOptionHTMLWithStatusNTextNCompactMode = function (ctrlType, label, title, iconClass, value, selected, displayHorizontal, type, hideInitially, tooltipDir) {
        var display = hideInitially ? ' style="display:none" ' : '';
        return '<li class="just_ico ' + (selected ? selectedCSSClass : '') + '"' + display +
            _getTopttItemHtml(type) +
            infChart.structureManager.common.getCtrlTypeHtml(ctrlType) +
            infChart.structureManager.common.getCtrlValueHtml(value) +
            _getCtrlStatusHtml(selected) +
            '><a target="_self" role="button">' + (displayHorizontal ? '<i class="' + iconClass + '"></i>' : '') + '<span ' + _getToolTipAttributes(title, tooltipDir) + ' data-localize="' + label + '"></span></a>' +
            '</li>';
    };

    /**
     * get inner html for li element in toolbar
     * @param {string} label - button label
     * @param {string} iconClass - icon class
     * @param {boolean} displayHorizontal - if true then show the button label
     * @param {boolean} showIconOnly - true if show icon only
     * @returns 
     */
    var _getInnerHtmlForLI = function (label, iconClass, displayHorizontal, showIconOnly) {
        var innerHtml, iconHtml = '';
        if (iconClass) {
            iconHtml = '<i rel="icon" class="' + iconClass + '"></i>';
        }
        if (displayHorizontal) {
            innerHtml = showIconOnly ? iconHtml : '<a>' + iconHtml + '<span data-localize="' + label + '"></span></a>';
        } else {
            innerHtml = iconHtml;
        }
        return innerHtml;
    };

    //endregion

    //region multi options

    /**
     * multi option element without caret
     * used by cross-hair, print, depth
     * @param {string} ctrlType
     * @param {string} label
     * @param {string} desc
     * @param {Array<object>} options
     * @param {string} optionsUlClass
     * @param {boolean} displayHorizontal
     * @param {string} type - ??
     * @returns {string}
     * @private
     */
    var _getMultiOptionHTML = function (ctrlType, label, desc, options, optionsUlClass, displayHorizontal, type, ttDir) {
        var html = '';
        if (options && options.length > 0) {
            var innerHtml;
            if (displayHorizontal) {
                innerHtml = '<a target="_self" class="dropdown-option" role="button" ' +  _getCtrlTooltipHtml(label) + '><i rel="icon"></i><span data-localize="' + label + '">' + desc + '</span></a>';
            } else {
                innerHtml = '<span ' +  _getCtrlTooltipHtml(label) + '><i rel="icon" ></i></span>';
            }
            html = '<li class="dropdown just_ico' + (!displayHorizontal ? ' compact-hide' : '') + '"' +

                _getTopttItemHtml(type) +
                infChart.structureManager.common.getCtrlTypeHtml(ctrlType) +
                '>' +
                innerHtml +
                '<ul class="dropdown-menu ' + optionsUlClass + '" role="menu">';
            infChart.util.forEach(options, function (i, obj) {
                var cls = obj.ico ? obj.ico : 'icon ico-' + obj.key;
                html += '<li' + _getCtrlItemHTML(ctrlType) +
                    infChart.structureManager.common.getCtrlValueHtml(obj.key) +
                    _getCtrlTooltipHtml(obj.label, undefined, undefined, ttDir) +
                    _getCtrlIconHtml(cls) +
                    '><i class="' + cls + '"></i></li>';
            });
            html += '</ul></li>';
        }
        return html;
    };

    /**
     * multi option element with caret
     * used for chart types and grid types
     * @param {string} ctrlType
     * @param {string} label
     * @param {string} desc
     * @param {Array<object>} options
     * @param {string} optionsUlClass
     * @param {boolean} displayHorizontal
     * @param {string} type - ??
     * @returns {string}
     * @private
     */
    var _getMultiOptionWithDropdownHTML = function (ctrlType, label, desc, options, optionsUlClass, displayHorizontal, type, verticalDropDown, adjustTooltipOnSides) {
        var html = '';
        if (options && options.length > 0) {
            html =
                '<li class="dropdown' + (!displayHorizontal ? ' compact-hide' : '') + '"' +
                _getTopttItemHtml(type) +
                infChart.structureManager.common.getCtrlTypeHtml(ctrlType) +
                '>' +
                '<a class="dropdown-toggle" role="button" aria-expanded="false" ' + _getCtrlTooltipHtml(label) + '>' +
                '<i rel="icon"></i>' +
                '<span cntrl-role="text"' + (displayHorizontal ? (' data-localize="' + label + '" ') : '') + '>' + (displayHorizontal ? desc : '') + '</span><span class="caret"></span>' +
                '</a>' +
                '<ul inf-ctrl="dropdown-menu-chart" class="dropdown-menu ' + optionsUlClass + '' + (verticalDropDown ? (' vertical-dropdown') : '') + '" role="menu">';

            infChart.util.forEach(options, function (i, obj) {
                var cls = obj.ico ? obj.ico : 'ico-' + obj.key,
                    ttDir = adjustTooltipOnSides ? i === 0 ? "bottom-right" : i === (options.length - 1) ? " bottom-left" : "bottom" : "bottom";
                var verticalDropDownSpan = '<span rel="additional-span" class="dropdown-text" data-localize="' + obj.label + '">' + infChart.manager.getLabel(obj.label) + '</span>';
                html += '<li ' +
                    _getCtrlItemHTML(ctrlType) +
                    infChart.structureManager.common.getCtrlValueHtml(obj.key) +
                    _getCtrlTooltipHtml(obj.label, undefined, undefined, ttDir) +
                    _getCtrlIconHtml(cls) +
                    '><i class="' + cls + '" '/*+_getCtrlTooltipHtml(obj.label, undefined, undefined, "bottom")*/ + '></i>' + (verticalDropDown ? (verticalDropDownSpan) : '') + '</li>';
            });
            html += '</ul></li>';
        }
        return html;
    };

    /**
     * multi option element with caret with fixed title and custom html
     * used for trade controls
     * @param {string} ctrlType
     * @param {string} label
     * @param {string} desc
     * @param {toolbarConfig} config
     * @param {string} type - ??
     * @returns {string}
     * @private
     */
    var _getMultiOptionDropdownHTMLWithCustomInnerHTML = function (ctrlType, label, desc, config, type) {
        var html = '';
        if (config.options && config.options.length > 0) {
            html = '<li class="dropdown ' + (config.baseClass ? config.baseClass : '') + '"' +
                _getTopttItemHtml(type) +
                infChart.structureManager.common.getCtrlTypeHtml(ctrlType) +
                '>' +
                '<a class="dropdown-toggle" role="button" aria-expanded="false">' +
                '<span cntrl-role="text" data-localize="' + label + '"></span><span class="caret"></span></a>' +
                '<ul class="dropdown-menu ' + (config.menuClass ? config.menuClass : '') + '" role="menu">';
            infChart.util.forEach(config.options, function (i, obj) {
                html += '<li' + (obj.cssClass ? (' class="' + obj.cssClass + '"') : '') +
                    _getCtrlItemHTML(ctrlType) +
                    infChart.structureManager.common.getCtrlValueHtml(obj.key) +
                    '>' + obj.html + '</li>';
            });
            html += '</ul></li>';
        }
        return html;
    };

    /**
     * multi option element with caret with fixed title
     * used for file
     * @param {string} ctrlType
     * @param {string} label
     * @param {string} desc
     * @param {Array<object>} options
     * @param {string} type - ??
     * @returns {string}
     * @private
     */
    var _getMultiOptionDropdownHTMLWithFixedTitle = function (ctrlType, label, desc, options, type) {
        var html = '';
        if (options && options.length > 0) {
            html = '<li class="dropdown"' +
                _getTopttItemHtml(type) +
                infChart.structureManager.common.getCtrlTypeHtml(ctrlType) +
                '>' +
                '<a target="_self" class="dropdown-toggle" role="button" aria-expanded="false">' +
                '<span cntrl-role="text" data-localize="' + label + '">' + desc + '</span><span class="caret"></span></a>' +
                '<ul class="dropdown-menu" role="menu">';
            infChart.util.forEach(options, function (i, obj) {
                html += '<li' + _getCtrlItemHTML(ctrlType) +
                    infChart.structureManager.common.getCtrlValueHtml(obj.key) +
                    ' inf-temp-type="' + obj.type + '"><a data-localize="' + obj.label + '" >' + obj.desc + '</a></li>';
            });
            html += '</ul></li>';
        }
        return html;
    };

    /**
     * multi option element with caret with each option in a new line
     * used for interval
     * @param {string} ctrlType
     * @param {string} label
     * @param {object} config
     * @param {string} type - ??
     * @returns {string}
     * @private
     */
    var _getMultiOptionWithHorizontalDropdownHTML = function (ctrlType, label, config, type) {
        var html = '';
        if (config.options && config.options.length > 0) {
            var ctrlTypeHtml = infChart.structureManager.common.getCtrlTypeHtml(ctrlType);
            if (config.options.length === 1) {
                var obj = config.options[0];
                html =
                    '<li' + infChart.structureManager.common.getCtrlValueHtml(obj.key) +
                    _getTopttItemHtml(type) +
                    ctrlTypeHtml + ' class="' + ( config.cls || "") + '" >' +
                    '<a class="selected-el" target="_self"' + _getCtrlTextHtml(obj.label, obj.shortLabel, config.shortLabel) + '>' + obj.desc + '</a>' +
                    '</li>';
            } else {
                html =
                    '<li class="dropdown ' + ( config.cls || "") + '"' + _getTopttItemHtml(type) + ctrlTypeHtml + '>' +
                    '<a target="_self" class="dropdown-toggle" role="button" aria-expanded="false" ' + _getCtrlTooltipHtml(label, undefined, undefined, "bottom") + '>' +
                    '<span ctrl-role="text"></span>' +
                    '<span class="caret"></span>' +
                    '</a>' +
                    '<ul class="dropdown-menu" role="menu">';
                html += _getHorizontalDropdownOptionsHTML(config.options, (config.display ? config.display.split(',') : undefined), config.shortLabel, ctrlType);
                html += '</ul></li>';
            }
        }
        return html;
    };

    var _getHorizontalDropdownOptionsHTML = function (options, displayOptions, showShortLabel, ctrlType) {
        var optionsHtml = '';
        infChart.util.forEach(options, function (i, obj) {
            if (!displayOptions || displayOptions.indexOf(obj.key) > -1) {
                optionsHtml +=
                    '<li' + _getCtrlItemHTML(ctrlType) +
                    infChart.structureManager.common.getCtrlValueHtml(obj.key) +
                    '>' +
                    '<a target="_self" ' + _getCtrlTextHtml(obj.label, obj.shortLabel, showShortLabel) + '>' + (showShortLabel && obj.shortDesc ? obj.shortDesc : obj.desc) + '</a>' +
                    '</li>';
            }
        });
        return optionsHtml;
    };

    //endregion

    //endregion

    var _getSettingsContainer = function (containerId, type) {
        var container, mainContainer = $("#" + containerId);
        switch (type) {
            case "indicator" :
                container = mainContainer.find('div[inf-container="indicator_settings"]');
                break;
            case "symbol" :
                container = mainContainer.find('div[inf-container="symbol_settings"]');
                break;
            case "file":
                container = mainContainer.find('div[inf-container="file_settings"]');
                break;
            case "trade":
                container = mainContainer.find('div[inf-container="trade_settings"]');
                break;
            case "indicatorPanelView":
                container = mainContainer.find('div[inf-container="indicator_panel"]');
                break;
            case "drawingToolPanelView":
                container = mainContainer.find('div[inf-container="drawing_tools_panel"]');
                break;
            case "symbolSettingsPanelView":
                container = mainContainer.find('div[inf-container="symbol_settings_panel"]');
                break;
            case "tradingPanelView"://todo : chart trader must use this
                container = mainContainer.find('div[inf-container="trading_panel"]');
                break;
            default:
                break;
        }
        return container;
    };

    var _createInstance = function () {
        return {
            createToolbar: _createToolbar,
            setHTML: _setHTML,
            setSelectedControls: _setSelectedControls,
            clearSelectedControls: _clearSelectedControls,
            getSettingsContainer: _getSettingsContainer,
            setDefaultValues: _setDefaultValues,
            setVisibility: _setVisibility,
            initializeTooltips: _initializeTooltips,
            getChartInstance: _getChartInstance   
        }
    };

    var _getInstance = function () {
        if (!_instance) {
            return _createInstance();
        }
        return _instance;
    };

    return _getInstance();
})();
/**
 * Created by dushani on 9/27/18.
 * HighCharts plugging to scale the x and y axis when user dragging the container
 * This is a modified version of Roland Banguiran's (banguiran@gmail.com) plugin for manually scaling Y-Axis range
 *
 *
 * Usage: Set infScalable:true in the chart options to enabble.
 * Default: false
 */

// JSLint options:
/*global Highcharts, document */

(function (H) {
    'use strict';
    var addEvent = H.addEvent,
        doc = document,
        body = doc.body,
        showXAxisResetButton = {},
        showYAxisResetButton = {};

    /**
     * Change the y axis extremes when drag the container vertically
     * @param axis
     * @param downYValue
     * @param downYPixels
     * @param dragYPixels
     * @returns {*}
     */
    var onYAxisDrag = function (axis, downYValue, downYPixels, dragYPixels) {

        var extremes = axis.getExtremes(),
            yScalestartDef = infChart.settings.defaults && infChart.settings.defaults.scaleYStart || 60,
            scaleStartDiff = yScalestartDef / ((axis.chart && axis.chart.infScaleY) || 1);

        if ((dragYPixels > (axis.top + axis.height) || dragYPixels < axis.top) || (!extremes.userMax && !extremes.userMin && Math.abs(dragYPixels - downYPixels) < scaleStartDiff)) {
            return;
        }

        var currentMin = extremes.min,
            currentMax = extremes.max,
            dataMin = extremes.dataMin,
            dataMax = extremes.dataMax,
            maxPxRange,
            minPxRange,
            min = H.isNumber(currentMin) ? currentMin : undefined,
            max = H.isNumber(currentMax) ? currentMax : undefined,
            currentRange = max - min,
            currentRate = currentRange / axis.height,
            hasNewExtremes,
            newMin,
            newMax,
            redrawRequired;

        // update max extreme only if min/max are defined
        if (H.isNumber(min) && H.isNumber(max)) {

            if (downYPixels < dragYPixels) {

                // user dragged container downwards and chart should be moved down.
                maxPxRange = dragYPixels - axis.top;
                minPxRange = (axis.top + axis.height) - dragYPixels;

                /* To feel user dragged the same value downwards adjust the current value which represents the mouse pointer by
                 *  changing the min and max taking the current pixel positions into account*/
                newMax = downYValue + currentRate * (maxPxRange);
                newMin = downYValue - currentRate * (minPxRange);

                // console.debug("Y :: newMax : " + newMax + ", dataMax : " + dataMax + ", newMin : " + newMin + ", currentRate : " + currentRate);
                if (newMin < dataMax /*&& (newMin <= dataMin || newMax >= dataMax)*/) {
                    // console.debug("Y :: newMin : " + newMin + ",  dataMax : " + dataMax);
                    hasNewExtremes = true;
                    redrawRequired = true;
                }

            } else if (downYPixels > dragYPixels) {

                // user dragged container upwards and chart should be moved up
                maxPxRange = dragYPixels - axis.top;
                minPxRange = (axis.top + axis.height) - dragYPixels;

                /* To feel user dragged the same value downwards adjust the current value which represents the mouse pointer by
                 *  changing the min and max taking the current pixel positions into account*/

                newMax = downYValue + currentRate * (maxPxRange);
                newMin = downYValue - currentRate * (minPxRange);

                // console.debug("Y :: newMax : " + newMax + ", dataMax : " + dataMax + ", newMin : " + newMin + ", currentRate : " + currentRate);
                if (newMax > dataMin /*&& newMin <= dataMin || newMax >= dataMax*/) {
                    // console.debug("Y :: newMax : " + newMin + ",  dataMin : " + dataMax);
                    hasNewExtremes = true;
                    redrawRequired = true;
                }
            }

            if (hasNewExtremes) {
                infChart.manager.setUserDefinedYAxisExtremes(axis.chart.renderTo.id, newMin, newMax, false, true, false);
            }
        }
        return redrawRequired;

    };

    /**
     * Calculate and change y axis zoom when dragging event triggers on y axis labels
     * @param chart
     * @param axis
     * @param delta
     * @param chartCore
     */
    var onYAxisLabelsDrag = function (chart, axis, delta, chartCore) {
        var extremes = axis.getExtremes(),
            actualExRange = extremes.dataMax - extremes.dataMin,
            actualSeriesExtremes = infChart.manager.getSeriesActualExtremes(chart.renderTo.id, chart.series[0].options.id),
            exDataMin = actualSeriesExtremes ? actualSeriesExtremes.dataMin : extremes.dataMin,
            exDataMax = actualSeriesExtremes ? actualSeriesExtremes.dataMax : extremes.dataMax,
            actualRange = actualSeriesExtremes ? actualSeriesExtremes.dataMax - actualSeriesExtremes.dataMin : exDataMax - exDataMin,
            min = extremes.min,
            max = extremes.max,
            dataMin = exDataMin - actualRange,
            dataMax = exDataMax + actualRange,
            totalTimeChange,
            currentRange = max - min,
            midTime = max - (currentRange / 2),
            newRange,
            newMin,
            newMax,
            tickSize = 0.03,//Use this to change responsiveness of the axis label drag
            doZoom = false,
            tickChangeWeight = Math.abs(delta) > 20 ? 2 : 1;

        if (delta > 0) {
            totalTimeChange = tickSize * tickChangeWeight * (max - min);
            newRange = currentRange - totalTimeChange;
            doZoom = newRange > (actualExRange / 10);

            if (doZoom) { // to keep minimum points to be 5
                newMax = Math.min(dataMax, midTime + (newRange * ((max - midTime) / currentRange)));
                newMin = newMax - newRange;
                setAxisZoom(chart, axis, dataMin, dataMax, newMin, newMax, false, chartCore);
            }
        } else if (!(dataMin >= min && dataMax <= max)) {
            var maxZoom = infChart.manager.getMaxZoomRange(chart);

            totalTimeChange = tickSize * tickChangeWeight * (max - min);
            newRange = currentRange + totalTimeChange;
            if (newRange > maxZoom) {
                newRange = maxZoom;
            }

            if (currentRange < maxZoom && currentRange != newRange) {
                newMax = Math.min(dataMax, midTime + (newRange * ((max - midTime) / currentRange)));
                newMin = newMax - newRange;
                setAxisZoom(chart, axis, dataMin, dataMax, newMin, newMax, false, chartCore);
            }
        }
    };

    /**
     * Calculate and change x axis zoom when dragging event triggers on x axis labels
     * @param chart
     * @param axis
     * @param delta
     * @param chartCore
     */
    var onXAxisLabelsDrag = function (chart, axis, delta, chartCore) {
        var extremes = axis.getExtremes(),
            actualExRange = extremes.dataMax - extremes.dataMin,
            min = extremes.min,
            max = extremes.max,
            dataMin = extremes.dataMin,
            dataMax = extremes.dataMax,
            totalTimeChange,
            currentRange = max - min,
            midTime = max - (currentRange / 2),
            newRange,
            newMin,
            tickSize = 0.015,
            doZoom = false,
            tickChangeWeight = Math.abs(delta) > 20 ? 2 : 1;
            chart.onXAxisLabelsDrag = true;

        if (delta > 0) {
            totalTimeChange = tickSize * tickChangeWeight * (max - min);
            newRange = currentRange - totalTimeChange;
            doZoom = !chart.series[0].closestPointRange || chart.series[0].closestPointRange * 5 < newRange;

            if (doZoom) {
                newMin = max - newRange;
                setAxisZoom(chart, axis, dataMin, dataMax, newMin, max, true, chartCore);
            }
        } else if (!(dataMin >= min && dataMax <= max)) {
            var maxZoom = infChart.manager.getMaxZoomRange(chart);

            totalTimeChange = tickSize * tickChangeWeight * (max - min);
            newRange = currentRange + totalTimeChange;
            if (newRange > maxZoom) {
                newRange = maxZoom;
            }

            if (currentRange < maxZoom && currentRange != newRange && dataMin <= (max - newRange)) {
                newMin = max - newRange;
                setAxisZoom(chart, axis, dataMin, dataMax, newMin, max, true, chartCore);
            }
        }
    };

    /**
     * Set calculated axis zoom
     * @param chart
     * @param axis
     * @param mainSeriesDataMin
     * @param mainSeriesDataMax
     * @param newMin
     * @param newMax
     * @param chartCore
     */
    var setAxisZoom = function (chart, axis, mainSeriesDataMin, mainSeriesDataMax, newMin, newMax, isXZoom, chartCore) {
        if (axis) {
            var isZoomUp = (newMax - newMin) <= (axis.max - axis.min),
                isRange = !isZoomUp ? ((axis.max >= newMin && axis.max <= newMax) || (axis.min >= newMin && axis.min <= newMax)) : (newMin >= axis.min && newMax <= axis.max);

            if ((!isNaN(newMin) && !isNaN(newMax)) && isRange
                && (!isZoomUp || (mainSeriesDataMax && mainSeriesDataMin && newMin < mainSeriesDataMax && newMax > mainSeriesDataMin))
            ) {

                if (isXZoom) {
                    infChart.manager.setUserDefinedXAxisExtremes(chart.renderTo.id, newMin, newMax, true);
                } else {
                    infChart.manager.setUserDefinedYAxisExtremes(chart.renderTo.id, newMin, newMax, true, true);
                }
                chartCore._fireEventListeners('setExtremesByDragging', isXZoom);
            }
        }
    }

    /**
     * Change the x axis extremes when drag the container horizontally
     * @param axis
     * @param downXValue
     * @param downXPixels
     * @param dragXPixels
     * @param downXextremes
     * @param isLinearAxis
     * @returns {*}
     */
    var onXAxisDrag = function (axis, downXValue, downXPixels, dragXPixels, downXextremes, isLinearAxis) {

        var extremes = axis.getExtremes(),
            currentMin = extremes.min,
            currentMax = extremes.max,
            dataMin = extremes.dataMin,
            dataMax = extremes.dataMax,
            maxPxRange,
            minPxRange,
            min = H.isNumber(currentMin) ? currentMin : undefined,
            max = H.isNumber(currentMax) ? currentMax : undefined,
            currentRange = max - min,
            currentRate = currentRange / axis.width,
            newMin,
            newMax,
            redrawRequired,
            iChart = infChart.manager.getChart(infChart.manager.getContainerIdFromChart(axis.chart.renderTo.id)),
            rangeMin = iChart && iChart.minRangeVal,
            chartExMin = iChart && iChart.exMinVal,
            currentPositions = !isLinearAxis && iChart.getPointPositions(),
            currentPointRate = !isLinearAxis && (downXextremes.maxIdx - downXextremes.minIdx + 1) / axis.width;


        // update max extreme only if min/max are defined
        if (H.isNumber(min) && H.isNumber(max)) {

            // user dragged container to the right and chart should be moved right.
            if (downXPixels < dragXPixels) {


                /* To feel user dragged the same value to the right adjust the current value which represents the mouse pointer by
                 *  changing the min and max taking the current pixel ratio into account*/

                if (isLinearAxis) {
                    maxPxRange = axis.left + axis.width - dragXPixels;
                    minPxRange = dragXPixels - axis.left;
                    newMax = downXValue + currentRate * (maxPxRange);
                    newMin = downXValue - currentRate * (minPxRange);

                    if (newMin < dataMin && extremes.min > dataMin) {
                        newMin = dataMin;
                    }

                    if (newMax > dataMax && extremes.max < dataMax) {
                        newMax = dataMax;
                    }
                } else {
                    /* Since axis is not linear adjust current value using no of points shifted instead of the axis value*/
                    var newMaxIdx = downXextremes.maxIdx - Math.floor((dragXPixels - downXPixels) * currentPointRate),
                        newMinIdx = downXextremes.minIdx - Math.floor((dragXPixels - downXPixels) * currentPointRate);
                    newMax = Math.min(axis.dataMax, currentPositions[newMaxIdx] || axis.dataMax);
                    newMin = Math.max(axis.dataMin, currentPositions[newMinIdx] || axis.dataMin);
                }
                //console.debug("X :: newMax : " + newMax + ", dataMax : " + dataMax + ", newMin : " + newMin + ", currentRate : " + currentRate);
                //  console.debug("X :: maxIdx : " + maxIdx + ", minIdx : " + minIdx + ", newMaxIdx : " + newMaxIdx + ", newMinIdx : " + newMinIdx);
                if ((newMin >= dataMin || (rangeMin && rangeMin < newMin) || (chartExMin && chartExMin < newMin)) && newMax <= dataMax) {
                    //console.debug("X :: newMax : " + newMin + ",  dataMin : " + dataMin + ", min/max range : " + (newMax - newMin));
                    // axis.setExtremes(newMin, newMax, false, false);
                    infChart.manager.setUserDefinedXAxisExtremes(axis.chart.renderTo.id, newMin, newMax, false, true, false);
                    redrawRequired = true;
                }

            } else if (downXPixels > dragXPixels) {
                // user dragged container to the left and chart should be moved left.

                /* To feel user dragged the same value to the left adjust the current value which represents the mouse pointer by
                 *  changing the min and max taking the current pixel ratio into account */

                if (isLinearAxis) {
                    maxPxRange = axis.left + axis.width - dragXPixels;
                    minPxRange = dragXPixels - axis.left;
                    newMax = downXValue + currentRate * (maxPxRange);
                    newMin = downXValue - currentRate * (minPxRange);

                } else {
                    /* Since axis is not linear adjust current value using no of points shifted instead of the axis value*/
                    newMax = Math.min(axis.dataMax, currentPositions[downXextremes.maxIdx + Math.floor((downXPixels - dragXPixels) * currentPointRate)] || axis.dataMax);
                    newMin = Math.max(axis.dataMin, currentPositions[downXextremes.minIdx + Math.floor((downXPixels - dragXPixels) * currentPointRate)] || axis.dataMin);
                }

                //  console.debug("X :: newMax : " + newMax + ", dataMax : " + dataMax + ", newMin : " + newMin + ", currentRate : " + currentRate);
                if ((newMin >= dataMin || (rangeMin && rangeMin < newMin) || (chartExMin && chartExMin < newMin)) && newMax <= dataMax) {
                    // console.debug("X :: newMax : " + newMin + ",  newMax : " + newMax + ",  dataMax : " + dataMax + ", min/max range : " + (newMax - newMin) + ", currentRange : " + currentRange);
                    // axis.setExtremes(newMin, newMax, false, false);
                    infChart.manager.setUserDefinedXAxisExtremes(axis.chart.renderTo.id, newMin, newMax, false, true, false);
                    redrawRequired = true;

                }
            }
        }
        return redrawRequired;
    };

    /**
     * Reset the y axis extremes
     * @param chart
     */
    var resetYZoom = function (chart) {
        infChart.manager.resetUserDefinedYAxisExtremes(chart.renderTo.id, true);
    };

    /**
     * Reset the x axis extremes
     * @param chart
     */
    var resetXZoom = function (chart) {
        infChart.manager.resetUserDefinedXAxisExtremes(chart.renderTo.id);
    };

    H.Chart.prototype.callbacks.push(function (chart) {
        var chartOptions = chart.userOptions,
            scalable = chartOptions && chartOptions.chart.infChart && chartOptions.chart.infScalable;

        // Enable dragging if specified.
        if (scalable) {

            var yAxis = chart.yAxis[0],
                xAxis = chart.xAxis[0],
                chartId = chart.renderTo.id,
                options = yAxis.options,
                labels = options.labels,
                pointer = chart.pointer,
                isDragging = false,
                isYAxisLabelDragging = false,
                previousDragYPixels,
                downYPixels,
                isXAxisLabelDragging = false,
                previousDragXPixels,
                downXPixels,
                downYValue,
                downXValue,
                downYPixelValue,
                downYPixelRate,
                downYrange,
                downXPixelValue,
                downXextremes,
                containerId = infChart.manager.getContainerIdFromChart(chartId),
                iChart,
                isLinearAxis = true;

            labels.style.cursor = 'ns-resize';

            infChart.util.bindEvent(chart.container, 'mousedown', function (e) {
                if (e.which == 1 || e.button == 0 || e.which == 0) {
                    downYPixels = chart.pointer.normalize(e).chartY;
                    downXPixels = pointer.normalize(e).chartX;
                    var extremes = yAxis.getExtremes(),
                        currentPositions;

                    iChart = infChart.manager.getChart(containerId);

                    downYValue = yAxis.toValue(downYPixels);
                    downYPixelValue = downYPixels;
                    downXPixelValue = downXPixels;
                    downYPixelRate = yAxis.toValue(0) - yAxis.toValue(1);
                    downYrange = extremes.max - extremes.min;
                    downXValue = chart.xAxis[0].toValue(downXPixels);

                    isLinearAxis = iChart.isLinearData();

                    downXextremes = chart.xAxis[0].getExtremes();

                    isDragging = true;

                    if (downXPixels > (xAxis.left + xAxis.width)) {
                        previousDragYPixels = downYPixels;
                        body.style.cursor = 'ns-resize';
                        isYAxisLabelDragging = true;
                    }

                    if (downYPixels > xAxis.height && downYPixels < chart.navigator.top) {
                        previousDragXPixels = downXPixels;
                        body.style.cursor = 'ew-resize';
                        isXAxisLabelDragging = true;
                    }

                    if (!isLinearAxis) {
                        /* current positions are used only in non-liniear axes*/
                        currentPositions = iChart.getPointPositions();
                        downXextremes.minIdx = downXextremes.min && Math.abs(infChart.util.binaryIndexOf(currentPositions, undefined, downXextremes.min));
                        downXextremes.maxIdx = downXextremes.max && Math.abs(infChart.util.binaryIndexOf(currentPositions, undefined, downXextremes.max));
                    }
                }
            });

            infChart.util.bindEvent(chart.container, 'mousemove', function (e) {
                if(e.type === 'touchmove' && e.touches.length > 1){
                    return;       
                }

                if (isDragging && (!chart.annotations || chart.annotations.allowZoom || isYAxisLabelDragging || isXAxisLabelDragging) && !(chart.navigator && (chart.navigator.grabbedLeft || chart.navigator.grabbedRight || chart.navigator.grabbedCenter))) {
                    if (isYAxisLabelDragging) {
                        var delta = previousDragYPixels - chart.pointer.normalize(e).chartY;

                        if (Math.abs(previousDragYPixels - chart.pointer.normalize(e).chartY) > 1) {
                            previousDragYPixels = chart.pointer.normalize(e).chartY;
                            onYAxisLabelsDrag(chart, yAxis, delta, iChart)
                        }
                    } else if (isXAxisLabelDragging) {
                        var deltaX = previousDragXPixels - chart.pointer.normalize(e).chartX;

                        if (Math.abs(deltaX) > 1) {
                            previousDragXPixels = chart.pointer.normalize(e).chartX;
                            onXAxisLabelsDrag(chart, chart.xAxis[0], deltaX, iChart);
                        }
                    } else {
                        chart.isChartDragging = true;
                        body.style.cursor = 'move';

                        var xAxis = chart.xAxis[0],
                            // dragXPixels = chart.pointer.normalize(e).chartX,
                            // dragYPixels = chart.pointer.normalize(e).chartY,
                            dragXPixels = e.chartX,
                            dragYPixels = e.chartY,
                            navigatorHeight = chart.options.navigator.height;

                        if (((dragXPixels > (xAxis.left + xAxis.width + xAxis.right) || dragXPixels < xAxis.left)) ||
                            ((dragYPixels > (yAxis.top + yAxis.height + yAxis.bottom - navigatorHeight) || dragYPixels < yAxis.top)) /*|| Math.abs(dragYPixels - downYPixels)<50*/) {
                            return;
                        }

                        // TODO :: check the possibility of redrawing only once
                        var xUpdateRequired = onXAxisDrag(xAxis, downXValue, downXPixelValue, dragXPixels, downXextremes, isLinearAxis) || false,
                            yUpdateRequired = onYAxisDrag(yAxis, downYValue, downYPixelValue, dragYPixels) || false;

                        if (xUpdateRequired || yUpdateRequired) {
                            // console.debug("scalable Axis :: xUpdateRequired : " + xUpdateRequired + " && yUpdateRequired:" + xUpdateRequired);
                            // infChart.manager.beforeScalingAxis(chartId, {
                            //     xAxis: xUpdateRequired,
                            //     yAxis: yUpdateRequired
                            // });
                            // if (xUpdateRequired && yUpdateRequired) {
                            //     infChart.manager.pauseScaleDrawings(chart.renderTo.id);
                            // }
                            chart.redraw();
                            chart.infManualCrosshair = true;
                            chart.pointer.runPointActions(e);
                            chart.infManualCrosshair = false;
                            iChart._fireEventListeners('setExtremesByDragging', {});
                            // if (xUpdateRequired && yUpdateRequired) {
                            //     infChart.manager.unPauseScaleDrawings(chart.renderTo.id);
                            // }
                        }

                        // infChart.manager.afterScalingAxis(chartId, {
                        //     xAxis: xUpdateRequired,
                        //     yAxis: yUpdateRequired
                        // });
                    }
                }
            });

            infChart.util.bindEvent(document, 'mouseup', function () {
                body.style.cursor = 'default';
                isDragging = false;
                isYAxisLabelDragging = false;
                isXAxisLabelDragging = false;
                chart.onXAxisLabelsDrag = false;
                chart.isChartDragging = false;
                chart.redraw();
                // chart.infContainerDragging = false;
            });

            addEvent(chart, 'destroy', function () {
                //remove axis-reset-container div
                infChart.structureManager.scalableAxis.removeButtonHTML(containerId);
            });

            addEvent(yAxis, 'afterSetExtremes', function () {
                var resizeRequired = false;
                if (infChart.manager.isDefaultYAxisExtremes(chartId)) {
                    resizeRequired = infChart.structureManager.scalableAxis.updateButtonView(containerId, false, false);
                    showYAxisResetButton[chartId] = false;
                } else if (!showYAxisResetButton[chartId]) {
                    resizeRequired = infChart.structureManager.scalableAxis.updateButtonView(containerId, false, true);
                    showYAxisResetButton[chartId] = true;
                }
                if (resizeRequired) {
                    infChart.manager.getChart(containerId).resizeChart();
                }
            });

            addEvent(xAxis, 'afterSetExtremes', function (e) {
                var resizeRequired = false;
                if (infChart.manager.isDefaultXAxisExtremes(chartId, e)) {
                    resizeRequired = infChart.structureManager.scalableAxis.updateButtonView(containerId, true, false);
                    showXAxisResetButton[chartId] = false;
                } else if (!showXAxisResetButton[chartId]) {
                    resizeRequired = infChart.structureManager.scalableAxis.updateButtonView(containerId, true, true);
                    showXAxisResetButton[chartId] = true;
                }
                if (resizeRequired) {
                    infChart.manager.getChart(containerId).resizeChart();
                }
            });

            infChart.structureManager.scalableAxis.setButtons(containerId, function () {
                showXAxisResetButton[chartId] = false;
                var resizeRequired = infChart.structureManager.scalableAxis.updateButtonView(containerId, true, false);
                resetXZoom(chart);
                if(resizeRequired){
                    infChart.manager.getChart(containerId).resizeChart();
                }
            }, function () {
                showYAxisResetButton[chartId] = false;
                var resizeRequired = infChart.structureManager.scalableAxis.updateButtonView(containerId, false, false);
                resetYZoom(chart);
                if(resizeRequired){
                    infChart.manager.getChart(containerId).resizeChart();
                }
            });
        }
    });

}(Highcharts));
/**
 * Created by dushani on 11/12/18.
 *
 * Code and HTMLs related to structural stuff such as layout legend tooltip and etc, goes here.
 */

 window.infChart = window.infChart || {};

 infChart.structureManager = (function ($, infChart) {

     var _getStructure = function (toolbarEnabled, toolbarProperties) {
         var html = '';
         if (toolbarEnabled) {
             html =
                 '<div inf-container="indicator_settings"></div>' +
                 '<div inf-container="symbol_settings"></div>' +
                 '<div inf-container="file_settings"></div>';

             if (toolbarProperties.top || toolbarProperties.upper || toolbarProperties.mobile) {
                 html += '<header inf-container="header">' +
                 '<nav class="navbar navbar-default">' +
                 '<div>' +
                 '<div inf-pnl="tb-trading"></div>' +
                 '<div inf-pnl="tb-mobile"></div>' +
                 '<div inf-pnl="tb-upper"></div>' +
                 '</div>' +
                 '</nav>' +
                         '</header>';

             }
             if (toolbarProperties && toolbarProperties.top) {
                 html += '<nav class="navbar navbar-default nav2" inf-container="top">' +
                 '<div>' +
                 '<div class="navbar-header ad-chart-navbar-header">' +
                 '<div class="collapse navbar-collapse defaultNavbar2"  style="display: block !important;">' +
                 '<div inf-pnl="tb-top"></div>' +
                 '</div>' +
                 '</div>' +
                 '</div>' +
                         '</nav>';
             }

             html += '<div class="clearfix"></div>' +
                 '<div inf-container="chart_container" class="chart_container">' +
                 '<div inf-ref="chart_row" class="chart-section">' +
                 '<div inf-pnl="tb-left"></div>' +
                 '<div inf-pnl="favorite-menu-panel"></div>' +
                 '<div inf-container="chartwrapper" class="chartwrapper">' +
                 '<div inf-container="chart_holder" class="chart_holder clearfix">' +
                 '<div inf-container="chart_top" class="chart-option-y-axis-reset-wrapper"></div>' +
                 '<div inf-container="highchartContainer" class="chart-outer-wrapper">' +
                 '<div inf-container="trade_settings" class="position-relative"></div>' +
                 '<div inf-container="drawing_settings" class="position-relative"></div>' +
                 '<div inf-container="quick_drawing_settings" class="position-relative"></div>' +
                 '<div inf-container="chart" style="height:100%"></div> ' +
                 '<div inf-container="order-book-volume" style="height:100%"></div>' +
                 '</div>' +
                 '</div>' +
                 '<div inf-pnl="tb-right"></div>' +
                 '<div inf-pnl="context-menu-panel" class="context-menu-panel" style="display: none;"></div>'+
                 '</div>' +
                 '</div>' +
                 '</div>' +
                 '<div inf-container="msg_container"></div>';

         } else {
             html = '<div inf-container="chartwrapper" class="chartwrapper">' +
                 '<div inf-container="chart_top" class="chart-option-y-axis-reset-wrapper"></div>' +
                 '<div inf-container="highchartContainer" class="chart-outer-wrapper">' +
                 '<div inf-container="trade_settings" class="position-relative"></div>' +
                 '<div inf-container="chart" class="mainchart_chart clearfix" style="height:100%"></div>' +
                 '<div inf-container="order-book-volume" style="height:100%"></div>' +
                 '</div>' +
                 '<div inf-pnl="context-menu-panel" class="context-menu-panel" style="display: none;"></div>'+
                 '<div inf-container="msg_container"></div>' +
                 '</div>';
         }
         return html;
     };

    var _getContainer = function (container, type) {
        var selector;
        switch (type) {
            case 'chartContainer':
                selector = 'div[inf-container="highchartContainer"]';
                break;
            case 'depthContainer':
                selector = 'div[inf-container="order-book-volume"]';
                break;
            case "indicator" :
                selector = 'div[inf-container="indicator_settings"]';
                break;
            case "symbol" :
                selector = 'div[inf-container="symbol_settings"]';
                break;
            case "file":
                selector = 'div[inf-container="file_settings"]';
                break;
            case "trade":
                selector = 'div[inf-container="trade_settings"]';
                break;
            case "drawing":
                selector = 'div[inf-container="drawing_settings"]';
                break;
            case "indicatorPanelView":
                selector = 'div[inf-container="indicator_panel"]';
                break;
            case "drawingToolPanelView":
                selector = 'div[inf-container="drawing_tools_panel"]';
                break;
            case "symbolSettingsPanelView":
                selector = 'div[inf-container="symbol_settings_panel"]';
                break;
            case "tradingPanelView":
                selector = 'div[inf-container="trading_panel"]';
                break;
            case "chart_top":
                selector = 'div[inf-container="chart_top"]';
                break;
            case "settingsPanel":
                selector = 'div[inf-pnl="tb-right"]';
                break;
            case "drawingToolbar":
                selector = 'div[inf-pnl="tb-left"]';
                break;
            case "tradingToolbar":
                selector = 'div[inf-pnl="tb-trading"]';
                break;
            case "contextMenuPanel":
                selector = 'div[inf-pnl="context-menu-panel"]';
                break;
            case "favoriteMenuPanel":
                selector = 'div[inf-pnl="favorite-menu-panel"]';
                break;
            case "quickDrawingSettingsPanel":
                selector = 'div[inf-container="quick_drawing_settings"]'
                break;
            default:
                break;
        }

        return selector && container ? container.querySelector(selector) : container;
    };

     var _getChartWrapperDimensions = function (id, containerElem) {

         if (!containerElem) {
             return;
         }

         var height = containerElem.clientHeight,
             width = containerElem.clientWidth,
             header = containerElem.querySelector('[inf-container="header"]'),
             headerHeight = 0;

         //header height - period bar
         if (header && header.style.display != 'none') {
             headerHeight = $(header).outerHeight(true);
         }

         //top button line height
         var top = containerElem.querySelector('[inf-container="top"]'), topHeight = 0;
         if (top && top.style.display != 'none') {
             topHeight = $(top).outerHeight(true);
         }

         var left = containerElem.querySelector('[inf-pnl="tb-left"]'), leftWidth = 0;
         if (left && left.style.display != 'none') {
             leftWidth = $(left).outerWidth(true);
         }

         return {
             width: width - leftWidth,//left tool bar is outside the wrapper
             height: height - headerHeight - topHeight
         };
     };

     var _getChartHolderDimensions = function (id, containerElem, wrapperDimensions) {

         if (!wrapperDimensions) {
             wrapperDimensions = _getChartWrapperDimensions(id, containerElem);
         }
         //right panel is in the wrapper
         var right = containerElem.querySelector('[inf-pnl="tb-right"]'),
             rightWidth = 0,
             wrapperHeight = wrapperDimensions.height,
             wrapperWidth = wrapperDimensions.width;

         if (right && right.style.display != 'none') {
             if (!right.classList.contains('chart-rp-on-resize')) {
                 rightWidth = 240;//this is a hack
             } else {
                 rightWidth = right.clientWidth;
             }
         }

         var holderWidth = wrapperWidth - rightWidth,
             holderHeight = wrapperHeight;

         return {
             width: holderWidth,
             height: holderHeight
         };
     };

     /**
      * Returns the chart container's dimensions along with the legend's deimensions
      * @param {string} id - chart container id
      * @param {Element} containerElem - container element
      * @param {object} holderDimensions - holder dimensions {width:{number},height:{number}}
      * @param {boolean} skipDepth - whether to set depth sizes or not
      * @returns {{width: *, height: number, legendHeight: number, legendWidth: *}} chart container dimensions
      * @private
      */
     var _getHighChartContainerDimensions = function (id, containerElem, holderDimensions, skipDepth) {
         holderDimensions = holderDimensions ? holderDimensions : _getChartHolderDimensions(id, containerElem);

         //legend height
         var holderWidth = holderDimensions.width,
             holderHeight = holderDimensions.height,
             legend = containerElem.querySelector('[inf-container="chart_top"]'),
             legendHeight = 0,
             legendWidth = holderWidth;

         if (legend && legend.style.display != 'none') {
             legendHeight = $(legend).outerHeight(true);
         }

         var chartWidth = holderWidth;
         var chartHeight = holderHeight - legendHeight;

         if (infChart.depthManager && !skipDepth) {
             var depthSize = infChart.depthManager.setContainerSize(id, containerElem, chartWidth, chartHeight);
             chartWidth = chartWidth - depthSize.width;
             chartHeight = chartHeight - depthSize.height;
         }

         return {width: chartWidth, height: chartHeight, legendHeight: legendHeight, legendWidth: legendWidth};
     };

     /**
      * Re arrange the top tb, uper tb, and the trading tb of the given container (compact toolbars if needed)
      * @param id
      * @param containerEl
      * @private
      */
     var _rearrangeUpperLayerToolbar = function (id, containerEl) {

         var width = containerEl && containerEl.clientWidth,
             topTb = containerEl.querySelector('[inf-pnl="tb-top"]'),
             upperTb = containerEl.querySelector('[inf-pnl="tb-upper"]'),
             leftTb = containerEl.querySelector('[inf-pnl="tb-left"]'),
             topTbFullWidth = topTb && +topTb.getAttribute("x-full-width"),
             upperTbFullWidth,
             tradingTb,
             tradingTbFullWidth,
             tradingTbCompactWidth,
             isTopTbCompacted = false,
             tradingTbHideWidth;

         upperTbFullWidth = upperTb && +upperTb.getAttribute("x-full-width");

         var chart = infChart.manager.getChart(id);

         if (chart && (chart.settings.toolbar.alwaysCompactToolbar || ((!topTbFullWidth && topTb && topTb.clientWidth > width ) ||
             (topTbFullWidth && topTbFullWidth > width)))) {

             if (!topTbFullWidth && topTb) {
                 topTb.setAttribute("x-full-width", topTb.clientWidth);
             }
             containerEl.xAddClass('compact-toolbar'); // top bar
             isTopTbCompacted = true;

             if ((!upperTbFullWidth && upperTb && upperTb.clientWidth > width ) ||
                 (upperTbFullWidth && upperTbFullWidth > width) /*width < 580 */) {
                 if (!upperTbFullWidth && upperTb) {
                     upperTb.setAttribute("x-full-width", upperTb.clientWidth);
                 }
                 containerEl.xAddClass('compact-upper-bar'); // upper
             } else {
                 containerEl.xRemoveClass('compact-upper-bar');
                 upperTb && upperTb.removeAttribute("x-full-width");
             }
             if(infChart.manager.getChart(id).settings.toolbar.verticalDropDown && topTb) {
                 var allElements = topTb.querySelectorAll('[inf-ctrl="dropdown-menu-chart"]');

                 for (i = 0; i < allElements.length; i++) {
                     allElements[i].classList.remove('vertical-dropdown');
                 }
             }
         } else {
             containerEl.xRemoveClass('compact-toolbar');
             containerEl.xRemoveClass('compact-upper-bar');
             topTb && topTb.removeAttribute("x-full-width");

             if (chart?.settings.toolbar.verticalDropDown && topTb) {
                 var allElements = topTb.querySelectorAll('[inf-ctrl="dropdown-menu-chart"]');

                 for (i = 0; i < allElements.length; i++) {
                     allElements[i].xAddClass('vertical-dropdown');
                 }
             }
         }

         tradingTb = containerEl.querySelector('[inf-pnl="tb-trading"]');
         tradingTbFullWidth = tradingTb && +tradingTb.getAttribute("x-full-width");
         tradingTbCompactWidth = tradingTb && +tradingTb.getAttribute("x-compact-width");
         tradingTbHideWidth = tradingTb && +tradingTb.getAttribute("x-compact-more-width");
         var upperWidth = upperTbFullWidth || upperTb && upperTb.clientWidth;

         if (tradingTb && upperTb && ((tradingTbFullWidth && (tradingTbFullWidth + upperWidth > width)) || (!tradingTbFullWidth && (tradingTb.clientWidth + upperWidth) > width))) {
             if (!tradingTbFullWidth && tradingTb) {
                 tradingTb.setAttribute("x-full-width", tradingTb.clientWidth);
             }
             containerEl.xAddClass('show-hide-trade-buttons');
             tradingTb = containerEl.querySelector('[inf-pnl="tb-trading"]');
             if (tradingTbCompactWidth && (tradingTbCompactWidth + upperWidth > width) || (tradingTb.clientWidth + upperWidth) > width) {
                 if (!tradingTbCompactWidth) {
                     tradingTb.setAttribute("x-compact-width", tradingTb.clientWidth);
                 }
                 containerEl.xAddClass('compact-trade-buttons');
                 tradingTb = containerEl.querySelector('[inf-pnl="tb-trading"]');
                 if (isTopTbCompacted && tradingTbHideWidth && (tradingTbHideWidth + upperWidth > width) || (tradingTb.clientWidth + upperWidth) > width) {
                     if (!tradingTbHideWidth) {
                         tradingTb.setAttribute("x-compact-more-width", tradingTb.clientWidth);
                     }
                     containerEl.xAddClass('compact-more-trade-buttons');

                 } else {
                     containerEl.xRemoveClass('compact-more-trade-buttons');
                     tradingTb && tradingTb.removeAttribute("x-compact-more-width");
                 }

             } else {
                 containerEl.xRemoveClass('compact-trade-buttons');
                 containerEl.xRemoveClass('compact-more-trade-buttons');
                 tradingTb && tradingTb.removeAttribute("x-compact-width");
                 tradingTb && tradingTb.removeAttribute("x-compact-more-width");
             }
         } else {
             containerEl.xRemoveClass('show-hide-trade-buttons');
             containerEl.xRemoveClass('compact-trade-buttons');
             containerEl.xRemoveClass('compact-more-trade-buttons');
             tradingTb && tradingTb.removeAttribute("x-full-width");
             tradingTb && tradingTb.removeAttribute("x-compact-width");
             tradingTb && tradingTb.removeAttribute("x-compact-more-width");

         }

     };

     /**
      * Apply classes suits fot the new dimensions and change the axis dimensions according to the size
      * @param id
      * @param containerEl
      * @returns {{height, width}|{height: number, width: number}|*}
      * @private
      */
     var _rearrangeStructure = function (id, containerEl) {
         if (containerEl) {
             var width = containerEl && containerEl.clientWidth,
                 topTb = containerEl.querySelector('[inf-pnl="tb-top"]'),
                 leftTb = containerEl.querySelector('[inf-pnl="tb-left"]'),
                 upperTb = containerEl.querySelector('[inf-pnl="tb-upper"]');

             _rearrangeUpperLayerToolbar(id, containerEl);

             var chartWrapperDimensions = _getChartWrapperDimensions(id, containerEl),
                 wrapperWidth = chartWrapperDimensions.width,
                 wrapperHeight = chartWrapperDimensions.height;
             //wrapperHeight = wrapperHeight < 100 ? 100 : wrapperHeight;

             var chartWrapperEl = containerEl.querySelector('[inf-container="chartwrapper"]');

             if (chartWrapperEl) {
                 $(chartWrapperEl).width(wrapperWidth);

                 if (leftTb && infChart.drawingsManager) {
                     $(leftTb).height(wrapperHeight);
                     infChart.drawingsManager.rearrangeDrawingToolbar(leftTb);
                 }

                 // dropdown's max height
                 var topTbH = 0, dropDowns;
                 if (topTb) {
                     dropDowns = containerEl.querySelectorAll("[inf-pnl=tb-top] > ul > .dropdown");
                     if (dropDowns && dropDowns.length > 0) {
                         var i = 0, len = dropDowns.length;
                         for (i; i < len; i++) {
                             $(dropDowns[i].querySelector("ul.dropdown-menu")).css({"max-height": wrapperHeight});
                         }
                     }
                     // dropDowns && dropDowns.length && infChart.util.forEach(dropDowns, function (i, dropDown) {
                     // $(dropDown.querySelector("ul.dropdown-menu")).css({"max-height" : wrapperHeight});
                     // });
                     if (infChart.indicatorMgr) {
                         infChart.structureManager.indicator.rearrangeIndicatorDropDownStructure(topTb, wrapperHeight);
                     }
                     var top = containerEl.querySelector('[inf-container="top"]');
                     if (top && top.style.display != 'none') {
                         topTbH = $(top).outerHeight(true);
                     }
                 }

                 if (upperTb) {
                     dropDowns = containerEl.querySelectorAll("[inf-pnl=tb-upper] > ul > .dropdown");
                     if (dropDowns && dropDowns.length > 0) {
                         var i = 0, len = dropDowns.length;
                         for (i; i < len; i++) {
                             $(dropDowns[i].querySelector("ul.dropdown-menu")).css({"max-height": wrapperHeight + topTbH});
                         }
                     }
                     // dropDowns && dropDowns.length && infChart.util.forEach(dropDowns, function (i, dropDown) {
                     //     $(dropDown.querySelector("ul.dropdown-menu")).css({"max-height" : wrapperHeight + topTbH});
                     // });
                 }
             }

             //right panel is in the wrapper
             var right = containerEl.querySelector('[inf-pnl="tb-right"]'), rightWidth = 0;
             if (right && right.style.display != "none") {
                 if (width > 680) {
                     right.xRemoveClass('chart-rp-on-resize');
                     rightWidth = 240;//this is a hack
                 } else {
                     right.xAddClass('chart-rp-on-resize');
                 }
                 $(right).height(wrapperHeight);
             }

             var holderDimensions = _getChartHolderDimensions(id, containerEl, chartWrapperDimensions),
                 holderWidth = holderDimensions.width,
                 holderHeight = holderDimensions.height,
                 holderEl = containerEl.querySelector('[inf-container="chart_holder"]');

             if (holderEl) {
                 $(holderEl).width(holderWidth);
             }

             //legend height
             var hChartContainerDimensions = _getHighChartContainerDimensions(id, containerEl, holderDimensions),
                 chartWidth = hChartContainerDimensions.width,
                 chartHeight = hChartContainerDimensions.height,
                 legendWidth = hChartContainerDimensions.legendWidth,
                 legendHeight = hChartContainerDimensions.legendHeight,
                 legendEl = containerEl.querySelector('[inf-container="chart_top"]'),
                 $hChartContainerEl = $(containerEl.querySelector('[inf-container="chart"]'));

             $hChartContainerEl.width(chartWidth);
             $hChartContainerEl.height(chartHeight);

             if (legendEl && legendEl.style.display != "none") {
                 infChart.structureManager.legend.rearrangeLegendStructure($(legendEl), legendWidth, legendHeight);
             }

             return {'height': chartHeight, 'width': chartWidth, 'legendWidth': legendWidth};
         }

     };

     var _isResizeRequired = function (id, containerEl) {
         var chartWrapperDimensions = containerEl && _getChartWrapperDimensions(id, containerEl),
             chartWrapperEl = containerEl && containerEl.querySelector('[inf-container="chartwrapper"]'),
             resizeRequired = false;

         resizeRequired = chartWrapperEl && (chartWrapperEl.clientHeight != chartWrapperDimensions.height || chartWrapperEl.clientWidth != chartWrapperDimensions.width);

         if (!resizeRequired && containerEl) {
             var holderDimensions = _getChartHolderDimensions(id, containerEl, chartWrapperDimensions),
                 chartHolderEl = containerEl.querySelector('[inf-container="chart_holder"]');
             resizeRequired = chartHolderEl && (chartHolderEl.clientHeight != holderDimensions.height || chartHolderEl.clientWidth != holderDimensions.width);

             if (!resizeRequired) {
                 var hChartContainerDimensions = _getHighChartContainerDimensions(id, containerEl, holderDimensions),
                     hChartContainerEl = containerEl.querySelector('[inf-container="chart"]');
                 resizeRequired = hChartContainerEl && (hChartContainerEl.clientHeight != hChartContainerDimensions.height || hChartContainerEl.clientWidth != hChartContainerDimensions.width);

             }

         }

         return resizeRequired;
     };

     var _adjustFullWidth = function (el, width, isRemove) {
         var currentWidth = el && +el.getAttribute("x-full-width");
         if (currentWidth) {
             currentWidth = isRemove ? currentWidth - width : currentWidth + width;
             el.setAttribute("x-full-width", currentWidth);
         }
     };

     return {
         getStructure: _getStructure,
         rearrangeStructure: _rearrangeStructure,
         getContainer: _getContainer,
         isResizeRequired: _isResizeRequired,
         rearrangeUpperLayerToolbar: _rearrangeUpperLayerToolbar,
         adjustFullWidth: _adjustFullWidth,
         getHighChartContainerDimensions: _getHighChartContainerDimensions
     };

 })(jQuery, infChart);

 infChart.structureManager.common = (function () {

     /**
      * Returns the css class to display positive or negative price values
      * @param isPositive
      * @returns {string}
      * @private
      */
     var _getPriceChangeClass = function (isPositive) {
         return isPositive ? "positive-text-change" : "negative-text-change";
     };

     /**
      * get inf-ctrl html
      * @param {string} type
      * @returns {string}
      * @private
      */
     var _getCtrlTypeHtml = function (type) {
         return ' inf-ctrl="' + type + '"';
     };

     /**
      * get inf-ctrl-value html
      * @param {string} value
      * @returns {string}
      * @private
      */
     var _getCtrlValueHtml = function (value) {
         return ' inf-ctrl-value="' + value + '"';
     };

     /**
      * get control element
      * @param container
      * @param {string} controlType
      * @returns {*}
      * @private
      */
     var _getControlElement = function (container, controlType) {
         return container.find('[inf-ctrl="' + controlType + '"]');
     };

     /**
      * get value from element
      * @param element
      * @returns {string}
      * @private
      */
     var _getValueFromAttribute = function (element) {
         return $(element).attr('inf-ctrl-value');
     };

     /**
      * single option without status
      * used in zoom, reset, fullscreen
      * @param parent
      * @param {string} controlType
      * @param {function} fn
      * @private
      */
     var _setSingleOptionControlWithoutStatus = function (parent, controlType, fn) {
         var control = _getControlElement(parent, controlType);
         control.click(function (event) {
             fn(_getValueFromAttribute(this));
             event.preventDefault();
         });
     };

     var _setOptionControlsToChildWithoutStatus = function (parent, controlType, clickFn, blurFn, KeyUpFn) {
         var control = _getControlElement(parent, controlType);
         var child = _getControlElement(control, controlType);
         control.click(function (event) {
             clickFn(event, control);
             event.preventDefault();
         });
         child.blur(function (event) {
             blurFn(event, control);
             event.preventDefault();
         });
         child.keyup(function (event) {
             KeyUpFn(event, control);
             event.preventDefault();
         });
     };

     var _closeAllPopups = function (container) {
         var fileActionPopups = $('#' + container).find("[data-inf-file-pop-up]");
         if (fileActionPopups.length > 0) {
             $.each(fileActionPopups, function (k, popup) {
                 $(popup).hide();
             });
         }
     };

     /**
      * wrap and get the no data message
      * @param message
      * @returns {string}
      * @private
      */
     var _getNoDataMsg = function (message) {
        return '<div inf-container="noDataContainer" >' + message + '</div>';

    };

    /**
      * resize and set colour to noData container
      * @param containerEl
      * @param {string} backgroundColor
      * @private
      */
     var _resizeAndSetColour = function(containerEl, backgroundColor){
        var chartWrapper = containerEl.querySelector('[inf-container="chartwrapper"]');
        $(containerEl.querySelector('[inf-container="noDataContainer"]')).css({"background-color": backgroundColor, "height": chartWrapper.clientHeight, "width": chartWrapper.clientWidth});
     };

     return {
         closeAllPopups: _closeAllPopups,
         getPriceChangeClass: _getPriceChangeClass,
         getCtrlTypeHtml: _getCtrlTypeHtml,
         getCtrlValueHtml: _getCtrlValueHtml,
         setSingleOptionControlWithoutStatus: _setSingleOptionControlWithoutStatus,
         setOptionControlsToChildWithoutStatus: _setOptionControlsToChildWithoutStatus,
         resizeAndSetColour: _resizeAndSetColour,
         getNoDataMsg: _getNoDataMsg
     };

 })();

 infChart.structureManager.scalableAxis = (function ($) {

     var _getButtonHTML = function () {
        var xAxisResetToolTip = infChart.structureManager.toolbar.getToolTipAttributes(infChart.manager.getLabel("label.resetXAxis"), "left");
        var yAxisResetToolTip = infChart.structureManager.toolbar.getToolTipAttributes(infChart.manager.getLabel("label.resetYAxis"), "left");
        var html = '<div class="axis-reset-container" inf-container="axis-reset-container">';
         //html += '<i rel="xResetZoomBtn" class="ico-re-set-x-axis"></i>';
        html += '<div rel="xResetZoomBtn" class="axis-reset-icon"' + xAxisResetToolTip + '><img src="data:image/svg+xml;base64, PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMiwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB3aWR0aD0iMTIwMHB4IiBoZWlnaHQ9IjEyMDBweCIgdmlld0JveD0iMCAwIDEyMDAgMTIwMCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTIwMCAxMjAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxwYXRoIGQ9Ik0xMDU0LjUsNzMwLjdjLTM0LDE5Mi42LTIxNi4yLDMyMS44LTQwOC42LDI5MWwzMy4zLDEwMy4zTDQzNy41LDkxMC4zbDMwNi45LTEwMS45bC03NS43LDg4CgljMTIyLjksMTguMiwyMzguNi02NC43LDI2MC4zLTE4Ny44YzIyLjEtMTI1LjItNjEuNS0yNDQuNi0xODYuNy0yNjYuN2wyMi4xLTEyNS41Qzk1OSwzNTAuNywxMDg4LjgsNTM2LjIsMTA1NC41LDczMC43egoJIE02NTAuMSw3ODAuNUw0ODIuMiw0MjAuOUw2NDIuNiw3Ni41SDQ5MC4xbC05Ni41LDIyNC4yTDI5OCw3Ni41SDE0NS42bDE1OC42LDM0NC40bC0xNjcsMzU5LjVoMTUyLjVsMTA0LTI0MS4ybDEwMy41LDI0MS4ySDY1MC4xegoJIi8+Cjwvc3ZnPgo="></div>';
         //html += '<i rel="xResetZoomBtn" class="ico-re-set-y-axis"></i>';
        html += '<div rel="yResetZoomBtn" class="axis-reset-icon"' + yAxisResetToolTip + '><img src="data:image/svg+xml;base64, PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMiwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB3aWR0aD0iMTIwMHB4IiBoZWlnaHQ9IjEyMDBweCIgdmlld0JveD0iMCAwIDEyMDAgMTIwMCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTIwMCAxMjAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxwYXRoIGQ9Ik0xMDU0LjUsNzMwLjdjLTM0LDE5Mi42LTIxNi4yLDMyMS44LTQwOC42LDI5MWwzMy4zLDEwMy4zTDQzNy41LDkxMC4zbDMwNi45LTEwMS45bC03NS43LDg4CgljMTIyLjksMTguMiwyMzguNi02NC43LDI2MC4zLTE4Ny44YzIyLjEtMTI1LjItNjEuNS0yNDQuNi0xODYuNy0yNjYuN2wyMi4xLTEyNS41Qzk1OSwzNTAuNywxMDg4LjgsNTM2LjIsMTA1NC41LDczMC43egoJIE02NDkuMiw3Ni4zSDUwNi4ybC05MC41LDI3NC45Yy05LjMsMjYuNS0xNS42LDU0LjgtMTguOCw4NC44aC0yLjZjLTIuOS0zMi42LTguMy02MC45LTE2LjItODQuOEwyODYsNzYuM0gxNDBsMTk0LDQ4NS4xbC03LjksMjQKCWMtOS45LDI5LjEtMjMuNyw1MC45LTQxLjMsNjUuM2MtMTcuNiwxNC40LTM4LjIsMjEuNi02MS44LDIxLjZjLTE4LjksMC0zNi40LTEuOS01Mi40LTUuN3YxMDUuOGMyMi4xLDUsNDQuNyw3LjQsNjcuNyw3LjQKCWM0Ni45LDAsODcuOS0xMi43LDEyMy0zOGMzNS4xLTI1LjMsNjIuMS02My41LDgxLjEtMTE0LjVMNjQ5LjIsNzYuM3oiLz4KPC9zdmc+Cg=="></div>';
        html += '</div>';
        return html;
     };

     var _getButton = function (containerId, isXAxis) {
         return $('#' + containerId).find((isXAxis ? '[rel="xResetZoomBtn"]' : '[rel="yResetZoomBtn"]'));
     };

     var _bindButtons = function (containerId, xBtnClickFn, yBtnClickFn) {
         _getButton(containerId, true).bind('click', xBtnClickFn);
         _getButton(containerId, false).bind('click', yBtnClickFn);
     };

     var _setButtons = function (containerId, xBtnClickFn, yBtnClickFn) {
         $('#' + containerId).find('div[inf-container="chart_top"]').append(_getButtonHTML());
         _bindButtons(containerId, xBtnClickFn, yBtnClickFn);
     };

     var _updateButtonView = function (containerId, isXAxis, show) {
         var btn = _getButton(containerId, isXAxis), isChange = false;
         if (show) {
             if (btn) {
                 btn.show();
                 isChange = true && !_getButton(containerId, !isXAxis).is(':visible');
             }
         } else {
             if (btn) {
                 btn.hide();
                 isChange = true && !_getButton(containerId, !isXAxis).is(':visible');
             }
         }
         return isChange;
     };

     var _removeButtonHTML = function (containerId) {
         $('#' + containerId).find('div[inf-container="axis-reset-container"]').remove();
     };

     return {
         setButtons: _setButtons,
         updateButtonView: _updateButtonView,
         removeButtonHTML: _removeButtonHTML
     }
 })(jQuery);

 infChart.structureManager.legend = (function ($, infChart) {

     /**
      * Returns the basic structure of the legend
      * @returns {string}
      * @private
      */
     var _getLegendStructureHTML = function () {
         return '<div inf-legend class="chart-option-wrapper">' +
             '<div class="box-main-comparison-legends-wrapper">' +
             '<div legend-section inf-legend-base-symbol class="box-main legend-base-symbol"></div>' +
             '<div legend-section inf-legend-comp-symbol class="comparison-indicator-legends comparison-legends" style="display: none;"></div>' +
             '</div>' +
             '<div legend-section inf-legend-ind class="comparison-indicator-legends indicators-legends" style="display: none;"></div>' +
             '</div>';
     };

     /**
      * Returns the html of the legend of given comparison series
      * @param seriesId
      * @param title
      * @param color
      * @param {boolean} settingsEnabled
      * @param {boolean} refreshEnabled
      * @param {boolean} closeEnabled
      * @param {boolean} tooltipEnabled
      * @returns {string}
      * @private
      */
     var _getComparisonLegendItemHTML = function (seriesId, title, color, settingsEnabled, refreshEnabled, closeEnabled, tooltipEnabled) {
         var colorInName = tooltipEnabled ? '' : 'style="color:' + color + ';"';
         return '<div inf-legend-item inf-series="' + seriesId + '"  class="box legend-item-wrapper clearfix" inf-legend-color="' + color + '">' +
             '<div class="legend-items" inf-legend-items ' + colorInName + '>' +
                 //'<div class="item-color" inf-legend-color style="background-color:' + color + ';"></div>' +
             '<div class="item-name">' + title + '</div>' +
             '<div inf-tooltip-items-container class="tooltip-items-container" style="color:' + color + ';"></div>' +
             '</div>' +
             _getLegendButtonsPopupHTML(settingsEnabled, refreshEnabled, closeEnabled) +
             '</div>';

     };

     /**
      * Returns the html of the legend of base series
      * @param seriesId
      * @param title
      * @param color
      * @param {boolean} settingsEnabled
      * @param {boolean} refreshEnabled
      * @param {boolean} closeEnabled
      * @returns {string}
      * @private
      */
     var _getBaseSymbolLegendItemHTML = function (seriesId, title, color, settingsEnabled, refreshEnabled, closeEnabled) {
         return '<div inf-legend-base-symbol-basic-data class="legend-base-symbol-basic-data">' +
             '<div class="legend-item-wrapper" inf-legend-item inf-series="' + seriesId + '">' +
             '<div class="legend-items" inf-legend-items>' +
             '<div class="box symbol-content">' +
             '<div class="item-color" inf-legend-color style="background-color:' + color + ';"></div>' +
             '<div legend-sym-with-tt>' +
             '<h3 class="main-symbol-name" inf-legend-title >' + title + '</h3>' +
             '</div>' +
             '</div>' +
             '</div>' +
             _getLegendButtonsPopupHTML(settingsEnabled, refreshEnabled, closeEnabled) +
             '</div>' +
             '</div>' +
             '<div legend-bid-ask-history></div>';
     };

     /**
      * Returns the html of the legend of given indicator series
      * @param seriesId
      * @param title
      * @param color
      * @param {boolean} settingsEnabled
      * @param {boolean} refreshEnabled
      * @param {boolean} closeEnabled
      * @private
      */
     var _getIndicatorLegendItemHTML = function (seriesId, title, color, settingsEnabled, refreshEnabled, closeEnabled) {
         return '<div inf-legend-item inf-series="' + seriesId + '" class="box legend-item-wrapper clearfix">' +
             '<div class="legend-items">' +
             '<div class="item-color" style="background-color:' + color + ';"></div>' +
             '<div class="item-name">' + title + '</div>' +
             '</div>' +
             _getLegendButtonsPopupHTML(settingsEnabled, refreshEnabled, closeEnabled) +
             '</div>';
     };

     /**
      * Returns the html of settings button of the legend
      * @returns {string}
      * @private
      */
     var _getLegendSettingsButtonHTML = function () {
         return '<li class="btn-group" rel="settings"><a class="btn btn-default opg-settings"><i class="fa fa-wrench"></i></a></li>';
     };

     /**
      * Returns the html of close button of the legend
      * @returns {string}
      * @private
      */
     var _getLegendCloseButtonHTML = function () {
         return '<li class="btn-group" rel="close"><a class="btn btn-default opg-delete"><i class="fa fa-trash-o"></i></a></li>';
     };

     /**
      * Returns the html of refresh button of the legend
      * @returns {string}
      * @private
      */
     var _getLegendRefreshButtonHTML = function () {
         return '<li class="btn-group" rel="refresh"><a class="btn btn-default opg-refresh"><i class="fa fa-refresh"></i></a></li>';
     };

     /**
      * Returns the popup of buttons for the given series of the given chart
      * @param {boolean} settingsEnabled
      * @param {boolean} refreshEnabled
      * @param {boolean} closeEnabled
      * @returns {string}
      * @private
      */
     var _getLegendButtonsPopupHTML = function (settingsEnabled, refreshEnabled, closeEnabled) {
         var htmlStr = '<div class="popup-options option-btn-group-colors"><ul class="btn-group">';
         if (settingsEnabled) {
             htmlStr += _getLegendSettingsButtonHTML();
         }
         if (refreshEnabled) {
             htmlStr += _getLegendRefreshButtonHTML();
         }
         if (closeEnabled) {
             htmlStr += _getLegendCloseButtonHTML();
         }
         htmlStr += '</ul></div>';
         return htmlStr;
     };

     /**
      * Update the html of the legend of the base series
      * @param title
      * @param color
      * @param seriesType
      * @param legendItemEl
      * @private
      */
     var _updateBaseSymbolLegendItemHTML = function (legendItemEl, color, title, seriesType) {
         // show / hide legend color according to the series type
         switch (seriesType) {
             case 'candlestick':
             case 'ohlc':
             case 'hlc':
             case 'equivolume':
             case 'heikinashi':
             case 'pint':
             case 'engulfingCandles':
                 legendItemEl.find("[inf-legend-color]").hide();
                 break;
             default:
                 legendItemEl.find("[inf-legend-color]").css({"background-color": color + ""});
                 legendItemEl.find("[inf-legend-color]").show();
                 break;
         }
         var titleEl = legendItemEl.find("[inf-legend-title]")[0];
         titleEl.innerHTML = title;
     };

     /**
      * Update the html of the legend of given comparison series
      * @param color
      * @param legendItemEl
      * @private
      */
     var _updateComparisonLegendItemHTML = function (legendItemEl, color) {
         legendItemEl.find("[inf-legend-color]").css({"background-color": color + ""});
     };

     /**
      * Update the html of the legend of given indicator series
      * @param color
      * @param legendItemEl
      * @private
      */
     var _updateIndicatorLegendItemHTML = function (legendItemEl, color) {
         legendItemEl.find("[inf-legend-color]").css({"background-color": color + ""});
     };

     var _bindLegendEvents = function (legendParentEl, seriesId, settingsFn, refreshFn, closeFn, onSymbolTitleLegendClicked) {
         var legendItemEl = legendParentEl.find("[inf-legend-item][inf-series=" + seriesId + "]");
         if (typeof settingsFn === 'function') {
             legendItemEl.find('li[rel="settings"]').bind('click', settingsFn);
         }

         if (typeof refreshFn === 'function') {
             legendItemEl.find('li[rel="refresh"]').bind('click', refreshFn);
         }

         if (typeof closeFn === 'function') {
             legendItemEl.find('li[rel="close"]').bind('click', closeFn);
         }
         if (typeof onSymbolTitleLegendClicked === 'function') {
            legendItemEl.bind('click', onSymbolTitleLegendClicked);
         }
     };

     /**
      * Returns the box wrapper to add next compare symbol
      * Since compare symbols are shown in two-by-two array, two of each legends wrapped together inside a box wrapper
      * @param $legendComp
      * @returns {*}
      * @private
      */
     var _getCurrentCompBoxWrapper = function ($legendComp) {
         var lastBoxEl = $legendComp.find("[inf-comp-box]:last-child"),
             addBox, legendCompEl;

         if (lastBoxEl.length == 0) {
             addBox = true;
         } else {
             var itemCount = lastBoxEl.find("[inf-legend-item]").length;
             if (itemCount == 2) {
                 addBox = true;
             }
         }

         if (addBox) {
             legendCompEl = $legendComp[0];
             if (legendCompEl) {
                 legendCompEl.insertAdjacentHTML('beforeend', '<div class="box" inf-comp-box></div>');
                 lastBoxEl = legendCompEl.lastElementChild;
             }
         } else {
             lastBoxEl = lastBoxEl[0];
         }
         /* var boxEls = $legendComp.find("[inf-comp-box]"),
          addBox, legendCompEl, lastBoxEl;

          if (boxEls.length <= 1 ) {
          addBox = true;
          }

          if (addBox) {
          legendCompEl = $legendComp[0];
          if (legendCompEl) {
          legendCompEl.insertAdjacentHTML('beforeend', '<div class="tooltip-row-container" inf-comp-box></div>');
          lastBoxEl = legendCompEl.lastElementChild;
          }
          } else {
          var minCount = 0, minBox;
          for(var i=0, iLen = boxEls.length;  i< iLen; i++) {
          var itemCount = $(boxEls[i]).find("[inf-legend-item]").length;
          if (itemCount < minCount || !minBox ) {
          minBox = boxEls[i];
          minCount = itemCount;
          }
          }
          lastBoxEl = minBox;
          }

          //https://xinfiit.atlassian.net/browse/CCA-3660*/

         return lastBoxEl;
     };

     /**
      * set legend for series
      * @param containerId
      * @param seriesId
      * @param seriesInfType
      * @param title
      * @param color
      * @param seriesType
      * @param settingsFn
      * @param refreshFn
      * @param closeFn
      * @private
      */
     var _setLegendForSeries = function (containerId, seriesId, seriesInfType, title, color, seriesType, settingsFn, refreshFn, closeFn, tooltipEnabled, onSymbolTitleLegendClicked) {
         var legendEl = $("#" + containerId).find("[inf-legend]"), legendItemEl,
             settingsEnabled = typeof settingsFn === 'function',
             refreshEnabled = typeof refreshFn === 'function',
             closeEnabled = typeof closeFn === 'function';

         switch (seriesInfType) {
             case 'base':
                 var legendBaseEl = legendEl.find("[inf-legend-base-symbol]");
                 legendItemEl = legendBaseEl.find("[inf-legend-item][inf-series=" + seriesId + "]");
                 if (!legendItemEl || legendItemEl.length == 0) {
                     legendBaseEl[0].innerHTML = _getBaseSymbolLegendItemHTML(seriesId, title, color, settingsEnabled, refreshEnabled, closeEnabled);
                     _bindLegendEvents(legendBaseEl, seriesId, settingsFn, refreshFn, closeFn, onSymbolTitleLegendClicked);
                 } else {
                     _updateBaseSymbolLegendItemHTML(legendItemEl, color, title, seriesType);
                 }
                 break;
             case 'compare':
                 var legendComp = legendEl.find("[inf-legend-comp-symbol]");
                 legendItemEl = legendComp.find("[inf-legend-item][inf-series=" + seriesId + "]");
                 if (!legendItemEl || legendItemEl.length == 0) {
                     if (!legendComp.is(':visible')) {
                         legendComp.show();
                     }
                     var lastBoxEl = _getCurrentCompBoxWrapper(legendComp);
                     lastBoxEl.insertAdjacentHTML('beforeend', _getComparisonLegendItemHTML(seriesId, title, color, settingsEnabled, refreshEnabled, closeEnabled, tooltipEnabled));
                     _bindLegendEvents($(lastBoxEl), seriesId, settingsFn, refreshFn, closeFn);
                 } else {
                     _updateComparisonLegendItemHTML(legendItemEl, color);
                 }
                 break;
             case 'indicator':
                 var legendInd = legendEl.find("[inf-legend-ind]");
                 legendItemEl = legendInd.find("[inf-legend-item][inf-series=" + seriesId + "]");
                 if (!legendItemEl || legendItemEl.length == 0) {
                     if (!legendInd.is(':visible')) {
                         legendInd.show();
                     }
                     legendInd[0].insertAdjacentHTML('beforeend', _getIndicatorLegendItemHTML(seriesId, title, color, settingsEnabled, refreshEnabled, closeEnabled));
                     _bindLegendEvents(legendInd, seriesId, settingsFn, refreshFn, closeFn);
                 } else {
                     _updateIndicatorLegendItemHTML(legendItemEl, color);
                 }
                 break;
             default:
                 break;
         }
     };

     /**
      * Apply classes suits for the given chart dimensions to arrange the structure od the legend
      * @param element
      * @param chartWidth
      * @private
      */
     var _rearrangeLegendStructure = function (element, chartWidth) {
         var legendContainerEl = element.find("[inf-legend]");
         if (chartWidth > 1040) {
             legendContainerEl.removeClass('compact-legend');
         } else {
             legendContainerEl.addClass('compact-legend');
         }
     };

     /**
      * Reposition legend items to avoid spaces between boxes
      * @param containerId
      * @param currentBox
      * @private
      */
     var _repositionComparisonLegends = function (containerId, currentBox) {
         var boxes = document.querySelectorAll("#" + containerId + ' [inf-legend] [inf-legend-comp-symbol] div[inf-comp-box]');
         var i = 0, len = boxes.length, currentBoxFound = false;
         for (i; i < len; i++) {
             if (!currentBoxFound) {
                 currentBoxFound = boxes[i] === currentBox;
             }
             if (currentBoxFound) {
                 if (i + 1 < len) {
                     var node = boxes[i + 1].removeChild(boxes[i + 1].firstElementChild);
                     boxes[i].appendChild(node);
                 } else {
                     if (boxes[i].children.length === 0) {
                         boxes[i].parentNode.removeChild(boxes[i]);
                     }
                 }
             }
         }
     };

     /**
      * Removing legend of the given series id and reposition legends if required.
      * @param containerId
      * @param seriesId
      * @param infType
      * @private
      */
     var _removeLegendItem = function (containerId, seriesId, infType) {
         var legItem = $("#" + containerId).find("[inf-legend] [inf-legend-item][inf-series=" + seriesId + "]");

         if (legItem && legItem[0]) {//todo : unbind click events???
             var parent = legItem[0].parentNode;
             parent.removeChild(legItem[0]);
             if (infType == 'compare') {
                 if (parent.children.length > 0) {//if box is empty no need to reposition
                     if (parent.nextSibling != null && parent.nextSibling.children.length > 0) {
                         // since boxed of two items shown in the comparison legend it need to be reposition to avoid spaces between boxes.
                         _repositionComparisonLegends(containerId, parent);
                     }
                 } else {
                     parent.parentNode.removeChild(parent);
                 }
             }
         }
     };

     /**
      * clean legend content
      * @param containerId
      * @private
      */
     var _cleanLegendContainer = function (containerId) {
         $("#" + containerId).find("[inf-legend] [legend-section]").html('');
     };

     /**
      * Update tooltip data for symbols
      * @param legendContainer
      * @param baseHTML
      * @param compareSymHTML
      * @private
      */
     var _updateSymbolDataInLegend = function (legendContainer, baseHTML, compareSymHTML) {
         var legendEl = legendContainer.find("[inf-legend]"),
             baseEl = legendEl.find("[inf-legend-base-symbol]"),
             baseSymbolBasicDataEL = legendEl.find("[inf-legend-base-symbol-basic-data] [inf-legend-items]"),
             baseTime,
             baseTimeParent;

         baseEl.find("[inf-tooltip-items]").remove();

         // updating base symbol
         if (baseHTML && baseEl[0]) {
             var htmlArray = [],
                 baseElTTHTMLArr = [];
             for (var key in baseHTML) {
                 if (baseHTML.hasOwnProperty(key)) {
                     if (key === 'time') {
                         var symWithTimeEl = baseEl.find("[legend-sym-with-tt]");
                         if (symWithTimeEl && symWithTimeEl[0]) {
                             symWithTimeEl[0].xRemoveChild(symWithTimeEl.find("[legend-tt]")[0]);
                             symWithTimeEl[0].xAppend(baseHTML[key]);
                             symWithTimeEl[0].lastChild.setAttribute("legend-tt", "");
                             baseTime = symWithTimeEl[0].lastChild.innerHTML;
                             baseTimeParent = baseHTML[key];
                         }
                     } else if (key === 'bidAskHistory') {
                         var bidAskHistoryEl = baseEl.find("[legend-bid-ask-history]");
                         if (bidAskHistoryEl && bidAskHistoryEl[0]) {
                             bidAskHistoryEl.html(baseHTML[key]);
                         }
                     } else {
                         if (htmlArray.length === 2) {
                             baseElTTHTMLArr.xPush(['<div class="box" inf-tooltip-items>', htmlArray.join(''), '</div>'].join(''));
                             htmlArray = [baseHTML[key]];
                         } else {
                             htmlArray.xPush(baseHTML[key]);
                         }
                     }
                 }
             }

             if (htmlArray.length > 0) {
                 baseElTTHTMLArr.xPush(['<div class="box" inf-tooltip-items>', htmlArray.join(''), '</div>'].join(''));
             }

             baseSymbolBasicDataEL[0].xAppend(baseElTTHTMLArr.join(''));
         }

         // compare symbols

         var compEl = legendEl.find("[inf-legend-comp-symbol]");
         if (compEl.find("[inf-legend-item]").length > 0) {

             // update empty values first
             var legendItemContainers = compEl.find("[inf-tooltip-items-container]");

             for (var i = 0, iLen = legendItemContainers.length; i < iLen; i++) {

                 var contTemp = legendItemContainers[i],
                     $contTemp = $(contTemp),
                     ttItems = $contTemp.find("[inf-tooltip-items]");
                 if (ttItems.length) {

                     // updating compare symbols when having previous values
                     ttItems.find("[tt-val]").text('--');

                     if (baseTime) {
                         $contTemp.find("[inf-tooltip-items][legend-tt]").html(baseTime);
                     } else {
                         ttItems.find("[tt-date]").text('--');
                         ttItems.find("[tt-time]").text('--');
                     }
                 } else {

                     // compare symbols those have no previous data
                     contTemp.xAppend(infChart.structureManager.tooltip.getTooltipValueItemHtml("close", '--', undefined, true, false));
                     contTemp.lastChild.setAttribute("inf-tooltip-items", "");

                     contTemp.xAppend(infChart.structureManager.tooltip.getTooltipValueItemHtml("volume", '--', undefined, false, true));
                     contTemp.lastChild.setAttribute("inf-tooltip-items", "");

                     /*if(baseTimeParent) {
                      contTemp.xAppend(baseTimeParent);
                      contTemp.lastChild.setAttribute("inf-tooltip-items", "");
                      contTemp.lastChild.setAttribute("legend-tt", "");
                      }*/
                 }

             }

             if (compareSymHTML) {
                 for (var sym in compareSymHTML) {
                     if (compareSymHTML.hasOwnProperty(sym)) {
                         var compLegendContainer = compEl.find("[inf-series=" + sym + "] [inf-tooltip-items-container]");
                         compLegendContainer.find("[inf-tooltip-items]").remove();
                         for (var compKey in compareSymHTML[sym]) {
                             if (compareSymHTML[sym].hasOwnProperty(compKey) && compLegendContainer[0]) {
                                 compLegendContainer[0].xAppend(compareSymHTML[sym][compKey]);
                                 compLegendContainer[0].lastChild.setAttribute("inf-tooltip-items", "");
                                 if (compKey == "time") {
                                     compLegendContainer[0].lastChild.setAttribute("legend-tt", "");
                                 }
                             }
                         }
                     }
                 }
             }
         }
     };

     /**
      * Executes on mouse hover of the series and highlights the series in the legend
      * @param containerId
      * @param seriesId
      * @param infType
      * @param tooltipEnabled
      * @private
      */
     var _onSeriesMouseOver = function (containerId, seriesId, infType, tooltipEnabled) {

         if (infType == "compare") {
             var $container = $("#" + containerId),
                 $legend = $container.find("[inf-legend]"),
                 $legItems = $legend.find("[inf-legend-item]"),
                 $item = $legend.find("[inf-series=" + seriesId + "]"),
                 color = $item.attr("inf-legend-color"),
                 $ttItems = $item.find("[inf-legend-items]");
             //colorObject = infChart.util.rgbString2hex(color),
             //colorStr = colorObject.red ? "rgba("+colorObject.red+","+colorObject.green + "," + colorObject.blue + ",0.3)" :
             //colorObject.hex + "" + "4d";

             $legItems.removeClass("active");
             $item.addClass("active");
             $ttItems.css('color', color);

             // set the color of the series as background color with a low opacity
             //$item.find("[inf-legend-items]").css('background-color' , colorStr);

         }
     };

     /**
      * Executes when mouse is leaving from a series and de-highlights the legend of the series
      * @param containerId
      * @param seriesId
      * @param infType
      * @param tooltipEnabled
      * @private
      */
     var _onSeriesMouseOut = function (containerId, seriesId, infType, tooltipEnabled) {
         var $container = $("#" + containerId),
             $item = $container.find("[inf-legend] [inf-legend-item][inf-series=" + seriesId + "]"),
             $ttItems;

         if (infType == "compare") {

             $item.removeClass("active");
             if (tooltipEnabled) {
                 $ttItems = $item.find("[inf-legend-items]");
                 $ttItems.css({'color': ''});
             }
         }
     };

     /**
      * Clean tooltip data from the series
      * @param containerId
      * @param seriesId
      * @param infType
      * @private
      */
     var _cleanSeriesData = function (containerId, seriesId, infType) {
         var $legend = $("#" + containerId).find("[inf-legend]");
         if (infType == "base") {
             var baseEl = $legend.find("[inf-legend-base-symbol]");

             baseEl.find("[inf-tooltip-items]").remove();
             baseEl.find("[legend-tt]").remove();
         } else {
             //other symbols goes here
             if (infType == "compare") {
                 var $item = $legend.find("[inf-series=" + seriesId + "]");
                 $item.find("[inf-tooltip-items]").remove();
             }
         }
     };

     var _setCompareSymbolColor = function (containerId, tooltipEnabled) {
         var $legendComp = $("#" + containerId).find("[inf-legend-comp-symbol]"),
             $legendItems = $legendComp.find("[inf-legend-item]"),
             $compItem, i, iLen;

         if (tooltipEnabled) {
             for (i = 0, iLen = $legendItems.length; i < iLen; i++) {
                 $compItem = $($legendItems[i]);
                 $compItem.find("[inf-legend-items]").css('color', '');
                 $compItem.find("[inf-tooltip-items-container]").css('color', $compItem.attr("inf-legend-color"));
             }
         } else {
             for (i = 0, iLen = $legendItems.length; i < iLen; i++) {
                 $compItem = $($legendItems[i]);
                 $compItem.find("[inf-legend-items]").css('color', $compItem.attr("inf-legend-color"));
             }
         }

     };

     /**
      * Show/hide data in the legend when toggling the tooltip
      * @param containerId
      * @param enabled
      * @private
      */
     var _toggleLegendTooltip = function (containerId, enabled) {
         if (enabled) {
             $("#" + containerId).find("[inf-legend]").removeClass("hide-tooltip");
         } else {
             $("#" + containerId).find("[inf-legend]").addClass("hide-tooltip");
         }
         _setCompareSymbolColor(containerId, enabled);
     };

     return {
         getStructureHTML: _getLegendStructureHTML,
         setLegendForSeries: _setLegendForSeries,
         rearrangeLegendStructure: _rearrangeLegendStructure,
         // repositionComparisonLegends: _repositionComparisonLegends,
         removeLegendItem: _removeLegendItem,
         updateSymbolDataInLegend: _updateSymbolDataInLegend,
         cleanLegendContainer: _cleanLegendContainer,
         onSeriesMouseOver: _onSeriesMouseOver,
         onSeriesMouseOut: _onSeriesMouseOut,
         toggleTooltip: _toggleLegendTooltip,
         cleanSeriesData: _cleanSeriesData
     };
 })(jQuery, infChart);

 infChart.structureManager.tooltip = (function ($) {

     /**
      * Returns the html string of the key value pair
      * @param key
      * @param value
      * @param isPositive
      * @param hideLabel to hide the price label
      * @param showParentheses to cover value by parentheses
      * @returns {string}
      * @private
      */
     var _getTooltipValueItemHtml = function (key, value, isPositive, hideLabel, showParentheses) {
         if (key === 'time') {
             var v = value.split(' ');
             return '<div class="value">' +
                 '<span class="lbl-time">' +
                 '<span tt-date class="date">' + v[0] + '</span>&nbsp;' +
                 '<span tt-time >' + (v[1] || '') + '</span>' +
                 '</span>' +
                 '</div>';
         } else if (key === 'bidAskHistory') {
             return value ? '<div class="bid-last-L-ask-last-H">' +
             '<div class="bid-last-L-ask-last-H-item-wrapper bid-last-L"><span class="box"></span><p>Bid</p>' +
             '<p class="value"> <span>Last</span><span>' + value.bidLast + '</span> <span>L</span><span>' + value.bidLow + '</span></p>' +
             '</div>' +
             '<div class="bid-last-L-ask-last-H-item-wrapper ask-last-H"><span class="box"></span><p>Ask</p>' +
             '<p class="value"> <span>Last</span><span>' + value.askLast + '</span> <span>H</span><span>' + value.askHigh + '</span> </p>' +
             '</div> </div>' : '';

         } else {
             var valueToShow =
                 (!hideLabel ? '<span class="lbl">' + infChart.manager.getLabel('label.tooltip.' + key) + '</span>' : '') +
                 '<span tt-val class="' + (showParentheses ? '' : ' val ') + (typeof isPositive === 'undefined' ? '' : infChart.structureManager.common.getPriceChangeClass(isPositive)) + '">' + (value != null ? value : '--') + '</span>';
             return '<div class="value">' + (showParentheses ? "(" + valueToShow + ")" : valueToShow) + '</div>';
         }
     };

     var _getIndicatorTooltipHtml = function (valueHtmlItems) {
         var html = '';
         if (typeof valueHtmlItems !== 'undefined') {
             html = '<span class="tooltip1"><span class="tooltip1_table">';
             for (var key in valueHtmlItems) {
                 if (valueHtmlItems.hasOwnProperty(key)) {
                     html += valueHtmlItems[key];
                 }
             }
             html += '</span></span>';
         }
         return html;
     };

     var _getIndicatorTooltipValueItemHtml = function (key, value, color) {
         if (key === 'time') {
             return '<span class="tooltip1_tr">' +
                 '<span class="tooltip1_td">&nbsp;</span>' +
                 '<span class="tooltip1_td">&nbsp;</span>' +
                 '<span class="tooltip1_td">' + value + '</span>' +
                 '</span>';
         } else {
             return '<span class="tooltip1_tr">' +
                 '<span class="tooltip1_td" style="background-color:' + color + '" >&nbsp;</span>' +
                 '<span class="tooltip1_td">' + key + '</span>' +
                 '<span class="tooltip1_td" style="text-align: right">' + value + '</span>' +
                 '</span>'
         }
     };

     var _getNewsTooltipValueItemHtml = function (headline) {
         return '<span class="tooltip1_tr news"><span class="tooltip1_td title">' + headline + '</span></span>';
     };

     var _getFlagsTooltipValueItemHtml = function (flag, color) {
         return '<span class="tooltip1_tr flags">' +
             '<span class="tooltip1_td" style="background-color:' + color + '" >&nbsp;</span>' +
             '<span class="tooltip1_td ">' + flag + '</span>' +
             '</span>';
     };

     /**
      * Doing structural changes when toggling the tooltip
      * @param containerId
      * @param enabled
      * @private
      */
     var _toggleToolTip = function (containerId, enabled) {
         infChart.structureManager.legend.toggleTooltip(containerId, enabled);
     };

     return {
         getTooltipValueItemHtml: _getTooltipValueItemHtml,
         getIndicatorTooltipValueItemHtml: _getIndicatorTooltipValueItemHtml,
         getNewsTooltipValueItemHtml: _getNewsTooltipValueItemHtml,
         getFlagsTooltipValueItemHtml: _getFlagsTooltipValueItemHtml,
         getIndicatorTooltipHtml: _getIndicatorTooltipHtml,
         toggleTooltip: _toggleToolTip
     }
 })(jQuery);

 infChart.structureManager.settings = (function ($, infChart) {

     /**
      * @typedef {object} rowItem
      * @property {string} [id] - unique id
      * @property {string} body - html content
      * @property {string} [title] - optional
      * @property {boolean} [isLabel=true] - is the title a label
      */

     /**
      * @typedef {object} sectionRow
      * @property {Array<rowItem>} items - section rows
      * @property {string} [cssClass] - optional
      */

     /**
      * @typedef {object} section
      * @property {Array<sectionRow>} rows - section rows
      * @property {string} [title] - optional
      */

     /**
      * get row item object
      * @param {string} [id]
      * @param {string} body
      * @param {string} title
      * @param {boolean} [isLabel]
      * @returns {rowItem}
      * @private
      */
     var _getRowItem = function (body, title, isLabel, id, cssClass) {
        return {
            'id': id,
            'title': title,
            'body': body,
            'isLabel': typeof isLabel === 'undefined' ? true : isLabel,
            'cssClass' : cssClass
        };
    };

     /**
      * get section object
      * @param {Array<rowItem>} items
      * @param {string} [cssClass]
      * @returns {sectionRow}
      * @private
      */
     var _getSectionRow = function (items, cssClass) {
         return {
             'items': items,
             'cssClass': cssClass
         };
     };

     /**
      * get section object
      * @param {Array<sectionRow>} items
      * @param {string} [title]
      * @returns {section}
      * @private
      */
     var _getSection = function (items, title) {
         return {
             'title': title,
             'rows': items
         };
     };

     //region control html

     /**
      * get mini color palette html
      * @param {string} ctrlType - tag used to identify the control
      * @param {string} ctrlValue - fib level id - P_all for all control
      * @param {string} color - hex color
      * @param {string} position - position of the palette
      * @param {number} opacity - color opacity
      * @param {string} iconClass - icon uesed in fib color palete
      * @returns {string} mini color html
      */
    var _getMiniColorPaletteHTML = function (ctrlType, ctrlValue, color, position, opacity, iconClass, mainClass, subType) {
        var opacityValue = parseFloat(opacity);
        return '<div class="change-color ' + (mainClass ? mainClass : '') + '">' +
            '<input type="hidden" inf-ctrl="' + ctrlType + '"sub-type="' + (subType ? subType : '') + '" inf-ctrl-val="' + ctrlValue + '" value="' + color + '"' +
            (typeof position === 'undefined' ? ' data-position="bottom-left"' : ' data-position="' + position + '"') +
            ((isNaN(opacityValue)) ? ' opacity="false"' : ' data-opacity="' + opacityValue + '"') + '>' +
            (iconClass ? '<div class="color-inner-box"><span class="'+ iconClass +'"></span></div>' : '') +
            '</div>';
     }

     /**
      * common class to get color pallet html
      * @param {string} ctrlType - tag used to identify the control
      * @param {string} ctrlValue - fib level id - P_all for all control
      * @param {string} color - hex color
      * @param {number} opacity - color opacity
      * @param {string} position - position of the palette
      * @returns {string} color palette html
      */
     var _getColorPaletteHTML = function (ctrlType, ctrlValue, color, opacity, position) {
         return '<div class="color-palette">' +
             '<div class="single-color-box">' +
             _getMiniColorPaletteHTML(ctrlType, ctrlValue, color, position, opacity) +
             '</div>' +
             '</div>';
     };

     /**
      * get line weight html - common method used as buttons and dropdown
      * @param {string} typeClass - class used for buttons and dropdown - default as buttons
      * @param {string} ctrlType - tag used to identify the control - default no type, used in fibs
      * @returns {string} get list elements html
      */
     var _getLineWeightHTML = function (typeClass, ctrlType) {
         return '<ul class="' + (typeClass ? typeClass : 'selection-types') + '"' + (ctrlType ? 'inf-ctrl="' + ctrlType + '"' : '') + '>' +
             '<li inf-ctrl="lineWidth" inf-size="1"><a><span class="line-weight-space">&#x2F;</span></a></li>' +
             '<li inf-ctrl="lineWidth" inf-size="2"><a><span class="line-weight-space">&#x2F;&#x2F;</span></a></li>' +
             '<li inf-ctrl="lineWidth" inf-size="3"><a><span class="line-weight-space">&#x2F;&#x2F;&#x2F;</span></a></li>' +
             '</ul>';
     };

     var _getGridLineWeightHTML = function (typeClass, ctrlType) {
        return '<ul class="' + (typeClass ? typeClass : 'selection-types') + '"' + (ctrlType ? 'inf-ctrl="' + ctrlType + '"' : '') + '>' +
            '<li inf-ctrl="gridLineWidth" inf-size="1"><a><span class="line-weight-space">&#x2F;</span></a></li>' +
            '<li inf-ctrl="gridLineWidth" inf-size="2"><a><span class="line-weight-space">&#x2F;&#x2F;</span></a></li>' +
            '<li inf-ctrl="gridLineWidth" inf-size="3"><a><span class="line-weight-space">&#x2F;&#x2F;&#x2F;</span></a></li>' +
            '<li inf-ctrl="gridLineWidth" inf-size="4"><a><span class="line-weight-space">&#x2F;&#x2F;&#x2F;&#x2F;</span></a></li>' +
            '</ul>';
    };

    var _getChartBackgroundOptionHTML = function () {
        return '<p class="item-label"><input id="solid" checked="checked" name="bgOptions" inf-ctrl="backgroundType" type="radio" inf-type="solid">Solid</p>' +
               '<p class="item-label"><input id="gradient" name="bgOptions" inf-ctrl="backgroundType" type="radio" inf-type="gradient">Gradient</p>';
    };

     var _getLineStyleHTML = function (typeClass, ctrlType) {
         return '<ul class="' + (typeClass ? typeClass : 'selection-types') + '"' + (ctrlType ? 'inf-ctrl="' + ctrlType + '"' : '') + '>' +
             '<li inf-ctrl="lineStyle" inf-style="solid"><a><i class="icon ico-minus-1"></i></a></li>' +
             '<li inf-ctrl="lineStyle" inf-style="dash"><a><i class="icon ico-ellipsis-2"></i></a></li>' +
             '</ul>';
     };

     var _getFontWeightHTML = function () {
         return '<ul class="selection-types">' +
             '<li inf-ctrl="fontStyle" inf-style="bold"><a><i class="icon ico-bold-2"></i></a></li>' +
             '<li inf-ctrl="fontStyle" inf-style="italic"><a><i class="icon ico-italic-2"></i></a></li>' +
             '<li inf-ctrl="fontStyle" inf-style="underline"><a><i class="icon ico-underline-1"></i></a></li>' +
             '</ul>';
     };

     var _getAlighStyleHTML = function (subType) {
        return '<ul class="selection-types" ' + (subType ? 'inf-ctrl="' + subType + '"' : '') + '>' +
            '<li inf-ctrl="alignStyle" inf-style="bottomLeft"><a><i class="icom icom-align-bottom-left"></i></a></li>' +
            '<li inf-ctrl="alignStyle" inf-style="topLeft"><a><i class="icom icom-align-top-left"></i></a></li>' +
            '<li inf-ctrl="alignStyle" inf-style="bottomCenter"><a><i class="icom icom-align-bottom-center"></i></a></li>' +
            '<li inf-ctrl="alignStyle" inf-style="topCenter"><a><i class="icom icom-align-top-center"></i></a></li>' +
            '<li inf-ctrl="alignStyle" inf-style="bottomRight"><a><i class="icom icom-align-bottom-right"></i></a></li>' +
            '<li inf-ctrl="alignStyle" inf-style="topRight"><a><i class="icom icom-align-top-right"></i></a></li>' +
            '</ul>';
     }

    var _getFontSizeHTML = function (fontSize) {
        var ctrlType = "single";
        return '<div class="dropdown font-size">' +
                '<button class="dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">' +
                    '<span inf-ctrl="' + ctrlType + 'SelectedFontSize" inf-ctrl-val="P_all" inf-size="' + fontSize + '">' + fontSize + '</span>' +
                    '<span class="caret"></span>' +
                '</button>' +
                _getLabelFontSizeListHTML('dropdown-menu', ctrlType) +
            '</div>';
    };

    var _getWaveDegreeHTML = function (waveDegree, waveDegreesList) {
        var ctrlType = "single";
        var waveDegreeSelected;
        infChart.util.forEach(waveDegreesList, function(index , value){
            if(value.name == waveDegree){
                waveDegreeSelected = value;
            }
        });
        return '<div class="w--100 opened-list">' +
                _getWaveDegreeListHTML('dropdown-menu', ctrlType, waveDegreesList, waveDegree) +
            '</div>';
    };

     //This method returns wave degree from all levels
     var _getWaveDegreeListHTML = function (typeClass, ctrlType, waveDegreesList, waveDegree) {
         var list = "";
         infChart.util.forEach(waveDegreesList, function(index , value){
            var item = '<li class="' + ( value.name == waveDegree ? 'active' : '' ) + '"inf-ctrl="waveDegree" inf-type=' + value.name + '><a><span>' + infChart.manager.getLabel(value.label) + '</span></a></li>';
            list = list + item;
        });

         return '<ul class="w--100"' + (ctrlType ? 'inf-ctrl="' + ctrlType + '"' : '') + '>' +
             list + '</ul>';
     };

    //This method returns font size list items from 7 to 40
    var _getLabelFontSizeListHTML = function (typeClass, ctrlType) {
        var list = "";
        for (var i = 7; i <= 40; i++){
            var item = '<li inf-ctrl="fontSize" inf-size=' + i +'><a><span class="line-weight-space">' + i + '</span></a></li>';
            list = list + item;
        }
        return '<ul class="' + (typeClass ? typeClass : 'selection-types') + '"' + (ctrlType ? 'inf-ctrl="' + ctrlType + '"' : '') + '>' +
            list + '</ul>';
    };

     //endregion

     //region row items

     /**
      * line weight
      * @returns {{title, body, isLabel}|rowItem}
      * @private
      */
     var _getLineWeightRowItem = function (typeClass, ctrlType) {
         return _getRowItem(_getLineWeightHTML(typeClass, ctrlType), 'label.lineWeight');
     };

     var _getGridLineWeightRowItem = function (typeClass, ctrlType) {
        return _getRowItem(_getGridLineWeightHTML(typeClass, ctrlType), 'label.gridLineWeight');
    };

    var _getChartBackgroundOptionRowItem = function () {
        return _getRowItem(_getChartBackgroundOptionHTML(), 'label.backgroundType');
    };

     /**
      * line style
      * @returns {{title, body, isLabel}|rowItem}
      * @private
      */
     var _getLineStyleRowItem = function () {
         return _getRowItem(_getLineStyleHTML(), 'label.lineStyle');
     };

     /**
      * font weight
      * @returns {{title, body, isLabel}|rowItem}
      * @private
      */
     var _getFontWeightRowItem = function () {
         return _getRowItem(_getFontWeightHTML(), 'label.fontStyle');
     };

    /**
     * font weight
     * @returns {{title, body, isLabel}|rowItem}
     * @private
     */
    var _getTextAlignRowItem = function (subType) {
        return _getRowItem(_getAlighStyleHTML(subType), 'label.textAlign');
    };

     /**
      * font size
      * @returns {{title, body, isLabel}|rowItem}
      * @private
      */
     var _getFontSizeRowItem = function (fontSize) {
         return _getRowItem(_getFontSizeHTML(fontSize), 'label.fontSize');
     };


     /**
      * wave degree
      * @returns {{title, body, isLabel}|rowItem}
      * @private
      */
      var _getWaveDegreeRowItem = function (waveDegree, waveDegreesList) {
        return _getRowItem(_getWaveDegreeHTML(waveDegree, waveDegreesList), 'label.waveDegree');
    };

     /**
      * color picker
      * @param title
      * @param ctrlType
      * @param color
      * @param [position]
      * @param [opacity]
      * @param [ctrlValue]
      * @param [isLabel]
      * @returns {{title, body, isLabel}|rowItem}
      * @private
      */
     var _getColorPickerRowItem = function (ctrlType, color, opacity, ctrlValue, position, title, isLabel) {
         return _getRowItem(_getColorPaletteHTML(ctrlType, ctrlValue, color, opacity, position), title, isLabel);
     };

     /**
      * create the color picker control with given body and other specifications
      * @param uniqueId
      * @param upColorPick
      * @param downColorPick
      * @param body
      * @returns {string} colorpicker html
      * @private
      */
     var _getColorPickerCtrlHTML = function (uniqueId, upColorPick, downColorPick, body) {
         var pickref = "color-ref-" + uniqueId,
             colorPickRel = !( upColorPick || upColorPick) ? 'inf-col-pick="colorPicker"' : '';

         if (upColorPick) {
             colorPickRel += 'inf-col-pick-up="' + upColorPick + '"';
         }
         if (downColorPick) {
             colorPickRel += 'inf-col-pick-down="' + downColorPick + '"';
         }

         return '<div inf-col-pick-container ' + colorPickRel + ' rel="' + uniqueId + '" inf-ref="' + pickref + '" class="tab-pane fade" >' + body + '</div>'
     };

     var _getChartSettingsPanel = function(chart) {

        var backgroundType = chart.chart.options.chart.backgroundColor && typeof chart.chart.options.chart.backgroundColor !== 'string' ? "gradient" : "solid";
        var chartSettingHTML = '<div inf-container="chart-setting-panel" class="chart-settings">';
        var gridSettingHTML = '<div inf-ref="grid-settings">';
        if(chart){
            var xgridColorSettingsHTML = _getSubBodySectionHTML(_getSection([_getSectionRow([
                _getColorPickerRowItem('colorPickerXGridLine', chart.chart.options.xAxis[0].gridLineColor, Highcharts.theme.xAxis.gridLineOpacity, 'xgridLine', 'top left', 'label.xGridLineColor')
            ], 'two-col-row')]));

            var ygridColorSettingsHTML = _getSubBodySectionHTML(_getSection([_getSectionRow([
                _getColorPickerRowItem('colorPickerYGridLine', chart.chart.options.yAxis[0].gridLineColor, Highcharts.theme.yAxis.gridLineOpacity, 'ygridLine', 'top left', 'label.yGridLineColor')
            ], 'two-col-row')]));

            var gridLineWeightSettingsHTML = _getSubBodySectionHTML(_getSection([
                _getSectionRow([_getGridLineWeightRowItem()])
            ]));

            var bgOptionHTML = _getSubBodySectionHTML(_getSection([
                _getSectionRow([_getChartBackgroundOptionRowItem()])
            ]));

            var backgroundColorHTML = _getSubBodySectionHTML(_getSection([
                _getSectionRow([_getColorPickerRowItem('colorPickerBackground', chart.chart.options.chart.backgroundColor, Highcharts.theme.chart.backgroundColorOpacity, 'background', 'top left', 'label.chartBackgroundColor')], 'two-col-row')
            ]));

            var gradientColorHTML = _getSubBodySectionHTML(_getSection([
                _getSectionRow([_getColorPickerRowItem('colorPickerGradientTop', backgroundType == "gradient" ? chart.chart.options.chart.backgroundColor.stops[0][1] : "transparent", Highcharts.theme.chart.backgroundColorOpacity, 'gradientTop', 'top left', 'label.chartBgGradientTopColor'),
                _getColorPickerRowItem('colorPickerGradientBottom', backgroundType == "gradient" ? chart.chart.options.chart.backgroundColor.stops[1][1] : "transparent", Highcharts.theme.chart.backgroundColorOpacity, 'gradientBottom', 'top right', 'label.chartBgGradientBottomColor')], 'two-col-row')
            ]));

            gridSettingHTML += gridLineWeightSettingsHTML;
            gridSettingHTML += _getColorPickerCtrlHTML(chart.chartId, false, false, xgridColorSettingsHTML);
            gridSettingHTML += _getColorPickerCtrlHTML(chart.chartId, false, false, ygridColorSettingsHTML);
            gridSettingHTML += '</div>';

            chartSettingHTML +=  gridSettingHTML;
            chartSettingHTML +=  bgOptionHTML;
            chartSettingHTML += _getColorPickerCtrlHTML(chart.chartId, false, false, backgroundColorHTML);
            chartSettingHTML += _getColorPickerCtrlHTML(chart.chartId, false, false, gradientColorHTML);

        }

        chartSettingHTML += '</div>';
        return _getRowItem(chartSettingHTML, '', true, chart.chartId);

     }

     var _getSeriesContentRowItem = function (seriesId, chartTypes) {

         var chartTypeTabHeaderHTML = '<ul class="selection-types chart-type">', chartTypeTabContentHTML = '<div class="tab-content">';

         infChart.util.forEach(chartTypes, function (i, chartTypeConfig) {
             chartTypeTabHeaderHTML += _getChartTypeOptionHTML(chartTypeConfig.type, seriesId, chartTypeConfig.icon);
             var id = _getIdWithChartTypeAndSeries(chartTypeConfig.type, seriesId), pickref = "color-ref-" + id, html;
             if (chartTypeConfig.colors.color) {
                 if (chartTypeConfig.type === 'line') {
                     html = _getSubBodySectionHTML(_getSection([
                         _getSectionRow([_getLineWeightRowItem()]),
                         _getSectionRow([_getColorPickerRowItem('colorPicker', chartTypeConfig.colors.color, chartTypeConfig.colors.opacity, 'color', 'top left', 'label.lineColor')], 'two-col-row')
                     ]));
                     chartTypeTabContentHTML += _getColorPickerCtrlHTML(id, false, false, html);
                 } else {
                     html = _getSubBodySectionHTML(_getSection([
                         _getSectionRow([_getColorPickerRowItem('colorPicker', chartTypeConfig.colors.color, chartTypeConfig.colors.opacity, 'color', 'top left', 'label.color')], 'two-col-row')
                     ]));
                     chartTypeTabContentHTML += _getColorPickerCtrlHTML(id, false, false, html);
                 }
             } else {
                 if (chartTypeConfig.colors.colUp) {
                     html = _getSubBodySectionHTML(_getSection([_getSectionRow([
                         _getColorPickerRowItem('colorPickerColUp', chartTypeConfig.colors.colUp, chartTypeConfig.colors.opacity, 'up', 'top left', 'label.up'),
                         _getColorPickerRowItem('colorPickerColDown', chartTypeConfig.colors.colDown, chartTypeConfig.colors.opacity, 'down', 'top right', 'label.down')
                     ], 'two-col-row')]));
                     chartTypeTabContentHTML += _getColorPickerCtrlHTML(id, 'colorPickerColUp', 'colorPickerColDown', html);
                 } else {
                     html = _getSubBodySectionHTML(_getSection([_getSectionRow([
                         _getColorPickerRowItem('colorPickerUp', chartTypeConfig.colors.up, chartTypeConfig.colors.opacity, 'up', 'top left', 'label.up'),
                         _getColorPickerRowItem('colorPickerDown', chartTypeConfig.colors.down, chartTypeConfig.colors.opacity, 'down', 'top right', 'label.down')
                     ], 'two-col-row')]));
                     chartTypeTabContentHTML += _getColorPickerCtrlHTML(id, 'colorPickerUp', 'colorPickerDown', html);
                 }
             }
         });

         chartTypeTabHeaderHTML += '</ul>';
         chartTypeTabContentHTML += '</div>';

         return _getRowItem(chartTypeTabHeaderHTML + chartTypeTabContentHTML, 'label.chartType', true, seriesId);
     };

     //endregion

     //region panel html

     var _getPanelHTML = function (parentPanelId, panelId, title, content, disableClose) {
         return '<div class="panel panel-default" rel="panel_' + panelId + '">' +
             '<div class="panel-heading">' +
             '<h4 class="panel-title">' +
             '<a class="collapsed" role="button" data-toggle="collapse" data-parent="div[rel=' + parentPanelId + ']" data-target="div[rel=' + panelId + ']" aria-expanded="false" aria-controls="' + panelId + '">' +
             '<span rel="panelTitle" class="title-contents">' + title + '</span>' +
             '<span class="panel-item-controllers">' + (!disableClose ? '<i class="fa fa-trash remove" rel="close"></i>' : '') + '<i class="fa fa-caret-down" aria-hidden="true"></i></span>' +
             '</a>' +
             '</h4>' +
             '</div>' +
             '<div rel="' + panelId + '" class="panel-collapse collapse">' +
             '<div class="panel-body panel-body-content">' + content + '</div>' +
             '</div>' +
             '</div>';
     };

     var _getPanelBodyHTML = function (sectionArray) {
         var html = '';
         infChart.util.forEach(sectionArray, function (i, section) {
             html += _getBodySectionHTML(section);
         });
         return html;
     };

     var _getSectionBodyHTML = function(columnArray){
        var html = '<div class="body-section-outer">';
        infChart.util.forEach(columnArray, function (i, column) {
            html += _getBodySectionHTML(column);
        });
        html += '</div>';
        return html;
     };

     var _getBodySectionHTML = function (section) {
         var html = '<div class="body-section">', isContentAvailable = false;
         if (section.title) {
             html += '<p class="section-heading" data-localize="' + section.title + '">' + infChart.manager.getLabel(section.title) + '</p>';
         }
         infChart.util.forEach(section.rows, function (i, sectionRow) {
             html += '<div class="section-row' + (sectionRow.cssClass ? ' ' + sectionRow.cssClass : '') + '">';
             infChart.util.forEach(sectionRow.items, function (ii, rowItem) {
                 if (!isContentAvailable) {
                     isContentAvailable = true;
                 }
                 html += '<div class="row-item"' + (rowItem.id ? ' inf-row-item-rel="' + rowItem.id + '"' : '') + '>';
                 if (rowItem.title) {
                     if (rowItem.isLabel) {
                         html += '<p class="item-label" data-localize="' + rowItem.title + '">' + infChart.manager.getLabel(rowItem.title) + '</p>';
                     } else {
                         html += '<p class="item-label">' + rowItem.title + '</p>';
                     }
                 }
                 html += '<div class="item-body' + (rowItem.cssClass ? ' ' + rowItem.cssClass : '') + '  ">' + rowItem.body + '</div>';
                 html += '</div>';
             });
             html += '</div>';
         });
         html += '</div>';
         return isContentAvailable ? html : '';
     };

     var _getSubBodySectionHTML = function (section) {
         var html = '<div class="sub-body-section">';
         if (section.title) {
             html += '<p class="section-heading" data-localize="' + section.title + '">' + infChart.manager.getLabel(section.title) + '</p>';
         }
         infChart.util.forEach(section.rows, function (i, sectionRow) {
             html += '<div class="sub-section-row' + (sectionRow.cssClass ? ' ' + sectionRow.cssClass : '') + '">';
             infChart.util.forEach(sectionRow.items, function (ii, rowItem) {
                 html += '<div class="sub-item-row">';
                 if (rowItem.title) {
                     if (rowItem.isLabel) {
                         html += '<p class="sub-item-label" data-localize="' + rowItem.title + '">' + infChart.manager.getLabel(rowItem.title) + '</p>';
                     } else {
                         html += '<p class="sub-item-label">' + rowItem.title + '</p>';
                     }
                 }
                 html += '<div class="sub-item-body">' + rowItem.body + '</div>';
                 html += '</div>';
             });
             html += '</div>';
         });
         html += '</div>';
         return html;
     };

     /**
      * get drawing setting popup html
      * @param {string} title - popup title
      * @param {string} content - settings content
      * @returns {string} - popup html
      */
     var _getPopupHTML = function (title, content) {
         return '<div class="drawing_popup o_list_holder settings-modal" data-inf-drawing-settings-pop-up="">' +
             '<div inf-pnl="popup-header" class="drawing_popup_header">' + title + '<ul><li class="header_ctrl" inf-ctrl="closeSettings"><span class="icon ico-close"></span> </li></ul></div>' +
             '<div inf-pnl="popup-body" class="drawing_popup_body">' + content +
             '</div>' +
             '</div>';
     };
     //endregion

     var _getChartTypeOptionHTML = function (chartType, seriesId, icon) {
         var id = _getIdWithChartTypeAndSeries(chartType, seriesId);
         return '<li>' +
             '<a data-toggle="tab" inf-series="' + seriesId + '" target="_self"  data-target="div[rel=' + id + ']" ind-ind-type="' + chartType + '">' +
             '<span class="' + icon + '"></span>' +
             '</a>' +
             '</li>';
     };

     var _getIdWithChartTypeAndSeries = function (chartType, seriesId) {
         return chartType + '_cfg_' + seriesId;
     };

     var _getChartStyleSection = function (chart) {
        return _getSection([_getSectionRow([_getChartSettingsPanel(chart)])]);
    };
     var _getSeriesStyleSection = function (seriesId, chartTypes) {
         return _getSection([_getSectionRow([_getSeriesContentRowItem(seriesId, chartTypes)])]);
     };

     //region bind events

     var _getColorPickerElement = function (id, container, selector) {
         return container.find('[inf-row-item-rel="' + id + '"] [inf-col-pick-container] input[inf-ctrl="' + selector + '"]');
     };

     /**
      * Returns the specified color picker input which is in the same group of given color picker
      * @param $miniColor
      * @param selector
      * @returns {*}
      * @private
      */
     var _getOtherColorPickerElement = function ($miniColor, selector) {
         return $miniColor.closest('[inf-col-pick-container]').find('input[inf-ctrl="' + selector + '"]');
     };

     var _bindChartColorPickerEvents = function (chartSettingPanel, chartId, callbacks) {

        var backgroundColorPicker = chartSettingPanel.find('[inf-row-item-rel="' + chartId + '"]').find('[inf-col-pick-container]').find('input[inf-ctrl="' + "colorPickerBackground" + '"]');
        var gridLineXColorPicker = chartSettingPanel.find('[inf-row-item-rel="' + chartId + '"]').find('[inf-col-pick-container]').find('input[inf-ctrl="' + "colorPickerXGridLine" + '"]');
        var gridLineYColorPicker = chartSettingPanel.find('[inf-row-item-rel="' + chartId + '"]').find('[inf-col-pick-container]').find('input[inf-ctrl="' + "colorPickerYGridLine" + '"]');
        var gradientTopColorPicker = chartSettingPanel.find('[inf-row-item-rel="' + chartId + '"]').find('[inf-col-pick-container]').find('input[inf-ctrl="' + "colorPickerGradientTop" + '"]');
        var gradientBottomColorPicker = chartSettingPanel.find('[inf-row-item-rel="' + chartId + '"]').find('[inf-col-pick-container]').find('input[inf-ctrl="' + "colorPickerGradientBottom" + '"]')

        chartSettingPanel.find('input[inf-ctrl=backgroundType]').on('click', function (e) {
            var bgType = $(this).attr("inf-type");
            setChartBackgroundOptions(chartSettingPanel, bgType, chartId);

        });

        infChart.util.bindColorPicker(gridLineXColorPicker, Highcharts.theme.yAxis.gridLineColor, function (rgb) {
            callbacks.onGridLineColorChange.call(this, rgb, undefined);
        });

        infChart.util.bindColorPicker(gridLineYColorPicker, Highcharts.theme.yAxis.gridLineColor, function (rgb) {
            callbacks.onGridLineColorChange.call(this, undefined, rgb);
        });

        infChart.util.bindColorPicker(backgroundColorPicker, undefined, function (rgb, hex, opacity) {
            callbacks.onBackgroundColorChange.call(this, hex, opacity, rgb);
        });

        infChart.util.bindColorPicker(gradientTopColorPicker, undefined, function (rgb, hex, opacity) {
            callbacks.onGradientBackgroundColorChange.call(this, hex, undefined, opacity, undefined, rgb);
        });

        infChart.util.bindColorPicker(gradientBottomColorPicker, undefined, function (rgb, hex, opacity) {
            callbacks.onGradientBackgroundColorChange.call(this, undefined, hex, undefined, opacity, rgb);
        });
     }


     var _bindSeriesColorPickerEvents = function ($container, seriesId, defaultColor, callbackFn) {

         infChart.util.bindColorPicker(_getColorPickerElement(seriesId, $container, 'colorPicker'), defaultColor,
             function (rgb, hex) {
                 var colors = {'color': rgb, 'hexColor': hex},
                     currentSeriesId = $(this).closest("[inf-row-item-rel]").attr('inf-row-item-rel');
                 callbackFn.call(this, currentSeriesId, colors);
             }
         );

         infChart.util.bindColorPicker(_getColorPickerElement(seriesId, $container, 'colorPickerUp'), defaultColor,
             function (rgb, hex) {
                 var colors = {'upColor': rgb, 'hexColor': hex},
                     $minicolorEl = $(this),
                     currentSeriesId = $minicolorEl.closest("[inf-row-item-rel]").attr('inf-row-item-rel'),
                     type = $minicolorEl.closest("[int-type]").attr("int-type");
                 colors.downColor = _getOtherColorPickerElement($minicolorEl, 'colorPickerDown').minicolors('rgbaString');
                 callbackFn.call(this, currentSeriesId, colors);
             }
         );

         infChart.util.bindColorPicker(_getColorPickerElement(seriesId, $container, 'colorPickerDown'), defaultColor,
             function (rgb, hex) {
                 var colors = {'downColor': rgb, 'hexColor': hex},
                     $miniColorEl = $(this),
                     currentSeriesId = $(this).closest("[inf-row-item-rel]").attr('inf-row-item-rel');
                 colors.upColor = _getOtherColorPickerElement($miniColorEl, 'colorPickerUp').minicolors('rgbaString');
                 callbackFn.call(this, currentSeriesId, colors);
             }
         );

         infChart.util.bindColorPicker(_getColorPickerElement(seriesId, $container, 'colorPickerColUp'), defaultColor,
             function (rgb, hex) {
                 var colors = {'upColor': rgb, 'hexColor': hex},
                     $miniColorEl = $(this),
                     currentSeriesId = $(this).closest("[inf-row-item-rel]").attr('inf-row-item-rel');
                 colors.downColor = _getOtherColorPickerElement($miniColorEl, 'colorPickerColDown').minicolors('rgbaString');
                 callbackFn.call(this, currentSeriesId, colors);
             }
         );

         infChart.util.bindColorPicker(_getColorPickerElement(seriesId, $container, 'colorPickerColDown'), defaultColor,
             function (rgb, hex) {
                 var colors = {'downColor': rgb, 'hexColor': hex},
                     $miniColorEl = $(this),
                     currentSeriesId = $(this).closest("[inf-row-item-rel]").attr('inf-row-item-rel');
                 colors.upColor = _getOtherColorPickerElement($miniColorEl, 'colorPickerColUp').minicolors('rgbaString');
                 callbackFn.call(this, currentSeriesId, colors);
             }
         );
     };

     /** set active line width of the given series in the settings panel
      *
      * @param $container
      * @param seriesId
      * @param lineWidth
      * @private
      */
     var _setActiveSeriesLineWidth = function ($container, seriesId, lineWidth) {
         var ctrlEl = $container.find('[inf-row-item-rel="' + seriesId + '"] ');
         ctrlEl.find("[inf-ctrl=lineWidth]").removeClass('active');
         ctrlEl.find("[inf-ctrl=lineWidth][inf-size=" + lineWidth + "]").addClass('active');
     };

     var _setActiveGridLineWidth = function (container, chartId, lineWidth) {
        var ctrlEl = container.find('[inf-row-item-rel="' + chartId + '"] ');
        ctrlEl.find("[inf-ctrl=gridLineWidth]").removeClass('active');
        ctrlEl.find("[inf-ctrl=gridLineWidth][inf-size=" + lineWidth + "]").addClass('active');
    };

     var _bindSeriesLineWidthEvents = function ($container, seriesId, callbackFn) {
         // set line styles
         $container.find('[inf-row-item-rel="' + seriesId + '"] [inf-ctrl=lineWidth]').on('click', function (e) {
             var strokeWidth = parseInt($(this).attr("inf-size"));
             _setActiveSeriesLineWidth($container, seriesId, strokeWidth);
             callbackFn.call(this, seriesId, strokeWidth);
             e.stopPropagation();
         });
     };

     var _bindGridLineWidthEvents = function (chartSettingPanel, callbackFn, chartId) {
        chartSettingPanel.find('[inf-row-item-rel="' + chartId + '"] [inf-ctrl=gridLineWidth]').on('click', function (e) {
            var strokeWidth = parseInt($(this).attr("inf-size"));
            _setActiveGridLineWidth(chartSettingPanel, chartId, strokeWidth);
            callbackFn.call(this, strokeWidth);
            e.stopPropagation();
        });
    };

    var _onSeriesChartTypeChangeEvent = function ($container, seriesId, callbackFn) {
        $container.find('[inf-row-item-rel="' + seriesId + '"] a[data-toggle="tab"]').on('shown.bs.tab', function (e) {
            if (e.relatedTarget) {//to prevent being called by trigger -> @see _initializeStylePanel
                var chartType = $(this).attr("ind-ind-type"), seriesStyle; // activated tab
                seriesStyle = getSeriesColorsForChartType($container, seriesId, chartType);
                seriesStyle['lineWeight'] = getSeriesLineWidth($container, seriesId, chartType);
                callbackFn(seriesId, chartType, seriesStyle);
            }
        });
    };

    var getSeriesLineWidth = function ($container, seriesId, chartType) {
        var lineWeight;
        var pickref = infChart.util.escapeSpecialCharacters("color-ref-" + chartType + '_cfg_' + seriesId);
        var container = $container.find("[inf-ref=" + pickref + "]"); 
        switch (chartType) {
            case 'line':
                lineWeight = parseInt(container.find("li[inf-ctrl=lineWidth].active").attr('inf-size'));
                break;
            case 'area':
                lineWeight = 1;
            default:
                break;
        }
        return lineWeight;
    };

     /**
      * Returns the colors object which colors are picked from color pickers
      * @param {jQueryElement} $container chart container
      * @param {string} seriesId indicator series id
      * @param {string} chartType chart type
      * @returns {object} colors object
      * @private
      */
     var getSeriesColorsForChartType = function ($container, seriesId, chartType) {
        var colors;
        var pickref = infChart.util.escapeSpecialCharacters("color-ref-" + chartType + '_cfg_' + seriesId);
        var container = $container.find("[inf-ref=" + pickref + "]");
        switch (chartType) {
            case 'area':
            case 'column':
            case 'candlestick':
            case 'ohlc':
            case 'hlc':
            case 'equivolume':
            case 'heikinashi':
            case 'point':
            case 'volume':
            case 'customCandle':
            case 'engulfingCandles':
                var areaUpEl = container.find("input[inf-ctrl=" + container.attr("inf-col-pick-up") + "]");
                var areaDownEl = container.find("input[inf-ctrl=" + container.attr("inf-col-pick-down") + "]");
                if (areaUpEl.length > 0 && areaDownEl.length > 0) {
                    colors = {
                        'upColor': areaUpEl.minicolors('rgbaString'),
                        'downColor': areaDownEl.minicolors('rgbaString'),
                        'hexColor': areaDownEl.minicolors('value')
                    };
                } else {
                    var colorPeckEl = container.find("input[inf-ctrl=" + container.attr("inf-col-pick") + "]");
                    if (colorPeckEl.length > 0) {
                        colors = {
                            'upColor': colorPeckEl.minicolors('rgbaString'),
                            'downColor': colorPeckEl.minicolors('rgbaString'),
                            'hexColor': colorPeckEl.minicolors('value')
                        };
                    }
                }
                break;
            default:
                var colorEl = container.find('input[inf-ctrl=colorPicker]');
                if (colorEl.length) {
                    colors = {
                        'color': colorEl.minicolors('rgbaString'),
                        'hexColor': colorEl.minicolors('value')
                    };
                }
                break;
        }
        return colors;
     };

     var setChartBackgroundOptions = function(settingPanel, type, chartId) {

        var containerId = infChart.manager.getContainerIdFromChart(chartId),
        chart = infChart.manager.getChart(containerId),
        currentBackgroundType = chart.chart.options.chart.backgroundColor && typeof chart.chart.options.chart.backgroundColor !== 'string' ? "gradient" : "solid",
        bgOptionItem = settingPanel.find('input[inf-ctrl=backgroundType]input[inf-type="'+type+'"]');
        bgOptionItem.attr('checked', 'checked');

        if(type == "solid") {
            settingPanel.find("[inf-ctrl-val='background']").closest("[inf-col-pick-container]").show();
            settingPanel.find("[inf-ctrl-val='gradientTop']").closest("[inf-col-pick-container]").hide();
            settingPanel.find("[inf-ctrl-val='gradientBottom']").closest("[inf-col-pick-container]").hide();
        }
        else if(type == "gradient") {
            settingPanel.find("[inf-ctrl-val='background']").closest("[inf-col-pick-container]").hide();
            settingPanel.find("[inf-ctrl-val='gradientTop']").closest("[inf-col-pick-container]").show();
            settingPanel.find("[inf-ctrl-val='gradientBottom']").closest("[inf-col-pick-container]").show();
        }

        if(currentBackgroundType !== type) {
            if(type === "solid") {
                settingPanel.find('input[inf-ctrl="colorPickerBackground"]').minicolors("value", {
                            color: chart.chartBackgroundColor,
                            opacity: chart.backgroundColorOpacity
                        });
                chart.setChartBackgroundColor(chart.chartBackgroundColor, chart.backgroundColorOpacity);

            }
            else if(type === "gradient") {
                settingPanel.find('input[inf-ctrl="colorPickerGradientTop"]').minicolors("value", {
                            color: chart.chartBgTopGradientColor,
                            opacity: chart.chartBgTopGradientColorOpacity
                        });
                settingPanel.find('input[inf-ctrl="colorPickerGradientBottom"]').minicolors("value", {
                            color: chart.chartBgBottomGradientColor,
                            opacity: chart.chartBgBottomGradientColorOpacity
                        });
                chart.setGradientChartBackgroundColor(chart.chartBgTopGradientColor, chart.chartBgBottomGradientColor, chart.chartBgTopGradientColorOpacity, chart.chartBgBottomGradientColorOpacity);
            }
        }

     }

     var _bindStyleElements = function ($container, seriesId, seriesColor, onSeriesChartTypeChange, onColorPickerChange, onLineWidthChange) {

         _onSeriesChartTypeChangeEvent($container, seriesId, onSeriesChartTypeChange);

         _bindSeriesColorPickerEvents($container, seriesId, seriesColor, onColorPickerChange);

         _bindSeriesLineWidthEvents($container, seriesId, onLineWidthChange);

     };

     var _bindChartStyleElements = function (chartId, chartSettingPanel, callbacks) {

        _bindChartColorPickerEvents(chartSettingPanel, chartId, callbacks);

        _bindGridLineWidthEvents(chartSettingPanel, callbacks.onGridLineWidthChange, chartId);
    };

    var _initializeStylePanel = function ($container, seriesId, seriesType, lineWidth) {
         $container.find('[inf-row-item-rel="' + seriesId + '"] a[data-toggle="tab"][ind-ind-type="' + seriesType + '"]').tab("show");
         $container.find('[inf-row-item-rel="' + seriesId + '"] li[inf-ctrl=lineWidth][inf-size="' + lineWidth + '"]').addClass("active");
    };

    var _initializeChartStylePanel = function (gridLineWidth, chartSettingPanel, chartId, backgroundType) {
        chartSettingPanel.find('[inf-row-item-rel="' + chartId + '"] li[inf-ctrl=gridLineWidth][inf-size="' + gridLineWidth + '"]').addClass("active");
        setChartBackgroundOptions(chartSettingPanel, backgroundType, chartId);
   };

     var _bindPanel = function ($container, onPanelClose) {

         $container.find('div.panel-collapse').on('show.bs.collapse', function () {
             $(this).parents('div.panel').addClass('active');
         }).on('hide.bs.collapse', function () {
             $(this).parents('div.panel').removeClass('active');
         });

         if (typeof onPanelClose !== 'undefined') {
             $container.find('i[rel="close"]').on('click', function (e) {
                 var rel = $(this).parents('div.panel').attr('rel');
                 onPanelClose(rel.substr('panel_'.length));
                 e.stopPropagation();
             });
         }
     };

     /**
      * bind drawing settings event popup
      * @param {object} $container - main container
      * @param {object} settingPopup - drawing object setting popup
      */
     var _bindPopup = function ($container, settingPopup, onToggleSettings) {
         settingPopup.find("li[inf-ctrl=closeSettings]").click(function (event) {
             onToggleSettings();
             event.preventDefault();
         });
         var containment = $($container).find('div[inf-container=chart]');
         settingPopup.draggable({
             handle: "div.drawing_popup_header",
             containment: containment
         });
     };

    /**
    * @param {boolean} isDisableDrawingSettingsPanel
    * hide other settngs popups
    */
    var _hideAllSettingsPopups = function (isDisableDrawingSettingsPanel) {
        if (isDisableDrawingSettingsPanel) {
            var drawingSettingsPopups = $(document.body).find("[data-inf-drawing-settings-pop-up]");
            if (drawingSettingsPopups.length > 0) {
                $.each(drawingSettingsPopups, function (k, popup) {
                    infChart.util.hideColorPicker(popup);
                    $(popup).hide();
                });
            }
        }
        var drawingQuickSettingsPopup = $(document.body).find("[data-inf-quick-drawing-settings-pop-up]");
        if (drawingQuickSettingsPopup.length > 0) {
            $.each(drawingQuickSettingsPopup, function (k, popup) {
                infChart.util.hideColorPicker(popup);
                $(popup).hide();
            });
        }
    };

     /**
      * get popup positions
      * @param {object} settingPopup - drawing object setting popup
      */
     var _getPopupPosition = function (settingPopup) {
         return {
             top: settingPopup[0].offsetTop,
             left: settingPopup[0].offsetLeft
         };
     };

     /**
      * set popup positions and max ehight
      * @param {object} container - main container
      * @param {object} settingPopup - drawing object setting popup
      * @param {object} position - custom popup position
      */
     var _setPopupPositionAndHeight = function (container, settingPopup, position) {
         var maxHeight = $(container).height() - $(settingPopup).find("div[inf-pnl=popup-header]").outerHeight(true) - 30;
         $(settingPopup).find("div[inf-pnl=popup-body]").css({
             "maxHeight": maxHeight < 0 ? 50 : maxHeight
         });
         var popupPosition = position ? position :  {top: 0, left: 200};
         $(settingPopup).css(popupPosition);
     };

     var _getQuicksettingListItemHTML = function (content, customClass, label, toolTipPosition) {
        var html = '<li class="flt-tlbar__item ' + (customClass ? customClass: '') + '" ' + 
            infChart.structureManager.toolbar.getToolTipAttributes(label, toolTipPosition) + '>' + content + '</li>';
        return html ;
     };

     var _getChartSettingPanel = function(chartId){

        var containerId = infChart.manager.getContainerIdFromChart(chartId);
        var chart = infChart.manager.getChart(containerId);
        var $container = $(chart.container);
        return $container.find('div[rel="panel_'+ chartId +'"]')
     }

     //endregion

     return {
         getSection: _getSection,
         getSectionRow: _getSectionRow,
         getRowItem: _getRowItem,
         getColorPickerRowItem: _getColorPickerRowItem,
         getLineStyleRowItem: _getLineStyleRowItem,
         getLineWeightRowItem: _getLineWeightRowItem,
         getFontSizeRowItem: _getFontSizeRowItem,
         getTextAlignRowItem: _getTextAlignRowItem,
         getFontWeightRowItem: _getFontWeightRowItem,
         getSeriesContentRowItem: _getSeriesContentRowItem,
         getChartStyleSection: _getChartStyleSection,
         getSeriesStyleSection: _getSeriesStyleSection,
         getPanelBodyHTML: _getPanelBodyHTML,
         getSectionBodyHTML: _getSectionBodyHTML,
         getPanelHTML: _getPanelHTML,
         getPopupHTML: _getPopupHTML,
         bindPopup: _bindPopup,
         bindStyleElements: _bindStyleElements,
         bindChartStyleElements: _bindChartStyleElements,
         initializeStylePanel: _initializeStylePanel,
         initializeChartStylePanel: _initializeChartStylePanel,
         bindPanel: _bindPanel,
         setActiveSeriesLineWidth: _setActiveSeriesLineWidth,
         setActiveGridLineWidth: _setActiveGridLineWidth,
         getSeriesColorsForChartType: getSeriesColorsForChartType,
         getPopupPosition : _getPopupPosition,
         setPopupPositionAndHeight: _setPopupPositionAndHeight,
         hideAllSettingsPopups: _hideAllSettingsPopups,
         getMiniColorPaletteHTML: _getMiniColorPaletteHTML,
         getLineWeightHTML: _getLineWeightHTML,
         getLineStyleHTML: _getLineStyleHTML,
         getColorPaletteHTML: _getColorPaletteHTML,
         getFontSizeHTML: _getFontSizeHTML,
         getQuicksettingListItemHTML: _getQuicksettingListItemHTML,
         getWaveDegreeRowItem: _getWaveDegreeRowItem,
         getChartSettingPanel: _getChartSettingPanel
     };
 })(jQuery, infChart);

 infChart.structureManager.templateSettings = (function ($, infChart) {

     var _loadPopup = function ($container, uniqueId, action, templateType, templates, callbackOnBtnClick) {
         var popupRef = "file-pop-up-" + uniqueId + "-" + action,
             fileActionPopup = $container.find("[data-inf-file-pop-up='" + popupRef + "']");

         if (!(fileActionPopup && fileActionPopup.length)) {
             var title = infChart.manager.getLabel('label.' + action);
             var actionButtonLabel = (action == 'saveTemplate' || action == 'save') ? infChart.manager.getLabel('label.save') : infChart.manager.getLabel('label.load');
             var html = '<div class="drawing_popup o_list_holder" data-inf-file-pop-up="">' +
                 '<div class="drawing_popup_header">' + title + '<ul><li class="header_ctrl" inf-ctrl="closeSettings"> <span class="icon ico-close"></span> </li></ul></div>' +
                 '<div class="drawing_popup_row">' +
                 '<ol class="o_list" inf-file-sel="' + action + '"  inf-temp-type="' + templateType + '">' +
                 '</ol>' +
                 '</div>' +
                 '<div class="drawing_popup_row">' +
                 '<span class="o_list_label">' + infChart.manager.getLabel('label.name') + '</span> <input type="text" value="" name="fileName" />' +
                 '</div>' +
                 '<div class="drawing_popup_row">' +
                 '<input type="button" value="' + infChart.manager.getLabel('label.delete') + '" inf-file-action="delete" inf-temp-type="' + templateType + '" />' +
                 '<input type="button" value="' + actionButtonLabel + '" inf-file-action="' + action + '" inf-temp-type="' + templateType + '"  />' +
                 '</div>' +
                 '</div>';

             fileActionPopup = $(html).appendTo($container.find("div[inf-container=file_settings]"));

             fileActionPopup.find("input[inf-file-action]").click(function (event) {

                 var clickAction = $(this).attr('inf-file-action'),
                     clickTemplateType = $(this).attr('inf-temp-type'),
                     textName = fileActionPopup.find('input[name=fileName]').val();

                 callbackOnBtnClick(fileActionPopup, clickAction, clickTemplateType, textName);
                 event.preventDefault();
             });

             fileActionPopup.find("li[inf-ctrl=closeSettings]").click(function (event) {
                 fileActionPopup.hide();
                 event.preventDefault();
             });

             fileActionPopup.draggable({handle: "div.drawing_popup_header", containment: $container});

             fileActionPopup.find("ol[inf-file-sel]").selectable({
                 selected: function (e, object) {
                     fileActionPopup.find('input[name=fileName]').val($(object.selected).html());
                 }
             });
         }

         _loadTemplateNames(fileActionPopup, templates);

         // Hiding all the opened popups in the document since there is no way to update popups when doing changes from another popup.
         var fileActionPopups = $(document.body).find("[data-inf-file-pop-up]");
         $.each(fileActionPopups, function (k, popup) {
             $(popup).hide();
         });

         fileActionPopup.css({top: 50, left: 200}).show();

     };

     /**
      * Append geiven templates to the list in the popup
      * @param fileActionPopup
      * @param templates
      * @private
      */
     var _loadTemplateNames = function (fileActionPopup, templates) {
         var lis = '';
         $.each(templates, function (i, val) {
             lis += '<li class="ui-widget-content">' + val + '</li>';
         });

         fileActionPopup.find("ol[inf-file-sel]").html(lis);
     };

     return {
         loadPopup: _loadPopup
     }
 })(jQuery, infChart);

 infChart.structureManager.toolbar = (function () {

     /**
      * @typedef {object} toolbarSubItemConfig
      * @property {string} key
      * @property {string} label
      * @property {string} shortLabel
      * @property {string} desc
      * @property {string} baseClass - class for li
      * @property {string} icon - icon class
      * @property {string} html - inner html content
      */

     /**
      * @typedef {object} toolbarItemConfig
      * @property {string} label
      * @property {string} value
      * @property {boolean} status
      * @property {string} [baseClass=undefined] baseClass - class for li
      * @property {string} icon - icon class
      * @property {string} html - inner html content
      * @property {Array<toolbarSubItemConfig>} options
      * @property {Array<string>} displayOptions
      * @property {boolean} isTextBased
      * @property {boolean} isIconBased
      * @property {boolean} isDropdown
      * @property {string} [menuClass=undefined] menuClass - class for ul
      */

     /**
      * get inf-ctrl html
      * @param {string} type
      * @returns {string}
      * @private
      */
     var _getCtrlTypeHtml = function (type) {
         return ' inf-ctrl="' + type + '"';
     };

     /**
      * get inf-ctrl-item html
      * @param {string} type
      * @returns {string}
      * @private
      */
     var _getCtrlItemHTML = function (type) {
         return ' inf-ctrl-item="' + type + '"';
     };

     /**
      * get inf-ctrl-value html
      * @param {string} value
      * @returns {string}
      * @private
      */
     var _getCtrlValueHtml = function (value) {
         return ' inf-ctrl-value="' + value + '"';
     };

     /**
      * get inf-status html
      * @param {string} status
      * @returns {string}
      * @private
      */
     var _getCtrlStatusHtml = function (status) {
         return ' inf-status="' + (status ? 'on' : 'off') + '"';
     };

     /**
      * get top tt type html - ???
      * @param {string} type
      * @returns {string}
      * @private
      */
     var _getTopttItemHtml = function (type) {
         return ' top-tt-item="' + (type || 'l') + '"';
     };

     var _getToolTipAttributes = function (title, direction, tooltipAdditionalCls) {
         if(title && title.trim() !== "") {
             return ' x-tt-class="adv-chart-tooltip ' + (direction || "bottom" ) + (tooltipAdditionalCls ? ' ' + tooltipAdditionalCls : '') + '" adv-chart-tooltip="' + title + '"';
         } else {
             return '';
         }
         //return 'data-container="body" data-toggle="tooltip" data-placement="' + (direction || "top" ) + '" title="' + title + '"';
     };

     /**
      * Return the attribute/value pairs related to tooltip
      * @param label
      * @param shortLabel
      * @param isShortLabel
      * @private
      */
     var _getCtrlTooltipHtml = function (label, shortLabel, isShortLabel) {
         var text = isShortLabel && shortLabel ? shortLabel : label;
         return _getToolTipAttributes(text);
     };

     /**
      * get inf-ico html
      * @param {string} icon
      * @returns {string}
      * @private
      */
     var _getCtrlIconAttrHtml = function (icon) {
         return ' inf-ico="' + icon + '"';
     };

     var _getCtrlTextHtml = function (label, desc, shortLabel) {
         var text = shortLabel ? shortLabel : label;
         return '<span data-localize="' + text + '">' + desc + '</span>';
     };

     var _getCtrlIconHtml = function (iconClass) {
         return '<i class="' + iconClass + '"></i>';
     };

     /**
      * get control element
      * @param container
      * @param {string} controlType
      * @returns {*}
      * @private
      */
     var _getControlElement = function (container, controlType) {
         return container.find('[inf-ctrl="' + controlType + '"]');
     };

     /**
      * get value from element
      * @param element
      * @returns {string}
      * @private
      */
     var _getValueFromAttribute = function (element) {
         return $(element).attr('inf-ctrl-value');
     };

     var _getInnerHtmlForLI = function (label, desc, customHtml, iconClass, showText) {
         var html;
         if (customHtml) {
             html = customHtml;
         } else {
             if (iconClass) {
                 if (showText) {
                     html = '<a>' + _getCtrlIconHtml(iconClass) + _getCtrlTextHtml(label, desc) + '</a>';
                 } else {
                     html = _getCtrlIconHtml(iconClass);
                 }
             } else {
                 html = _getCtrlTextHtml(label, desc);
             }
         }
         return html;
     };

     /**
      * single element
      * @param {string} ctrlType
      * @param {string} label
      * @param {string} desc
      * @param {string} baseClass
      * @param {string} iconClass
      * @param {string} value
      * @param {boolean} status
      * @param {string} html
      * @param {boolean} showText
      * @param {string} type - ??
      * @returns {string}
      * @private
      */
     var _getSingleOptionHTML = function (ctrlType, label, desc, baseClass, iconClass, value, status, html, showText, type) {
         var htmlArray = [], classes = [];
         htmlArray.push('<li role="button"');
         if (baseClass) {
             classes.push(baseClass);
         }
         if (status === true) {
             classes.push('selected');
         }
         if (classes.length > 0) {
             htmlArray.push(' class="' + classes.join(' ') + '"');
         }
         htmlArray.push(_getTopttItemHtml(type));
         htmlArray.push(_getCtrlTypeHtml(ctrlType));
         if (typeof status !== 'undefined') {
             htmlArray.push(_getCtrlStatusHtml(status));
         }
         if (value) {
             htmlArray.push(_getCtrlValueHtml(value));
         }
         htmlArray.push(' title="' + label, '">');
         htmlArray.push(_getInnerHtmlForLI(label, desc, html, iconClass, showText));
         htmlArray.push('</li>');
         return htmlArray.join('');
     };

     /**
      * multi option element
      * @param {string} ctrlType
      * @param {string} label
      * @param {string} desc
      * @param {string} baseClass
      * @param {Array<object>} options
      * @param {Array<string>} displayOptions
      * @param {string} optionsUlClass
      * @param {boolean} isDropdown
      * @param {boolean} isTextBased
      * @param {boolean} isIconBased
      * @param {boolean} showText
      * @param {string} type - ??
      * @returns {string}
      * @private
      */
     var _getMultiOptionHTML = function (ctrlType, label, desc, baseClass, options, displayOptions, optionsUlClass, isDropdown, isTextBased, isIconBased, showText, type) {
         var htmlArray = [];
         htmlArray.push('<li class="dropdown');
         if (baseClass) {
             htmlArray.push(' ' + baseClass);
         }
         htmlArray.push('"');
         htmlArray.push(_getTopttItemHtml(type));
         htmlArray.push(_getCtrlTypeHtml(ctrlType));
         htmlArray.push('>');

         if (isDropdown) {
             htmlArray.push('<a class="dropdown-toggle" role="button" aria-expanded="false" title="' + label + '">');
         }

         if (isTextBased) {
             htmlArray.push('<span ctrl-role="text"></span>');
         } else if (isIconBased) {
             if (showText) {
                 if (!isDropdown) {
                     htmlArray.push('<a class="dropdown-option" role="button">');
                 }
                 htmlArray.push('<i rel="icon"></i>');
                 htmlArray.push(_getCtrlTextHtml(label, desc));
                 if (!isDropdown) {
                     htmlArray.push('</a>');
                 }
             } else {
                 htmlArray.push('<i rel="icon"></i>');
             }
         } else {
             htmlArray.push(_getCtrlTextHtml(label, desc));
         }

         if (isDropdown) {
             htmlArray.push('<span class="caret"></span></a>');
         }

         htmlArray.push('<ul role="menu" class="dropdown-menu');
         if (optionsUlClass) {
             htmlArray.push(' ' + optionsUlClass);
         }
         htmlArray.push('">');
         htmlArray.push(_getSubOptionsHTML(ctrlType, options, displayOptions));
         htmlArray.push('</ul></li>');
         return htmlArray.join('');
     };

     var _getSubOptionsHTML = function (ctrlType, options, displayOptions) {
         var htmlArray = [];
         infChart.util.forEach(options, function (i, obj) {
             if (!displayOptions || displayOptions.indexOf(obj.key) > -1) {
                 htmlArray.push('<li');
                 htmlArray.push(_getCtrlItemHTML(ctrlType));
                 htmlArray.push(_getCtrlValueHtml(obj.key));
                 if (obj.cssClass) {
                     htmlArray.push(' class="' + obj.baseClass + '"');
                 }
                 if (obj.icon) {
                     htmlArray.push(_getCtrlTooltipHtml(obj.label));
                     htmlArray.push(_getCtrlIconAttrHtml(obj.icon));
                 }
                 htmlArray.push('>');
                 if (obj.html) {
                     htmlArray.push(obj.html);
                 } else if (obj.icon) {
                     htmlArray.push(_getCtrlIconHtml(obj.icon));
                 } else {
                     htmlArray.push(_getCtrlTextHtml(obj.label, obj.desc, obj.shortLabel));
                 }
                 htmlArray.push('</li>');
             }
         });
         return htmlArray.join('');
     };

     /**
      *
      * @param {string} key
      * @param {toolbarItemConfig} config
      * @param {boolean} showText
      * @param {string} type
      * @returns {string}
      * @private
      */
     var _getItemHTML = function (key, config, showText, type) {
         var html = '';
         if (config.options && config.options.length > 0) {
             html = _getMultiOptionHTML(key, config.label, config.desc, config.baseClass, config.options, config.displayOptions,
                 config.menuClass, config.isDropdown, config.isTextBased, config.isIconBased, showText, type);
         } else {
             html = _getSingleOptionHTML(key, config.label, config.desc, config.baseClass, config.icon, config.value, config.status, config.html, showText, type);
         }
         return html;
     };

     var _bindItem = function (parent, key, config, fn) {
         if (config.options && config.options.length > 0) {
             if (config.isIconBased) {
                 _setMultiOptionControlWithIcon(parent, key, fn);
             } else if (config.isTextBased) {
                 _setMultiOptionControlWithText(parent, key, fn);
             } else {
                 _setMultiOptionControl(parent, key, fn);
             }
         } else {
             if (typeof config.status !== 'undefined') {
                 _setSingleOptionControlWithStatus(parent, key, fn);
             } else {
                 _setSingleOptionControl(parent, key, fn);
             }
         }
     };

     /**
      * multi option - control where selected icon is shown
      * used in chart types and grid types
      * @param parent
      * @param {string} controlType
      * @param {function} fn
      * @private
      */
     var _setMultiOptionControlWithIcon = function (parent, controlType, fn) {
         var control = _getControlElement(parent, controlType);
         _getOptionElementsForMultiOptions(control).click(function (event) {
             var value = _getValueFromAttribute(this);
             fn(value);
             _setSelectedValueInMultiOptionControlWithIcon(control, value);
             event.preventDefault();
         });
     };

     /**
      * multi option - control where selected text is shown
      * used for interval
      * @param parent
      * @param {string} controlType
      * @param {function} fn
      * @private
      */
     var _setMultiOptionControlWithText = function (parent, controlType, fn) {
         var control = _getControlElement(parent, controlType);
         _getOptionElementsForMultiOptions(control).click(function (event) {
             var value = _getValueFromAttribute(this);
             fn(value);
             _setSelectedValueInMultiOptionControlWithText(control, value);
             event.preventDefault();
         });
     };

     /**
      * multi option with static text
      * used for file
      * @param parent
      * @param {string} controlType
      * @param {function} fn
      * @private
      */
     var _setMultiOptionControl = function (parent, controlType, fn) {
         var control = _getControlElement(parent, controlType);
         _getOptionElementsForMultiOptions(control).click(function (event) {
             var action = _getValueFromAttribute(this);
             fn(action);
             event.preventDefault();
         });
     };

     /**
      * set selected icon to multi select using the selected value
      * used in chart types and grid types
      * @param control
      * @param {string} value
      * @private
      */
     var _setSelectedValueInMultiOptionControlWithIcon = function (control, value) {
         _setSelectedIconInMultiOptionControlWithIcon(control, _getSelectedElementIconFromValue(control, value));
     };

     /**
      * set selected icon to multi select
      * @param control
      * @param {string} iconClass
      * @private
      */
     var _setSelectedIconInMultiOptionControlWithIcon = function (control, iconClass) {
         control.find('i[rel="icon"]').removeClass().addClass(iconClass);
     };

     /**
      * set selected text to multi select
      * used in interval, period
      * can handle categorized option
      * @param control
      * @param {string} value
      * @param {boolean} enabled
      * @private
      */
     var _setSelectedValueInMultiOptionControlWithText = function (control, value, enabled) {
         var selectedElement = _getSelectedElementFromValue(control, value);
         if (selectedElement && selectedElement.length > 0) {
             var parent = selectedElement.parent('ul').parent('li');
             if (parent && parent.length > 0) {
                 parent.find('a span[ctrl-role="text"]').html(selectedElement.text());
                 if (typeof enabled === 'undefined' || enabled === true) {
                     parent.addClass('active');
                 }
             }
         }
     };

     /**
      * get bind element
      * @param control
      * @returns {*}
      * @private
      */
     var _getOptionElementsForMultiOptions = function (control) {
         return control.find('[inf-ctrl-value]');
     };

     var _setSingleOptionControl = function (parent, controlType, fn) {
         var control = _getControlElement(parent, controlType);
         control.click(function (event) {
             fn(_getValueFromAttribute(this));
             event.preventDefault();
         });
     };

     /**
      * single option without status
      * used in zoom, reset, fullscreen
      * @param parent
      * @param {string} controlType
      * @param {function} fn
      * @private
      */
     var _setSingleOptionControlWithStatus = function (parent, controlType, fn) {
         var control = _getControlElement(parent, controlType);
         control.click(function (event) {
             var attrValue = _getValueFromAttribute(this);
             var status = fn(attrValue);
             _setButtonStatus(control, status);
             event.preventDefault();
         });
     };

     /**
      * set button status
      * @param control
      * @param {boolean} status
      * @private
      */
     var _setButtonStatus = function (control, status) {
         if (status) {
             control.attr("inf-status", "on");
             control.addClass('selected');
         } else {
             control.attr("inf-status", "off");
             control.removeClass('selected');
         }
     };

     /**
      * get selected element
      * @param control
      * @param {string} value
      * @returns {*}
      * @private
      */
     var _getSelectedElementFromValue = function (control, value) {
         return control.find('[inf-ctrl-value="' + value + '"]');
     };

     /**
      * get selected element icon
      * @param control
      * @param {string} value
      * @returns {string} - icon class
      * @private
      */
     var _getSelectedElementIconFromValue = function (control, value) {
         return _getSelectedElementFromValue(control, value).attr('inf-ico');
     };

      /**
      * Bind favorite menu item events and aff dragable
      * @param {string} $container 
      * @param {string} favoriteMenu 
      */
       var _bindFavoriteMenuEvents = function($container, favoriteMenu, containerId) {
        var chart = infChart.manager.getChart(containerId);
        favoriteMenu.find("div[inf-ctrl=closeFavorite]").click(function (event) {
            infChart.drawingsManager.toggleFavorite(favoriteMenu, containerId);
            event.preventDefault();
        });
         
        function startFix(event, ui) {
            ui.position.left = 0;
            ui.position.top = 0;
        }

        function dragFix(event, ui) {
            infChart.util.dragFix(chart, event, ui)
        }

        var containment = $($container).find('div[inf-container=chart_container]');
        var favoriteMenuElement = favoriteMenu.find('[inf-container="favorite-menu"]'); 
        favoriteMenuElement.draggable({
            handle: "div.flt-tlbar__drag",
            containment: containment,
            drag: dragFix,
            start: startFix
        });
        _positionFavoriteMenu(containerId)
     };

     /**
      * Position/re-Position Favorite Menu
      * @param {*} containerId 
      */
     var _positionFavoriteMenu = function(containerId){
        var chart = infChart.manager.getChart(containerId);
        var $container = $(chart.container);
        var chartElement = $container.find('[inf-container="chart_container"]');
        var favoriteMenuElement = $container.find('[inf-container="favorite-menu"]'); 
        var chartTop = $container.find('[inf-container="chart_top"]');

        if(chartElement){
            favoriteMenuElement.css("left",chartElement.width()/2  - favoriteMenuElement.width()/2)
            favoriteMenuElement.css("top",chartTop.height()/2 - favoriteMenuElement.height()/2)
        }

     }

     var _setChartTypeTabActive = function(settingPanel, seriesType){
        settingPanel.find("[ind-ind-type=" + seriesType + "]").parent('li').addClass('active').siblings().removeClass('active');
     }

     return {
         getItemHTML: _getItemHTML,
         getSubOptionsHTML: _getSubOptionsHTML,
         bindItem: _bindItem,
         getControlElement: _getControlElement,
         getToolTipAttributes: _getToolTipAttributes,
         bindFavoriteMenuEvents:_bindFavoriteMenuEvents,
         positionFavoriteMenu: _positionFavoriteMenu,
         setChartTypeTabActive: _setChartTypeTabActive
     };

 })();

/**
 * Management of templates of the chart goes here
 * @type {*|{}}
 */
var infChart = window.infChart || {};

infChart.templatesManager = (function ($, infChart) {
    var _savedTemplates = {};
    var _instances = {};
    var _providerInstances = {};

    /**
     * initialize template manager
     * @private
     */
    var _initialize = function (chartId, providerObj) {
        _setDataProvider(chartId, providerObj);
    };

    /**
     * save all chart templates for given type
     * @param {string} chartId - chart id
     * @param {string} type - template type
     * @param {object} template - template objects
     * @private
     */
    var _saveChartTemplates = function (chartId, type, template) {
        var providerType = _getProviderType(chartId);
        _savedTemplates[providerType][type] = template;
        _providerInstances[providerType].saveChartTemplates(type, { ...template });
    };

    /**
     * get saved chart templates
     * @param {string} chartId - chart id
     * @param {string} type - template type
     * @returns {object}
     * @private
     */
    var _getChartTemplates = function (chartId, type) {
        var providerType = _getProviderType(chartId);
        var template;
        if (_savedTemplates[providerType]?.[type]) {
            template = { ..._savedTemplates[providerType][type] };
        }
        return template;
    };

    /**
     * load saved chart templates for all template types
     * @param {string} chartId - chartId
     * @param {string} providerType - provider type
     * @private
     */
    var _loadAllSavedTemplates = function (chartId, providerType) {
        _savedTemplates[providerType] = {};
        for (let key in infChart.constants.fileTemplateTypes) {
            let templateType = infChart.constants.fileTemplateTypes[key];
            _providerInstances[providerType].getChartTemplates(templateType, function (template) {
                _savedTemplates[providerType][templateType] = { ...template };
            });
        }
    };

    /**
     * set data provider
     * @param {string} chartId - chart id
     * @param {string} providerObj - chart id
     * @private
     */
    var _setDataProvider = function(chartId, providerObj) {
        if (providerObj) {
            if (!_providerInstances[providerObj.type]) {
                var dataProvider;
                switch (providerObj.type) {
                    case 'infinit':
                        dataProvider = new infChart.xinTemplatesDataProvider();
                        break;
                    default:
                        dataProvider = new infChart.mockTemplatesDataProvider();
                        break;
                }
                _providerInstances[providerObj.type] = dataProvider;
                _loadAllSavedTemplates(chartId, providerObj.type);
            }
            _instances[chartId] = providerObj.type;
        }
    };

    /**
     * get provider type for given chart
     * @param {string} chartId - chart id
     * @returns {string} - provider type
     * @private
     */
    var _getProviderType = function (chartId) {
        return _instances[chartId];
    };

    return {
        initialize : _initialize,
        saveChartTemplates : _saveChartTemplates,
        getChartTemplates : _getChartTemplates
    };

})(jQuery, infChart);
infChart.templatesDataProvider = function(vendor){};

infChart.templatesDataProvider.prototype.saveChartTemplates = function(type, templates){};

infChart.templatesDataProvider.prototype.getChartTemplates = function(type, onSuccess){};

(function(infChart, $){

    infChart.mockTemplatesDataProvider = function () {
        infChart.templatesDataProvider.apply(this, arguments);
    };

    infChart.util.extend(infChart.templatesDataProvider, infChart.mockTemplatesDataProvider);

    infChart.mockTemplatesDataProvider.prototype.saveChartTemplates = function(type, templates){
        infChart.util.saveData(infChart.util.getUserName() + "_" + type, templates);
    };

    infChart.mockTemplatesDataProvider.prototype.getChartTemplates = function(type, onSuccess){
        var templates = infChart.util.getData(infChart.util.getUserName() + "_" + type);
        onSuccess(templates);
    };
})(infChart, jQuery);